var Z2 = Object.defineProperty, fr = (e, t) => {
    for (var n in t) Z2(e, n, {
        get: t[n],
        enumerable: !0
    });
}, ve = (e, t, n) => (((a, r, s) => {
    r in a ? Z2(a, r, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: s
    }) : a[r] = s;
})(e, typeof t != "symbol" ? t + "" : t, n), n), Y2 = (e, t, n) => {
    if (!t.has(e)) throw TypeError("Cannot " + n);
}, sa = (e, t, n) => (Y2(e, t, "read from private field"), n ? n.call(e) : t.get(e)), mr = (e, t, n) => {
    if (t.has(e)) throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n);
}, ds = (e, t, n, a) => (Y2(e, t, "write to private field"), a ? a.call(e, n) : t.set(e, n), 
n), Dh = {};

fr(Dh, {
    Abs: () => ol,
    Acos: () => cs,
    Acosh: () => hs,
    AdadeltaOptimizer: () => rm,
    AdagradOptimizer: () => sm,
    AdamOptimizer: () => im,
    AdamaxOptimizer: () => om,
    Add: () => Ar,
    AddN: () => fs,
    All: () => ms,
    Any: () => gs,
    ArgMax: () => ll,
    ArgMin: () => ul,
    Asin: () => ys,
    Asinh: () => As,
    Atan: () => xs,
    Atan2: () => vs,
    Atanh: () => bs,
    AvgPool: () => ws,
    AvgPool3D: () => dl,
    AvgPool3DGrad: () => ju,
    AvgPoolGrad: () => Hu,
    BackendWasm: () => cw,
    BatchMatMul: () => ks,
    BatchToSpaceND: () => pl,
    Bincount: () => Is,
    BitwiseAnd: () => cl,
    BroadcastArgs: () => hl,
    BroadcastTo: () => uI,
    Cast: () => Ss,
    Ceil: () => Ns,
    ClipByValue: () => xr,
    Complex: () => qu,
    ComplexAbs: () => Xu,
    Concat: () => fl,
    Conv2D: () => Cs,
    Conv2DBackpropFilter: () => Ku,
    Conv2DBackpropInput: () => Ts,
    Conv3D: () => Rs,
    Conv3DBackpropFilterV2: () => ml,
    Conv3DBackpropInputV2: () => Es,
    Cos: () => $s,
    Cosh: () => Ms,
    CropAndResize: () => Os,
    Cumprod: () => Fs,
    Cumsum: () => _s,
    DataStorage: () => Wu,
    DenseBincount: () => gl,
    DepthToSpace: () => Ps,
    DepthwiseConv2dNative: () => Ds,
    DepthwiseConv2dNativeBackpropFilter: () => Zu,
    DepthwiseConv2dNativeBackpropInput: () => Yu,
    Diag: () => yl,
    Dilation2D: () => zs,
    Dilation2DBackpropFilter: () => xl,
    Dilation2DBackpropInput: () => Al,
    Draw: () => Ju,
    ENV: () => Vh,
    Einsum: () => Qu,
    Elu: () => Ws,
    EluGrad: () => bl,
    Environment: () => c0,
    Equal: () => Vs,
    Erf: () => Bs,
    Exp: () => Us,
    ExpandDims: () => vl,
    Expm1: () => Gs,
    FFT: () => ed,
    Fill: () => wl,
    FlipLeftRight: () => Hs,
    Floor: () => js,
    FloorDiv: () => qs,
    FromPixels: () => hd,
    FusedBatchNorm: () => Xs,
    FusedConv2D: () => kr,
    FusedDepthwiseConv2D: () => Ir,
    GPGPUContext: () => Qd,
    GatherNd: () => Ks,
    GatherV2: () => kl,
    GraphModel: () => Ic,
    Greater: () => Zs,
    GreaterEqual: () => Ys,
    IFFT: () => td,
    Identity: () => Js,
    Imag: () => nd,
    IsFinite: () => Qs,
    IsInf: () => ei,
    IsNan: () => ti,
    KernelBackend: () => al,
    LRN: () => pi,
    LRNGrad: () => Il,
    LeakyRelu: () => ni,
    Less: () => ai,
    LessEqual: () => ri,
    LinSpace: () => si,
    Log: () => ii,
    Log1p: () => oi,
    LogSoftmax: () => dI,
    LogicalAnd: () => li,
    LogicalNot: () => ui,
    LogicalOr: () => di,
    LogicalXor: () => f0,
    LowerBound: () => pI,
    MathBackendCPU: () => Mm,
    MathBackendWebGL: () => Wc,
    MatrixBandPart: () => cI,
    Max: () => ci,
    MaxPool: () => fi,
    MaxPool3D: () => Sl,
    MaxPool3DGrad: () => rd,
    MaxPoolGrad: () => ad,
    MaxPoolWithArgmax: () => Nl,
    Maximum: () => hi,
    Mean: () => mi,
    Min: () => gi,
    Minimum: () => yi,
    MirrorPad: () => Ai,
    Mod: () => xi,
    MomentumOptimizer: () => lm,
    Multinomial: () => bi,
    Multiply: () => vi,
    Neg: () => Cl,
    NonMaxSuppressionV3: () => ki,
    NonMaxSuppressionV4: () => Tl,
    NonMaxSuppressionV5: () => Ii,
    NotEqual: () => wi,
    OP_SCOPE_SUFFIX: () => af,
    OneHot: () => Si,
    OnesLike: () => Rl,
    Optimizer: () => zr,
    OptimizerConstructors: () => GA,
    Pack: () => El,
    PadV2: () => Ni,
    Pool: () => hI,
    Pow: () => Ci,
    Prelu: () => Ti,
    Prod: () => Ri,
    RMSPropOptimizer: () => um,
    RaggedGather: () => Bp,
    RaggedRange: () => Vp,
    RaggedTensorToTensor: () => Up,
    Range: () => $l,
    Rank: () => Xh,
    Real: () => sd,
    RealDiv: () => Ls,
    Reciprocal: () => Ei,
    Reduction: () => cn,
    Relu: () => $i,
    Relu6: () => _i,
    Reshape: () => Ml,
    ResizeBilinear: () => Fi,
    ResizeBilinearGrad: () => _l,
    ResizeNearestNeighbor: () => Mi,
    ResizeNearestNeighborGrad: () => Fl,
    Reverse: () => Oi,
    RotateWithOffset: () => ro,
    Round: () => Pi,
    Rsqrt: () => Di,
    SGDOptimizer: () => Ac,
    ScatterNd: () => zi,
    SearchSorted: () => Wi,
    Select: () => Ol,
    Selu: () => Bi,
    Sigmoid: () => Hi,
    Sign: () => Gi,
    Sin: () => Vi,
    Sinh: () => Ui,
    Slice: () => Pl,
    Softmax: () => Ki,
    Softplus: () => ji,
    SpaceToBatchND: () => Dl,
    SparseFillEmptyRows: () => id,
    SparseReshape: () => Ll,
    SparseSegmentMean: () => Wl,
    SparseSegmentSum: () => Bl,
    SparseToDense: () => Zi,
    SplitV: () => zl,
    Sqrt: () => qi,
    Square: () => od,
    SquaredDifference: () => Yi,
    StaticRegexReplace: () => ld,
    Step: () => vr,
    StridedSlice: () => Ji,
    StringNGrams: () => Vl,
    StringSplit: () => ud,
    StringToHashBucketFast: () => dd,
    Sub: () => Qi,
    Sum: () => Xi,
    Tan: () => eo,
    Tanh: () => to,
    Tensor: () => vt,
    TensorBuffer: () => $t,
    TensorScatterUpdate: () => Li,
    Tile: () => br,
    TopK: () => no,
    Transform: () => ao,
    Transpose: () => Xa,
    Unique: () => pd,
    Unpack: () => Ul,
    UnsortedSegmentSum: () => cd,
    UpperBound: () => fI,
    Variable: () => wd,
    WebGPUBackend: () => M1,
    ZerosLike: () => Gl,
    _FusedMatMul: () => wr,
    abs: () => Ln,
    acos: () => Y0,
    acosh: () => J0,
    add: () => _e,
    addN: () => hf,
    all: () => Q0,
    any: () => eg,
    argMax: () => Zl,
    argMin: () => tg,
    asin: () => ng,
    asinh: () => ag,
    atan: () => rg,
    atan2: () => sg,
    atanh: () => ig,
    avgPool: () => gf,
    avgPool3d: () => dg,
    backend: () => Rr,
    backend_util: () => C,
    basicLSTMCell: () => pg,
    batchNorm: () => $d,
    batchNorm2d: () => cg,
    batchNorm3d: () => hg,
    batchNorm4d: () => fg,
    batchToSpaceND: () => yf,
    bincount: () => Af,
    bitwiseAnd: () => mg,
    booleanMaskAsync: () => Qy,
    broadcastArgs: () => gg,
    broadcastTo: () => Jl,
    broadcast_util: () => mo,
    browser: () => Lr,
    buffer: () => We,
    cast: () => Qe,
    ceil: () => yg,
    clipByValue: () => Ag,
    clone: () => wn,
    complex: () => Ka,
    concat: () => yt,
    concat1d: () => xg,
    concat2d: () => Jp,
    concat3d: () => bg,
    concat4d: () => vg,
    conv1d: () => wg,
    conv2d: () => Md,
    conv2dTranspose: () => Ig,
    conv3d: () => Sg,
    conv3dTranspose: () => Ng,
    copyRegisteredKernels: () => xI,
    cos: () => Cg,
    cosh: () => Tg,
    cosineWindow: () => hc,
    cumprod: () => Rg,
    cumsum: () => Eg,
    customGrad: () => Da,
    denseBincount: () => $g,
    deprecationWarn: () => _0,
    depthToSpace: () => Mg,
    depthwiseConv2d: () => Qp,
    deregisterOp: () => J9,
    device_util: () => Id,
    diag: () => Fg,
    dilation2d: () => _g,
    disableDeprecationWarnings: () => FI,
    dispose: () => ae,
    disposeVariables: () => _I,
    div: () => ze,
    divNoNan: () => Pg,
    dot: () => Dg,
    dropout: () => rA,
    einsum: () => go,
    elu: () => vf,
    enableDebugMode: () => MI,
    enableProdMode: () => F0,
    enclosingPowerOfTwo: () => em,
    engine: () => Mt,
    ensureShape: () => zg,
    env: () => H,
    equal: () => bf,
    erf: () => Lg,
    euclideanNorm: () => Vg,
    exp: () => Fr,
    expandDims: () => pn,
    expm1: () => Ug,
    eye: () => kf,
    fft: () => uc,
    fill: () => Qa,
    findBackend: () => O0,
    findBackendFactory: () => LI,
    floor: () => If,
    floorDiv: () => Zp,
    forceHalfFloat: () => Wb,
    fused: () => tm,
    gather: () => Sf,
    gatherND: () => aA,
    gather_util: () => fm,
    getBackend: () => dn,
    getGradient: () => Gh,
    getKernel: () => md,
    getKernelsForBackend: () => so,
    getThreadsCount: () => cB,
    gpgpu_util: () => fb,
    grad: () => mS,
    grads: () => gS,
    greater: () => Od,
    greaterEqual: () => Nf,
    ifft: () => Bd,
    imag: () => Pd,
    image: () => Ue,
    inTopKAsync: () => sA,
    io: () => nr,
    irfft: () => Xf,
    isFinite: () => Gg,
    isInf: () => Hg,
    isNaN: () => jg,
    keep: () => ba,
    kernel_impls: () => ua,
    leakyRelu: () => Cf,
    less: () => ec,
    lessEqual: () => tc,
    linalg: () => mA,
    linspace: () => qg,
    loadGraphModel: () => Cx,
    loadGraphModelSync: () => $N,
    localResponseNormalization: () => Xg,
    log: () => eu,
    log1p: () => Tf,
    logSigmoid: () => Zg,
    logSoftmax: () => Yg,
    logSumExp: () => Ef,
    logicalAnd: () => Dd,
    logicalNot: () => $f,
    logicalOr: () => Mf,
    logicalXor: () => Jg,
    losses: () => gA,
    lowerBound: () => Qg,
    matMul: () => ut,
    math: () => EA,
    max: () => Jn,
    maxPool: () => Ff,
    maxPool3d: () => ey,
    maxPoolWithArgmax: () => ty,
    maximum: () => _f,
    mean: () => zd,
    memory: () => OI,
    meshgrid: () => ny,
    min: () => yo,
    minimum: () => Ld,
    mirrorPad: () => ay,
    mod: () => sc,
    moments: () => ry,
    movingAverage: () => eA,
    mul: () => ne,
    multiRNNCell: () => sy,
    multinomial: () => iy,
    neg: () => wa,
    nextFrame: () => HA,
    node: () => e7,
    norm: () => _d,
    notEqual: () => Of,
    oneHot: () => ic,
    ones: () => _r,
    onesLike: () => oy,
    op: () => V,
    outerProduct: () => ly,
    pad: () => Or,
    pad1d: () => uy,
    pad2d: () => dy,
    pad3d: () => py,
    pad4d: () => cy,
    pool: () => hy,
    pow: () => Ql,
    prelu: () => Df,
    print: () => cf,
    prod: () => fy,
    profile: () => PI,
    raggedGather: () => my,
    raggedRange: () => gy,
    raggedTensorToTensor: () => yy,
    rand: () => Ay,
    randomGamma: () => wy,
    randomNormal: () => Uf,
    randomStandardNormal: () => ky,
    randomUniform: () => oc,
    randomUniformInt: () => Iy,
    range: () => tu,
    ready: () => rf,
    real: () => nu,
    reciprocal: () => Sy,
    registerBackend: () => ql,
    registerGradient: () => gI,
    registerKernel: () => Aa,
    registerOp: () => Y9,
    relu: () => Wd,
    relu6: () => Gf,
    removeBackend: () => zI,
    reshape: () => Q,
    reverse: () => Pr,
    reverse1d: () => Ny,
    reverse2d: () => Cy,
    reverse3d: () => Ty,
    reverse4d: () => Ry,
    rfft: () => dc,
    round: () => Hf,
    rsqrt: () => Ey,
    scalar: () => je,
    scatterND: () => tA,
    scatter_util: () => pc,
    searchSorted: () => rc,
    selu: () => $y,
    separableConv2d: () => My,
    serialization: () => xA,
    setBackend: () => Xp,
    setPlatform: () => WI,
    setThreadsCount: () => pB,
    setWasmPath: () => dB,
    setWasmPaths: () => S1,
    setWebGLContext: () => Zm,
    setdiff1dAsync: () => Fy,
    shared: () => Sc,
    sigmoid: () => va,
    sign: () => _y,
    signal: () => fA,
    sin: () => Oy,
    sinh: () => Py,
    slice: () => He,
    slice1d: () => Dy,
    slice2d: () => zy,
    slice3d: () => lc,
    slice4d: () => jf,
    slice_util: () => St,
    softmax: () => qf,
    softplus: () => Rf,
    spaceToBatchND: () => Pf,
    sparse: () => yA,
    sparseToDense: () => nA,
    spectral: () => hA,
    split: () => Ia,
    sqrt: () => Pa,
    square: () => oa,
    squaredDifference: () => Kf,
    squeeze: () => at,
    stack: () => Bn,
    step: () => Zf,
    stridedSlice: () => Ly,
    string: () => AA,
    sub: () => $e,
    sum: () => dt,
    sumOutType: () => kd,
    tan: () => Wy,
    tanh: () => Yp,
    tensor: () => Ye,
    tensor1d: () => Yt,
    tensor2d: () => Dr,
    tensor3d: () => Yf,
    tensor4d: () => By,
    tensor5d: () => Vy,
    tensor6d: () => Uy,
    tensorScatterUpdate: () => Hy,
    tensor_util: () => k0,
    test_util: () => xy,
    tidy: () => qe,
    tile: () => Ao,
    time: () => DI,
    topk: () => jy,
    train: () => K8,
    transpose: () => au,
    truncatedNormal: () => qy,
    unique: () => Xy,
    unregisterGradient: () => AI,
    unregisterKernel: () => yI,
    unsortedSegmentSum: () => Ky,
    unstack: () => la,
    upcastType: () => Zt,
    upperBound: () => Zy,
    util: () => k,
    valueAndGrad: () => yS,
    valueAndGrads: () => AS,
    variable: () => Yy,
    variableGrads: () => Kg,
    version: () => W1,
    version_converter: () => MN,
    version_core: () => X8,
    version_cpu: () => LC,
    version_wasm: () => hB,
    version_webgl: () => VM,
    webgl: () => UM,
    webgl_util: () => P5,
    webgpu_util: () => ww,
    where: () => er,
    whereAsync: () => Qf,
    zeros: () => ka,
    zerosLike: () => Wn
});

var I6 = Object.create, zh = Object.defineProperty, S6 = Object.getOwnPropertyDescriptor, N6 = Object.getOwnPropertyNames, C6 = Object.getPrototypeOf, T6 = Object.prototype.hasOwnProperty, zt = (e, t) => () => (t || e((t = {
    exports: {}
}).exports, t), t.exports), Ze = (e, t) => {
    for (var n in t) zh(e, n, {
        get: t[n],
        enumerable: !0
    });
}, nl = (e, t, n) => (n = e != null ? I6(C6(e)) : {}, ((a, r, s, i) => {
    if (r && typeof r == "object" || typeof r == "function") for (let l of N6(r)) !T6.call(a, l) && l !== s && zh(a, l, {
        get: () => r[l],
        enumerable: !(i = S6(r, l)) || i.enumerable
    });
    return a;
})(!t && e && e.__esModule ? n : zh(n, "default", {
    value: e,
    enumerable: !0
}), e)), R6 = zt((e, t) => {
    t.exports = a;
    var n = null;
    try {
        n = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11 ])), {}).exports;
    } catch {}
    function a(w, E, $) {
        this.low = 0 | w, this.high = 0 | E, this.unsigned = !!$;
    }
    function r(w) {
        return (w && w.__isLong__) === !0;
    }
    a.prototype.__isLong__, Object.defineProperty(a.prototype, "__isLong__", {
        value: !0
    }), a.isLong = r;
    var s = {}, i = {};
    function l(w, E) {
        var $, M, F;
        return E ? (F = 0 <= (w >>>= 0) && w < 256) && (M = i[w]) ? M : ($ = p(w, (0 | w) < 0 ? -1 : 0, !0), 
        F && (i[w] = $), $) : (F = -128 <= (w |= 0) && w < 128) && (M = s[w]) ? M : ($ = p(w, w < 0 ? -1 : 0, !1), 
        F && (s[w] = $), $);
    }
    function o(w, E) {
        if (isNaN(w)) return E ? A : y;
        if (E) {
            if (w < 0) return A;
            if (w >= f) return N;
        } else {
            if (w <= -m) return T;
            if (w + 1 >= m) return I;
        }
        return w < 0 ? o(-w, E).neg() : p(w % h | 0, w / h | 0, E);
    }
    function p(w, E, $) {
        return new a(w, E, $);
    }
    a.fromInt = l, a.fromNumber = o, a.fromBits = p;
    var u = Math.pow;
    function c(w, E, $) {
        if (w.length === 0) throw Error("empty string");
        if (w === "NaN" || w === "Infinity" || w === "+Infinity" || w === "-Infinity") return y;
        if (typeof E == "number" ? ($ = E, E = !1) : E = !!E, ($ = $ || 10) < 2 || 36 < $) throw RangeError("radix");
        var M;
        if ((M = w.indexOf("-")) > 0) throw Error("interior hyphen");
        if (M === 0) return c(w.substring(1), E, $).neg();
        for (var F = o(u($, 8)), P = y, L = 0; L < w.length; L += 8) {
            var O = Math.min(8, w.length - L), B = parseInt(w.substring(L, L + O), $);
            if (O < 8) {
                var G = o(u($, O));
                P = P.mul(G).add(o(B));
            } else P = (P = P.mul(F)).add(o(B));
        }
        return P.unsigned = E, P;
    }
    function d(w, E) {
        return typeof w == "number" ? o(w, E) : typeof w == "string" ? c(w, E) : p(w.low, w.high, typeof E == "boolean" ? E : w.unsigned);
    }
    a.fromString = c, a.fromValue = d;
    var h = 4294967296, f = h * h, m = f / 2, g = l(1 << 24), y = l(0);
    a.ZERO = y;
    var A = l(0, !0);
    a.UZERO = A;
    var x = l(1);
    a.ONE = x;
    var b = l(1, !0);
    a.UONE = b;
    var v = l(-1);
    a.NEG_ONE = v;
    var I = p(-1, 2147483647, !1);
    a.MAX_VALUE = I;
    var N = p(-1, -1, !0);
    a.MAX_UNSIGNED_VALUE = N;
    var T = p(0, -2147483648, !1);
    a.MIN_VALUE = T;
    var R = a.prototype;
    R.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low;
    }, R.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * h + (this.low >>> 0) : this.high * h + (this.low >>> 0);
    }, R.toString = function(w) {
        if ((w = w || 10) < 2 || 36 < w) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
            if (this.eq(T)) {
                var E = o(w), $ = this.div(E), M = $.mul(E).sub(this);
                return $.toString(w) + M.toInt().toString(w);
            }
            return "-" + this.neg().toString(w);
        }
        for (var F = o(u(w, 6), this.unsigned), P = this, L = ""; ;) {
            var O = P.div(F), B = (P.sub(O.mul(F)).toInt() >>> 0).toString(w);
            if ((P = O).isZero()) return B + L;
            for (;B.length < 6; ) B = "0" + B;
            L = "" + B + L;
        }
    }, R.getHighBits = function() {
        return this.high;
    }, R.getHighBitsUnsigned = function() {
        return this.high >>> 0;
    }, R.getLowBits = function() {
        return this.low;
    }, R.getLowBitsUnsigned = function() {
        return this.low >>> 0;
    }, R.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(T) ? 64 : this.neg().getNumBitsAbs();
        for (var w = this.high != 0 ? this.high : this.low, E = 31; E > 0 && !(w & 1 << E); E--);
        return this.high != 0 ? E + 33 : E + 1;
    }, R.isZero = function() {
        return this.high === 0 && this.low === 0;
    }, R.eqz = R.isZero, R.isNegative = function() {
        return !this.unsigned && this.high < 0;
    }, R.isPositive = function() {
        return this.unsigned || this.high >= 0;
    }, R.isOdd = function() {
        return !(1 & ~this.low);
    }, R.isEven = function() {
        return !(1 & this.low);
    }, R.equals = function(w) {
        return r(w) || (w = d(w)), (this.unsigned === w.unsigned || this.high >>> 31 != 1 || w.high >>> 31 != 1) && this.high === w.high && this.low === w.low;
    }, R.eq = R.equals, R.notEquals = function(w) {
        return !this.eq(w);
    }, R.neq = R.notEquals, R.ne = R.notEquals, R.lessThan = function(w) {
        return this.comp(w) < 0;
    }, R.lt = R.lessThan, R.lessThanOrEqual = function(w) {
        return this.comp(w) <= 0;
    }, R.lte = R.lessThanOrEqual, R.le = R.lessThanOrEqual, R.greaterThan = function(w) {
        return this.comp(w) > 0;
    }, R.gt = R.greaterThan, R.greaterThanOrEqual = function(w) {
        return this.comp(w) >= 0;
    }, R.gte = R.greaterThanOrEqual, R.ge = R.greaterThanOrEqual, R.compare = function(w) {
        if (r(w) || (w = d(w)), this.eq(w)) return 0;
        var E = this.isNegative(), $ = w.isNegative();
        return E && !$ ? -1 : !E && $ ? 1 : this.unsigned ? w.high >>> 0 > this.high >>> 0 || w.high === this.high && w.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(w).isNegative() ? -1 : 1;
    }, R.comp = R.compare, R.negate = function() {
        return !this.unsigned && this.eq(T) ? T : this.not().add(x);
    }, R.neg = R.negate, R.add = function(w) {
        r(w) || (w = d(w));
        var E = this.high >>> 16, $ = 65535 & this.high, M = this.low >>> 16, F = 65535 & this.low, P = w.high >>> 16, L = 65535 & w.high, O = w.low >>> 16, B = 0, G = 0, W = 0, z = 0;
        return W += (z += F + (65535 & w.low)) >>> 16, G += (W += M + O) >>> 16, 
        B += (G += $ + L) >>> 16, B += E + P, p((W &= 65535) << 16 | (z &= 65535), (B &= 65535) << 16 | (G &= 65535), this.unsigned);
    }, R.subtract = function(w) {
        return r(w) || (w = d(w)), this.add(w.neg());
    }, R.sub = R.subtract, R.multiply = function(w) {
        if (this.isZero()) return y;
        if (r(w) || (w = d(w)), n) return p(n.mul(this.low, this.high, w.low, w.high), n.get_high(), this.unsigned);
        if (w.isZero()) return y;
        if (this.eq(T)) return w.isOdd() ? T : y;
        if (w.eq(T)) return this.isOdd() ? T : y;
        if (this.isNegative()) return w.isNegative() ? this.neg().mul(w.neg()) : this.neg().mul(w).neg();
        if (w.isNegative()) return this.mul(w.neg()).neg();
        if (this.lt(g) && w.lt(g)) return o(this.toNumber() * w.toNumber(), this.unsigned);
        var E = this.high >>> 16, $ = 65535 & this.high, M = this.low >>> 16, F = 65535 & this.low, P = w.high >>> 16, L = 65535 & w.high, O = w.low >>> 16, B = 65535 & w.low, G = 0, W = 0, z = 0, X = 0;
        return z += (X += F * B) >>> 16, W += (z += M * B) >>> 16, z &= 65535, W += (z += F * O) >>> 16, 
        G += (W += $ * B) >>> 16, W &= 65535, G += (W += M * O) >>> 16, W &= 65535, 
        G += (W += F * L) >>> 16, G += E * B + $ * O + M * L + F * P, p((z &= 65535) << 16 | (X &= 65535), (G &= 65535) << 16 | (W &= 65535), this.unsigned);
    }, R.mul = R.multiply, R.divide = function(w) {
        if (r(w) || (w = d(w)), w.isZero()) throw Error("division by zero");
        var E, $, M;
        if (n) return this.unsigned || this.high !== -2147483648 || w.low !== -1 || w.high !== -1 ? p((this.unsigned ? n.div_u : n.div_s)(this.low, this.high, w.low, w.high), n.get_high(), this.unsigned) : this;
        if (this.isZero()) return this.unsigned ? A : y;
        if (this.unsigned) {
            if (w.unsigned || (w = w.toUnsigned()), w.gt(this)) return A;
            if (w.gt(this.shru(1))) return b;
            M = A;
        } else {
            if (this.eq(T)) return w.eq(x) || w.eq(v) ? T : w.eq(T) ? x : (E = this.shr(1).div(w).shl(1)).eq(y) ? w.isNegative() ? x : v : ($ = this.sub(w.mul(E)), 
            M = E.add($.div(w)));
            if (w.eq(T)) return this.unsigned ? A : y;
            if (this.isNegative()) return w.isNegative() ? this.neg().div(w.neg()) : this.neg().div(w).neg();
            if (w.isNegative()) return this.div(w.neg()).neg();
            M = y;
        }
        for ($ = this; $.gte(w); ) {
            E = Math.max(1, Math.floor($.toNumber() / w.toNumber()));
            for (var F = Math.ceil(Math.log(E) / Math.LN2), P = F <= 48 ? 1 : u(2, F - 48), L = o(E), O = L.mul(w); O.isNegative() || O.gt($); ) O = (L = o(E -= P, this.unsigned)).mul(w);
            L.isZero() && (L = x), M = M.add(L), $ = $.sub(O);
        }
        return M;
    }, R.div = R.divide, R.modulo = function(w) {
        return r(w) || (w = d(w)), n ? p((this.unsigned ? n.rem_u : n.rem_s)(this.low, this.high, w.low, w.high), n.get_high(), this.unsigned) : this.sub(this.div(w).mul(w));
    }, R.mod = R.modulo, R.rem = R.modulo, R.not = function() {
        return p(~this.low, ~this.high, this.unsigned);
    }, R.and = function(w) {
        return r(w) || (w = d(w)), p(this.low & w.low, this.high & w.high, this.unsigned);
    }, R.or = function(w) {
        return r(w) || (w = d(w)), p(this.low | w.low, this.high | w.high, this.unsigned);
    }, R.xor = function(w) {
        return r(w) || (w = d(w)), p(this.low ^ w.low, this.high ^ w.high, this.unsigned);
    }, R.shiftLeft = function(w) {
        return r(w) && (w = w.toInt()), (w &= 63) == 0 ? this : w < 32 ? p(this.low << w, this.high << w | this.low >>> 32 - w, this.unsigned) : p(0, this.low << w - 32, this.unsigned);
    }, R.shl = R.shiftLeft, R.shiftRight = function(w) {
        return r(w) && (w = w.toInt()), (w &= 63) == 0 ? this : w < 32 ? p(this.low >>> w | this.high << 32 - w, this.high >> w, this.unsigned) : p(this.high >> w - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, R.shr = R.shiftRight, R.shiftRightUnsigned = function(w) {
        if (r(w) && (w = w.toInt()), (w &= 63) === 0) return this;
        var E = this.high;
        return w < 32 ? p(this.low >>> w | E << 32 - w, E >>> w, this.unsigned) : p(w === 32 ? E : E >>> w - 32, 0, this.unsigned);
    }, R.shru = R.shiftRightUnsigned, R.shr_u = R.shiftRightUnsigned, R.toSigned = function() {
        return this.unsigned ? p(this.low, this.high, !1) : this;
    }, R.toUnsigned = function() {
        return this.unsigned ? this : p(this.low, this.high, !0);
    }, R.toBytes = function(w) {
        return w ? this.toBytesLE() : this.toBytesBE();
    }, R.toBytesLE = function() {
        var w = this.high, E = this.low;
        return [ 255 & E, E >>> 8 & 255, E >>> 16 & 255, E >>> 24, 255 & w, w >>> 8 & 255, w >>> 16 & 255, w >>> 24 ];
    }, R.toBytesBE = function() {
        var w = this.high, E = this.low;
        return [ w >>> 24, w >>> 16 & 255, w >>> 8 & 255, 255 & w, E >>> 24, E >>> 16 & 255, E >>> 8 & 255, 255 & E ];
    }, a.fromBytes = function(w, E, $) {
        return $ ? a.fromBytesLE(w, E) : a.fromBytesBE(w, E);
    }, a.fromBytesLE = function(w, E) {
        return new a(w[0] | w[1] << 8 | w[2] << 16 | w[3] << 24, w[4] | w[5] << 8 | w[6] << 16 | w[7] << 24, E);
    }, a.fromBytesBE = function(w, E) {
        return new a(w[4] << 24 | w[5] << 16 | w[6] << 8 | w[7], w[0] << 24 | w[1] << 16 | w[2] << 8 | w[3], E);
    };
}), E6 = zt(() => {}), $6 = zt(() => {}), M6 = zt((e, t) => {
    (function(n, a, r) {
        function s(o) {
            var p = this, u = function() {
                var c = 4022871197, d = function(h) {
                    h = String(h);
                    for (var f = 0; f < h.length; f++) {
                        var m = .02519603282416938 * (c += h.charCodeAt(f));
                        m -= c = m >>> 0, c = (m *= c) >>> 0, c += 4294967296 * (m -= c);
                    }
                    return 2.3283064365386963e-10 * (c >>> 0);
                };
                return d;
            }();
            p.next = function() {
                var c = 2091639 * p.s0 + 2.3283064365386963e-10 * p.c;
                return p.s0 = p.s1, p.s1 = p.s2, p.s2 = c - (p.c = 0 | c);
            }, p.c = 1, p.s0 = u(" "), p.s1 = u(" "), p.s2 = u(" "), p.s0 -= u(o), 
            p.s0 < 0 && (p.s0 += 1), p.s1 -= u(o), p.s1 < 0 && (p.s1 += 1), p.s2 -= u(o), 
            p.s2 < 0 && (p.s2 += 1), u = null;
        }
        function i(o, p) {
            return p.c = o.c, p.s0 = o.s0, p.s1 = o.s1, p.s2 = o.s2, p;
        }
        function l(o, p) {
            var u = new s(o), c = p && p.state, d = u.next;
            return d.int32 = function() {
                return 4294967296 * u.next() | 0;
            }, d.double = function() {
                return d() + 11102230246251565e-32 * (2097152 * d() | 0);
            }, d.quick = d, c && (typeof c == "object" && i(c, u), d.state = function() {
                return i(u, {});
            }), d;
        }
        a && a.exports ? a.exports = l : r && r.amd ? r(function() {
            return l;
        }) : this.alea = l;
    })(0, typeof t == "object" && t, typeof define == "function" && define);
}), F6 = zt((e, t) => {
    (function(n, a, r) {
        function s(o) {
            var p = this, u = "";
            p.x = 0, p.y = 0, p.z = 0, p.w = 0, p.next = function() {
                var d = p.x ^ p.x << 11;
                return p.x = p.y, p.y = p.z, p.z = p.w, p.w ^= p.w >>> 19 ^ d ^ d >>> 8;
            }, o === (0 | o) ? p.x = o : u += o;
            for (var c = 0; c < u.length + 64; c++) p.x ^= 0 | u.charCodeAt(c), 
            p.next();
        }
        function i(o, p) {
            return p.x = o.x, p.y = o.y, p.z = o.z, p.w = o.w, p;
        }
        function l(o, p) {
            var u = new s(o), c = p && p.state, d = function() {
                return (u.next() >>> 0) / 4294967296;
            };
            return d.double = function() {
                do {
                    var h = ((u.next() >>> 11) + (u.next() >>> 0) / 4294967296) / 2097152;
                } while (h === 0);
                return h;
            }, d.int32 = u.next, d.quick = d, c && (typeof c == "object" && i(c, u), 
            d.state = function() {
                return i(u, {});
            }), d;
        }
        a && a.exports ? a.exports = l : r && r.amd ? r(function() {
            return l;
        }) : this.xor128 = l;
    })(0, typeof t == "object" && t, typeof define == "function" && define);
}), _6 = zt((e, t) => {
    (function(n, a, r) {
        function s(o) {
            var p = this, u = "";
            p.next = function() {
                var d = p.x ^ p.x >>> 2;
                return p.x = p.y, p.y = p.z, p.z = p.w, p.w = p.v, (p.d = p.d + 362437 | 0) + (p.v = p.v ^ p.v << 4 ^ d ^ d << 1) | 0;
            }, p.x = 0, p.y = 0, p.z = 0, p.w = 0, p.v = 0, o === (0 | o) ? p.x = o : u += o;
            for (var c = 0; c < u.length + 64; c++) p.x ^= 0 | u.charCodeAt(c), 
            c == u.length && (p.d = p.x << 10 ^ p.x >>> 4), p.next();
        }
        function i(o, p) {
            return p.x = o.x, p.y = o.y, p.z = o.z, p.w = o.w, p.v = o.v, p.d = o.d, 
            p;
        }
        function l(o, p) {
            var u = new s(o), c = p && p.state, d = function() {
                return (u.next() >>> 0) / 4294967296;
            };
            return d.double = function() {
                do {
                    var h = ((u.next() >>> 11) + (u.next() >>> 0) / 4294967296) / 2097152;
                } while (h === 0);
                return h;
            }, d.int32 = u.next, d.quick = d, c && (typeof c == "object" && i(c, u), 
            d.state = function() {
                return i(u, {});
            }), d;
        }
        a && a.exports ? a.exports = l : r && r.amd ? r(function() {
            return l;
        }) : this.xorwow = l;
    })(0, typeof t == "object" && t, typeof define == "function" && define);
}), O6 = zt((e, t) => {
    (function(n, a, r) {
        function s(o) {
            var p = this;
            p.next = function() {
                var u, c, d = p.x, h = p.i;
                return u = d[h], c = (u ^= u >>> 7) ^ u << 24, c ^= (u = d[h + 1 & 7]) ^ u >>> 10, 
                c ^= (u = d[h + 3 & 7]) ^ u >>> 3, c ^= (u = d[h + 4 & 7]) ^ u << 7, 
                u = d[h + 7 & 7], c ^= (u ^= u << 13) ^ u << 9, d[h] = c, p.i = h + 1 & 7, 
                c;
            }, function(u, c) {
                var d, h = [];
                if (c === (0 | c)) h[0] = c; else for (c = "" + c, d = 0; d < c.length; ++d) h[7 & d] = h[7 & d] << 15 ^ c.charCodeAt(d) + h[d + 1 & 7] << 13;
                for (;h.length < 8; ) h.push(0);
                for (d = 0; d < 8 && h[d] === 0; ++d);
                for (d == 8 ? h[7] = -1 : h[d], u.x = h, u.i = 0, d = 256; d > 0; --d) u.next();
            }(p, o);
        }
        function i(o, p) {
            return p.x = o.x.slice(), p.i = o.i, p;
        }
        function l(o, p) {
            o == null && (o = +new Date());
            var u = new s(o), c = p && p.state, d = function() {
                return (u.next() >>> 0) / 4294967296;
            };
            return d.double = function() {
                do {
                    var h = ((u.next() >>> 11) + (u.next() >>> 0) / 4294967296) / 2097152;
                } while (h === 0);
                return h;
            }, d.int32 = u.next, d.quick = d, c && (c.x && i(c, u), d.state = function() {
                return i(u, {});
            }), d;
        }
        a && a.exports ? a.exports = l : r && r.amd ? r(function() {
            return l;
        }) : this.xorshift7 = l;
    })(0, typeof t == "object" && t, typeof define == "function" && define);
}), P6 = zt((e, t) => {
    (function(n, a, r) {
        function s(o) {
            var p = this;
            p.next = function() {
                var u, c, d = p.w, h = p.X, f = p.i;
                return p.w = d = d + 1640531527 | 0, c = h[f + 34 & 127], u = h[f = f + 1 & 127], 
                c ^= c << 13, u ^= u << 17, c ^= c >>> 15, u ^= u >>> 12, c = h[f] = c ^ u, 
                p.i = f, c + (d ^ d >>> 16) | 0;
            }, function(u, c) {
                var d, h, f, m, g, y = [], A = 128;
                for (c === (0 | c) ? (h = c, c = null) : (c += "\0", h = 0, A = Math.max(A, c.length)), 
                f = 0, m = -32; m < A; ++m) c && (h ^= c.charCodeAt((m + 32) % c.length)), 
                m === 0 && (g = h), h ^= h << 10, h ^= h >>> 15, h ^= h << 4, h ^= h >>> 13, 
                m >= 0 && (g = g + 1640531527 | 0, f = (d = y[127 & m] ^= h + g) == 0 ? f + 1 : 0);
                for (f >= 128 && (y[127 & (c && c.length || 0)] = -1), f = 127, 
                m = 512; m > 0; --m) h = y[f + 34 & 127], d = y[f = f + 1 & 127], 
                h ^= h << 13, d ^= d << 17, h ^= h >>> 15, d ^= d >>> 12, y[f] = h ^ d;
                u.w = g, u.X = y, u.i = f;
            }(p, o);
        }
        function i(o, p) {
            return p.i = o.i, p.w = o.w, p.X = o.X.slice(), p;
        }
        function l(o, p) {
            o == null && (o = +new Date());
            var u = new s(o), c = p && p.state, d = function() {
                return (u.next() >>> 0) / 4294967296;
            };
            return d.double = function() {
                do {
                    var h = ((u.next() >>> 11) + (u.next() >>> 0) / 4294967296) / 2097152;
                } while (h === 0);
                return h;
            }, d.int32 = u.next, d.quick = d, c && (c.X && i(c, u), d.state = function() {
                return i(u, {});
            }), d;
        }
        a && a.exports ? a.exports = l : r && r.amd ? r(function() {
            return l;
        }) : this.xor4096 = l;
    })(0, typeof t == "object" && t, typeof define == "function" && define);
}), D6 = zt((e, t) => {
    (function(n, a, r) {
        function s(o) {
            var p = this, u = "";
            p.next = function() {
                var d = p.b, h = p.c, f = p.d, m = p.a;
                return d = d << 25 ^ d >>> 7 ^ h, h = h - f | 0, f = f << 24 ^ f >>> 8 ^ m, 
                m = m - d | 0, p.b = d = d << 20 ^ d >>> 12 ^ h, p.c = h = h - f | 0, 
                p.d = f << 16 ^ h >>> 16 ^ m, p.a = m - d | 0;
            }, p.a = 0, p.b = 0, p.c = -1640531527, p.d = 1367130551, o === Math.floor(o) ? (p.a = o / 4294967296 | 0, 
            p.b = 0 | o) : u += o;
            for (var c = 0; c < u.length + 20; c++) p.b ^= 0 | u.charCodeAt(c), 
            p.next();
        }
        function i(o, p) {
            return p.a = o.a, p.b = o.b, p.c = o.c, p.d = o.d, p;
        }
        function l(o, p) {
            var u = new s(o), c = p && p.state, d = function() {
                return (u.next() >>> 0) / 4294967296;
            };
            return d.double = function() {
                do {
                    var h = ((u.next() >>> 11) + (u.next() >>> 0) / 4294967296) / 2097152;
                } while (h === 0);
                return h;
            }, d.int32 = u.next, d.quick = d, c && (typeof c == "object" && i(c, u), 
            d.state = function() {
                return i(u, {});
            }), d;
        }
        a && a.exports ? a.exports = l : r && r.amd ? r(function() {
            return l;
        }) : this.tychei = l;
    })(0, typeof t == "object" && t, typeof define == "function" && define);
}), z6 = zt(() => {}), L6 = zt((e, t) => {
    (function(n, a, r) {
        var s, i = 256, l = "random", o = r.pow(i, 6), p = r.pow(2, 52), u = 2 * p, c = i - 1;
        function d(A, x, b) {
            var v = [], I = g(m((x = x == 1 ? {
                entropy: !0
            } : x || {}).entropy ? [ A, y(a) ] : A ?? function() {
                try {
                    var R;
                    return s && (R = s.randomBytes) ? R = R(i) : (R = new Uint8Array(i), 
                    (n.crypto || n.msCrypto).getRandomValues(R)), y(R);
                } catch {
                    var w = n.navigator, E = w && w.plugins;
                    return [ +new Date(), n, E, n.screen, y(a) ];
                }
            }(), 3), v), N = new h(v), T = function() {
                for (var R = N.g(6), w = o, E = 0; R < p; ) R = (R + E) * i, w *= i, 
                E = N.g(1);
                for (;R >= u; ) R /= 2, w /= 2, E >>>= 1;
                return (R + E) / w;
            };
            return T.int32 = function() {
                return 0 | N.g(4);
            }, T.quick = function() {
                return N.g(4) / 4294967296;
            }, T.double = T, g(y(N.S), a), (x.pass || b || function(R, w, E, $) {
                return $ && ($.S && f($, N), R.state = function() {
                    return f(N, {});
                }), E ? (r[l] = R, w) : R;
            })(T, I, "global" in x ? x.global : this == r, x.state);
        }
        function h(A) {
            var x, b = A.length, v = this, I = 0, N = v.i = v.j = 0, T = v.S = [];
            for (b || (A = [ b++ ]); I < i; ) T[I] = I++;
            for (I = 0; I < i; I++) T[I] = T[N = c & N + A[I % b] + (x = T[I])], 
            T[N] = x;
            (v.g = function(R) {
                for (var w, E = 0, $ = v.i, M = v.j, F = v.S; R--; ) w = F[$ = c & $ + 1], 
                E = E * i + F[c & (F[$] = F[M = c & M + w]) + (F[M] = w)];
                return v.i = $, v.j = M, E;
            })(i);
        }
        function f(A, x) {
            return x.i = A.i, x.j = A.j, x.S = A.S.slice(), x;
        }
        function m(A, x) {
            var b, v = [], I = typeof A;
            if (x && I == "object") for (b in A) try {
                v.push(m(A[b], x - 1));
            } catch {}
            return v.length ? v : I == "string" ? A : A + "\0";
        }
        function g(A, x) {
            for (var b, v = A + "", I = 0; I < v.length; ) x[c & I] = c & (b ^= 19 * x[c & I]) + v.charCodeAt(I++);
            return y(x);
        }
        function y(A) {
            return String.fromCharCode.apply(0, A);
        }
        if (g(r.random(), a), typeof t == "object" && t.exports) {
            t.exports = d;
            try {
                s = z6();
            } catch {}
        } else typeof define == "function" && define.amd ? define(function() {
            return d;
        }) : r["seed" + l] = d;
    })(typeof self < "u" ? self : e, [], Math);
}), J2 = zt((e, t) => {
    var n = M6(), a = F6(), r = _6(), s = O6(), i = P6(), l = D6(), o = L6();
    o.alea = n, o.xor128 = a, o.xorwow = r, o.xorshift7 = s, o.xor4096 = i, o.tychei = l, 
    t.exports = o;
}), Q2 = zt(() => {}), e0 = zt(() => {}), W6 = zt(() => {}), B6 = zt(() => {}), V6 = zt(() => {}), U6 = zt((e, t) => {
    var n, a = (n = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0, 
    typeof __filename < "u" && (n = n || __filename), function(r) {
        function s() {
            return L.buffer != G && pe(L.buffer), z;
        }
        function i() {
            return L.buffer != G && pe(L.buffer), X;
        }
        function l() {
            return L.buffer != G && pe(L.buffer), q;
        }
        function o() {
            return L.buffer != G && pe(L.buffer), Z;
        }
        var p, u, c, d = (r = r || {}) !== void 0 ? r : {};
        d.ready = new Promise(function(j, J) {
            p = j, u = J;
        }), typeof process < "u" && process.listeners && (c = {
            uncaughtException: process.listeners("uncaughtException"),
            unhandledRejection: process.listeners("unhandledRejection")
        });
        var h, f, m, g = Object.assign({}, d), y = (j, J) => {
            throw J;
        }, A = typeof window == "object", x = typeof importScripts == "function", b = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", v = d.ENVIRONMENT_IS_PTHREAD || !1, I = "";
        function N(j) {
            return d.locateFile ? d.locateFile(j, I) : I + j;
        }
        if (b) {
            var T = Q2(), R = e0();
            let j;
            I = x ? R.dirname(I) + "/" : __dirname + "/", h = (J, Ae) => (J = nn(J) ? new URL(J) : R.normalize(J), 
            T.readFileSync(J, Ae ? void 0 : "utf8")), m = J => {
                var Ae = h(J, !0);
                return Ae.buffer || (Ae = new Uint8Array(Ae)), Ae;
            }, f = (J, Ae, Fe) => {
                J = nn(J) ? new URL(J) : R.normalize(J), T.readFile(J, function(Ie, ke) {
                    Ie ? Fe(Ie) : Ae(ke.buffer);
                });
            }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), 
            process.on("uncaughtException", function(J) {
                if (!(J instanceof Pe)) throw J;
            }), process.on("unhandledRejection", function(J) {
                throw J;
            }), y = (J, Ae) => {
                if (me()) throw process.exitCode = J, Ae;
                (function(Fe) {
                    Fe instanceof Pe || F("exiting due to exception: " + Fe);
                })(Ae), process.exit(J);
            }, d.inspect = function() {
                return "[Emscripten Module object]";
            };
            try {
                j = W6();
            } catch (J) {
                throw J;
            }
            global.Worker = j.Worker;
        } else (A || x) && (x ? I = self.location.href : typeof document < "u" && document.currentScript && (I = document.currentScript.src), 
        n !== void 0 && n && (I = n), I = I.indexOf("blob:") !== 0 ? I.substr(0, I.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", 
        b || (h = j => {
            var J = new XMLHttpRequest();
            return J.open("GET", j, !1), J.send(null), J.responseText;
        }, x && (m = j => {
            var J = new XMLHttpRequest();
            return J.open("GET", j, !1), J.responseType = "arraybuffer", J.send(null), 
            new Uint8Array(J.response);
        }), f = (j, J, Ae) => {
            var Fe = new XMLHttpRequest();
            Fe.open("GET", j, !0), Fe.responseType = "arraybuffer", Fe.onload = () => {
                Fe.status == 200 || Fe.status == 0 && Fe.response ? J(Fe.response) : Ae();
            }, Fe.onerror = Ae, Fe.send(null);
        }));
        b && typeof performance > "u" && (global.performance = B6().performance);
        var w = void 0, E = void 0;
        b && (w = j => T.writeSync(1, j + `
`), E = j => T.writeSync(2, j + `
`));
        var $, M = d.print || w, F = d.printErr || E;
        Object.assign(d, g), g = null, d.arguments && d.arguments, d.thisProgram && d.thisProgram, 
        d.quit && (y = d.quit), d.wasmBinary && ($ = d.wasmBinary);
        var P = d.noExitRuntime || !0;
        typeof WebAssembly != "object" && nt("no native wasm support detected");
        var L, O, B, G, W, z, X, q, Z, Y = !1, te = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
        function re(j, J, Ae) {
            for (var Fe = (J >>>= 0) + Ae, Ie = J; j[Ie] && !(Ie >= Fe); ) ++Ie;
            if (Ie - J > 16 && j.buffer && te) return te.decode(j.buffer instanceof SharedArrayBuffer ? j.slice(J, Ie) : j.subarray(J, Ie));
            for (var ke = ""; J < Ie; ) {
                var Ke = j[J++];
                if (128 & Ke) {
                    var Dt = 63 & j[J++];
                    if ((224 & Ke) != 192) {
                        var kt = 63 & j[J++];
                        if ((Ke = (240 & Ke) == 224 ? (15 & Ke) << 12 | Dt << 6 | kt : (7 & Ke) << 18 | Dt << 12 | kt << 6 | 63 & j[J++]) < 65536) ke += String.fromCharCode(Ke); else {
                            var ra = Ke - 65536;
                            ke += String.fromCharCode(55296 | ra >> 10, 56320 | 1023 & ra);
                        }
                    } else ke += String.fromCharCode((31 & Ke) << 6 | Dt);
                } else ke += String.fromCharCode(Ke);
            }
            return ke;
        }
        function pe(j) {
            G = j, d.HEAP8 = W = new Int8Array(j), d.HEAP16 = new Int16Array(j), 
            d.HEAP32 = X = new Int32Array(j), d.HEAPU8 = z = new Uint8Array(j), 
            d.HEAPU16 = new Uint16Array(j), d.HEAPU32 = q = new Uint32Array(j), 
            d.HEAPF32 = new Float32Array(j), d.HEAPF64 = Z = new Float64Array(j);
        }
        v && (G = d.buffer);
        var ge = d.INITIAL_MEMORY || 16777216;
        if (v) L = d.wasmMemory, G = d.buffer; else if (d.wasmMemory) L = d.wasmMemory; else if (!((L = new WebAssembly.Memory({
            initial: ge / 65536,
            maximum: 65536,
            shared: !0
        })).buffer instanceof SharedArrayBuffer)) throw F("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), 
        b && F("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"), 
        Error("bad memory");
        L && (G = L.buffer), ge = G.byteLength, pe(G);
        var Re, ye = [], Me = [], Ee = [];
        function me() {
            return P;
        }
        function Oe() {
            !v && mt(Me);
        }
        var we = 0, Be = null;
        function nt(j) {
            d.onAbort && d.onAbort(j), F(j = "Aborted(" + j + ")"), Y = !0, B = 1, 
            j += ". Build with -sASSERTIONS for more info.";
            var J = new WebAssembly.RuntimeError(j);
            throw u(J), J;
        }
        var Ve, ue = "data:application/octet-stream;base64,";
        function ct(j) {
            return j.startsWith(ue);
        }
        function nn(j) {
            return j.startsWith("file://");
        }
        function K(j) {
            try {
                if (j == Ve && $) return new Uint8Array($);
                if (m) return m(j);
                throw "both async and sync fetching of the wasm failed";
            } catch (J) {
                nt(J);
            }
        }
        ct(Ve = "tfjs-backend-wasm-threaded-simd.wasm") || (Ve = N(Ve));
        var ie = {};
        function Pe(j) {
            this.name = "ExitStatus", this.message = "Program terminated with exit(" + j + ")", 
            this.status = j;
        }
        function Ge(j) {
            var J = Ce.pthreads[j];
            (function(Ae, Fe) {
                Ae || nt(Fe);
            })(J), Ce.returnWorkerToPool(J);
        }
        function De(j) {
            var J = Ce.getNewWorker();
            if (!J) return 6;
            Ce.runningWorkers.push(J), Ce.pthreads[j.pthread_ptr] = J, J.pthread_ptr = j.pthread_ptr;
            var Ae = {
                cmd: "run",
                start_routine: j.startRoutine,
                arg: j.arg,
                pthread_ptr: j.pthread_ptr
            };
            return J.runPthread = () => {
                b && J.ref(), J.postMessage(Ae, j.transferList), delete J.runPthread;
            }, J.loaded && J.runPthread(), 0;
        }
        function Xe(j) {
            if (v) return Kn(1, 1, j);
            B = j, me() || (Ce.terminateAllThreads(), d.onExit && d.onExit(j), Y = !0), 
            y(j, new Pe(j));
        }
        var et = function(j, J) {
            if (B = j, !J && v) throw an(j), "unwind";
            Xe(j);
        }, Ce = {
            unusedWorkers: [],
            runningWorkers: [],
            tlsInitFunctions: [],
            pthreads: {},
            init: function() {
                v ? Ce.initWorker() : Ce.initMainThread();
            },
            initMainThread: function() {
                for (var j = 8; j--; ) Ce.allocateUnusedWorker();
            },
            initWorker: function() {
                P = !1;
            },
            setExitStatus: function(j) {
                B = j;
            },
            terminateAllThreads: function() {
                for (var j of Object.values(Ce.pthreads)) Ce.returnWorkerToPool(j);
                for (var j of Ce.unusedWorkers) j.terminate();
                Ce.unusedWorkers = [];
            },
            returnWorkerToPool: function(j) {
                var J = j.pthread_ptr;
                delete Ce.pthreads[J], Ce.unusedWorkers.push(j), Ce.runningWorkers.splice(Ce.runningWorkers.indexOf(j), 1), 
                j.pthread_ptr = 0, b && j.unref(), _h(J);
            },
            receiveObjectTransfer: function(j) {},
            threadInitTLS: function() {
                Ce.tlsInitFunctions.forEach(j => j());
            },
            loadWasmModuleToWorker: function(j, J) {
                j.onmessage = Ie => {
                    var ke = Ie.data, Ke = ke.cmd;
                    if (j.pthread_ptr && (Ce.currentProxiedOperationCallerThread = j.pthread_ptr), 
                    ke.targetThread && ke.targetThread != Cp()) {
                        var Dt = Ce.pthreads[ke.targetThread];
                        return Dt ? Dt.postMessage(ke, ke.transferList) : F('Internal error! Worker sent a message "' + Ke + '" to target pthread ' + ke.targetThread + ", but that thread no longer exists!"), 
                        void (Ce.currentProxiedOperationCallerThread = void 0);
                    }
                    Ke === "processProxyingQueue" ? bn(ke.queue) : Ke === "spawnThread" ? De(ke) : Ke === "cleanupThread" ? Ge(ke.thread) : Ke === "killThread" ? function(kt) {
                        var ra = Ce.pthreads[kt];
                        delete Ce.pthreads[kt], ra.terminate(), _h(kt), Ce.runningWorkers.splice(Ce.runningWorkers.indexOf(ra), 1), 
                        ra.pthread_ptr = 0;
                    }(ke.thread) : Ke === "cancelThread" ? function(kt) {
                        Ce.pthreads[kt].postMessage({
                            cmd: "cancel"
                        });
                    }(ke.thread) : Ke === "loaded" ? (j.loaded = !0, b && j.unref(), 
                    J && J(j), j.runPthread && j.runPthread()) : Ke === "print" ? M("Thread " + ke.threadId + ": " + ke.text) : Ke === "printErr" ? F("Thread " + ke.threadId + ": " + ke.text) : Ke === "alert" ? alert("Thread " + ke.threadId + ": " + ke.text) : ke.target === "setimmediate" ? j.postMessage(ke) : Ke === "callHandler" ? d[ke.handler](...ke.args) : Ke && F("worker sent an unknown command " + Ke), 
                    Ce.currentProxiedOperationCallerThread = void 0;
                }, j.onerror = Ie => {
                    throw F("worker sent an error! " + Ie.filename + ":" + Ie.lineno + ": " + Ie.message), 
                    Ie;
                }, b && (j.on("message", function(Ie) {
                    j.onmessage({
                        data: Ie
                    });
                }), j.on("error", function(Ie) {
                    j.onerror(Ie);
                }), j.on("detachedExit", function() {}));
                var Ae = [];
                for (var Fe of [ "onExit", "onAbort", "print", "printErr" ]) d.hasOwnProperty(Fe) && Ae.push(Fe);
                j.postMessage({
                    cmd: "load",
                    handlers: Ae,
                    urlOrBlob: d.mainScriptUrlOrBlob || n,
                    wasmMemory: L,
                    wasmModule: O
                });
            },
            allocateUnusedWorker: function() {
                var j, J = N("tfjs-backend-wasm-threaded-simd.worker.js");
                j = new Worker(J), Ce.unusedWorkers.push(j);
            },
            getNewWorker: function() {
                return Ce.unusedWorkers.length == 0 && (Ce.allocateUnusedWorker(), 
                Ce.loadWasmModuleToWorker(Ce.unusedWorkers[0])), Ce.unusedWorkers.pop();
            }
        };
        function mt(j) {
            for (;j.length > 0; ) j.shift()(d);
        }
        function an(j) {
            if (v) return Kn(2, 0, j);
            try {
                et(j);
            } catch (J) {
                (function(Ae) {
                    if (Ae instanceof Pe || Ae == "unwind") return B;
                    y(1, Ae);
                })(J);
            }
        }
        d.PThread = Ce, d.establishStackSpace = function() {
            var j = Cp(), J = i()[j + 52 >>> 2], Ae = i()[j + 56 >>> 2];
            G2(J, J - Ae), $p(J);
        };
        var _a, os = [];
        function Du(j, J, Ae, Fe) {
            return v ? Kn(3, 1, j, J, Ae, Fe) : zu(j, J, Ae, Fe);
        }
        function zu(j, J, Ae, Fe) {
            if (typeof SharedArrayBuffer > "u") return F("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 
            6;
            var Ie = [];
            if (v && Ie.length === 0) return Du(j, J, Ae, Fe);
            var ke = {
                startRoutine: Ae,
                pthread_ptr: j,
                arg: Fe,
                transferList: Ie
            };
            return v ? (ke.cmd = "spawnThread", postMessage(ke, Ie), 0) : De(ke);
        }
        function bn(j) {
            Atomics.store(i(), j >> 2, 1), Cp() && V2(j), Atomics.compareExchange(i(), j >> 2, 1, 0);
        }
        function Pn(j) {
            Pn.shown || (Pn.shown = {}), Pn.shown[j] || (Pn.shown[j] = 1, b && (j = "warning: " + j), 
            F(j));
        }
        function Kn(j, J) {
            var Ae = arguments.length - 2, Fe = arguments;
            return function(Ie) {
                var ke = Oh(), Ke = Ie();
                return $p(ke), Ke;
            }(() => {
                for (var Ie = Ae, ke = Mp(8 * Ie), Ke = ke >> 3, Dt = 0; Dt < Ae; Dt++) {
                    var kt = Fe[2 + Dt];
                    o()[Ke + Dt >>> 0] = kt;
                }
                return B2(j, Ie, ke, J);
            });
        }
        d.invokeEntryPoint = function(j, J) {
            var Ae = function(Fe) {
                var Ie = os[Fe];
                return Ie || (Fe >= os.length && (os.length = Fe + 1), os[Fe] = Ie = Re.get(Fe)), 
                Ie;
            }(j)(J);
            me() ? Ce.setExitStatus(Ae) : U2(Ae);
        }, d.executeNotifiedProxyingQueue = bn, _a = b ? () => {
            var j = process.hrtime();
            return 1e3 * j[0] + j[1] / 1e6;
        } : () => performance.timeOrigin + performance.now();
        var ls = [];
        function Fh(j) {
            try {
                return L.grow(j - G.byteLength + 65535 >>> 16), pe(L.buffer), 1;
            } catch {}
        }
        function Np(j) {
            return v ? Kn(4, 1, j) : 52;
        }
        function el(j, J, Ae, Fe, Ie) {
            return v ? Kn(5, 1, j, J, Ae, Fe, Ie) : 70;
        }
        var Zn = [ null, [], [] ];
        function Bt(j, J) {
            var Ae = Zn[j];
            J === 0 || J === 10 ? ((j === 1 ? M : F)(re(Ae, 0)), Ae.length = 0) : Ae.push(J);
        }
        function Lu(j, J, Ae, Fe) {
            if (v) return Kn(6, 1, j, J, Ae, Fe);
            for (var Ie = 0, ke = 0; ke < Ae; ke++) {
                var Ke = l()[J >>> 2], Dt = l()[J + 4 >>> 2];
                J += 8;
                for (var kt = 0; kt < Dt; kt++) Bt(j, s()[Ke + kt >>> 0]);
                Ie += Dt;
            }
            return l()[Fe >>> 2] = Ie, 0;
        }
        function us(j) {
            return d["_" + j];
        }
        function tl(j, J) {
            (L.buffer != G && pe(L.buffer), W).set(j, J >>> 0);
        }
        function Vt(j, J, Ae, Fe, Ie) {
            var ke = {
                string: ga => {
                    var hr = 0;
                    if (ga != null && ga !== 0) {
                        var Fp = 1 + (ga.length << 2);
                        (function(v6, w6, k6) {
                            (function(Ph, ya, rn, K2) {
                                if (!(K2 > 0)) return 0;
                                rn >>>= 0;
                                for (var _p = rn + K2 - 1, Op = 0; Op < Ph.length; ++Op) {
                                    var sn = Ph.charCodeAt(Op);
                                    if (sn >= 55296 && sn <= 57343 && (sn = 65536 + ((1023 & sn) << 10) | 1023 & Ph.charCodeAt(++Op)), 
                                    sn <= 127) {
                                        if (rn >= _p) break;
                                        ya[rn++ >>> 0] = sn;
                                    } else if (sn <= 2047) {
                                        if (rn + 1 >= _p) break;
                                        ya[rn++ >>> 0] = 192 | sn >> 6, ya[rn++ >>> 0] = 128 | 63 & sn;
                                    } else if (sn <= 65535) {
                                        if (rn + 2 >= _p) break;
                                        ya[rn++ >>> 0] = 224 | sn >> 12, ya[rn++ >>> 0] = 128 | sn >> 6 & 63, 
                                        ya[rn++ >>> 0] = 128 | 63 & sn;
                                    } else {
                                        if (rn + 3 >= _p) break;
                                        ya[rn++ >>> 0] = 240 | sn >> 18, ya[rn++ >>> 0] = 128 | sn >> 12 & 63, 
                                        ya[rn++ >>> 0] = 128 | sn >> 6 & 63, ya[rn++ >>> 0] = 128 | 63 & sn;
                                    }
                                }
                                ya[rn >>> 0] = 0;
                            })(v6, s(), w6, k6);
                        })(ga, hr = Mp(Fp), Fp);
                    }
                    return hr;
                },
                array: ga => {
                    var hr = Mp(ga.length);
                    return tl(ga, hr), hr;
                }
            };
            function Ke(ga) {
                return J === "string" ? function(hr, Fp) {
                    return (hr >>>= 0) ? re(s(), hr, Fp) : "";
                }(ga) : J === "boolean" ? !!ga : ga;
            }
            var Dt = us(j), kt = [], ra = 0;
            if (Fe) for (var ja = 0; ja < Fe.length; ja++) {
                var j2 = ke[Ae[ja]];
                j2 ? (ra === 0 && (ra = Oh()), kt[ja] = j2(Fe[ja])) : kt[ja] = Fe[ja];
            }
            var q2, X2 = Dt.apply(null, kt);
            return q2 = X2, ra !== 0 && $p(ra), X2 = Ke(q2);
        }
        Ce.init();
        var x6 = [ null, Xe, an, Du, Np, el, Lu ], L2 = {
            __emscripten_init_main_thread_js: function(j) {
                W2(j, !x, 1, !A), Ce.threadInitTLS();
            },
            __emscripten_thread_cleanup: function(j) {
                v ? postMessage({
                    cmd: "cleanupThread",
                    thread: j
                }) : Ge(j);
            },
            __pthread_create_js: zu,
            _emscripten_default_pthread_stack_size: function() {
                return 65536;
            },
            _emscripten_get_now_is_monotonic: function() {
                return !0;
            },
            _emscripten_notify_task_queue: function(j, J, Ae, Fe) {
                if (j == J) setTimeout(() => bn(Fe)); else if (v) postMessage({
                    targetThread: j,
                    cmd: "processProxyingQueue",
                    queue: Fe
                }); else {
                    var Ie = Ce.pthreads[j];
                    if (!Ie) return;
                    Ie.postMessage({
                        cmd: "processProxyingQueue",
                        queue: Fe
                    });
                }
                return 1;
            },
            _emscripten_set_offscreencanvas_size: function(j, J, Ae) {
                return -1;
            },
            abort: function() {
                nt("");
            },
            emscripten_check_blocking_allowed: function() {
                b || x || Pn("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
            },
            emscripten_date_now: function() {
                return Date.now();
            },
            emscripten_get_heap_max: function() {
                return 4294901760;
            },
            emscripten_get_now: _a,
            emscripten_memcpy_big: function(j, J, Ae) {
                s().copyWithin(j >>> 0, J >>> 0, J + Ae >>> 0);
            },
            emscripten_num_logical_cores: function() {
                return b ? V6().cpus().length : navigator.hardwareConcurrency;
            },
            emscripten_receive_on_main_thread_js: function(j, J, Ae) {
                ls.length = J;
                for (var Fe = Ae >> 3, Ie = 0; Ie < J; Ie++) ls[Ie] = o()[Fe + Ie >>> 0];
                return (j < 0 ? ie[-j - 1] : x6[j]).apply(null, ls);
            },
            emscripten_resize_heap: function(j) {
                var J = s().length;
                if ((j >>>= 0) <= J) return !1;
                var Ae, Fe, Ie = 4294901760;
                if (j > Ie) return !1;
                for (var ke = 1; ke <= 4; ke *= 2) {
                    var Ke = J * (1 + .2 / ke);
                    if (Ke = Math.min(Ke, j + 100663296), Fh(Math.min(Ie, (Ae = Math.max(j, Ke)) + ((Fe = 65536) - Ae % Fe) % Fe))) return !0;
                }
                return !1;
            },
            emscripten_unwind_to_js_event_loop: function() {
                throw "unwind";
            },
            exit: et,
            fd_close: Np,
            fd_seek: el,
            fd_write: Lu,
            memory: L || d.wasmMemory
        };
        (function() {
            var j = {
                env: L2,
                wasi_snapshot_preview1: L2
            };
            function J(Ie, ke) {
                var Ke = Ie.exports;
                if (d.asm = Ke, function(kt) {
                    Ce.tlsInitFunctions.push(kt);
                }(d.asm._emscripten_tls_init), Re = d.asm.__indirect_function_table, 
                function(kt) {
                    Me.unshift(kt);
                }(d.asm.__wasm_call_ctors), O = ke, !v) {
                    var Dt = Ce.unusedWorkers.length;
                    Ce.unusedWorkers.forEach(function(kt) {
                        Ce.loadWasmModuleToWorker(kt, function() {
                            --Dt || function(ra) {
                                if (we--, d.monitorRunDependencies && d.monitorRunDependencies(we), 
                                we == 0 && Be) {
                                    var ja = Be;
                                    Be = null, ja();
                                }
                            }();
                        });
                    });
                }
            }
            function Ae(Ie) {
                J(Ie.instance, Ie.module);
            }
            function Fe(Ie) {
                return function() {
                    if (!$ && (A || x)) {
                        if (typeof fetch == "function" && !nn(Ve)) return fetch(Ve, {
                            credentials: "same-origin"
                        }).then(function(ke) {
                            if (!ke.ok) throw "failed to load wasm binary file at '" + Ve + "'";
                            return ke.arrayBuffer();
                        }).catch(function() {
                            return K(Ve);
                        });
                        if (f) return new Promise(function(ke, Ke) {
                            f(Ve, function(Dt) {
                                ke(new Uint8Array(Dt));
                            }, Ke);
                        });
                    }
                    return Promise.resolve().then(function() {
                        return K(Ve);
                    });
                }().then(function(ke) {
                    return WebAssembly.instantiate(ke, j);
                }).then(function(ke) {
                    return ke;
                }).then(Ie, function(ke) {
                    F("failed to asynchronously prepare wasm: " + ke), nt(ke);
                });
            }
            if (v || (we++, d.monitorRunDependencies && d.monitorRunDependencies(we)), 
            d.instantiateWasm) try {
                return d.instantiateWasm(j, J);
            } catch (Ie) {
                F("Module.instantiateWasm callback failed with error: " + Ie), u(Ie);
            }
            ($ || typeof WebAssembly.instantiateStreaming != "function" || ct(Ve) || nn(Ve) || b || typeof fetch != "function" ? Fe(Ae) : fetch(Ve, {
                credentials: "same-origin"
            }).then(function(Ie) {
                return WebAssembly.instantiateStreaming(Ie, j).then(Ae, function(ke) {
                    return F("wasm streaming compile failed: " + ke), F("falling back to ArrayBuffer instantiation"), 
                    Fe(Ae);
                });
            })).catch(u);
        })(), d.___wasm_call_ctors = function() {
            return (d.___wasm_call_ctors = d.asm.__wasm_call_ctors).apply(null, arguments);
        }, d._init = function() {
            return (d._init = d.asm.init).apply(null, arguments);
        }, d._init_with_threads_count = function() {
            return (d._init_with_threads_count = d.asm.init_with_threads_count).apply(null, arguments);
        }, d._get_threads_count = function() {
            return (d._get_threads_count = d.asm.get_threads_count).apply(null, arguments);
        }, d._register_tensor = function() {
            return (d._register_tensor = d.asm.register_tensor).apply(null, arguments);
        }, d._dispose_data = function() {
            return (d._dispose_data = d.asm.dispose_data).apply(null, arguments);
        }, d._dispose = function() {
            return (d._dispose = d.asm.dispose).apply(null, arguments);
        }, d._Abs = function() {
            return (d._Abs = d.asm.Abs).apply(null, arguments);
        }, d._Acos = function() {
            return (d._Acos = d.asm.Acos).apply(null, arguments);
        }, d._Acosh = function() {
            return (d._Acosh = d.asm.Acosh).apply(null, arguments);
        }, d._Add = function() {
            return (d._Add = d.asm.Add).apply(null, arguments);
        }, d._AddN = function() {
            return (d._AddN = d.asm.AddN).apply(null, arguments);
        }, d._All = function() {
            return (d._All = d.asm.All).apply(null, arguments);
        }, d._Any = function() {
            return (d._Any = d.asm.Any).apply(null, arguments);
        }, d._ArgMax = function() {
            return (d._ArgMax = d.asm.ArgMax).apply(null, arguments);
        }, d._ArgMin = function() {
            return (d._ArgMin = d.asm.ArgMin).apply(null, arguments);
        }, d._Asin = function() {
            return (d._Asin = d.asm.Asin).apply(null, arguments);
        }, d._Asinh = function() {
            return (d._Asinh = d.asm.Asinh).apply(null, arguments);
        }, d._Atan = function() {
            return (d._Atan = d.asm.Atan).apply(null, arguments);
        }, d._Atan2 = function() {
            return (d._Atan2 = d.asm.Atan2).apply(null, arguments);
        }, d._Atanh = function() {
            return (d._Atanh = d.asm.Atanh).apply(null, arguments);
        }, d._AvgPool = function() {
            return (d._AvgPool = d.asm.AvgPool).apply(null, arguments);
        }, d._AvgPool3D = function() {
            return (d._AvgPool3D = d.asm.AvgPool3D).apply(null, arguments);
        }, d._AvgPool3DGrad = function() {
            return (d._AvgPool3DGrad = d.asm.AvgPool3DGrad).apply(null, arguments);
        }, d._AvgPoolGrad = function() {
            return (d._AvgPoolGrad = d.asm.AvgPoolGrad).apply(null, arguments);
        }, d._BatchMatMul = function() {
            return (d._BatchMatMul = d.asm.BatchMatMul).apply(null, arguments);
        }, d._Bincount = function() {
            return (d._Bincount = d.asm.Bincount).apply(null, arguments);
        }, d._BitwiseAnd = function() {
            return (d._BitwiseAnd = d.asm.BitwiseAnd).apply(null, arguments);
        }, d._Ceil = function() {
            return (d._Ceil = d.asm.Ceil).apply(null, arguments);
        }, d._ClipByValue = function() {
            return (d._ClipByValue = d.asm.ClipByValue).apply(null, arguments);
        }, d._Conv2D = function() {
            return (d._Conv2D = d.asm.Conv2D).apply(null, arguments);
        }, d._Conv2DBackpropInput = function() {
            return (d._Conv2DBackpropInput = d.asm.Conv2DBackpropInput).apply(null, arguments);
        }, d._Conv3D = function() {
            return (d._Conv3D = d.asm.Conv3D).apply(null, arguments);
        }, d._Conv3DBackpropFilterV2 = function() {
            return (d._Conv3DBackpropFilterV2 = d.asm.Conv3DBackpropFilterV2).apply(null, arguments);
        }, d._Conv3DBackpropInputV2 = function() {
            return (d._Conv3DBackpropInputV2 = d.asm.Conv3DBackpropInputV2).apply(null, arguments);
        }, d._Cos = function() {
            return (d._Cos = d.asm.Cos).apply(null, arguments);
        }, d._Cosh = function() {
            return (d._Cosh = d.asm.Cosh).apply(null, arguments);
        }, d._CropAndResize = function() {
            return (d._CropAndResize = d.asm.CropAndResize).apply(null, arguments);
        }, d._Cumprod = function() {
            return (d._Cumprod = d.asm.Cumprod).apply(null, arguments);
        }, d._Cumsum = function() {
            return (d._Cumsum = d.asm.Cumsum).apply(null, arguments);
        }, d._DenseBincount = function() {
            return (d._DenseBincount = d.asm.DenseBincount).apply(null, arguments);
        }, d._DepthToSpace = function() {
            return (d._DepthToSpace = d.asm.DepthToSpace).apply(null, arguments);
        }, d._DepthwiseConv2dNative = function() {
            return (d._DepthwiseConv2dNative = d.asm.DepthwiseConv2dNative).apply(null, arguments);
        }, d._Diag = function() {
            return (d._Diag = d.asm.Diag).apply(null, arguments);
        }, d._Dilation2D = function() {
            return (d._Dilation2D = d.asm.Dilation2D).apply(null, arguments);
        }, d._Dilation2DBackpropFilter = function() {
            return (d._Dilation2DBackpropFilter = d.asm.Dilation2DBackpropFilter).apply(null, arguments);
        }, d._Dilation2DBackpropInput = function() {
            return (d._Dilation2DBackpropInput = d.asm.Dilation2DBackpropInput).apply(null, arguments);
        }, d._Elu = function() {
            return (d._Elu = d.asm.Elu).apply(null, arguments);
        }, d._EluGrad = function() {
            return (d._EluGrad = d.asm.EluGrad).apply(null, arguments);
        }, d._Equal = function() {
            return (d._Equal = d.asm.Equal).apply(null, arguments);
        }, d._Erf = function() {
            return (d._Erf = d.asm.Erf).apply(null, arguments);
        }, d._Exp = function() {
            return (d._Exp = d.asm.Exp).apply(null, arguments);
        }, d._Expm1 = function() {
            return (d._Expm1 = d.asm.Expm1).apply(null, arguments);
        }, d._FlipLeftRight = function() {
            return (d._FlipLeftRight = d.asm.FlipLeftRight).apply(null, arguments);
        }, d._Floor = function() {
            return (d._Floor = d.asm.Floor).apply(null, arguments);
        }, d._FloorDiv = function() {
            return (d._FloorDiv = d.asm.FloorDiv).apply(null, arguments);
        }, d._FusedBatchNorm = function() {
            return (d._FusedBatchNorm = d.asm.FusedBatchNorm).apply(null, arguments);
        }, d._FusedConv2D = function() {
            return (d._FusedConv2D = d.asm.FusedConv2D).apply(null, arguments);
        }, d._FusedDepthwiseConv2D = function() {
            return (d._FusedDepthwiseConv2D = d.asm.FusedDepthwiseConv2D).apply(null, arguments);
        }, d._Gather = function() {
            return (d._Gather = d.asm.Gather).apply(null, arguments);
        }, d._GatherNd = function() {
            return (d._GatherNd = d.asm.GatherNd).apply(null, arguments);
        }, d._Greater = function() {
            return (d._Greater = d.asm.Greater).apply(null, arguments);
        }, d._GreaterEqual = function() {
            return (d._GreaterEqual = d.asm.GreaterEqual).apply(null, arguments);
        }, d._IsFinite = function() {
            return (d._IsFinite = d.asm.IsFinite).apply(null, arguments);
        }, d._IsInf = function() {
            return (d._IsInf = d.asm.IsInf).apply(null, arguments);
        }, d._IsNan = function() {
            return (d._IsNan = d.asm.IsNan).apply(null, arguments);
        }, d._LRN = function() {
            return (d._LRN = d.asm.LRN).apply(null, arguments);
        }, d._LRNGrad = function() {
            return (d._LRNGrad = d.asm.LRNGrad).apply(null, arguments);
        }, d._LeakyRelu = function() {
            return (d._LeakyRelu = d.asm.LeakyRelu).apply(null, arguments);
        }, d._Less = function() {
            return (d._Less = d.asm.Less).apply(null, arguments);
        }, d._LessEqual = function() {
            return (d._LessEqual = d.asm.LessEqual).apply(null, arguments);
        }, d._LinSpace = function() {
            return (d._LinSpace = d.asm.LinSpace).apply(null, arguments);
        }, d._Log = function() {
            return (d._Log = d.asm.Log).apply(null, arguments);
        }, d._Log1p = function() {
            return (d._Log1p = d.asm.Log1p).apply(null, arguments);
        }, d._LogicalAnd = function() {
            return (d._LogicalAnd = d.asm.LogicalAnd).apply(null, arguments);
        }, d._LogicalNot = function() {
            return (d._LogicalNot = d.asm.LogicalNot).apply(null, arguments);
        }, d._LogicalOr = function() {
            return (d._LogicalOr = d.asm.LogicalOr).apply(null, arguments);
        }, d._LogicalXor = function() {
            return (d._LogicalXor = d.asm.LogicalXor).apply(null, arguments);
        }, d._Max = function() {
            return (d._Max = d.asm.Max).apply(null, arguments);
        }, d._MaxPool = function() {
            return (d._MaxPool = d.asm.MaxPool).apply(null, arguments);
        }, d._MaxPool3D = function() {
            return (d._MaxPool3D = d.asm.MaxPool3D).apply(null, arguments);
        }, d._MaxPool3DGrad = function() {
            return (d._MaxPool3DGrad = d.asm.MaxPool3DGrad).apply(null, arguments);
        }, d._MaxPoolGrad = function() {
            return (d._MaxPoolGrad = d.asm.MaxPoolGrad).apply(null, arguments);
        }, d._MaxPoolWithArgmax = function() {
            return (d._MaxPoolWithArgmax = d.asm.MaxPoolWithArgmax).apply(null, arguments);
        }, d._Maximum = function() {
            return (d._Maximum = d.asm.Maximum).apply(null, arguments);
        }, d._Mean = function() {
            return (d._Mean = d.asm.Mean).apply(null, arguments);
        }, d._Min = function() {
            return (d._Min = d.asm.Min).apply(null, arguments);
        }, d._Minimum = function() {
            return (d._Minimum = d.asm.Minimum).apply(null, arguments);
        }, d._MirrorPad = function() {
            return (d._MirrorPad = d.asm.MirrorPad).apply(null, arguments);
        }, d._Mod = function() {
            return (d._Mod = d.asm.Mod).apply(null, arguments);
        }, d._Multinomial = function() {
            return (d._Multinomial = d.asm.Multinomial).apply(null, arguments);
        }, d._Multiply = function() {
            return (d._Multiply = d.asm.Multiply).apply(null, arguments);
        }, d._Neg = function() {
            return (d._Neg = d.asm.Neg).apply(null, arguments);
        }, d._NonMaxSuppressionV3 = function() {
            return (d._NonMaxSuppressionV3 = d.asm.NonMaxSuppressionV3).apply(null, arguments);
        }, d._NonMaxSuppressionV4 = function() {
            return (d._NonMaxSuppressionV4 = d.asm.NonMaxSuppressionV4).apply(null, arguments);
        }, d._NonMaxSuppressionV5 = function() {
            return (d._NonMaxSuppressionV5 = d.asm.NonMaxSuppressionV5).apply(null, arguments);
        }, d._NotEqual = function() {
            return (d._NotEqual = d.asm.NotEqual).apply(null, arguments);
        }, d._OneHot = function() {
            return (d._OneHot = d.asm.OneHot).apply(null, arguments);
        }, d._PadV2 = function() {
            return (d._PadV2 = d.asm.PadV2).apply(null, arguments);
        }, d._Pow = function() {
            return (d._Pow = d.asm.Pow).apply(null, arguments);
        }, d._Prelu = function() {
            return (d._Prelu = d.asm.Prelu).apply(null, arguments);
        }, d._Prod = function() {
            return (d._Prod = d.asm.Prod).apply(null, arguments);
        }, d._RealDiv = function() {
            return (d._RealDiv = d.asm.RealDiv).apply(null, arguments);
        }, d._Reciprocal = function() {
            return (d._Reciprocal = d.asm.Reciprocal).apply(null, arguments);
        }, d._Relu = function() {
            return (d._Relu = d.asm.Relu).apply(null, arguments);
        }, d._Relu6 = function() {
            return (d._Relu6 = d.asm.Relu6).apply(null, arguments);
        }, d._ResizeBilinear = function() {
            return (d._ResizeBilinear = d.asm.ResizeBilinear).apply(null, arguments);
        }, d._ResizeBilinearGrad = function() {
            return (d._ResizeBilinearGrad = d.asm.ResizeBilinearGrad).apply(null, arguments);
        }, d._ResizeNearestNeighbor = function() {
            return (d._ResizeNearestNeighbor = d.asm.ResizeNearestNeighbor).apply(null, arguments);
        }, d._ResizeNearestNeighborGrad = function() {
            return (d._ResizeNearestNeighborGrad = d.asm.ResizeNearestNeighborGrad).apply(null, arguments);
        }, d._Reverse = function() {
            return (d._Reverse = d.asm.Reverse).apply(null, arguments);
        }, d._RotateWithOffset = function() {
            return (d._RotateWithOffset = d.asm.RotateWithOffset).apply(null, arguments);
        }, d._Round = function() {
            return (d._Round = d.asm.Round).apply(null, arguments);
        }, d._Rsqrt = function() {
            return (d._Rsqrt = d.asm.Rsqrt).apply(null, arguments);
        }, d._ScatterNd = function() {
            return (d._ScatterNd = d.asm.ScatterNd).apply(null, arguments);
        }, d._SearchSorted = function() {
            return (d._SearchSorted = d.asm.SearchSorted).apply(null, arguments);
        }, d._SelectV2 = function() {
            return (d._SelectV2 = d.asm.SelectV2).apply(null, arguments);
        }, d._Selu = function() {
            return (d._Selu = d.asm.Selu).apply(null, arguments);
        }, d._Sigmoid = function() {
            return (d._Sigmoid = d.asm.Sigmoid).apply(null, arguments);
        }, d._Sign = function() {
            return (d._Sign = d.asm.Sign).apply(null, arguments);
        }, d._Sin = function() {
            return (d._Sin = d.asm.Sin).apply(null, arguments);
        }, d._Sinh = function() {
            return (d._Sinh = d.asm.Sinh).apply(null, arguments);
        }, d._Softmax = function() {
            return (d._Softmax = d.asm.Softmax).apply(null, arguments);
        }, d._Softplus = function() {
            return (d._Softplus = d.asm.Softplus).apply(null, arguments);
        }, d._SparseFillEmptyRows = function() {
            return (d._SparseFillEmptyRows = d.asm.SparseFillEmptyRows).apply(null, arguments);
        }, d._SparseReshape = function() {
            return (d._SparseReshape = d.asm.SparseReshape).apply(null, arguments);
        }, d._SparseSegmentReduction = function() {
            return (d._SparseSegmentReduction = d.asm.SparseSegmentReduction).apply(null, arguments);
        }, d._SparseToDense = function() {
            return (d._SparseToDense = d.asm.SparseToDense).apply(null, arguments);
        }, d._Sqrt = function() {
            return (d._Sqrt = d.asm.Sqrt).apply(null, arguments);
        }, d._Square = function() {
            return (d._Square = d.asm.Square).apply(null, arguments);
        }, d._SquaredDifference = function() {
            return (d._SquaredDifference = d.asm.SquaredDifference).apply(null, arguments);
        }, d._Step = function() {
            return (d._Step = d.asm.Step).apply(null, arguments);
        }, d._StridedSlice = function() {
            return (d._StridedSlice = d.asm.StridedSlice).apply(null, arguments);
        }, d._Sub = function() {
            return (d._Sub = d.asm.Sub).apply(null, arguments);
        }, d._Sum = function() {
            return (d._Sum = d.asm.Sum).apply(null, arguments);
        }, d._Tan = function() {
            return (d._Tan = d.asm.Tan).apply(null, arguments);
        }, d._Tanh = function() {
            return (d._Tanh = d.asm.Tanh).apply(null, arguments);
        }, d._TensorScatterUpdate = function() {
            return (d._TensorScatterUpdate = d.asm.TensorScatterUpdate).apply(null, arguments);
        }, d._Tile = function() {
            return (d._Tile = d.asm.Tile).apply(null, arguments);
        }, d._TopK = function() {
            return (d._TopK = d.asm.TopK).apply(null, arguments);
        }, d._Transform = function() {
            return (d._Transform = d.asm.Transform).apply(null, arguments);
        }, d._Transpose = function() {
            return (d._Transpose = d.asm.Transpose).apply(null, arguments);
        }, d.__FusedMatMul = function() {
            return (d.__FusedMatMul = d.asm._FusedMatMul).apply(null, arguments);
        }, d._malloc = function() {
            return (d._malloc = d.asm.malloc).apply(null, arguments);
        }, d._free = function() {
            return (d._free = d.asm.free).apply(null, arguments);
        }, d.__emscripten_tls_init = function() {
            return (d.__emscripten_tls_init = d.asm._emscripten_tls_init).apply(null, arguments);
        };
        var Cp = d._pthread_self = function() {
            return (Cp = d._pthread_self = d.asm.pthread_self).apply(null, arguments);
        };
        d.___errno_location = function() {
            return (d.___errno_location = d.asm.__errno_location).apply(null, arguments);
        };
        var W2 = d.__emscripten_thread_init = function() {
            return (W2 = d.__emscripten_thread_init = d.asm._emscripten_thread_init).apply(null, arguments);
        };
        d.__emscripten_thread_crashed = function() {
            return (d.__emscripten_thread_crashed = d.asm._emscripten_thread_crashed).apply(null, arguments);
        }, d._emscripten_main_thread_process_queued_calls = function() {
            return (d._emscripten_main_thread_process_queued_calls = d.asm.emscripten_main_thread_process_queued_calls).apply(null, arguments);
        }, d._emscripten_main_browser_thread_id = function() {
            return (d._emscripten_main_browser_thread_id = d.asm.emscripten_main_browser_thread_id).apply(null, arguments);
        };
        var B2 = d._emscripten_run_in_main_runtime_thread_js = function() {
            return (B2 = d._emscripten_run_in_main_runtime_thread_js = d.asm.emscripten_run_in_main_runtime_thread_js).apply(null, arguments);
        };
        d._emscripten_dispatch_to_thread_ = function() {
            return (d._emscripten_dispatch_to_thread_ = d.asm.emscripten_dispatch_to_thread_).apply(null, arguments);
        };
        var Tp, Rp, Ep, V2 = d.__emscripten_proxy_execute_task_queue = function() {
            return (V2 = d.__emscripten_proxy_execute_task_queue = d.asm._emscripten_proxy_execute_task_queue).apply(null, arguments);
        }, _h = d.__emscripten_thread_free_data = function() {
            return (_h = d.__emscripten_thread_free_data = d.asm._emscripten_thread_free_data).apply(null, arguments);
        }, U2 = d.__emscripten_thread_exit = function() {
            return (U2 = d.__emscripten_thread_exit = d.asm._emscripten_thread_exit).apply(null, arguments);
        }, G2 = d._emscripten_stack_set_limits = function() {
            return (G2 = d._emscripten_stack_set_limits = d.asm.emscripten_stack_set_limits).apply(null, arguments);
        }, Oh = d.stackSave = function() {
            return (Oh = d.stackSave = d.asm.stackSave).apply(null, arguments);
        }, $p = d.stackRestore = function() {
            return ($p = d.stackRestore = d.asm.stackRestore).apply(null, arguments);
        }, Mp = d.stackAlloc = function() {
            return (Mp = d.stackAlloc = d.asm.stackAlloc).apply(null, arguments);
        };
        function H2(j) {
            if (!(we > 0)) {
                if (v) return p(d), Oe(), void startWorker(d);
                (function() {
                    if (d.preRun) for (typeof d.preRun == "function" && (d.preRun = [ d.preRun ]); d.preRun.length; ) Ae = d.preRun.shift(), 
                    ye.unshift(Ae);
                    var Ae;
                    mt(ye);
                })(), we > 0 || (d.setStatus ? (d.setStatus("Running..."), setTimeout(function() {
                    setTimeout(function() {
                        d.setStatus("");
                    }, 1), J();
                }, 1)) : J());
            }
            function J() {
                Tp || (Tp = !0, d.calledRun = !0, !Y && (Oe(), p(d), d.onRuntimeInitialized && d.onRuntimeInitialized(), 
                function() {
                    if (!v) {
                        if (d.postRun) for (typeof d.postRun == "function" && (d.postRun = [ d.postRun ]); d.postRun.length; ) Ae = d.postRun.shift(), 
                        Ee.unshift(Ae);
                        mt(Ee);
                    }
                    var Ae;
                }()));
            }
        }
        if (d.dynCall_iijjiiii = function() {
            return (d.dynCall_iijjiiii = d.asm.dynCall_iijjiiii).apply(null, arguments);
        }, d.dynCall_jiji = function() {
            return (d.dynCall_jiji = d.asm.dynCall_jiji).apply(null, arguments);
        }, d.keepRuntimeAlive = me, d.wasmMemory = L, d.cwrap = function(j, J, Ae, Fe) {
            var Ie = (Ae = Ae || []).every(ke => ke === "number" || ke === "boolean");
            return J !== "string" && Ie && !Fe ? us(j) : function() {
                return Vt(j, J, Ae, arguments);
            };
        }, d.ExitStatus = Pe, d.PThread = Ce, Be = function j() {
            Tp || H2(), Tp || (Be = j);
        }, d.preInit) for (typeof d.preInit == "function" && (d.preInit = [ d.preInit ]); d.preInit.length > 0; ) d.preInit.pop()();
        if (H2(), c && (Rp = {
            uncaughtException: process.listeners("uncaughtException").filter(function(j) {
                return !c.uncaughtException.indexOf(j) > -1;
            }),
            unhandledRejection: process.listeners("unhandledRejection").filter(function(j) {
                return !c.unhandledRejection.indexOf(j) > -1;
            })
        }), typeof WasmBackendModule < "u") Ep = WasmBackendModule; else {
            if (r === void 0) throw new Error("Could not find wasm module in post.js");
            Ep = r;
        }
        if (Rp) {
            var b6 = Ep._dispose;
            Ep._dispose = function() {
                b6(), Rp.uncaughtException.forEach(function(j) {
                    process.removeListener("uncaughtException", j);
                }), Rp.unhandledRejection.forEach(function(j) {
                    process.removeListener("unhandledRejection", j);
                });
            };
        }
        return r.ready;
    });
    typeof e == "object" && typeof t == "object" ? t.exports = a : typeof define == "function" && define.amd ? define([], function() {
        return a;
    }) : typeof e == "object" && (e.WasmBackendModuleThreadedSimd = a);
}), G6 = zt((e, t) => {
    t.exports.wasmWorkerContents = `"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`;
}), H6 = zt((e, t) => {
    var n, a = (n = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0, 
    typeof __filename < "u" && (n = n || __filename), function(r) {
        var s, i, l, o = (r = r || {}) !== void 0 ? r : {};
        o.ready = new Promise(function(K, ie) {
            s = K, i = ie;
        }), typeof process < "u" && process.listeners && (l = {
            uncaughtException: process.listeners("uncaughtException"),
            unhandledRejection: process.listeners("unhandledRejection")
        });
        var p, u, c, d = Object.assign({}, o), h = typeof window == "object", f = typeof importScripts == "function", m = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", g = "";
        if (m) {
            var y = Q2(), A = e0();
            g = f ? A.dirname(g) + "/" : __dirname + "/", p = (K, ie) => (K = Y(K) ? new URL(K) : A.normalize(K), 
            y.readFileSync(K, ie ? void 0 : "utf8")), c = K => {
                var ie = p(K, !0);
                return ie.buffer || (ie = new Uint8Array(ie)), ie;
            }, u = (K, ie, Pe) => {
                K = Y(K) ? new URL(K) : A.normalize(K), y.readFile(K, function(Ge, De) {
                    Ge ? Pe(Ge) : ie(De.buffer);
                });
            }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), 
            process.on("uncaughtException", function(K) {
                if (!(K instanceof re)) throw K;
            }), process.on("unhandledRejection", function(K) {
                throw K;
            }), o.inspect = function() {
                return "[Emscripten Module object]";
            };
        } else (h || f) && (f ? g = self.location.href : typeof document < "u" && document.currentScript && (g = document.currentScript.src), 
        n && (g = n), g = g.indexOf("blob:") !== 0 ? g.substr(0, g.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", 
        p = K => {
            var ie = new XMLHttpRequest();
            return ie.open("GET", K, !1), ie.send(null), ie.responseText;
        }, f && (c = K => {
            var ie = new XMLHttpRequest();
            return ie.open("GET", K, !1), ie.responseType = "arraybuffer", ie.send(null), 
            new Uint8Array(ie.response);
        }), u = (K, ie, Pe) => {
            var Ge = new XMLHttpRequest();
            Ge.open("GET", K, !0), Ge.responseType = "arraybuffer", Ge.onload = () => {
                Ge.status == 200 || Ge.status == 0 && Ge.response ? ie(Ge.response) : Pe();
            }, Ge.onerror = Pe, Ge.send(null);
        });
        var x, b = o.print || void 0, v = o.printErr || void 0;
        Object.assign(o, d), d = null, o.arguments && o.arguments, o.thisProgram && o.thisProgram, 
        o.quit && o.quit, o.wasmBinary && (x = o.wasmBinary), o.noExitRuntime, typeof WebAssembly != "object" && W("no native wasm support detected");
        var I, N, T, R, w, E = !1, $ = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
        function M(K, ie, Pe) {
            for (var Ge = (ie >>>= 0) + Pe, De = ie; K[De] && !(De >= Ge); ) ++De;
            if (De - ie > 16 && K.buffer && $) return $.decode(K.subarray(ie, De));
            for (var Xe = ""; ie < De; ) {
                var et = K[ie++];
                if (128 & et) {
                    var Ce = 63 & K[ie++];
                    if ((224 & et) != 192) {
                        var mt = 63 & K[ie++];
                        if ((et = (240 & et) == 224 ? (15 & et) << 12 | Ce << 6 | mt : (7 & et) << 18 | Ce << 12 | mt << 6 | 63 & K[ie++]) < 65536) Xe += String.fromCharCode(et); else {
                            var an = et - 65536;
                            Xe += String.fromCharCode(55296 | an >> 10, 56320 | 1023 & an);
                        }
                    } else Xe += String.fromCharCode((31 & et) << 6 | Ce);
                } else Xe += String.fromCharCode(et);
            }
            return Xe;
        }
        function F(K) {
            N = K, o.HEAP8 = T = new Int8Array(K), o.HEAP16 = new Int16Array(K), 
            o.HEAP32 = new Int32Array(K), o.HEAPU8 = R = new Uint8Array(K), o.HEAPU16 = new Uint16Array(K), 
            o.HEAPU32 = w = new Uint32Array(K), o.HEAPF32 = new Float32Array(K), 
            o.HEAPF64 = new Float64Array(K);
        }
        o.INITIAL_MEMORY;
        var P = [], L = [], O = [], B = 0, G = null;
        function W(K) {
            o.onAbort && o.onAbort(K), v(K = "Aborted(" + K + ")"), E = !0, K += ". Build with -sASSERTIONS for more info.";
            var ie = new WebAssembly.RuntimeError(K);
            throw i(ie), ie;
        }
        var z, X, q = "data:application/octet-stream;base64,";
        function Z(K) {
            return K.startsWith(q);
        }
        function Y(K) {
            return K.startsWith("file://");
        }
        function te(K) {
            try {
                if (K == z && x) return new Uint8Array(x);
                if (c) return c(K);
                throw "both async and sync fetching of the wasm failed";
            } catch (ie) {
                W(ie);
            }
        }
        function re(K) {
            this.name = "ExitStatus", this.message = "Program terminated with exit(" + K + ")", 
            this.status = K;
        }
        function pe(K) {
            for (;K.length > 0; ) K.shift()(o);
        }
        function ge(K) {
            try {
                return I.grow(K - N.byteLength + 65535 >>> 16), F(I.buffer), 1;
            } catch {}
        }
        Z(z = "tfjs-backend-wasm.wasm") || (X = z, z = o.locateFile ? o.locateFile(X, g) : g + X);
        var Re = [ null, [], [] ];
        function ye(K, ie) {
            var Pe = Re[K];
            ie === 0 || ie === 10 ? ((K === 1 ? b : v)(M(Pe, 0)), Pe.length = 0) : Pe.push(ie);
        }
        function Me(K) {
            return o["_" + K];
        }
        function Ee(K, ie, Pe, Ge, De) {
            var Xe = {
                string: bn => {
                    var Pn = 0;
                    if (bn != null && bn !== 0) {
                        var Kn = 1 + (bn.length << 2);
                        (function(ls, Fh, Np) {
                            (function(el, Zn, Bt, Lu) {
                                if (!(Lu > 0)) return 0;
                                Bt >>>= 0;
                                for (var us = Bt + Lu - 1, tl = 0; tl < el.length; ++tl) {
                                    var Vt = el.charCodeAt(tl);
                                    if (Vt >= 55296 && Vt <= 57343 && (Vt = 65536 + ((1023 & Vt) << 10) | 1023 & el.charCodeAt(++tl)), 
                                    Vt <= 127) {
                                        if (Bt >= us) break;
                                        Zn[Bt++ >>> 0] = Vt;
                                    } else if (Vt <= 2047) {
                                        if (Bt + 1 >= us) break;
                                        Zn[Bt++ >>> 0] = 192 | Vt >> 6, Zn[Bt++ >>> 0] = 128 | 63 & Vt;
                                    } else if (Vt <= 65535) {
                                        if (Bt + 2 >= us) break;
                                        Zn[Bt++ >>> 0] = 224 | Vt >> 12, Zn[Bt++ >>> 0] = 128 | Vt >> 6 & 63, 
                                        Zn[Bt++ >>> 0] = 128 | 63 & Vt;
                                    } else {
                                        if (Bt + 3 >= us) break;
                                        Zn[Bt++ >>> 0] = 240 | Vt >> 18, Zn[Bt++ >>> 0] = 128 | Vt >> 12 & 63, 
                                        Zn[Bt++ >>> 0] = 128 | Vt >> 6 & 63, Zn[Bt++ >>> 0] = 128 | 63 & Vt;
                                    }
                                }
                                Zn[Bt >>> 0] = 0;
                            })(ls, R, Fh, Np);
                        })(bn, Pn = ue(Kn), Kn);
                    }
                    return Pn;
                },
                array: bn => {
                    var Pn = ue(bn.length);
                    return function(Kn, ls) {
                        T.set(Kn, ls >>> 0);
                    }(bn, Pn), Pn;
                }
            };
            function et(bn) {
                return ie === "string" ? function(Pn, Kn) {
                    return (Pn >>>= 0) ? M(R, Pn, Kn) : "";
                }(bn) : ie === "boolean" ? !!bn : bn;
            }
            var Ce = Me(K), mt = [], an = 0;
            if (Ge) for (var _a = 0; _a < Ge.length; _a++) {
                var os = Xe[Pe[_a]];
                os ? (an === 0 && (an = nt()), mt[_a] = os(Ge[_a])) : mt[_a] = Ge[_a];
            }
            var Du, zu = Ce.apply(null, mt);
            return Du = zu, an !== 0 && Ve(an), zu = et(Du);
        }
        var me = {
            abort: function() {
                W("");
            },
            emscripten_get_heap_max: function() {
                return 4294901760;
            },
            emscripten_memcpy_big: function(K, ie, Pe) {
                R.copyWithin(K >>> 0, ie >>> 0, ie + Pe >>> 0);
            },
            emscripten_resize_heap: function(K) {
                var ie, Pe, Ge = R.length, De = 4294901760;
                if ((K >>>= 0) > De) return !1;
                for (var Xe = 1; Xe <= 4; Xe *= 2) {
                    var et = Ge * (1 + .2 / Xe);
                    if (et = Math.min(et, K + 100663296), ge(Math.min(De, (ie = Math.max(K, et)) + ((Pe = 65536) - ie % Pe) % Pe))) return !0;
                }
                return !1;
            },
            fd_close: function(K) {
                return 52;
            },
            fd_seek: function(K, ie, Pe, Ge, De) {
                return 70;
            },
            fd_write: function(K, ie, Pe, Ge) {
                for (var De = 0, Xe = 0; Xe < Pe; Xe++) {
                    var et = w[ie >>> 2], Ce = w[ie + 4 >>> 2];
                    ie += 8;
                    for (var mt = 0; mt < Ce; mt++) ye(K, R[et + mt >>> 0]);
                    De += Ce;
                }
                return w[Ge >>> 2] = De, 0;
            }
        };
        (function() {
            var K = {
                env: me,
                wasi_snapshot_preview1: me
            };
            function ie(De, Xe) {
                var et = De.exports;
                o.asm = et, F((I = o.asm.memory).buffer), o.asm.__indirect_function_table, 
                function(Ce) {
                    L.unshift(Ce);
                }(o.asm.__wasm_call_ctors), function(Ce) {
                    if (B--, o.monitorRunDependencies && o.monitorRunDependencies(B), 
                    B == 0 && G) {
                        var mt = G;
                        G = null, mt();
                    }
                }();
            }
            function Pe(De) {
                ie(De.instance);
            }
            function Ge(De) {
                return function() {
                    if (!x && (h || f)) {
                        if (typeof fetch == "function" && !Y(z)) return fetch(z, {
                            credentials: "same-origin"
                        }).then(function(Xe) {
                            if (!Xe.ok) throw "failed to load wasm binary file at '" + z + "'";
                            return Xe.arrayBuffer();
                        }).catch(function() {
                            return te(z);
                        });
                        if (u) return new Promise(function(Xe, et) {
                            u(z, function(Ce) {
                                Xe(new Uint8Array(Ce));
                            }, et);
                        });
                    }
                    return Promise.resolve().then(function() {
                        return te(z);
                    });
                }().then(function(Xe) {
                    return WebAssembly.instantiate(Xe, K);
                }).then(function(Xe) {
                    return Xe;
                }).then(De, function(Xe) {
                    v("failed to asynchronously prepare wasm: " + Xe), W(Xe);
                });
            }
            if (B++, o.monitorRunDependencies && o.monitorRunDependencies(B), o.instantiateWasm) try {
                return o.instantiateWasm(K, ie);
            } catch (De) {
                v("Module.instantiateWasm callback failed with error: " + De), i(De);
            }
            (x || typeof WebAssembly.instantiateStreaming != "function" || Z(z) || Y(z) || m || typeof fetch != "function" ? Ge(Pe) : fetch(z, {
                credentials: "same-origin"
            }).then(function(De) {
                return WebAssembly.instantiateStreaming(De, K).then(Pe, function(Xe) {
                    return v("wasm streaming compile failed: " + Xe), v("falling back to ArrayBuffer instantiation"), 
                    Ge(Pe);
                });
            })).catch(i);
        })(), o.___wasm_call_ctors = function() {
            return (o.___wasm_call_ctors = o.asm.__wasm_call_ctors).apply(null, arguments);
        }, o._init = function() {
            return (o._init = o.asm.init).apply(null, arguments);
        }, o._init_with_threads_count = function() {
            return (o._init_with_threads_count = o.asm.init_with_threads_count).apply(null, arguments);
        }, o._get_threads_count = function() {
            return (o._get_threads_count = o.asm.get_threads_count).apply(null, arguments);
        }, o._register_tensor = function() {
            return (o._register_tensor = o.asm.register_tensor).apply(null, arguments);
        }, o._dispose_data = function() {
            return (o._dispose_data = o.asm.dispose_data).apply(null, arguments);
        }, o._dispose = function() {
            return (o._dispose = o.asm.dispose).apply(null, arguments);
        }, o._Abs = function() {
            return (o._Abs = o.asm.Abs).apply(null, arguments);
        }, o._Acos = function() {
            return (o._Acos = o.asm.Acos).apply(null, arguments);
        }, o._Acosh = function() {
            return (o._Acosh = o.asm.Acosh).apply(null, arguments);
        }, o._Add = function() {
            return (o._Add = o.asm.Add).apply(null, arguments);
        }, o._AddN = function() {
            return (o._AddN = o.asm.AddN).apply(null, arguments);
        }, o._All = function() {
            return (o._All = o.asm.All).apply(null, arguments);
        }, o._Any = function() {
            return (o._Any = o.asm.Any).apply(null, arguments);
        }, o._ArgMax = function() {
            return (o._ArgMax = o.asm.ArgMax).apply(null, arguments);
        }, o._ArgMin = function() {
            return (o._ArgMin = o.asm.ArgMin).apply(null, arguments);
        }, o._Asin = function() {
            return (o._Asin = o.asm.Asin).apply(null, arguments);
        }, o._Asinh = function() {
            return (o._Asinh = o.asm.Asinh).apply(null, arguments);
        }, o._Atan = function() {
            return (o._Atan = o.asm.Atan).apply(null, arguments);
        }, o._Atan2 = function() {
            return (o._Atan2 = o.asm.Atan2).apply(null, arguments);
        }, o._Atanh = function() {
            return (o._Atanh = o.asm.Atanh).apply(null, arguments);
        }, o._AvgPool = function() {
            return (o._AvgPool = o.asm.AvgPool).apply(null, arguments);
        }, o._AvgPool3D = function() {
            return (o._AvgPool3D = o.asm.AvgPool3D).apply(null, arguments);
        }, o._AvgPool3DGrad = function() {
            return (o._AvgPool3DGrad = o.asm.AvgPool3DGrad).apply(null, arguments);
        }, o._AvgPoolGrad = function() {
            return (o._AvgPoolGrad = o.asm.AvgPoolGrad).apply(null, arguments);
        }, o._BatchMatMul = function() {
            return (o._BatchMatMul = o.asm.BatchMatMul).apply(null, arguments);
        }, o._Bincount = function() {
            return (o._Bincount = o.asm.Bincount).apply(null, arguments);
        }, o._BitwiseAnd = function() {
            return (o._BitwiseAnd = o.asm.BitwiseAnd).apply(null, arguments);
        }, o._Ceil = function() {
            return (o._Ceil = o.asm.Ceil).apply(null, arguments);
        }, o._ClipByValue = function() {
            return (o._ClipByValue = o.asm.ClipByValue).apply(null, arguments);
        }, o._Conv2D = function() {
            return (o._Conv2D = o.asm.Conv2D).apply(null, arguments);
        }, o._Conv2DBackpropInput = function() {
            return (o._Conv2DBackpropInput = o.asm.Conv2DBackpropInput).apply(null, arguments);
        }, o._Conv3D = function() {
            return (o._Conv3D = o.asm.Conv3D).apply(null, arguments);
        }, o._Conv3DBackpropFilterV2 = function() {
            return (o._Conv3DBackpropFilterV2 = o.asm.Conv3DBackpropFilterV2).apply(null, arguments);
        }, o._Conv3DBackpropInputV2 = function() {
            return (o._Conv3DBackpropInputV2 = o.asm.Conv3DBackpropInputV2).apply(null, arguments);
        }, o._Cos = function() {
            return (o._Cos = o.asm.Cos).apply(null, arguments);
        }, o._Cosh = function() {
            return (o._Cosh = o.asm.Cosh).apply(null, arguments);
        }, o._CropAndResize = function() {
            return (o._CropAndResize = o.asm.CropAndResize).apply(null, arguments);
        }, o._Cumprod = function() {
            return (o._Cumprod = o.asm.Cumprod).apply(null, arguments);
        }, o._Cumsum = function() {
            return (o._Cumsum = o.asm.Cumsum).apply(null, arguments);
        }, o._DenseBincount = function() {
            return (o._DenseBincount = o.asm.DenseBincount).apply(null, arguments);
        }, o._DepthToSpace = function() {
            return (o._DepthToSpace = o.asm.DepthToSpace).apply(null, arguments);
        }, o._DepthwiseConv2dNative = function() {
            return (o._DepthwiseConv2dNative = o.asm.DepthwiseConv2dNative).apply(null, arguments);
        }, o._Diag = function() {
            return (o._Diag = o.asm.Diag).apply(null, arguments);
        }, o._Dilation2D = function() {
            return (o._Dilation2D = o.asm.Dilation2D).apply(null, arguments);
        }, o._Dilation2DBackpropFilter = function() {
            return (o._Dilation2DBackpropFilter = o.asm.Dilation2DBackpropFilter).apply(null, arguments);
        }, o._Dilation2DBackpropInput = function() {
            return (o._Dilation2DBackpropInput = o.asm.Dilation2DBackpropInput).apply(null, arguments);
        }, o._Elu = function() {
            return (o._Elu = o.asm.Elu).apply(null, arguments);
        }, o._EluGrad = function() {
            return (o._EluGrad = o.asm.EluGrad).apply(null, arguments);
        }, o._Equal = function() {
            return (o._Equal = o.asm.Equal).apply(null, arguments);
        }, o._Erf = function() {
            return (o._Erf = o.asm.Erf).apply(null, arguments);
        }, o._Exp = function() {
            return (o._Exp = o.asm.Exp).apply(null, arguments);
        }, o._Expm1 = function() {
            return (o._Expm1 = o.asm.Expm1).apply(null, arguments);
        }, o._FlipLeftRight = function() {
            return (o._FlipLeftRight = o.asm.FlipLeftRight).apply(null, arguments);
        }, o._Floor = function() {
            return (o._Floor = o.asm.Floor).apply(null, arguments);
        }, o._FloorDiv = function() {
            return (o._FloorDiv = o.asm.FloorDiv).apply(null, arguments);
        }, o._FusedBatchNorm = function() {
            return (o._FusedBatchNorm = o.asm.FusedBatchNorm).apply(null, arguments);
        }, o._FusedConv2D = function() {
            return (o._FusedConv2D = o.asm.FusedConv2D).apply(null, arguments);
        }, o._FusedDepthwiseConv2D = function() {
            return (o._FusedDepthwiseConv2D = o.asm.FusedDepthwiseConv2D).apply(null, arguments);
        }, o._Gather = function() {
            return (o._Gather = o.asm.Gather).apply(null, arguments);
        }, o._GatherNd = function() {
            return (o._GatherNd = o.asm.GatherNd).apply(null, arguments);
        }, o._Greater = function() {
            return (o._Greater = o.asm.Greater).apply(null, arguments);
        }, o._GreaterEqual = function() {
            return (o._GreaterEqual = o.asm.GreaterEqual).apply(null, arguments);
        }, o._IsFinite = function() {
            return (o._IsFinite = o.asm.IsFinite).apply(null, arguments);
        }, o._IsInf = function() {
            return (o._IsInf = o.asm.IsInf).apply(null, arguments);
        }, o._IsNan = function() {
            return (o._IsNan = o.asm.IsNan).apply(null, arguments);
        }, o._LRN = function() {
            return (o._LRN = o.asm.LRN).apply(null, arguments);
        }, o._LRNGrad = function() {
            return (o._LRNGrad = o.asm.LRNGrad).apply(null, arguments);
        }, o._LeakyRelu = function() {
            return (o._LeakyRelu = o.asm.LeakyRelu).apply(null, arguments);
        }, o._Less = function() {
            return (o._Less = o.asm.Less).apply(null, arguments);
        }, o._LessEqual = function() {
            return (o._LessEqual = o.asm.LessEqual).apply(null, arguments);
        }, o._LinSpace = function() {
            return (o._LinSpace = o.asm.LinSpace).apply(null, arguments);
        }, o._Log = function() {
            return (o._Log = o.asm.Log).apply(null, arguments);
        }, o._Log1p = function() {
            return (o._Log1p = o.asm.Log1p).apply(null, arguments);
        }, o._LogicalAnd = function() {
            return (o._LogicalAnd = o.asm.LogicalAnd).apply(null, arguments);
        }, o._LogicalNot = function() {
            return (o._LogicalNot = o.asm.LogicalNot).apply(null, arguments);
        }, o._LogicalOr = function() {
            return (o._LogicalOr = o.asm.LogicalOr).apply(null, arguments);
        }, o._LogicalXor = function() {
            return (o._LogicalXor = o.asm.LogicalXor).apply(null, arguments);
        }, o._Max = function() {
            return (o._Max = o.asm.Max).apply(null, arguments);
        }, o._MaxPool = function() {
            return (o._MaxPool = o.asm.MaxPool).apply(null, arguments);
        }, o._MaxPool3D = function() {
            return (o._MaxPool3D = o.asm.MaxPool3D).apply(null, arguments);
        }, o._MaxPool3DGrad = function() {
            return (o._MaxPool3DGrad = o.asm.MaxPool3DGrad).apply(null, arguments);
        }, o._MaxPoolGrad = function() {
            return (o._MaxPoolGrad = o.asm.MaxPoolGrad).apply(null, arguments);
        }, o._MaxPoolWithArgmax = function() {
            return (o._MaxPoolWithArgmax = o.asm.MaxPoolWithArgmax).apply(null, arguments);
        }, o._Maximum = function() {
            return (o._Maximum = o.asm.Maximum).apply(null, arguments);
        }, o._Mean = function() {
            return (o._Mean = o.asm.Mean).apply(null, arguments);
        }, o._Min = function() {
            return (o._Min = o.asm.Min).apply(null, arguments);
        }, o._Minimum = function() {
            return (o._Minimum = o.asm.Minimum).apply(null, arguments);
        }, o._MirrorPad = function() {
            return (o._MirrorPad = o.asm.MirrorPad).apply(null, arguments);
        }, o._Mod = function() {
            return (o._Mod = o.asm.Mod).apply(null, arguments);
        }, o._Multinomial = function() {
            return (o._Multinomial = o.asm.Multinomial).apply(null, arguments);
        }, o._Multiply = function() {
            return (o._Multiply = o.asm.Multiply).apply(null, arguments);
        }, o._Neg = function() {
            return (o._Neg = o.asm.Neg).apply(null, arguments);
        }, o._NonMaxSuppressionV3 = function() {
            return (o._NonMaxSuppressionV3 = o.asm.NonMaxSuppressionV3).apply(null, arguments);
        }, o._NonMaxSuppressionV4 = function() {
            return (o._NonMaxSuppressionV4 = o.asm.NonMaxSuppressionV4).apply(null, arguments);
        }, o._NonMaxSuppressionV5 = function() {
            return (o._NonMaxSuppressionV5 = o.asm.NonMaxSuppressionV5).apply(null, arguments);
        }, o._NotEqual = function() {
            return (o._NotEqual = o.asm.NotEqual).apply(null, arguments);
        }, o._OneHot = function() {
            return (o._OneHot = o.asm.OneHot).apply(null, arguments);
        }, o._PadV2 = function() {
            return (o._PadV2 = o.asm.PadV2).apply(null, arguments);
        }, o._Pow = function() {
            return (o._Pow = o.asm.Pow).apply(null, arguments);
        }, o._Prelu = function() {
            return (o._Prelu = o.asm.Prelu).apply(null, arguments);
        }, o._Prod = function() {
            return (o._Prod = o.asm.Prod).apply(null, arguments);
        }, o._RealDiv = function() {
            return (o._RealDiv = o.asm.RealDiv).apply(null, arguments);
        }, o._Reciprocal = function() {
            return (o._Reciprocal = o.asm.Reciprocal).apply(null, arguments);
        }, o._Relu = function() {
            return (o._Relu = o.asm.Relu).apply(null, arguments);
        }, o._Relu6 = function() {
            return (o._Relu6 = o.asm.Relu6).apply(null, arguments);
        }, o._ResizeBilinear = function() {
            return (o._ResizeBilinear = o.asm.ResizeBilinear).apply(null, arguments);
        }, o._ResizeBilinearGrad = function() {
            return (o._ResizeBilinearGrad = o.asm.ResizeBilinearGrad).apply(null, arguments);
        }, o._ResizeNearestNeighbor = function() {
            return (o._ResizeNearestNeighbor = o.asm.ResizeNearestNeighbor).apply(null, arguments);
        }, o._ResizeNearestNeighborGrad = function() {
            return (o._ResizeNearestNeighborGrad = o.asm.ResizeNearestNeighborGrad).apply(null, arguments);
        }, o._Reverse = function() {
            return (o._Reverse = o.asm.Reverse).apply(null, arguments);
        }, o._RotateWithOffset = function() {
            return (o._RotateWithOffset = o.asm.RotateWithOffset).apply(null, arguments);
        }, o._Round = function() {
            return (o._Round = o.asm.Round).apply(null, arguments);
        }, o._Rsqrt = function() {
            return (o._Rsqrt = o.asm.Rsqrt).apply(null, arguments);
        }, o._ScatterNd = function() {
            return (o._ScatterNd = o.asm.ScatterNd).apply(null, arguments);
        }, o._SearchSorted = function() {
            return (o._SearchSorted = o.asm.SearchSorted).apply(null, arguments);
        }, o._SelectV2 = function() {
            return (o._SelectV2 = o.asm.SelectV2).apply(null, arguments);
        }, o._Selu = function() {
            return (o._Selu = o.asm.Selu).apply(null, arguments);
        }, o._Sigmoid = function() {
            return (o._Sigmoid = o.asm.Sigmoid).apply(null, arguments);
        }, o._Sign = function() {
            return (o._Sign = o.asm.Sign).apply(null, arguments);
        }, o._Sin = function() {
            return (o._Sin = o.asm.Sin).apply(null, arguments);
        }, o._Sinh = function() {
            return (o._Sinh = o.asm.Sinh).apply(null, arguments);
        }, o._Softmax = function() {
            return (o._Softmax = o.asm.Softmax).apply(null, arguments);
        }, o._Softplus = function() {
            return (o._Softplus = o.asm.Softplus).apply(null, arguments);
        }, o._SparseFillEmptyRows = function() {
            return (o._SparseFillEmptyRows = o.asm.SparseFillEmptyRows).apply(null, arguments);
        }, o._SparseReshape = function() {
            return (o._SparseReshape = o.asm.SparseReshape).apply(null, arguments);
        }, o._SparseSegmentReduction = function() {
            return (o._SparseSegmentReduction = o.asm.SparseSegmentReduction).apply(null, arguments);
        }, o._SparseToDense = function() {
            return (o._SparseToDense = o.asm.SparseToDense).apply(null, arguments);
        }, o._Sqrt = function() {
            return (o._Sqrt = o.asm.Sqrt).apply(null, arguments);
        }, o._Square = function() {
            return (o._Square = o.asm.Square).apply(null, arguments);
        }, o._SquaredDifference = function() {
            return (o._SquaredDifference = o.asm.SquaredDifference).apply(null, arguments);
        }, o._Step = function() {
            return (o._Step = o.asm.Step).apply(null, arguments);
        }, o._StridedSlice = function() {
            return (o._StridedSlice = o.asm.StridedSlice).apply(null, arguments);
        }, o._Sub = function() {
            return (o._Sub = o.asm.Sub).apply(null, arguments);
        }, o._Sum = function() {
            return (o._Sum = o.asm.Sum).apply(null, arguments);
        }, o._Tan = function() {
            return (o._Tan = o.asm.Tan).apply(null, arguments);
        }, o._Tanh = function() {
            return (o._Tanh = o.asm.Tanh).apply(null, arguments);
        }, o._TensorScatterUpdate = function() {
            return (o._TensorScatterUpdate = o.asm.TensorScatterUpdate).apply(null, arguments);
        }, o._Tile = function() {
            return (o._Tile = o.asm.Tile).apply(null, arguments);
        }, o._TopK = function() {
            return (o._TopK = o.asm.TopK).apply(null, arguments);
        }, o._Transform = function() {
            return (o._Transform = o.asm.Transform).apply(null, arguments);
        }, o._Transpose = function() {
            return (o._Transpose = o.asm.Transpose).apply(null, arguments);
        }, o.__FusedMatMul = function() {
            return (o.__FusedMatMul = o.asm._FusedMatMul).apply(null, arguments);
        }, o._malloc = function() {
            return (o._malloc = o.asm.malloc).apply(null, arguments);
        }, o._free = function() {
            return (o._free = o.asm.free).apply(null, arguments);
        }, o.___errno_location = function() {
            return (o.___errno_location = o.asm.__errno_location).apply(null, arguments);
        };
        var Oe, we, Be, nt = o.stackSave = function() {
            return (nt = o.stackSave = o.asm.stackSave).apply(null, arguments);
        }, Ve = o.stackRestore = function() {
            return (Ve = o.stackRestore = o.asm.stackRestore).apply(null, arguments);
        }, ue = o.stackAlloc = function() {
            return (ue = o.stackAlloc = o.asm.stackAlloc).apply(null, arguments);
        };
        function ct(K) {
            function ie() {
                Oe || (Oe = !0, o.calledRun = !0, !E && (pe(L), s(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), 
                function() {
                    if (o.postRun) for (typeof o.postRun == "function" && (o.postRun = [ o.postRun ]); o.postRun.length; ) Pe = o.postRun.shift(), 
                    O.unshift(Pe);
                    var Pe;
                    pe(O);
                }()));
            }
            B > 0 || (function() {
                if (o.preRun) for (typeof o.preRun == "function" && (o.preRun = [ o.preRun ]); o.preRun.length; ) Pe = o.preRun.shift(), 
                P.unshift(Pe);
                var Pe;
                pe(P);
            }(), B > 0) || (o.setStatus ? (o.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                    o.setStatus("");
                }, 1), ie();
            }, 1)) : ie());
        }
        if (o.dynCall_iijjiiii = function() {
            return (o.dynCall_iijjiiii = o.asm.dynCall_iijjiiii).apply(null, arguments);
        }, o.dynCall_jiji = function() {
            return (o.dynCall_jiji = o.asm.dynCall_jiji).apply(null, arguments);
        }, o.cwrap = function(K, ie, Pe, Ge) {
            var De = (Pe = Pe || []).every(Xe => Xe === "number" || Xe === "boolean");
            return ie !== "string" && De && !Ge ? Me(K) : function() {
                return Ee(K, ie, Pe, arguments);
            };
        }, G = function K() {
            Oe || ct(), Oe || (G = K);
        }, o.preInit) for (typeof o.preInit == "function" && (o.preInit = [ o.preInit ]); o.preInit.length > 0; ) o.preInit.pop()();
        if (ct(), l && (we = {
            uncaughtException: process.listeners("uncaughtException").filter(function(K) {
                return !l.uncaughtException.indexOf(K) > -1;
            }),
            unhandledRejection: process.listeners("unhandledRejection").filter(function(K) {
                return !l.unhandledRejection.indexOf(K) > -1;
            })
        }), r !== void 0) Be = r; else {
            if (typeof WasmBackendModuleThreadedSimd > "u") throw new Error("Could not find wasm module in post.js");
            Be = WasmBackendModuleThreadedSimd;
        }
        if (we) {
            var nn = Be._dispose;
            Be._dispose = function() {
                nn(), we.uncaughtException.forEach(function(K) {
                    process.removeListener("uncaughtException", K);
                }), we.unhandledRejection.forEach(function(K) {
                    process.removeListener("unhandledRejection", K);
                });
            };
        }
        return r.ready;
    });
    typeof e == "object" && typeof t == "object" ? t.exports = a : typeof define == "function" && define.amd ? define([], function() {
        return a;
    }) : typeof e == "object" && (e.WasmBackendModule = a);
}), Wu = class {
    constructor(e, t) {
        this.backend = e, this.dataMover = t, this.data = new WeakMap(), this.dataIdsCount = 0;
    }
    get(e) {
        return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e);
    }
    set(e, t) {
        this.dataIdsCount++, this.data.set(e, t);
    }
    has(e) {
        return this.data.has(e);
    }
    delete(e) {
        return this.dataIdsCount--, this.data.delete(e);
    }
    numDataIds() {
        return this.dataIdsCount;
    }
}, al = class {
    refCount(e) {
        return Dn("refCount");
    }
    incRef(e) {
        return Dn("incRef");
    }
    timerAvailable() {
        return !0;
    }
    time(e) {
        return Dn("time");
    }
    read(e) {
        return Dn("read");
    }
    readSync(e) {
        return Dn("readSync");
    }
    readToGPU(e, t) {
        return Dn("readToGPU");
    }
    numDataIds() {
        return Dn("numDataIds");
    }
    disposeData(e, t) {
        return Dn("disposeData");
    }
    write(e, t, n) {
        return Dn("write");
    }
    move(e, t, n, a, r) {
        return Dn("move");
    }
    createTensorFromGPUData(e, t, n) {
        return Dn("createTensorFromGPUData");
    }
    memory() {
        return Dn("memory");
    }
    floatPrecision() {
        return Dn("floatPrecision");
    }
    epsilon() {
        return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
    }
    dispose() {
        return Dn("dispose");
    }
};

function Dn(e) {
    throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`);
}

function t0(e) {
    let t = e.length, n = 0;
    for (;t > 0; ) n = Math.random() * t | 0, t--, Pp(e, t, n);
}

function j6(e, t) {
    if (e.length !== t.length) throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);
    let n = e.length, a = 0;
    for (;n > 0; ) a = Math.random() * n | 0, n--, Pp(e, n, a), Pp(t, n, a);
}

function Bu(e, t, n) {
    return Math.max(e, Math.min(t, n));
}

function q6(e) {
    return e % 2 == 0 ? e : e + 1;
}

function Pp(e, t, n) {
    let a = e[t];
    e[t] = e[n], e[n] = a;
}

function X6(e) {
    let t = 0;
    for (let n = 0; n < e.length; n++) t += e[n];
    return t;
}

function K6(e, t) {
    let n = Math.random();
    return t * n + (1 - n) * e;
}

function Z6(e, t) {
    let n = 0;
    for (let a = 0; a < e.length; a++) {
        let r = Number(e[a]) - Number(t[a]);
        n += r * r;
    }
    return n;
}

function D(e, t) {
    if (!e) throw new Error(typeof t == "string" ? t : t());
}

function ln(e, t, n = "") {
    D(qa(e, t), () => n + ` Shapes ${e} and ${t} must match`);
}

function ps(e) {
    D(e != null, () => "The input to the tensor constructor must be a non-null value.");
}

function ht(e) {
    if (e.length === 0) return 1;
    let t = e[0];
    for (let n = 1; n < e.length; n++) t *= e[n];
    return t;
}

function Y6(e) {
    return e.length === 0;
}

function n0(e, t) {
    if (e === t) return !0;
    if (e == null || t == null || e.length !== t.length) return !1;
    for (let n = 0; n < e.length; n++) if (e[n] !== null && t[n] !== null && e[n] !== t[n]) return !1;
    return !0;
}

function qa(e, t) {
    if (e === t) return !0;
    if (e == null || t == null || e.length !== t.length) return !1;
    for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
    return !0;
}

function rl(e) {
    return e % 1 == 0;
}

function J6(e) {
    if (Math.tanh != null) return Math.tanh(e);
    if (e === 1 / 0) return 1;
    if (e === -1 / 0) return -1;
    {
        let t = Math.exp(2 * e);
        return (t - 1) / (t + 1);
    }
}

function Q6(e) {
    let t = Math.ceil(Math.sqrt(e));
    return [ t, Math.ceil(e / t) ];
}

function eI(e) {
    let t = new Uint32Array(e);
    for (let n = 0; n < e; ++n) t[n] = n;
    return t0(t), t;
}

function Vu(e, t) {
    return t <= e.length ? e : e + " ".repeat(t - e.length);
}

function tI(e, t = r => 0, n, a) {
    return new Promise((r, s) => {
        let i = 0, l = () => {
            if (e()) return void r();
            i++;
            let o = t(i);
            n != null && i >= n ? s() : a != null ? a(l, o) : setTimeout(l, o);
        };
        l();
    });
}

function nI(e, t) {
    let n = 1, a = -1;
    for (let s = 0; s < e.length; ++s) if (e[s] >= 0) n *= e[s]; else if (e[s] === -1) {
        if (a !== -1) throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${a} and dim ${s}`);
        a = s;
    } else if (e[s] < 0) throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);
    if (a === -1) {
        if (t > 0 && t !== n) throw Error(`Size(${t}) must match the product of shape ${e}`);
        return e;
    }
    if (n === 0) throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);
    if (t % n != 0) throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);
    let r = e.slice();
    return r[a] = t / n, r;
}

function Uu(e, t) {
    let n = t.length;
    return D((e = e == null ? t.map((a, r) => r) : [].concat(e)).every(a => a >= -n && a < n), () => `All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`), 
    D(e.every(a => rl(a)), () => `All values in axis param must be integers but got axis ${e}`), 
    e.map(a => a < 0 ? n + a : a);
}

function a0(e, t) {
    let n = [], a = [], r = t != null && Array.isArray(t) && t.length === 0, s = t == null || r ? null : Uu(t, e).sort(), i = 0;
    for (let l = 0; l < e.length; ++l) {
        if (s != null) {
            if (s[i] === l && e[l] !== 1) throw new Error(`Can't squeeze axis ${l} since its dim '${e[l]}' is not 1`);
            (s[i] == null || s[i] > l) && e[l] === 1 && (n.push(e[l]), a.push(l)), 
            s[i] <= l && i++;
        }
        e[l] !== 1 && (n.push(e[l]), a.push(l));
    }
    return {
        newShape: n,
        keptDims: a
    };
}

function r0(e, t) {
    return Lh(e, t);
}

function Lh(e, t) {
    let n = null;
    if (e == null || e === "float32") n = new Float32Array(t); else if (e === "int32") n = new Int32Array(t); else if (e === "bool") n = new Uint8Array(t); else {
        if (e !== "string") throw new Error(`Unknown data type ${e}`);
        n = new Array(t);
    }
    return n;
}

function s0(e, t) {
    for (let n = 0; n < e.length; n++) {
        let a = e[n];
        if (isNaN(a) || !isFinite(a)) throw Error(`A tensor of type ${t} being uploaded contains ${a}.`);
    }
}

function i0(e) {
    return e === "bool" || e === "complex64" || e === "float32" || e === "int32" || e === "string";
}

function aI(e, t) {
    return !(t === "complex64" || t === "float32" && e !== "complex64" || t === "int32" && e !== "float32" && e !== "complex64" || t === "bool" && e === "bool");
}

function Dp(e) {
    if (e === "float32" || e === "int32") return 4;
    if (e === "complex64") return 8;
    if (e === "bool") return 1;
    throw new Error(`Unknown dtype ${e}`);
}

function o0(e) {
    if (e == null) return 0;
    let t = 0;
    return e.forEach(n => t += n.length), t;
}

function gr(e) {
    return typeof e == "string" || e instanceof String;
}

function l0(e) {
    return typeof e == "boolean";
}

function u0(e) {
    return typeof e == "number";
}

function Gu(e) {
    return Array.isArray(e) ? Gu(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray ? "int32" : u0(e) ? "float32" : gr(e) ? "string" : l0(e) ? "bool" : "float32";
}

function yr(e) {
    return !!(e && e.constructor && e.call && e.apply);
}

function zp(e, t) {
    for (let n = t; n < e; ++n) if (e % n == 0) return n;
    return e;
}

function sl(e) {
    let t = e.length;
    if (t < 2) return [];
    let n = new Array(t - 1);
    n[t - 2] = e[t - 1];
    for (let a = t - 3; a >= 0; --a) n[a] = n[a + 1] * e[a + 1];
    return n;
}

function d0(e, t, n, a = !1) {
    let r = new Array();
    if (t.length === 1) {
        let s = t[0] * (a ? 2 : 1);
        for (let i = 0; i < s; i++) r[i] = n[e + i];
    } else {
        let s = t[0], i = t.slice(1), l = i.reduce((o, p) => o * p) * (a ? 2 : 1);
        for (let o = 0; o < s; o++) r[o] = d0(e + o * l, i, n, a);
    }
    return r;
}

function il(e, t, n = !1) {
    if (e.length === 0) return t[0];
    let a = e.reduce((r, s) => r * s) * (n ? 2 : 1);
    if (a === 0) return [];
    if (a !== t.length) throw new Error(`[${e}] does not match the input size ${t.length}${n ? " for a complex tensor" : ""}.`);
    return d0(0, e, t, n);
}

function rI(e, t) {
    if (Array.isArray(e)) return e;
    if (t === "float32") return e instanceof Float32Array ? e : new Float32Array(e);
    if (t === "int32") return e instanceof Int32Array ? e : new Int32Array(e);
    if (t === "bool" || t === "string") return Uint8Array.from(new Int32Array(e));
    throw new Error(`Unknown dtype ${t}`);
}

function Wh(e, t) {
    let n = Lp(e, t);
    for (let a = 0; a < n.length; a++) n[a] = 1;
    return n;
}

function Lp(e, t) {
    if (t == null || t === "float32" || t === "complex64") return new Float32Array(e);
    if (t === "int32") return new Int32Array(e);
    if (t === "bool") return new Uint8Array(e);
    throw new Error(`Unknown data type ${t}`);
}

function sI(e, t) {
    let n = e.reduce((a, r) => a * r, 1);
    if (t == null || t === "float32") return il(e, new Float32Array(n));
    if (t === "int32") return il(e, new Int32Array(n));
    if (t === "bool") return il(e, new Uint8Array(n));
    throw new Error(`Unknown data type ${t}`);
}

function zn(e) {
    e.forEach(t => {
        D(Number.isInteger(t) && t >= 0, () => `Tensor must have a shape comprised of positive integers but got shape [${e}].`);
    });
}

function iI(e, t, n) {
    if (t === 0) return 0;
    if (t === 1) return e[0];
    let a = e[e.length - 1];
    for (let r = 0; r < e.length - 1; ++r) a += n[r] * e[r];
    return a;
}

function oI(e, t, n) {
    if (t === 0) return [];
    if (t === 1) return [ e ];
    let a = new Array(t);
    for (let r = 0; r < a.length - 1; ++r) a[r] = Math.floor(e / n[r]), e -= a[r] * n[r];
    return a[a.length - 1] = e, a;
}

function Wp(e) {
    return e && e.then && typeof e.then == "function";
}

var p0 = "tfjsflags", c0 = class {
    constructor(e) {
        this.global = e, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, 
        this.getQueryParams = lI, this.populateURLFlags();
    }
    setPlatform(e, t) {
        this.platform != null && (H().getBool("IS_TEST") || H().getBool("PROD")), 
        this.platformName = e, this.platform = t;
    }
    registerFlag(e, t, n) {
        if (this.flagRegistry[e] = {
            evaluationFn: t,
            setHook: n
        }, this.urlFlags[e] != null) {
            let a = this.urlFlags[e];
            H().getBool("IS_TEST") || H().getBool("PROD"), this.set(e, a);
        }
    }
    async getAsync(e) {
        return e in this.flags || (this.flags[e] = await this.evaluateFlag(e)), 
        this.flags[e];
    }
    get(e) {
        if (e in this.flags) return this.flags[e];
        let t = this.evaluateFlag(e);
        if (Wp(t)) throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);
        return this.flags[e] = t, this.flags[e];
    }
    getNumber(e) {
        return this.get(e);
    }
    getBool(e) {
        return this.get(e);
    }
    getString(e) {
        return this.get(e);
    }
    getFlags() {
        return this.flags;
    }
    get features() {
        return this.flags;
    }
    set(e, t) {
        if (this.flagRegistry[e] == null) throw new Error(`Cannot set flag ${e} as it has not been registered.`);
        this.flags[e] = t, this.flagRegistry[e].setHook != null && this.flagRegistry[e].setHook(t);
    }
    evaluateFlag(e) {
        if (this.flagRegistry[e] == null) throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);
        return this.flagRegistry[e].evaluationFn();
    }
    setFlags(e) {
        this.flags = Object.assign({}, e);
    }
    reset() {
        this.flags = {}, this.urlFlags = {}, this.populateURLFlags();
    }
    populateURLFlags() {
        if (this.global === void 0 || this.global.location === void 0 || this.global.location.search === void 0) return;
        let e = this.getQueryParams(this.global.location.search);
        p0 in e && e[p0].split(",").forEach(t => {
            let [ n, a ] = t.split(":");
            this.urlFlags[n] = function(r, s) {
                let i = s.toLowerCase();
                return i === "true" || i === "false" ? i === "true" : "" + +i === i ? +i : s;
            }(0, a);
        });
    }
};

function lI(e) {
    let t = {};
    return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (n, ...a) => (function(r, s, i) {
        r[decodeURIComponent(s)] = decodeURIComponent(i || "");
    }(t, a[0], a[1]), a.join("="))), t;
}

function H() {
    return Vh;
}

var Bh, Vh = null;

function h0() {
    if (Bh == null) {
        let e;
        if (typeof window < "u") e = window; else if (typeof global < "u") e = global; else if (typeof process < "u") e = process; else {
            if (typeof self > "u") throw new Error("Could not find a global object");
            e = self;
        }
        Bh = e;
    }
    return Bh;
}

function Uh(e, t) {
    let n = function() {
        let a = h0();
        return a._tfGlobals == null && (a._tfGlobals = new Map()), a._tfGlobals;
    }();
    if (n.has(e)) return n.get(e);
    {
        let a = t();
        return n.set(e, a), n.get(e);
    }
}

var ol = "Abs", cs = "Acos", hs = "Acosh", Ar = "Add", fs = "AddN", ms = "All", gs = "Any", ll = "ArgMax", ul = "ArgMin", ys = "Asin", As = "Asinh", xs = "Atan", bs = "Atanh", vs = "Atan2", ws = "AvgPool", Hu = "AvgPoolGrad", dl = "AvgPool3D", ju = "AvgPool3DGrad", ks = "BatchMatMul", pl = "BatchToSpaceND", Is = "Bincount", cl = "BitwiseAnd", uI = "BroadcastTo", hl = "BroadcastArgs", Ss = "Cast", Ns = "Ceil", xr = "ClipByValue", qu = "Complex", Xu = "ComplexAbs", fl = "Concat", Cs = "Conv2D", Ku = "Conv2DBackpropFilter", Ts = "Conv2DBackpropInput", Rs = "Conv3D", ml = "Conv3DBackpropFilterV2", Es = "Conv3DBackpropInputV2", $s = "Cos", Ms = "Cosh", Fs = "Cumprod", _s = "Cumsum", Os = "CropAndResize", gl = "DenseBincount", Ps = "DepthToSpace", Ds = "DepthwiseConv2dNative", Zu = "DepthwiseConv2dNativeBackpropFilter", Yu = "DepthwiseConv2dNativeBackpropInput", yl = "Diag", zs = "Dilation2D", Al = "Dilation2DBackpropInput", xl = "Dilation2DBackpropFilter", Ju = "Draw", Ls = "RealDiv", Qu = "Einsum", Ws = "Elu", bl = "EluGrad", Bs = "Erf", Vs = "Equal", Us = "Exp", vl = "ExpandDims", Gs = "Expm1", ed = "FFT", wl = "Fill", Hs = "FlipLeftRight", js = "Floor", qs = "FloorDiv", Xs = "FusedBatchNorm", kl = "GatherV2", Ks = "GatherNd", Zs = "Greater", Ys = "GreaterEqual", Js = "Identity", td = "IFFT", nd = "Imag", Qs = "IsFinite", ei = "IsInf", ti = "IsNan", ni = "LeakyRelu", ai = "Less", ri = "LessEqual", si = "LinSpace", ii = "Log", oi = "Log1p", li = "LogicalAnd", ui = "LogicalNot", di = "LogicalOr", f0 = "LogicalXor", dI = "LogSoftmax", pI = "LowerBound", pi = "LRN", Il = "LRNGrad", cI = "MatrixBandPart", ci = "Max", hi = "Maximum", fi = "MaxPool", ad = "MaxPoolGrad", Sl = "MaxPool3D", rd = "MaxPool3DGrad", Nl = "MaxPoolWithArgmax", mi = "Mean", gi = "Min", yi = "Minimum", Ai = "MirrorPad", xi = "Mod", bi = "Multinomial", vi = "Multiply", Cl = "Neg", wi = "NotEqual", ki = "NonMaxSuppressionV3", Tl = "NonMaxSuppressionV4", Ii = "NonMaxSuppressionV5", Rl = "OnesLike", Si = "OneHot", El = "Pack", Ni = "PadV2", hI = "Pool", Ci = "Pow", Ti = "Prelu", Ri = "Prod", Bp = "RaggedGather", Vp = "RaggedRange", Up = "RaggedTensorToTensor", $l = "Range", sd = "Real", Ei = "Reciprocal", $i = "Relu", Ml = "Reshape", Mi = "ResizeNearestNeighbor", Fl = "ResizeNearestNeighborGrad", Fi = "ResizeBilinear", _l = "ResizeBilinearGrad", _i = "Relu6", Oi = "Reverse", Pi = "Round", Di = "Rsqrt", zi = "ScatterNd", Li = "TensorScatterUpdate", Wi = "SearchSorted", Ol = "Select", Bi = "Selu", Pl = "Slice", Vi = "Sin", Ui = "Sinh", Gi = "Sign", Hi = "Sigmoid", ji = "Softplus", qi = "Sqrt", Xi = "Sum", Dl = "SpaceToBatchND", zl = "SplitV", Ki = "Softmax", id = "SparseFillEmptyRows", Ll = "SparseReshape", Wl = "SparseSegmentMean", Bl = "SparseSegmentSum", Zi = "SparseToDense", Yi = "SquaredDifference", od = "Square", ld = "StaticRegexReplace", Ji = "StridedSlice", Vl = "StringNGrams", ud = "StringSplit", dd = "StringToHashBucketFast", Qi = "Sub", eo = "Tan", to = "Tanh", br = "Tile", no = "TopK", ao = "Transform", Xa = "Transpose", pd = "Unique", Ul = "Unpack", cd = "UnsortedSegmentSum", fI = "UpperBound", Gl = "ZerosLike", vr = "Step", hd = "FromPixels", ro = "RotateWithOffset", wr = "_FusedMatMul", kr = "FusedConv2D", Ir = "FusedDepthwiseConv2D";

function Sr(...e) {
    H().getBool("IS_TEST") || H().getBool("PROD");
}

function mI(...e) {
    H().getBool("IS_TEST") || H().getBool("PROD");
}

var Hl = Uh("kernelRegistry", () => new Map()), fd = Uh("gradRegistry", () => new Map());

function md(e, t) {
    let n = Hh(e, t);
    return Hl.get(n);
}

function Gh(e) {
    return fd.get(e);
}

function so(e) {
    let t = Hl.entries(), n = [];
    for (;;) {
        let {
            done: a,
            value: r
        } = t.next();
        if (a) break;
        let [ s, i ] = r, [ l ] = s.split("_");
        l === e && n.push(i);
    }
    return n;
}

function Aa(e) {
    let {
        kernelName: t,
        backendName: n
    } = e, a = Hh(t, n);
    Hl.has(a) && Sr(), Hl.set(a, e);
}

function gI(e) {
    let {
        kernelName: t
    } = e;
    fd.has(t) && H().getBool("DEBUG") && Sr(), fd.set(t, e);
}

function yI(e, t) {
    let n = Hh(e, t);
    if (!Hl.has(n)) throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);
    Hl.delete(n);
}

function AI(e) {
    if (!fd.has(e)) throw new Error(`The gradient '${e}' for backend is not registered`);
    fd.delete(e);
}

function xI(e, t) {
    so(e).forEach(n => {
        Aa(Object.assign({}, n, {
            backendName: t
        }));
    });
}

function Hh(e, t) {
    return `${t}_${e}`;
}

var k = {};

function m0(e) {
    return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray;
}

Ze(k, {
    arraysEqual: () => qa,
    arraysEqualWithNull: () => n0,
    assert: () => D,
    assertNonNegativeIntegerDimensions: () => zn,
    assertNonNull: () => ps,
    assertShapesMatch: () => ln,
    bytesFromStringArray: () => o0,
    bytesPerElement: () => Dp,
    checkConversionForErrors: () => s0,
    clamp: () => Bu,
    computeStrides: () => sl,
    convertBackendValuesAndArrayBuffer: () => rI,
    createScalarValue: () => vI,
    createShuffledIndices: () => eI,
    decodeString: () => jp,
    distSquared: () => Z6,
    encodeString: () => Ad,
    fetch: () => wI,
    fingerPrint64: () => bI,
    flatten: () => Cr,
    getArrayFromDType: () => Lh,
    getTypedArrayFromDType: () => r0,
    hasEncodingLoss: () => aI,
    hexToLong: () => gd,
    indexToLoc: () => oI,
    inferDtype: () => Gu,
    inferFromImplicitShape: () => nI,
    isBoolean: () => l0,
    isFunction: () => yr,
    isInt: () => rl,
    isNumber: () => u0,
    isPromise: () => Wp,
    isScalarShape: () => Y6,
    isString: () => gr,
    isTypedArray: () => Gt,
    isValidDtype: () => i0,
    locToIndex: () => iI,
    makeOnesTypedArray: () => Wh,
    makeZerosNestedTypedArray: () => sI,
    makeZerosTypedArray: () => Lp,
    nearestDivisor: () => zp,
    nearestLargerEven: () => q6,
    now: () => yd,
    parseAxisParam: () => Uu,
    randUniform: () => K6,
    repeatedTry: () => tI,
    rightPad: () => Vu,
    shuffle: () => t0,
    shuffleCombo: () => j6,
    sizeFromShape: () => ht,
    sizeToSquarishShape: () => Q6,
    squeezeShape: () => a0,
    sum: () => X6,
    swap: () => Pp,
    tanh: () => J6,
    toNestedArray: () => il,
    toTypedArray: () => Hp
});

var g0 = nl(R6()), io = g0.default || g0;

function gd(e) {
    return io.fromString(e, !0, 16);
}

var y0 = gd("c3a5c85c97cb3127"), oo = gd("b492b66fbe98f273"), un = gd("9ae16a3b2f90404f");

function jh(e) {
    return e.xor(e.shru(47));
}

function A0(e, t, n) {
    let a = e.slice(t, t + n);
    return io.fromBytes(Array.from(a), !0, !0);
}

function gt(e, t) {
    return A0(e, t, 8);
}

function x0(e, t) {
    return A0(e, t, 4);
}

function Ut(e, t) {
    return t === 0 ? e : e.shru(t).or(e.shl(64 - t));
}

function Nr(e, t, n = gd("9ddfea08eb382d69")) {
    let a = e.xor(t).mul(n);
    a = a.xor(a.shru(47));
    let r = t.xor(a).mul(n);
    return r = r.xor(r.shru(47)), r = r.mul(n), r;
}

function Gp(e, t, n, a) {
    return function(r, s, i, l, o, p) {
        o = o.add(r), p = Ut(p.add(o).add(l), 21);
        let u = o;
        return o = (o = o.add(s)).add(i), p = p.add(Ut(o, 44)), [ o.add(l), p.add(u) ];
    }(gt(e, t), gt(e, t + 8), gt(e, t + 16), gt(e, t + 24), n, a);
}

function bI(e, t = e.length) {
    let n = io.fromNumber(81, !0);
    if (t <= 32) return t <= 16 ? function(d, h = d.length) {
        if (h >= 8) {
            let f = un.add(2 * h), m = gt(d, 0).add(un), g = gt(d, h - 8);
            return Nr(Ut(g, 37).mul(f).add(m), Ut(m, 25).add(g).mul(f), f);
        }
        if (h >= 4) {
            let f = un.add(2 * h);
            return Nr(x0(d, 0).shl(3).add(h), x0(d, h - 4), f);
        }
        if (h > 0) {
            let f = d[0] + (d[h >> 1] << 8), m = h + (d[h - 1] << 2);
            return jh(un.mul(f).xor(y0.mul(m))).mul(un);
        }
        return un;
    }(e, t) : function(d, h = d.length) {
        let f = un.add(2 * h), m = gt(d, 0).mul(oo), g = gt(d, 8), y = gt(d, h - 8).mul(f), A = gt(d, h - 16).mul(un);
        return Nr(Ut(m.add(g), 43).add(Ut(y, 30)).add(A), m.add(Ut(g.add(un), 18)).add(y), f);
    }(e, t);
    if (t <= 64) return function(d, h = d.length) {
        let f = un.add(2 * h), m = gt(d, 0).mul(un), g = gt(d, 8), y = gt(d, h - 8).mul(f), A = gt(d, h - 16).mul(un), x = Ut(m.add(g), 43).add(Ut(y, 30)).add(A), b = Nr(x, m.add(Ut(g.add(un), 18)).add(y), f), v = gt(d, 16).mul(f), I = gt(d, 24), N = x.add(gt(d, h - 32)).mul(f), T = b.add(gt(d, h - 24)).mul(f);
        return Nr(Ut(v.add(I), 43).add(Ut(N, 30)).add(T), v.add(Ut(I.add(m), 18)).add(N), f);
    }(e, t);
    let a = n, r = n.mul(oo).add(113), s = jh(r.mul(un).add(113)).mul(un), i = [ io.UZERO, io.UZERO ], l = [ io.UZERO, io.UZERO ];
    a = a.mul(un).add(gt(e, 0));
    let o = 0, p = 64 * (t - 1 >> 6), u = p + (t - 1 & 63) - 63;
    do {
        a = Ut(a.add(r).add(i[0]).add(gt(e, o + 8)), 37).mul(oo), r = Ut(r.add(i[1]).add(gt(e, o + 48)), 42).mul(oo), 
        a = a.xor(l[1]), r = r.add(i[0]).add(gt(e, o + 40)), s = Ut(s.add(l[0]), 33).mul(oo), 
        i = Gp(e, o, i[1].mul(oo), a.add(l[0])), l = Gp(e, o + 32, s.add(l[1]), r.add(gt(e, o + 16))), 
        [ s, a ] = [ a, s ], o += 64;
    } while (o !== p);
    let c = oo.add(s.and(255).shl(1));
    return o = u, l[0] = l[0].add(t - 1 & 63), i[0] = i[0].add(l[0]), l[0] = l[0].add(i[0]), 
    a = Ut(a.add(r).add(i[0]).add(gt(e, o + 8)), 37).mul(c), r = Ut(r.add(i[1]).add(gt(e, o + 48)), 42).mul(c), 
    a = a.xor(l[1].mul(9)), r = r.add(i[0].mul(9).add(gt(e, o + 40))), s = Ut(s.add(l[0]), 33).mul(c), 
    i = Gp(e, o, i[1].mul(c), a.add(l[0])), l = Gp(e, o + 32, s.add(l[1]), r.add(gt(e, o + 16))), 
    [ s, a ] = [ a, s ], Nr(Nr(i[0], l[0], c).add(jh(r).mul(y0)).add(s), Nr(i[1], l[1], c).add(a), c);
}

function vI(e, t) {
    return t === "string" ? Ad(e) : Hp([ e ], t);
}

function Hp(e, t) {
    if (t === "string") throw new Error("Cannot convert a string[] to a TypedArray");
    if (Array.isArray(e) && (e = Cr(e)), H().getBool("DEBUG") && s0(e, t), function(n, a) {
        return n instanceof Float32Array && a === "float32" || n instanceof Int32Array && a === "int32" || n instanceof Uint8Array && a === "bool";
    }(e, t)) return e;
    if (t == null || t === "float32" || t === "complex64") return new Float32Array(e);
    if (t === "int32") return new Int32Array(e);
    if (t === "bool") {
        let n = new Uint8Array(e.length);
        for (let a = 0; a < n.length; ++a) Math.round(e[a]) !== 0 && (n[a] = 1);
        return n;
    }
    throw new Error(`Unknown data type ${t}`);
}

function yd() {
    return H().platform.now();
}

function wI(e, t) {
    return H().platform.fetch(e, t);
}

function Ad(e, t = "utf-8") {
    return t = t || "utf-8", H().platform.encode(e, t);
}

function jp(e, t = "utf-8") {
    return t = t || "utf-8", H().platform.decode(e, t);
}

function Gt(e) {
    return H().platform.isTypedArray != null ? H().platform.isTypedArray(e) : m0(e);
}

function Cr(e, t = [], n = !1) {
    if (t == null && (t = []), typeof e == "boolean" || typeof e == "number" || typeof e == "string" || Wp(e) || e == null || Gt(e) && n) t.push(e); else if (Array.isArray(e) || Gt(e)) for (let a = 0; a < e.length; ++a) Cr(e[a], t, n); else {
        let a = -1;
        for (let r of Object.keys(e)) /^([1-9]+[0-9]*|0)$/.test(r) && (a = Math.max(a, Number(r)));
        for (let r = 0; r <= a; r++) Cr(e[r], t, n);
    }
    return t;
}

var kI = class {
    constructor(e, t) {
        this.backendTimer = e, this.logger = t, t == null && (this.logger = new SI());
    }
    profileKernel(e, t, n) {
        let a, r, s = () => {
            a = n();
        }, i = yd();
        if (this.backendTimer.timerAvailable()) r = this.backendTimer.time(s); else {
            s();
            for (let l of a) l.dataSync();
            r = Promise.resolve({
                kernelMs: yd() - i
            });
        }
        if (H().getBool("CHECK_COMPUTATION_FOR_ERRORS")) for (let l = 0; l < a.length; l++) {
            let o = a[l];
            o.data().then(p => {
                II(p, o.dtype, e);
            });
        }
        return {
            kernelName: e,
            outputs: a,
            inputs: t,
            timeMs: r.then(l => l.kernelMs),
            extraInfo: r.then(l => l.getExtraProfileInfo != null ? l.getExtraProfileInfo() : "")
        };
    }
    logKernelProfile(e) {
        let {
            kernelName: t,
            outputs: n,
            timeMs: a,
            inputs: r,
            extraInfo: s
        } = e;
        n.forEach(i => {
            Promise.all([ i.data(), a, s ]).then(l => {
                this.logger.logKernelProfile(t, i, l[0], l[1], r, l[2]);
            });
        });
    }
};

function II(e, t, n) {
    if (t !== "float32") return !1;
    for (let a = 0; a < e.length; a++) {
        let r = e[a];
        if (isNaN(r) || !isFinite(r)) return !0;
    }
    return !1;
}

var SI = class {
    logKernelProfile(e, t, n, a, r, s) {
        typeof a == "number" ? Vu(`${a}ms`, 9) : a.error, Vu(e, 25), t.rank, t.size, 
        Vu(t.shape.toString(), 14);
        let i = "";
        for (let l in r) {
            let o = r[l];
            if (o != null) {
                let p = o.shape || t.shape, u = p.length;
                i += `${l}: ${u}D ${u > 0 ? p : ""} `;
            }
        }
    }
}, b0 = 20, xd = 3, qh = 7;

function NI(e, t, n, a) {
    let r = sl(t), s = function(p, u, c, d) {
        let h = ht(u), f = d[d.length - 1], m = new Array(f).fill(0), g = u.length, y = c === "complex64" ? vd(p) : p;
        if (g > 1) for (let A = 0; A < h / f; A++) {
            let x = A * f;
            for (let b = 0; b < f; b++) m[b] = Math.max(m[b], bd(y[x + b], 0, c).length);
        }
        return m;
    }(e, t, n, r), i = t.length, l = qp(e, t, n, r, s), o = [ "Tensor" ];
    return a && (o.push(`  dtype: ${n}`), o.push(`  rank: ${i}`), o.push(`  shape: [${t}]`), 
    o.push("  values:")), o.push(l.map(p => "    " + p).join(`
`)), o.join(`
`);
}

function bd(e, t, n) {
    let a;
    return a = Array.isArray(e) ? `${parseFloat(e[0].toFixed(qh))} + ${parseFloat(e[1].toFixed(qh))}j` : gr(e) ? `'${e}'` : n === "bool" ? v0(e) : parseFloat(e.toFixed(qh)).toString(), 
    Vu(a, t);
}

function v0(e) {
    return e === 0 ? "false" : "true";
}

function qp(e, t, n, a, r, s = !0) {
    let i = n === "complex64" ? 2 : 1, l = t[0], o = t.length;
    if (o === 0) return n === "complex64" ? [ bd(vd(e)[0], 0, n) ] : n === "bool" ? [ v0(e[0]) ] : [ e[0].toString() ];
    if (o === 1) {
        if (l > b0) {
            let m = xd * i, g = Array.from(e.slice(0, m)), y = Array.from(e.slice((l - xd) * i, l * i));
            return n === "complex64" && (g = vd(g), y = vd(y)), [ "[" + g.map((A, x) => bd(A, r[x], n)).join(", ") + ", ..., " + y.map((A, x) => bd(A, r[l - xd + x], n)).join(", ") + "]" ];
        }
        return [ "[" + (n === "complex64" ? vd(e) : Array.from(e)).map((m, g) => bd(m, r[g], n)).join(", ") + "]" ];
    }
    let p = t.slice(1), u = a.slice(1), c = a[0] * i, d = [];
    if (l > b0) {
        for (let m = 0; m < xd; m++) {
            let g = m * c, y = g + c;
            d.push(...qp(e.slice(g, y), p, n, u, r, !1));
        }
        d.push("...");
        for (let m = l - xd; m < l; m++) {
            let g = m * c, y = g + c;
            d.push(...qp(e.slice(g, y), p, n, u, r, m === l - 1));
        }
    } else for (let m = 0; m < l; m++) {
        let g = m * c, y = g + c;
        d.push(...qp(e.slice(g, y), p, n, u, r, m === l - 1));
    }
    let h = o === 2 ? "," : "";
    d[0] = "[" + (l > 0 ? d[0] + h : "");
    for (let m = 1; m < d.length - 1; m++) d[m] = " " + d[m] + h;
    let f = `,
`;
    for (let m = 2; m < o; m++) f += `
`;
    return d[d.length - 1] = " " + d[d.length - 1] + "]" + (s ? "" : f), d;
}

function vd(e) {
    let t = [];
    for (let n = 0; n < e.length; n += 2) t.push([ e[n], e[n + 1] ]);
    return t;
}

var $t = class {
    constructor(e, t, n) {
        if (this.dtype = t, this.shape = e.slice(), this.size = ht(e), n != null) {
            let a = n.length;
            D(a === this.size, () => `Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`);
        }
        if (t === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
        this.values = n || Lh(t, this.size), this.strides = sl(e);
    }
    set(e, ...t) {
        t.length === 0 && (t = [ 0 ]), D(t.length === this.rank, () => `The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);
        let n = this.locToIndex(t);
        this.values[n] = e;
    }
    get(...e) {
        e.length === 0 && (e = [ 0 ]);
        let t = 0;
        for (let a of e) {
            if (a < 0 || a >= this.shape[t]) {
                let r = `Requested out of range element at ${e}.   Buffer shape=${this.shape}`;
                throw new Error(r);
            }
            t++;
        }
        let n = e[e.length - 1];
        for (let a = 0; a < e.length - 1; ++a) n += this.strides[a] * e[a];
        return this.values[n];
    }
    locToIndex(e) {
        if (this.rank === 0) return 0;
        if (this.rank === 1) return e[0];
        let t = e[e.length - 1];
        for (let n = 0; n < e.length - 1; ++n) t += this.strides[n] * e[n];
        return t;
    }
    indexToLoc(e) {
        if (this.rank === 0) return [];
        if (this.rank === 1) return [ e ];
        let t = new Array(this.shape.length);
        for (let n = 0; n < t.length - 1; ++n) t[n] = Math.floor(e / this.strides[n]), 
        e -= t[n] * this.strides[n];
        return t[t.length - 1] = e, t;
    }
    get rank() {
        return this.shape.length;
    }
    toTensor() {
        return xa().makeTensor(this.values, this.shape, this.dtype);
    }
}, xa = null, jl = null, vt = class {
    constructor(e, t, n, a) {
        this.kept = !1, this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || "float32", 
        this.size = ht(e), this.strides = sl(e), this.dataId = n, this.id = a, this.rankType = this.rank < 5 ? this.rank.toString() : "higher";
    }
    get rank() {
        return this.shape.length;
    }
    async buffer() {
        let e = await this.data();
        return jl.buffer(this.shape, this.dtype, e);
    }
    bufferSync() {
        return jl.buffer(this.shape, this.dtype, this.dataSync());
    }
    async array() {
        let e = await this.data();
        return il(this.shape, e, this.dtype === "complex64");
    }
    arraySync() {
        return il(this.shape, this.dataSync(), this.dtype === "complex64");
    }
    async data() {
        this.throwIfDisposed();
        let e = xa().read(this.dataId);
        if (this.dtype === "string") {
            let t = await e;
            try {
                return t.map(n => jp(n));
            } catch {
                throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
            }
        }
        return e;
    }
    dataToGPU(e) {
        return this.throwIfDisposed(), xa().readToGPU(this.dataId, e);
    }
    dataSync() {
        this.throwIfDisposed();
        let e = xa().readSync(this.dataId);
        if (this.dtype === "string") try {
            return e.map(t => jp(t));
        } catch {
            throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
        }
        return e;
    }
    async bytes() {
        this.throwIfDisposed();
        let e = await xa().read(this.dataId);
        return this.dtype === "string" ? e : new Uint8Array(e.buffer);
    }
    dispose() {
        this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), xa().disposeTensor(this), 
        this.isDisposedInternal = !0);
    }
    get isDisposed() {
        return this.isDisposedInternal;
    }
    throwIfDisposed() {
        if (this.isDisposed) throw new Error("Tensor is disposed.");
    }
    print(e = !1) {
        return jl.print(this, e);
    }
    clone() {
        return this.throwIfDisposed(), jl.clone(this);
    }
    toString(e = !1) {
        return NI(this.dataSync(), this.shape, this.dtype, e);
    }
    cast(e) {
        return this.throwIfDisposed(), jl.cast(this, e);
    }
    variable(e = !0, t, n) {
        return this.throwIfDisposed(), xa().makeVariable(this, e, t, n);
    }
};

function w0() {
    return Uh("Tensor", () => vt);
}

Object.defineProperty(vt, Symbol.hasInstance, {
    value: e => !!e && e.data != null && e.dataSync != null && e.throwIfDisposed != null
}), w0();

var wd = class extends vt {
    constructor(e, t, n, a) {
        super(e.shape, e.dtype, e.dataId, a), this.trainable = t, this.name = n;
    }
    assign(e) {
        if (e.dtype !== this.dtype) throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);
        if (!qa(e.shape, this.shape)) throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);
        xa().disposeTensor(this), this.dataId = e.dataId, xa().incRef(this, null);
    }
    dispose() {
        xa().disposeVariable(this), this.isDisposedInternal = !0;
    }
};

Object.defineProperty(wd, Symbol.hasInstance, {
    value: e => e instanceof vt && e.assign != null && e.assign instanceof Function
});

var Xh, lo, Kh, Zh, Yh, Jh, k0 = {};

Ze(k0, {
    assertTypesMatch: () => N0,
    getTensorsInContainer: () => Qh,
    isTensorInList: () => TI,
    makeTypesMatch: () => It
}), (lo = Xh || (Xh = {})).R0 = "R0", lo.R1 = "R1", lo.R2 = "R2", lo.R3 = "R3", 
lo.R4 = "R4", lo.R5 = "R5", lo.R6 = "R6", function(e) {
    e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64";
}(Kh || (Kh = {})), function(e) {
    e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64";
}(Zh || (Zh = {})), function(e) {
    e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64";
}(Yh || (Yh = {})), function(e) {
    e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64";
}(Jh || (Jh = {}));

var CI = {
    float32: Yh,
    int32: Kh,
    bool: Zh,
    complex64: Jh
};

function Zt(e, t) {
    if (e === "string" || t === "string") {
        if (e === "string" && t === "string") return "string";
        throw new Error(`Can not upcast ${e} with ${t}`);
    }
    return CI[e][t];
}

function kd(e) {
    return Zt(e, "int32");
}

function I0(e) {
    return e != null && typeof e == "object" && "texture" in e && e.texture instanceof WebGLTexture;
}

function S0(e) {
    return typeof GPUBuffer < "u" && e != null && typeof e == "object" && "buffer" in e && e.buffer instanceof GPUBuffer;
}

function It(e, t) {
    if (e.dtype === t.dtype) return [ e, t ];
    let n = Zt(e.dtype, t.dtype);
    return [ e.cast(n), t.cast(n) ];
}

function N0(e, t) {
    D(e.dtype === t.dtype, () => `The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`);
}

function TI(e, t) {
    return t.some(n => n.id === e.id);
}

function Qh(e) {
    let t = [];
    return C0(e, t, new Set()), t;
}

function C0(e, t, n) {
    if (e == null) return;
    if (e instanceof vt) return void t.push(e);
    if (!function(r) {
        return Array.isArray(r) || typeof r == "object";
    }(e)) return;
    let a = e;
    for (let r in a) {
        let s = a[r];
        n.has(s) || (n.add(s), C0(s, t, n));
    }
}

function ef(e) {
    return e.kernelName != null;
}

var T0 = class {
    constructor() {
        this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, 
        this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, 
        this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], 
        this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, 
        this.activeProfile = {
            newBytes: 0,
            newTensors: 0,
            peakBytes: 0,
            kernels: [],
            result: null,
            get kernelNames() {
                return Array.from(new Set(this.kernels.map(e => e.name)));
            }
        };
    }
    dispose() {
        for (let e in this.registeredVariables) this.registeredVariables[e].dispose();
    }
}, tf = class O2 {
    constructor(t) {
        this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, 
        this.state = new T0();
    }
    async ready() {
        if (this.pendingBackendInit != null) return this.pendingBackendInit.then(() => {});
        if (this.backendInstance != null) return;
        let t = this.getSortedBackends();
        for (let n = 0; n < t.length; n++) {
            let a = t[n];
            if (await this.initializeBackend(a).success) return void await this.setBackend(a);
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    get backend() {
        if (this.pendingBackendInit != null) throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
        if (this.backendInstance == null) {
            let {
                name: t,
                asyncInit: n
            } = this.initializeBackendsAndReturnBest();
            if (n) throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);
            this.setBackend(t);
        }
        return this.backendInstance;
    }
    backendNames() {
        return Object.keys(this.registryFactory);
    }
    findBackend(t) {
        if (!(t in this.registry)) {
            if (!(t in this.registryFactory)) return null;
            {
                let {
                    asyncInit: n
                } = this.initializeBackend(t);
                if (n) return null;
            }
        }
        return this.registry[t];
    }
    findBackendFactory(t) {
        return t in this.registryFactory ? this.registryFactory[t].factory : null;
    }
    registerBackend(t, n, a = 1) {
        return t in this.registryFactory ? (Sr(), !1) : (this.registryFactory[t] = {
            factory: n,
            priority: a
        }, !0);
    }
    async setBackend(t) {
        if (this.registryFactory[t] == null) throw new Error(`Backend name '${t}' not found in registry`);
        if (this.backendName = t, this.registry[t] == null) {
            this.backendInstance = null;
            let {
                success: n,
                asyncInit: a
            } = this.initializeBackend(t);
            if (!(a ? await n : n)) return !1;
        }
        return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), 
        this.profiler = new kI(this.backendInstance), !0;
    }
    setupRegisteredKernels() {
        so(this.backendName).forEach(t => {
            t.setupFunc != null && t.setupFunc(this.backendInstance);
        });
    }
    disposeRegisteredKernels(t) {
        so(t).forEach(n => {
            n.disposeFunc != null && n.disposeFunc(this.registry[t]);
        });
    }
    initializeBackend(t) {
        let n = this.registryFactory[t];
        if (n == null) throw new Error(`Cannot initialize backend ${t}, no registration found.`);
        try {
            let a = n.factory();
            if (!a || a instanceof al || typeof a.then != "function") return this.registry[t] = a, 
            {
                success: !0,
                asyncInit: !1
            };
            {
                let r = ++this.pendingBackendInitId, s = a.then(i => !(r < this.pendingBackendInitId) && (this.registry[t] = i, 
                this.pendingBackendInit = null, !0)).catch(i => (r < this.pendingBackendInitId || (this.pendingBackendInit = null, 
                Sr(), Sr(i.stack || i.message)), !1));
                return this.pendingBackendInit = s, {
                    success: s,
                    asyncInit: !0
                };
            }
        } catch (a) {
            return Sr(), Sr(a.stack || a.message), {
                success: !1,
                asyncInit: !1
            };
        }
    }
    removeBackend(t) {
        if (!(t in this.registryFactory)) throw new Error(`${t} backend not found in registry`);
        this.backendName === t && this.pendingBackendInit != null && this.pendingBackendInitId++, 
        t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), 
        delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, 
        this.backendName = null, this.backendInstance = null);
    }
    getSortedBackends() {
        if (Object.keys(this.registryFactory).length === 0) throw new Error("No backend found in registry.");
        return Object.keys(this.registryFactory).sort((t, n) => this.registryFactory[n].priority - this.registryFactory[t].priority);
    }
    initializeBackendsAndReturnBest() {
        let t = this.getSortedBackends();
        for (let n = 0; n < t.length; n++) {
            let a = t[n], {
                success: r,
                asyncInit: s
            } = this.initializeBackend(a);
            if (s || r) return {
                name: a,
                asyncInit: s
            };
        }
        throw new Error("Could not initialize any backends, all backend initializations failed.");
    }
    moveData(t, n) {
        let a = this.state.tensorInfo.get(n), r = a.backend, s = this.readSync(n), i = r.refCount(n);
        r.disposeData(n, !0), a.backend = t, t.move(n, s, a.shape, a.dtype, i), 
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;
    }
    tidy(t, n) {
        let a, r = null;
        if (n == null) {
            if (typeof t != "function") throw new Error("Please provide a function to tidy()");
            n = t;
        } else {
            if (typeof t != "string" && !(t instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
            if (typeof n != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
            r = t;
        }
        return this.scopedRun(() => this.startScope(r), () => this.endScope(a), () => (a = n(), 
        a));
    }
    scopedRun(t, n, a) {
        t();
        try {
            let r = a();
            return n(), r;
        } catch (r) {
            throw n(), r;
        }
    }
    nextTensorId() {
        return O2.nextTensorId++;
    }
    nextVariableId() {
        return O2.nextVariableId++;
    }
    clone(t) {
        let n = U.runKernel(Js, {
            x: t
        }), a = {
            x: t
        };
        return this.addTapeNode(this.state.activeScope.name, a, [ n ], r => ({
            x: () => {
                let s = {
                    x: r
                }, i = {
                    dtype: "float32"
                };
                return U.runKernel(Ss, s, i);
            }
        }), [], {}), n;
    }
    runKernel(t, n, a) {
        if (this.backendName == null && this.backend, md(t, this.backendName) == null) throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);
        return this.runKernelFunc({
            kernelName: t,
            inputs: n,
            attrs: a
        });
    }
    shouldCheckForMemLeaks() {
        return this.ENV.getBool("IS_TEST");
    }
    checkKernelForMemLeak(t, n, a) {
        let r = this.backend.numDataIds(), s = 0;
        a.forEach(o => {
            s += o.dtype === "complex64" ? 3 : 1;
        });
        let i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1], l = r - n - s - i;
        if (l > 0) throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`);
    }
    runKernelFunc(t) {
        let n, a, r = [], s = this.isTapeOn(), i = this.state.numBytes, l = this.state.numTensors;
        this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0), this.backendName == null && this.backend;
        let o, p = ef(t) ? t.kernelName : this.state.activeScope != null ? this.state.activeScope.name : "";
        if (ef(t)) {
            let {
                kernelName: f,
                inputs: m,
                attrs: g
            } = t;
            this.backendName == null && this.backend;
            let y = md(f, this.backendName);
            D(y != null, () => `Cannot find registered kernel '${f}' for backend '${this.backendName}'`), 
            a = () => {
                let A = this.backend.numDataIds();
                o = y.kernelFunc({
                    inputs: m,
                    attrs: g,
                    backend: this.backend
                });
                let x = Array.isArray(o) ? o : [ o ];
                this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(f, A, x);
                let b = x.map(v => v.rank != null ? v : this.makeTensorFromTensorInfo(v));
                if (s) {
                    let v = this.getTensorsForGradient(f, m, b);
                    r = this.saveTensorsForBackwardMode(v);
                }
                return b;
            };
        } else {
            let {
                forwardFunc: f
            } = t, m = g => {
                s && (r = g.map(y => this.keep(this.clone(y))));
            };
            a = () => {
                let g = this.backend.numDataIds();
                o = this.tidy(() => f(this.backend, m));
                let y = Array.isArray(o) ? o : [ o ];
                return this.shouldCheckForMemLeaks() && this.checkKernelForMemLeak(p, g, y), 
                y;
            };
        }
        let u, {
            inputs: c,
            attrs: d
        } = t, h = ef(t) ? null : t.backwardsFunc;
        return this.scopedRun(() => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {
            this.ENV.getBool("DEBUG") || this.state.profiling ? (u = this.profiler.profileKernel(p, c, () => a()), 
            this.ENV.getBool("DEBUG") && this.profiler.logKernelProfile(u), n = u.outputs) : n = a();
        }), s && this.addTapeNode(p, c, n, h, r, d), this.state.profiling && this.state.activeProfile.kernels.push({
            name: p,
            bytesAdded: this.state.numBytes - i,
            totalBytesSnapshot: this.state.numBytes,
            tensorsAdded: this.state.numTensors - l,
            totalTensorsSnapshot: this.state.numTensors,
            inputShapes: Object.keys(c).map(f => c[f] != null ? c[f].shape : null),
            outputShapes: n.map(f => f.shape),
            kernelTimeMs: u.timeMs,
            extraInfo: u.extraInfo
        }), Array.isArray(o) ? n : n[0];
    }
    saveTensorsForBackwardMode(t) {
        return t.map(n => this.keep(this.clone(n)));
    }
    getTensorsForGradient(t, n, a) {
        let r = Gh(t);
        if (r != null) {
            let s, i = r.inputsToSave || [], l = r.outputsToSave || [];
            r.saveAllInputs ? (D(Array.isArray(n), () => "saveAllInputs is true, expected inputs to be an array."), 
            s = Object.keys(n).map(p => n[p])) : s = i.map(p => n[p]);
            let o = a.filter((p, u) => l[u]);
            return s.concat(o);
        }
        return [];
    }
    makeTensor(t, n, a, r) {
        if (t == null) throw new Error("Values passed to engine.makeTensor() are null");
        a = a || "float32", r = r || this.backend;
        let s = t;
        a === "string" && gr(t[0]) && (s = t.map(o => Ad(o)));
        let i = r.write(s, n, a), l = new vt(n, a, i, this.nextTensorId());
        if (this.trackTensor(l, r), a === "string") {
            let o = this.state.tensorInfo.get(i), p = o0(s);
            this.state.numBytes += p - o.bytes, o.bytes = p;
        }
        return l;
    }
    makeTensorFromDataId(t, n, a, r) {
        let s = {
            dataId: t,
            shape: n,
            dtype: a = a || "float32"
        };
        return this.makeTensorFromTensorInfo(s, r);
    }
    makeTensorFromTensorInfo(t, n) {
        let {
            dataId: a,
            shape: r,
            dtype: s
        } = t, i = new vt(r, s, a, this.nextTensorId());
        return this.trackTensor(i, n), i;
    }
    makeVariable(t, n = !0, a, r) {
        a = a || this.nextVariableId().toString(), r != null && r !== t.dtype && (t = t.cast(r));
        let s = new wd(t, n, a, this.nextTensorId());
        if (this.state.registeredVariables[s.name] != null) throw new Error(`Variable with name ${s.name} was already registered`);
        return this.state.registeredVariables[s.name] = s, this.incRef(s, this.backend), 
        s;
    }
    trackTensor(t, n) {
        this.state.numTensors++, t.dtype === "string" && this.state.numStringTensors++;
        let a = 0;
        t.dtype !== "complex64" && t.dtype !== "string" && (a = t.size * Dp(t.dtype)), 
        this.state.numBytes += a, this.state.tensorInfo.has(t.dataId) || (this.state.numDataBuffers++, 
        this.state.tensorInfo.set(t.dataId, {
            backend: n || this.backend,
            dtype: t.dtype,
            shape: t.shape,
            bytes: a
        })), t instanceof wd || this.track(t);
    }
    incRef(t, n) {
        this.trackTensor(t, n), this.backend.incRef(t.dataId);
    }
    removeDataId(t, n) {
        this.state.tensorInfo.has(t) && this.state.tensorInfo.get(t).backend === n && (this.state.tensorInfo.delete(t), 
        this.state.numDataBuffers--);
    }
    disposeTensor(t) {
        if (!this.state.tensorInfo.has(t.dataId)) return;
        let n = this.state.tensorInfo.get(t.dataId);
        if (this.state.numTensors--, t.dtype === "string" && (this.state.numStringTensors--, 
        this.state.numBytes -= n.bytes), t.dtype !== "complex64" && t.dtype !== "string") {
            let a = t.size * Dp(t.dtype);
            this.state.numBytes -= a;
        }
        n.backend.disposeData(t.dataId) && this.removeDataId(t.dataId, n.backend);
    }
    disposeVariables() {
        for (let t in this.state.registeredVariables) {
            let n = this.state.registeredVariables[t];
            this.disposeVariable(n);
        }
    }
    disposeVariable(t) {
        this.disposeTensor(t), this.state.registeredVariables[t.name] != null && delete this.state.registeredVariables[t.name];
    }
    memory() {
        let t = this.backend.memory();
        return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, 
        t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, 
        t.reasons == null && (t.reasons = []), t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), 
        t;
    }
    async profile(t) {
        this.state.profiling = !0;
        let n = this.state.numBytes, a = this.state.numTensors;
        this.state.activeProfile.kernels = [], this.state.activeProfile.result = await t(), 
        this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max(...this.state.activeProfile.kernels.map(r => r.totalBytesSnapshot)), 
        this.state.activeProfile.newBytes = this.state.numBytes - n, this.state.activeProfile.newTensors = this.state.numTensors - a;
        for (let r of this.state.activeProfile.kernels) r.kernelTimeMs = await r.kernelTimeMs, 
        r.extraInfo = await r.extraInfo;
        return this.state.activeProfile;
    }
    isTapeOn() {
        return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;
    }
    addTapeNode(t, n, a, r, s, i) {
        let l = {
            id: this.state.nextTapeNodeId++,
            kernelName: t,
            inputs: n,
            outputs: a,
            saved: s
        }, o = Gh(t);
        o != null && (r = o.gradFunc), r != null && (l.gradient = p => (p = p.map((u, c) => {
            if (u == null) {
                let d = a[c], h = Lp(d.size, d.dtype);
                return this.makeTensor(h, d.shape, d.dtype);
            }
            return u;
        }), r(p.length > 1 ? p : p[0], s, i))), this.state.activeTape.push(l);
    }
    keep(t) {
        return t.kept = !0, t;
    }
    startTape() {
        this.state.gradientDepth === 0 && (this.state.activeTape = []), this.state.gradientDepth++;
    }
    endTape() {
        this.state.gradientDepth--;
    }
    startScope(t) {
        let n = {
            track: [],
            name: "unnamed scope",
            id: this.state.nextScopeId++
        };
        t && (n.name = t), this.state.scopeStack.push(n), this.state.activeScope = n;
    }
    endScope(t) {
        let n = Qh(t), a = new Set(n.map(s => s.id));
        for (let s = 0; s < this.state.activeScope.track.length; s++) {
            let i = this.state.activeScope.track[s];
            !i.kept && !a.has(i.id) && i.dispose();
        }
        let r = this.state.scopeStack.pop();
        this.state.activeScope = this.state.scopeStack.length === 0 ? null : this.state.scopeStack[this.state.scopeStack.length - 1], 
        n.forEach(s => {
            !s.kept && s.scopeId === r.id && this.track(s);
        });
    }
    gradients(t, n, a, r = !1) {
        if (D(n.length > 0, () => "gradients() received an empty list of xs."), 
        a != null && a.dtype !== "float32") throw new Error(`dy must have 'float32' dtype, but has '${a.dtype}'`);
        let s = this.scopedRun(() => this.startTape(), () => this.endTape(), () => this.tidy("forward", t));
        D(s instanceof vt, () => "The result y returned by f() must be a tensor.");
        let i = function(l, o, p) {
            let u = {}, c = {};
            for (let m = 0; m < o.length; m++) u[o[m].id] = !0;
            for (let m = 0; m < l.length; m++) {
                let g = l[m], y = g.inputs;
                for (let A in y) {
                    let x = y[A], b = !1;
                    for (let v = 0; v < o.length; v++) if (u[x.id]) {
                        g.outputs.forEach(I => u[I.id] = !0), b = !0, c[g.id] = !0;
                        break;
                    }
                    if (b) break;
                }
            }
            let d = {};
            d[p.id] = !0;
            let h = {};
            for (let m = l.length - 1; m >= 0; m--) {
                let g = l[m], y = g.inputs;
                for (let A = 0; A < g.outputs.length; A++) if (d[g.outputs[A].id]) {
                    for (let x in y) d[y[x].id] = !0, h[g.id] = !0;
                    break;
                }
            }
            let f = [];
            for (let m = 0; m < l.length; m++) {
                let g = l[m];
                if (c[g.id] && h[g.id]) {
                    let y = {};
                    for (let x in g.inputs) {
                        let b = g.inputs[x];
                        u[b.id] && (y[x] = b);
                    }
                    let A = Object.assign({}, g);
                    A.inputs = y, A.outputs = g.outputs, f.push(A);
                }
            }
            return f;
        }(this.state.activeTape, n, s);
        if (!r && i.length === 0 && n.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
        return this.tidy("backward", () => {
            let l = {};
            l[s.id] = a ?? function(p) {
                let u = Wh(ht(p), "float32");
                return U.makeTensor(u, p, "float32");
            }(s.shape), function(p, u, c, d) {
                for (let h = u.length - 1; h >= 0; h--) {
                    let f = u[h], m = [];
                    if (f.outputs.forEach(y => {
                        let A = p[y.id];
                        A != null ? m.push(A) : m.push(null);
                    }), f.gradient == null) throw new Error(`Cannot compute gradient: gradient function not found for ${f.kernelName}.`);
                    let g = f.gradient(m);
                    for (let y in f.inputs) {
                        if (!(y in g)) throw new Error(`Cannot backprop through input ${y}. Available gradients found: ${Object.keys(g)}.`);
                        let A = c(() => g[y]());
                        if (A.dtype !== "float32") throw new Error(`Error in gradient for op ${f.kernelName}. The gradient of input ${y} must have 'float32' dtype, but has '${A.dtype}'`);
                        let x = f.inputs[y];
                        if (!qa(A.shape, x.shape)) throw new Error(`Error in gradient for op ${f.kernelName}. The gradient of input '${y}' has shape '${A.shape}', which does not match the shape of the input '${x.shape}'`);
                        if (p[x.id] == null) p[x.id] = A; else {
                            let b = p[x.id];
                            p[x.id] = d(b, A), b.dispose();
                        }
                    }
                }
            }(l, i, p => this.tidy(p), RI);
            let o = n.map(p => l[p.id]);
            return this.state.gradientDepth === 0 && (this.state.activeTape.forEach(p => {
                for (let u of p.saved) u.dispose();
            }), this.state.activeTape = null), {
                value: s,
                grads: o
            };
        });
    }
    customGrad(t) {
        return D(yr(t), () => "The f passed in customGrad(f) must be a function."), 
        (...n) => {
            D(n.every(s => s instanceof vt), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
            let a, r = {};
            return n.forEach((s, i) => {
                r[i] = s;
            }), this.runKernelFunc({
                forwardFunc: (s, i) => (a = t(...n, i), D(a.value instanceof vt, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), 
                D(yr(a.gradFunc), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), 
                a.value),
                backwardsFunc: (s, i) => {
                    let l = a.gradFunc(s, i), o = Array.isArray(l) ? l : [ l ];
                    D(o.length === n.length, () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), 
                    D(o.every(u => u instanceof vt), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
                    let p = {};
                    return o.forEach((u, c) => {
                        p[c] = () => u;
                    }), p;
                },
                inputs: r
            });
        };
    }
    readSync(t) {
        return this.state.tensorInfo.get(t).backend.readSync(t);
    }
    read(t) {
        return this.state.tensorInfo.get(t).backend.read(t);
    }
    readToGPU(t, n) {
        return this.state.tensorInfo.get(t).backend.readToGPU(t, n);
    }
    async time(t) {
        let n = yd(), a = await this.backend.time(t);
        return a.wallMs = yd() - n, a;
    }
    track(t) {
        return this.state.activeScope != null && (t.scopeId = this.state.activeScope.id, 
        this.state.activeScope.track.push(t)), t;
    }
    get registeredVariables() {
        return this.state.registeredVariables;
    }
    reset() {
        this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new T0();
        for (let t in this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), 
        delete this.registry[t];
        this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;
    }
};

function R0() {
    let e = h0();
    if (e._tfengine == null) {
        let t = new c0(e);
        e._tfengine = new tf(t);
    }
    return function(t) {
        Vh = t;
    }(e._tfengine.ENV), function(t) {
        xa = t;
    }(() => e._tfengine), e._tfengine;
}

tf.nextTensorId = 0, tf.nextVariableId = 0;

var U = R0();

function RI(e, t) {
    let n = {
        a: e,
        b: t
    };
    return U.runKernel(Ar, n);
}

var nf, Id = {};

function EI(e) {
    nf = e;
}

function $I(e) {
    if (nf !== void 0) return nf;
    if (e || typeof navigator < "u" && navigator != null) {
        if (e || (e = navigator), e.product === "ReactNative") return !0;
        let t = e.userAgent || e.vendor || (typeof window < "u" ? window.opera : "");
        if (!t) {
            let n = e;
            return n.userAgentData && n.userAgentData.mobile;
        }
        return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
    }
    return !1;
}

function E0() {
    return typeof window < "u" && window.document != null || typeof WorkerGlobalScope < "u";
}

Ze(Id, {
    isBrowser: () => E0,
    isMobile: () => $I,
    mockIsMobile: () => EI
});

var vn = H();

function Oa(e, t) {
    let n = e;
    if (Gt(e)) return t === "string" ? [] : [ e.length ];
    if (I0(e)) {
        let r = e.channels || "RGBA";
        return [ e.height, e.width * r.length ];
    }
    if (S0(e)) return [ e.buffer.size / (t == null ? 4 : Dp(t)) ];
    if (!Array.isArray(e)) return [];
    let a = [];
    for (;Array.isArray(n) || Gt(n) && t !== "string"; ) a.push(n.length), n = n[0];
    return Array.isArray(e) && H().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && $0(e, a, []), 
    a;
}

function $0(e, t, n) {
    if (n = n || [], !Array.isArray(e) && !Gt(e)) return void D(t.length === 0, () => `Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);
    D(t.length > 0, () => `Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`), 
    D(e.length === t[0], () => `Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);
    let a = t.slice(1);
    for (let r = 0; r < e.length; ++r) $0(e[r], a, n.concat(r));
}

function M0(e, t, n, a) {
    if (e !== "string_or_numeric") {
        if (e == null) throw new Error("Expected dtype cannot be null.");
        if (e !== "numeric" && e !== t || e === "numeric" && t === "string") throw new Error(`Argument '${n}' passed to '${a}' must be ${e} tensor, but got ${t} tensor`);
    }
}

function _(e, t, n, a = "numeric") {
    if (e instanceof w0()) return M0(a, e.dtype, t, n), e;
    let r = Gu(e);
    if (r !== "string" && [ "bool", "int32", "float32" ].indexOf(a) >= 0 && (r = a), 
    M0(a, r, t, n), e == null || !Gt(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") {
        let l = e == null ? "null" : e.constructor.name;
        throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`);
    }
    let s = Oa(e, r);
    !Gt(e) && !Array.isArray(e) && (e = [ e ]);
    let i = r !== "string" ? Hp(e, r) : Cr(e, [], !0);
    return U.makeTensor(i, s, r);
}

function Sd(e, t, n, a = "numeric") {
    if (!Array.isArray(e)) throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);
    return e.map((r, s) => _(r, `${t}[${s}]`, n, a));
}

vn.registerFlag("DEBUG", () => !1, e => {}), vn.registerFlag("IS_BROWSER", () => E0()), 
vn.registerFlag("IS_NODE", () => typeof process < "u" && process.versions !== void 0 && process.versions.node !== void 0), 
vn.registerFlag("IS_CHROME", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)), 
vn.registerFlag("IS_SAFARI", () => typeof navigator < "u" && navigator != null && navigator.userAgent != null && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor)), 
vn.registerFlag("PROD", () => !1), vn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => vn.getBool("DEBUG")), 
vn.registerFlag("DEPRECATION_WARNINGS_ENABLED", () => !0), vn.registerFlag("IS_TEST", () => !1), 
vn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", () => vn.getBool("DEBUG")), vn.registerFlag("WRAP_TO_IMAGEBITMAP", () => !1), 
vn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => !1), vn.registerFlag("USE_SETTIMEOUTCUSTOM", () => !1);

var af = "__op";

function V(e) {
    let t = Object.keys(e);
    if (t.length !== 1) throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);
    let n = t[0], a = e[n];
    n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += af;
    let r = (...s) => {
        U.startScope(n);
        try {
            let i = a(...s);
            return Wp(i), U.endScope(i), i;
        } catch (i) {
            throw U.endScope(null), i;
        }
    };
    return Object.defineProperty(r, "name", {
        value: n,
        configurable: !0
    }), r;
}

var Ka = V({
    complex_: function(e, t) {
        let n = _(e, "real", "complex"), a = _(t, "imag", "complex");
        ln(n.shape, a.shape, `real and imag shapes, ${n.shape} and ${a.shape}, must match in call to tf.complex().`);
        let r = {
            real: n,
            imag: a
        };
        return U.runKernel(qu, r);
    }
});

function Tr(e, t, n, a) {
    if (a == null) a = Gu(e); else if (a === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
    if (S0(e) || I0(e)) {
        if (a !== "float32" && a !== "int32") throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${a}.`);
        return U.backend.createTensorFromGPUData(e, t || n, a);
    }
    if (!Gt(e) && !Array.isArray(e) && typeof e != "number" && typeof e != "boolean" && typeof e != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
    if (t != null) {
        zn(t);
        let r = ht(t), s = ht(n);
        D(r === s, () => `Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);
        for (let i = 0; i < n.length; ++i) {
            let l = n[i], o = i !== n.length - 1 || l !== ht(t.slice(i));
            D(n[i] === t[i] || !o, () => `Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `);
        }
    }
    return !Gt(e) && !Array.isArray(e) && (e = [ e ]), t = t || n, e = a !== "string" ? Hp(e, a) : Cr(e, [], !0), 
    U.makeTensor(e, t, a);
}

function Ye(e, t, n) {
    return Tr(e, t, Oa(e, n), n);
}

var uo = {
    float32: 4,
    float16: 2,
    int32: 4,
    uint16: 2,
    uint8: 1,
    bool: 1,
    complex64: 8
}, Za = class f6 {
    static join(t) {
        return new f6(t).slice();
    }
    constructor(t) {
        if (this.shards = [], this.previousShardIndex = 0, t == null || (t instanceof Array || (t = [ t ]), 
        (t = t.map(a => Gt(a) ? a.buffer : a)).length === 0)) return;
        this.bufferUniformSize = t[0].byteLength;
        let n = 0;
        for (let a = 0; a < t.length; a++) {
            let r = t[a];
            a !== t.length - 1 && r.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
            let s = n + r.byteLength;
            this.shards.push({
                buffer: r,
                start: n,
                end: s
            }), n = s;
        }
        this.shards.length === 0 && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end;
    }
    slice(t = 0, n = this.byteLength) {
        if (this.shards.length === 0) return new ArrayBuffer(0);
        if (t = isNaN(Number(t)) ? 0 : t, n = isNaN(Number(n)) ? 0 : n, t = Math.max(0, t), 
        (n = Math.min(this.byteLength, n)) <= t) return new ArrayBuffer(0);
        let a = this.findShardForByte(t);
        if (a === -1) throw new Error(`Could not find start shard for byte ${t}`);
        let r = new ArrayBuffer(n - t), s = new Uint8Array(r), i = 0;
        for (let l = a; l < this.shards.length; l++) {
            let o = this.shards[l], p = t + i - o.start, u = i, c = Math.min(n, o.end) - o.start, d = new Uint8Array(o.buffer, p, c - p);
            if (s.set(d, u), i += d.length, n < o.end) break;
        }
        return r;
    }
    findShardForByte(t) {
        if (this.shards.length === 0 || t < 0 || t >= this.byteLength) return -1;
        if (this.bufferUniformSize != null) return this.previousShardIndex = Math.floor(t / this.bufferUniformSize), 
        this.previousShardIndex;
        function n(r) {
            return t < r.start ? -1 : t >= r.end ? 1 : 0;
        }
        if (n(this.shards[this.previousShardIndex]) === 0) return this.previousShardIndex;
        let a = function(r, s) {
            let i = 0, l = r.length;
            for (;i <= l; ) {
                let o = Math.floor((l - i) / 2) + i, p = s(r[o]);
                if (p === 0) return o;
                p < 0 ? l = o : i = o + 1;
            }
            return -1;
        }(this.shards, n);
        return a === -1 ? -1 : (this.previousShardIndex = a, this.previousShardIndex);
    }
};

function F0() {
    H().set("PROD", !0);
}

function MI() {
    H().set("DEBUG", !0);
}

function FI() {
    H().set("DEPRECATION_WARNINGS_ENABLED", !1);
}

function _0(e) {
    H().getBool("DEPRECATION_WARNINGS_ENABLED");
}

function _I() {
    U.disposeVariables();
}

function Mt() {
    return U;
}

function OI() {
    return U.memory();
}

function PI(e) {
    return U.profile(e);
}

function qe(e, t) {
    return U.tidy(e, t);
}

function ae(e) {
    Qh(e).forEach(t => t.dispose());
}

function ba(e) {
    return U.keep(e);
}

function DI(e) {
    return U.time(e);
}

function Xp(e) {
    return U.setBackend(e);
}

function rf() {
    return U.ready();
}

function dn() {
    return U.backendName;
}

function zI(e) {
    U.removeBackend(e);
}

function O0(e) {
    return U.findBackend(e);
}

function LI(e) {
    return U.findBackendFactory(e);
}

function ql(e, t, n = 1) {
    return U.registerBackend(e, t, n);
}

function Rr() {
    return U.backend;
}

function WI(e, t) {
    H().setPlatform(e, t);
}

var Er = 4;

async function BI(e, t) {
    let n = [], a = [], r = Array.isArray(e) ? e.map(s => s.name) : Object.keys(e);
    for (let s = 0; s < r.length; ++s) {
        let i = r[s], l = Array.isArray(e) ? e[s].tensor : e[i];
        if (l.dtype !== "float32" && l.dtype !== "int32" && l.dtype !== "bool" && l.dtype !== "string" && l.dtype !== "complex64") throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);
        let o = {
            name: i,
            shape: l.shape,
            dtype: l.dtype
        };
        if (l.dtype === "string") {
            let p = new Promise(async u => {
                let c = await l.bytes(), d = c.reduce((m, g) => m + g.length, 0) + Er * c.length, h = new Uint8Array(d), f = 0;
                for (let m = 0; m < c.length; m++) {
                    let g = c[m], y = new Uint8Array(new Uint32Array([ g.length ]).buffer);
                    h.set(y, f), f += Er, h.set(g, f), f += g.length;
                }
                u(h);
            });
            a.push(p);
        } else a.push(l.data());
        t != null && (o.group = t), n.push(o);
    }
    return {
        data: GI(await Promise.all(a)),
        specs: n
    };
}

function P0(e, t) {
    let n = new Za(e), a = {}, r = 0;
    for (let s of t) {
        let i = VI(s, (l, o) => n.slice(r + l, r + o));
        a[s.name] = D0(s, n.slice(r, r + i)), r += i;
    }
    return a;
}

function VI(e, t) {
    let n, a = ht(e.shape);
    if ("quantization" in e) {
        let r = e.quantization;
        n = uo[r.dtype];
    } else {
        if (e.dtype === "string") {
            let r = 0;
            for (let s = 0; s < a; s++) r += Er + new Uint32Array(t(r, r + Er))[0];
            return r;
        }
        n = uo[e.dtype];
    }
    return a * n;
}

async function UI(e, t) {
    let n, a = ht(e.shape);
    if ("quantization" in e) {
        let r = e.quantization;
        n = uo[r.dtype];
    } else {
        if (e.dtype === "string") {
            let r = 0;
            for (let s = 0; s < a; s++) r += Er + new Uint32Array(await t(r, r + Er))[0];
            return r;
        }
        n = uo[e.dtype];
    }
    return a * n;
}

function D0(e, t) {
    let n, a = e.name, r = e.dtype, s = e.shape, i = ht(s), l = 0;
    if ("quantization" in e) {
        let o = e.quantization;
        if (o.dtype === "uint8" || o.dtype === "uint16") {
            if (!("min" in o) || !("scale" in o)) throw new Error(`Weight ${e.name} with quantization ${o.dtype} doesn't have corresponding metadata min and scale.`);
        } else {
            if (o.dtype !== "float16") throw new Error(`Weight ${e.name} has unknown quantization dtype ${o.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);
            if (r !== "float32") throw new Error(`Weight ${e.name} is quantized with ${o.dtype} which only supports weights of type float32 not ${r}.`);
        }
        let p = uo[o.dtype], u = o.dtype === "uint8" ? new Uint8Array(t) : new Uint16Array(t);
        if (r === "float32") if (o.dtype === "uint8" || o.dtype === "uint16") {
            n = new Float32Array(u.length);
            for (let c = 0; c < u.length; c++) {
                let d = u[c];
                n[c] = d * o.scale + o.min;
            }
        } else {
            if (o.dtype !== "float16") throw new Error(`Unsupported quantization type ${o.dtype} for weight type float32.`);
            n = function() {
                let c = function() {
                    let f = g => {
                        let y = g << 13, A = 0;
                        for (;!(8388608 & y); ) A -= 8388608, y <<= 1;
                        return y &= -8388609, A += 947912704, y | A;
                    }, m = new Uint32Array(2048);
                    m[0] = 0;
                    for (let g = 1; g < 1024; g++) m[g] = f(g);
                    for (let g = 1024; g < 2048; g++) m[g] = 939524096 + (g - 1024 << 13);
                    return m;
                }(), d = function() {
                    let f = new Uint32Array(64);
                    f[0] = 0, f[31] = 1199570944, f[32] = 2147483648, f[63] = 3347054592;
                    for (let m = 1; m < 31; m++) f[m] = m << 23;
                    for (let m = 33; m < 63; m++) f[m] = 2147483648 + (m - 32 << 23);
                    return f;
                }(), h = function() {
                    let f = new Uint32Array(64);
                    for (let m = 0; m < 64; m++) f[m] = 1024;
                    return f[0] = f[32] = 0, f;
                }();
                return f => {
                    let m = new ArrayBuffer(4 * f.length), g = new Uint32Array(m);
                    for (let y = 0; y < f.length; y++) {
                        let A = f[y], x = c[h[A >> 10] + (1023 & A)] + d[A >> 10];
                        g[y] = x;
                    }
                    return new Float32Array(m);
                };
            }()(u);
        } else {
            if (r !== "int32") throw new Error(`Unsupported dtype in weight '${a}': ${r}`);
            if (o.dtype !== "uint8" && o.dtype !== "uint16") throw new Error(`Unsupported quantization type ${o.dtype} for weight type int32.`);
            n = new Int32Array(u.length);
            for (let c = 0; c < u.length; c++) {
                let d = u[c];
                n[c] = Math.round(d * o.scale + o.min);
            }
        }
        l += i * p;
    } else if (r === "string") {
        let o = ht(e.shape);
        n = [];
        for (let p = 0; p < o; p++) {
            let u = new Uint32Array(t.slice(l, l + Er))[0];
            l += Er;
            let c = new Uint8Array(t.slice(l, l + u));
            n.push(c), l += u;
        }
    } else {
        let o = uo[r];
        if (r === "float32") n = new Float32Array(t); else if (r === "int32") n = new Int32Array(t); else {
            if (r !== "bool") {
                if (r === "complex64") {
                    n = new Float32Array(t);
                    let p = new Float32Array(n.length / 2), u = new Float32Array(n.length / 2);
                    for (let f = 0; f < p.length; f++) p[f] = n[2 * f], u[f] = n[2 * f + 1];
                    let c = Ye(p, s, "float32"), d = Ye(u, s, "float32"), h = Ka(c, d);
                    return c.dispose(), d.dispose(), h;
                }
                throw new Error(`Unsupported dtype in weight '${a}': ${r}`);
            }
            n = new Uint8Array(t);
        }
        l += i * o;
    }
    return Ye(n, s, r);
}

async function z0(e, t, n) {
    let a = new Uint8Array(t);
    for (;a.byteLength < n; ) {
        let {
            done: r,
            value: s
        } = await e.read();
        if (r && s == null) {
            let l = n - a.byteLength;
            throw new Error(`Reader is done but ${l} bytes are still expected`);
        }
        let i = new Uint8Array(a.length + s.byteLength);
        i.set(a, 0), i.set(new Uint8Array(s), a.length), a = i;
    }
    return a.buffer;
}

async function L0(e, t) {
    let n = {}, a = e.getReader(), r = new ArrayBuffer(0);
    for (let s of t) {
        let i = await UI(s, async (p, u) => (r = await z0(a, r, u), r.slice(p, u)));
        r = await z0(a, r, i);
        let l = r.slice(0, i);
        r = r.slice(i);
        let o = D0(s, l);
        if (n[s.name] = o, dn() === "webgpu") {
            let p = Rr();
            "uploadToGPU" in p && ht(o.shape) >= H().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && p.uploadToGPU(o.dataId);
        }
    }
    return n;
}

function GI(e) {
    if (e === null) throw new Error(`Invalid input value: ${JSON.stringify(e)}`);
    let t = 0, n = [];
    e.forEach(s => {
        if (t += s.byteLength, n.push(s.byteLength === s.buffer.byteLength ? s : new s.constructor(s)), 
        !(s instanceof Float32Array || s instanceof Int32Array || s instanceof Uint8Array)) throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`);
    });
    let a = new Uint8Array(t), r = 0;
    return n.forEach(s => {
        a.set(new Uint8Array(s.buffer), r), r += s.byteLength;
    }), a.buffer;
}

var sf = typeof Buffer < "u" && (typeof Blob > "u" || typeof atob > "u" || typeof btoa > "u");

function W0(e) {
    return sf ? Buffer.byteLength(e, "utf8") : new Blob([ e ]).size;
}

function HI(e) {
    return Za.join(e);
}

function B0(e) {
    for (e = e.trim(); e.endsWith("/"); ) e = e.slice(0, e.length - 1);
    let t = e.split("/");
    return t[t.length - 1];
}

function V0(e, t) {
    let n = {
        modelTopology: e.modelTopology,
        format: e.format,
        generatedBy: e.generatedBy,
        convertedBy: e.convertedBy,
        weightsManifest: t
    };
    return e.signature != null && (n.signature = e.signature), e.userDefinedMetadata != null && (n.userDefinedMetadata = e.userDefinedMetadata), 
    e.modelInitializer != null && (n.modelInitializer = e.modelInitializer), e.initializerSignature != null && (n.initializerSignature = e.initializerSignature), 
    e.trainingConfig != null && (n.trainingConfig = e.trainingConfig), n;
}

function U0(e, t, n) {
    let a = {
        modelTopology: e.modelTopology,
        format: e.format,
        generatedBy: e.generatedBy,
        convertedBy: e.convertedBy
    };
    if (e.trainingConfig != null && (a.trainingConfig = e.trainingConfig), e.weightsManifest != null) {
        if (!t) throw new Error("modelJSON has weightsManifest but weightSpecs is null");
        if (!n) throw new Error("modelJSON has weightsManifest but weightData is null");
        a.weightSpecs = t, a.weightData = n;
    }
    return e.signature != null && (a.signature = e.signature), e.userDefinedMetadata != null && (a.userDefinedMetadata = e.userDefinedMetadata), 
    e.modelInitializer != null && (a.modelInitializer = e.modelInitializer), e.initializerSignature != null && (a.initializerSignature = e.initializerSignature), 
    a;
}

async function of(e, t) {
    let n, a;
    return e.weightsManifest != null && ([ n, a ] = await t(e.weightsManifest)), 
    U0(e, n, a);
}

function Nd(e) {
    if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
    return {
        dateSaved: new Date(),
        modelTopologyType: "JSON",
        modelTopologyBytes: e.modelTopology == null ? 0 : W0(JSON.stringify(e.modelTopology)),
        weightSpecsBytes: e.weightSpecs == null ? 0 : W0(JSON.stringify(e.weightSpecs)),
        weightDataBytes: e.weightData == null ? 0 : new Za(e.weightData).byteLength
    };
}

function lf(e) {
    let t = [];
    for (let n of e) t.push(...n.weights);
    return t;
}

var Yn = class Fa {
    constructor() {
        this.saveRouters = [], this.loadRouters = [];
    }
    static getInstance() {
        return Fa.instance == null && (Fa.instance = new Fa()), Fa.instance;
    }
    static registerSaveRouter(t) {
        Fa.getInstance().saveRouters.push(t);
    }
    static registerLoadRouter(t) {
        Fa.getInstance().loadRouters.push(t);
    }
    static getSaveHandlers(t) {
        return Fa.getHandlers(t, "save");
    }
    static getLoadHandlers(t, n) {
        return Fa.getHandlers(t, "load", n);
    }
    static getHandlers(t, n, a) {
        let r = [];
        return (n === "load" ? Fa.getInstance().loadRouters : Fa.getInstance().saveRouters).forEach(s => {
            let i = s(t, a);
            i !== null && r.push(i);
        }), r;
    }
}, jI = e => Yn.registerSaveRouter(e), qI = e => Yn.registerLoadRouter(e), XI = e => Yn.getSaveHandlers(e), KI = (e, t) => Yn.getLoadHandlers(e, t), uf = "tensorflowjs", po = "models_store", $r = "model_info_store";

function G0() {
    if (!H().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
    let e = typeof window > "u" ? self : window, t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
    if (t == null) throw new Error("The current browser does not appear to support IndexedDB.");
    return t;
}

function df(e) {
    let t = e.result;
    t.createObjectStore(po, {
        keyPath: "modelPath"
    }), t.createObjectStore($r, {
        keyPath: "modelPath"
    });
}

var co = class {
    constructor(e) {
        if (this.indexedDB = G0(), e == null || !e) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
        this.modelPath = e;
    }
    async save(e) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        return this.databaseAction(this.modelPath, e);
    }
    async load() {
        return this.databaseAction(this.modelPath);
    }
    databaseAction(e, t) {
        return new Promise((n, a) => {
            let r = this.indexedDB.open(uf, 1);
            r.onupgradeneeded = () => df(r), r.onsuccess = () => {
                let s = r.result;
                if (t == null) {
                    let i = s.transaction(po, "readonly"), l = i.objectStore(po).get(this.modelPath);
                    l.onsuccess = () => {
                        if (l.result == null) return s.close(), a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));
                        n(l.result.modelArtifacts);
                    }, l.onerror = o => (s.close(), a(l.error)), i.oncomplete = () => s.close();
                } else {
                    t.weightData = Za.join(t.weightData);
                    let i, l, o = Nd(t), p = s.transaction($r, "readwrite"), u = p.objectStore($r);
                    try {
                        i = u.put({
                            modelPath: this.modelPath,
                            modelArtifactsInfo: o
                        });
                    } catch (c) {
                        return a(c);
                    }
                    i.onsuccess = () => {
                        l = s.transaction(po, "readwrite");
                        let c, d = l.objectStore(po);
                        try {
                            c = d.put({
                                modelPath: this.modelPath,
                                modelArtifacts: t,
                                modelArtifactsInfo: o
                            });
                        } catch (h) {
                            return a(h);
                        }
                        c.onsuccess = () => n({
                            modelArtifactsInfo: o
                        }), c.onerror = h => {
                            u = p.objectStore($r);
                            let f = u.delete(this.modelPath);
                            f.onsuccess = () => (s.close(), a(c.error)), f.onerror = m => (s.close(), 
                            a(c.error));
                        };
                    }, i.onerror = c => (s.close(), a(i.error)), p.oncomplete = () => {
                        l == null ? s.close() : l.oncomplete = () => s.close();
                    };
                }
            }, r.onerror = s => a(r.error);
        });
    }
};

co.URL_SCHEME = "indexeddb://";

var H0 = e => H().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(co.URL_SCHEME) ? function(t) {
    return new co(t);
}(e.slice(co.URL_SCHEME.length)) : null;

Yn.registerSaveRouter(H0), Yn.registerLoadRouter(H0);

var Ya = "/", Xl = "tensorflowjs_models", j0 = "info", ZI = "model_topology", YI = "weight_specs", JI = "weight_data", QI = "model_metadata";

function q0(e) {
    return {
        info: [ Xl, e, j0 ].join(Ya),
        topology: [ Xl, e, ZI ].join(Ya),
        weightSpecs: [ Xl, e, YI ].join(Ya),
        weightData: [ Xl, e, JI ].join(Ya),
        modelMetadata: [ Xl, e, QI ].join(Ya)
    };
}

function X0(e) {
    for (let t of Object.values(e)) window.localStorage.removeItem(t);
}

function eS(e) {
    let t = e.split(Ya);
    if (t.length < 3) throw new Error(`Invalid key format: ${e}`);
    return t.slice(1, t.length - 1).join(Ya);
}

var ho = class {
    constructor(e) {
        if (!H().getBool("IS_BROWSER") || typeof window > "u" || window.localStorage === void 0) throw new Error("The current environment does not support local storage.");
        if (this.LS = window.localStorage, e == null || !e) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
        this.modelPath = e, this.keys = q0(this.modelPath);
    }
    async save(e) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
        {
            let t = JSON.stringify(e.modelTopology), n = JSON.stringify(e.weightSpecs), a = Nd(e), r = Za.join(e.weightData);
            try {
                this.LS.setItem(this.keys.info, JSON.stringify(a)), this.LS.setItem(this.keys.topology, t), 
                this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, function(i) {
                    if (sf) return Buffer.from(i).toString("base64");
                    let l = new Uint8Array(i), o = "";
                    for (let p = 0, u = l.length; p < u; p++) o += String.fromCharCode(l[p]);
                    return btoa(o);
                }(r));
                let s = {
                    format: e.format,
                    generatedBy: e.generatedBy,
                    convertedBy: e.convertedBy,
                    signature: e.signature != null ? e.signature : void 0,
                    userDefinedMetadata: e.userDefinedMetadata != null ? e.userDefinedMetadata : void 0,
                    modelInitializer: e.modelInitializer != null ? e.modelInitializer : void 0,
                    initializerSignature: e.initializerSignature != null ? e.initializerSignature : void 0,
                    trainingConfig: e.trainingConfig != null ? e.trainingConfig : void 0
                };
                return this.LS.setItem(this.keys.modelMetadata, JSON.stringify(s)), 
                {
                    modelArtifactsInfo: a
                };
            } catch {
                throw X0(this.keys), new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`);
            }
        }
    }
    async load() {
        let e = JSON.parse(this.LS.getItem(this.keys.info));
        if (e == null) throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);
        if (e.modelTopologyType !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
        let t = {}, n = JSON.parse(this.LS.getItem(this.keys.topology));
        if (n == null) throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);
        t.modelTopology = n;
        let a = JSON.parse(this.LS.getItem(this.keys.weightSpecs));
        if (a == null) throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);
        t.weightSpecs = a;
        let r = this.LS.getItem(this.keys.modelMetadata);
        if (r != null) {
            let i = JSON.parse(r);
            t.format = i.format, t.generatedBy = i.generatedBy, t.convertedBy = i.convertedBy, 
            i.signature != null && (t.signature = i.signature), i.userDefinedMetadata != null && (t.userDefinedMetadata = i.userDefinedMetadata), 
            i.modelInitializer != null && (t.modelInitializer = i.modelInitializer), 
            i.initializerSignature != null && (t.initializerSignature = i.initializerSignature), 
            i.trainingConfig != null && (t.trainingConfig = i.trainingConfig);
        }
        let s = this.LS.getItem(this.keys.weightData);
        if (s == null) throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);
        return t.weightData = function(i) {
            if (sf) {
                let p = Buffer.from(i, "base64");
                return p.buffer.slice(p.byteOffset, p.byteOffset + p.byteLength);
            }
            let l = atob(i), o = new Uint8Array(l.length);
            for (let p = 0; p < l.length; ++p) o.set([ l.charCodeAt(p) ], p);
            return o.buffer;
        }(s), t;
    }
};

ho.URL_SCHEME = "localstorage://";

var K0 = e => H().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(ho.URL_SCHEME) ? function(t) {
    return new ho(t);
}(e.slice(ho.URL_SCHEME.length)) : null;

Yn.registerSaveRouter(K0), Yn.registerLoadRouter(K0);

var Kl = "://", Mr = class is {
    constructor() {
        this.managers = {};
    }
    static getInstance() {
        return is.instance == null && (is.instance = new is()), is.instance;
    }
    static registerManager(t, n) {
        D(t != null, () => "scheme must not be undefined or null."), t.endsWith(Kl) && (t = t.slice(0, t.indexOf(Kl))), 
        D(t.length > 0, () => "scheme must not be an empty string.");
        let a = is.getInstance();
        D(a.managers[t] == null, () => `A model store manager is already registered for scheme '${t}'.`), 
        a.managers[t] = n;
    }
    static getManager(t) {
        let n = is.getInstance().managers[t];
        if (n == null) throw new Error(`Cannot find model manager for scheme '${t}'`);
        return n;
    }
    static getSchemes() {
        return Object.keys(is.getInstance().managers);
    }
};

function Kp(e) {
    if (e.indexOf(Kl) === -1) throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Mr.getSchemes().join(",")}`);
    return {
        scheme: e.split(Kl)[0],
        path: e.split(Kl)[1]
    };
}

async function Z0(e, t, n = !1) {
    D(e !== t, () => `Old path and new path are the same: '${e}'`);
    let a = Yn.getLoadHandlers(e);
    D(a.length > 0, () => `Copying failed because no load handler is found for source URL ${e}.`), 
    D(a.length < 2, () => `Copying failed because more than one (${a.length}) load handlers for source URL ${e}.`);
    let r = a[0], s = Yn.getSaveHandlers(t);
    D(s.length > 0, () => `Copying failed because no save handler is found for destination URL ${t}.`), 
    D(s.length < 2, () => `Copying failed because more than one (${a.length}) save handlers for destination URL ${t}.`);
    let i = s[0], l = Kp(e).scheme, o = Kp(e).path, p = l === Kp(e).scheme, u = await r.load();
    n && p && await Mr.getManager(l).removeModel(o);
    let c = await i.save(u);
    return n && !p && await Mr.getManager(l).removeModel(o), c.modelArtifactsInfo;
}

async function tS() {
    let e = Mr.getSchemes(), t = {};
    for (let n of e) {
        let a = await Mr.getManager(n).listModels();
        for (let r in a) t[n + Kl + r] = a[r];
    }
    return t;
}

async function nS(e) {
    let t = Kp(e);
    return Mr.getManager(t.scheme).removeModel(t.path);
}

async function aS(e, t) {
    return Z0(e, t, !1);
}

async function rS(e, t) {
    return Z0(e, t, !0);
}

if (H().get("IS_BROWSER")) {
    H().setPlatform("browser", new class {
        constructor() {
            this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, 
            this.hasEventListener = !1;
        }
        fetch(e, t) {
            return fetch(e, t);
        }
        now() {
            return performance.now();
        }
        encode(e, t) {
            if (t !== "utf-8" && t !== "utf8") throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);
            return this.textEncoder == null && (this.textEncoder = new TextEncoder()), 
            this.textEncoder.encode(e);
        }
        decode(e, t) {
            return new TextDecoder(t).decode(e);
        }
        setTimeoutCustom(e, t) {
            typeof window < "u" && H().getBool("USE_SETTIMEOUTCUSTOM") ? (this.functionRefs.push(e), 
            setTimeout(() => {
                window.postMessage({
                    name: this.messageName,
                    index: this.functionRefs.length - 1
                }, "*");
            }, t), this.hasEventListener || (this.hasEventListener = !0, window.addEventListener("message", n => {
                n.source === window && n.data.name === this.messageName && (n.stopPropagation(), 
                (0, this.functionRefs[n.data.index])(), this.handledMessageCount++, 
                this.handledMessageCount === this.functionRefs.length && (this.functionRefs = [], 
                this.handledMessageCount = 0));
            }, !0))) : setTimeout(e, t);
        }
        isTypedArray(e) {
            return m0(e);
        }
    }());
    try {
        Mr.registerManager(ho.URL_SCHEME, new class {
            constructor() {
                D(H().getBool("IS_BROWSER"), () => "Current environment is not a web browser"), 
                D(typeof window > "u" || window.localStorage !== void 0, () => "Current browser does not appear to support localStorage"), 
                this.LS = window.localStorage;
            }
            async listModels() {
                let e = {}, t = Xl + Ya, n = Ya + j0;
                for (let a = 0; a < this.LS.length; ++a) {
                    let r = this.LS.key(a);
                    r.startsWith(t) && r.endsWith(n) && (e[eS(r)] = JSON.parse(this.LS.getItem(r)));
                }
                return e;
            }
            async removeModel(e) {
                e = function(a) {
                    return a.startsWith(ho.URL_SCHEME) ? a.slice(ho.URL_SCHEME.length) : a;
                }(e);
                let t = q0(e);
                if (this.LS.getItem(t.info) == null) throw new Error(`Cannot find model at path '${e}'`);
                let n = JSON.parse(this.LS.getItem(t.info));
                return X0(t), n;
            }
        }());
    } catch {}
    try {
        Mr.registerManager(co.URL_SCHEME, new class {
            constructor() {
                this.indexedDB = G0();
            }
            async listModels() {
                return new Promise((e, t) => {
                    let n = this.indexedDB.open(uf, 1);
                    n.onupgradeneeded = () => df(n), n.onsuccess = () => {
                        let a = n.result, r = a.transaction($r, "readonly"), s = r.objectStore($r).getAll();
                        s.onsuccess = () => {
                            let i = {};
                            for (let l of s.result) i[l.modelPath] = l.modelArtifactsInfo;
                            e(i);
                        }, s.onerror = i => (a.close(), t(s.error)), r.oncomplete = () => a.close();
                    }, n.onerror = a => t(n.error);
                });
            }
            async removeModel(e) {
                return e = function(t) {
                    return t.startsWith(co.URL_SCHEME) ? t.slice(co.URL_SCHEME.length) : t;
                }(e), new Promise((t, n) => {
                    let a = this.indexedDB.open(uf, 1);
                    a.onupgradeneeded = () => df(a), a.onsuccess = () => {
                        let r, s = a.result, i = s.transaction($r, "readwrite"), l = i.objectStore($r), o = l.get(e);
                        o.onsuccess = () => {
                            if (o.result == null) return s.close(), n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));
                            {
                                let p = l.delete(e), u = () => {
                                    r = s.transaction(po, "readwrite");
                                    let c = r.objectStore(po).delete(e);
                                    c.onsuccess = () => t(o.result.modelArtifactsInfo), 
                                    c.onerror = d => n(o.error);
                                };
                                p.onsuccess = u, p.onerror = c => (u(), s.close(), 
                                n(o.error));
                            }
                        }, o.onerror = p => (s.close(), n(o.error)), i.oncomplete = () => {
                            r == null ? s.close() : r.oncomplete = () => s.close();
                        };
                    }, a.onerror = r => n(a.error);
                });
            }
        }());
    } catch {}
}

var pf, sS = () => E6();

function We(e, t = "float32", n) {
    return t = t || "float32", zn(e), new $t(e, t, n);
}

H().get("IS_NODE") && !H().get("IS_BROWSER") && H().setPlatform("node", new class {
    constructor() {
        this.util = $6(), this.textEncoder = new this.util.TextEncoder();
    }
    fetch(e, t) {
        return H().global.fetch != null ? H().global.fetch(e, t) : (pf == null && (pf = sS()), 
        pf(e, t));
    }
    now() {
        let e = process.hrtime();
        return 1e3 * e[0] + e[1] / 1e6;
    }
    encode(e, t) {
        if (t !== "utf-8" && t !== "utf8") throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);
        return this.textEncoder.encode(e);
    }
    decode(e, t) {
        return e.length === 0 ? "" : new this.util.TextDecoder(t).decode(e);
    }
    isTypedArray(e) {
        return this.util.types.isFloat32Array(e) || this.util.types.isInt32Array(e) || this.util.types.isUint8Array(e) || this.util.types.isUint8ClampedArray(e);
    }
}());

var Qe = V({
    cast_: function(e, t) {
        let n = _(e, "x", "cast");
        if (!i0(t)) throw new Error(`Failed to cast to unknown dtype ${t}`);
        if (t === "string" && n.dtype !== "string" || t !== "string" && n.dtype === "string") throw new Error("Only strings can be casted to strings");
        let a = {
            x: n
        }, r = {
            dtype: t
        };
        return U.runKernel(Ss, a, r);
    }
}), wn = V({
    clone_: function(e) {
        let t = {
            x: _(e, "x", "clone", "string_or_numeric")
        };
        return U.runKernel(Js, t);
    }
});

function cf(e, t = !1) {}

R0(), function(e) {
    jl = e;
}({
    buffer: We,
    cast: Qe,
    clone: wn,
    print: cf
});

var _e = V({
    add_: function(e, t) {
        let n = _(e, "a", "add"), a = _(t, "b", "add");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Ar, r);
    }
}), Zp = V({
    floorDiv_: function(e, t) {
        let n = _(e, "a", "floorDiv"), a = _(t, "b", "floorDiv");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(qs, r);
    }
}), ze = V({
    div_: function(e, t) {
        let n = _(e, "a", "div"), a = _(t, "b", "div");
        if ([ n, a ] = It(n, a), n.dtype === "int32" && a.dtype === "int32") return Zp(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Ls, r, {});
    }
}), ne = V({
    mul_: function(e, t) {
        let n = _(e, "a", "mul"), a = _(t, "b", "mul");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(vi, r);
    }
}), Ln = V({
    abs_: function(e) {
        let t = _(e, "x", "abs");
        if (t.dtype === "complex64") {
            let n = {
                x: t
            };
            return U.runKernel(Xu, n);
        }
        {
            let n = {
                x: t
            };
            return U.runKernel(ol, n);
        }
    }
}), Y0 = V({
    acos_: function(e) {
        let t = {
            x: _(e, "x", "acos")
        };
        return U.runKernel(cs, t);
    }
}), J0 = V({
    acosh_: function(e) {
        let t = {
            x: _(e, "x", "acosh")
        };
        return U.runKernel(hs, t);
    }
}), hf = V({
    addN_: function(e) {
        D(Array.isArray(e), () => "The argument passed to tf.addN() must be a list of tensors"), 
        D(e.length >= 1, () => `Must pass at least one tensor to tf.addN(), but got ${e.length}`);
        let t = e.map((r, s) => _(r, `tensors${s}`, "addN")), n = t[0];
        t.forEach(r => {
            if (r.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype");
        }), t.forEach(r => {
            if (!qa(r.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape");
        });
        let a = t;
        return U.runKernel(fs, a);
    }
}), Q0 = V({
    all_: function(e, t = null, n = !1) {
        let a = {
            x: _(e, "x", "all", "bool")
        }, r = {
            axis: t,
            keepDims: n
        };
        return U.runKernel(ms, a, r);
    }
}), eg = V({
    any_: function(e, t = null, n = !1) {
        let a = {
            x: _(e, "x", "any", "bool")
        }, r = {
            axis: t,
            keepDims: n
        };
        return U.runKernel(gs, a, r);
    }
}), Zl = V({
    argMax_: function(e, t = 0) {
        let n = {
            x: _(e, "x", "argMax")
        }, a = {
            axis: t
        };
        return U.runKernel(ll, n, a);
    }
}), tg = V({
    argMin_: function(e, t = 0) {
        let n = {
            x: _(e, "x", "argMin")
        }, a = {
            axis: t
        };
        return U.runKernel(ul, n, a);
    }
}), ng = V({
    asin_: function(e) {
        let t = {
            x: _(e, "x", "asin")
        };
        return U.runKernel(ys, t);
    }
}), ag = V({
    asinh_: function(e) {
        let t = {
            x: _(e, "x", "asinh")
        };
        return U.runKernel(As, t);
    }
}), rg = V({
    atan_: function(e) {
        let t = {
            x: _(e, "x", "atan")
        };
        return U.runKernel(xs, t);
    }
}), sg = V({
    atan2_: function(e, t) {
        let n = _(e, "a", "atan2"), a = _(t, "b", "atan2");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(vs, r);
    }
}), ig = V({
    atanh_: function(e) {
        let t = {
            x: _(e, "x", "atanh")
        };
        return U.runKernel(bs, t);
    }
});

function iS(e, t, n, a, r = "NHWC", s) {
    return Cd(e, [ ...t, e[3] ], n, s, a, null, null, ug(r));
}

function og(e, t, n, a, r, s, i = "channelsLast") {
    let l, [ o, p ] = Td(t);
    if (i === "channelsLast") l = [ o, p, e[3], e[3] ]; else {
        if (i !== "channelsFirst") throw new Error(`Unknown dataFormat ${i}`);
        l = [ o, p, e[1], e[1] ];
    }
    return Cd(e, l, n, a, r, s, !1, i);
}

function oS(e, t, n, a, r, s, i = "NDHWC") {
    let l, o, [ p, u, c ] = mf(t);
    if (i === "NDHWC") o = "channelsLast", l = [ p, u, c, e[4], e[4] ]; else {
        if (i !== "NCDHW") throw new Error(`Unknown dataFormat ${i}`);
        o = "channelsFirst", l = [ p, u, c, e[1], e[1] ];
    }
    return lg(e, l, n, a, r, !1, o, s);
}

function Cd(e, t, n, a, r, s, i = !1, l = "channelsLast") {
    let [ o, p, u, c ] = [ -1, -1, -1, -1 ];
    if (l === "channelsLast") [ o, p, u, c ] = e; else {
        if (l !== "channelsFirst") throw new Error(`Unknown dataFormat ${l}`);
        [ o, c, p, u ] = e;
    }
    let d, [ h, f, , m ] = t, [ g, y ] = Td(n), [ A, x ] = Td(a), b = Yl(h, A), v = Yl(f, x), {
        padInfo: I,
        outHeight: N,
        outWidth: T
    } = function(w, E, $, M, F, P, L, O, B) {
        let G, W, z;
        if (typeof w == "number") {
            G = {
                top: w,
                bottom: w,
                left: w,
                right: w,
                type: w === 0 ? "VALID" : "NUMBER"
            };
            let X = function(q, Z, Y, te, re) {
                te == null && (te = ff(q, Z, Y));
                let pe = q[0], ge = q[1], Re = Rd((pe - Z + 2 * te) / Y + 1, re), ye = Rd((ge - Z + 2 * te) / Y + 1, re);
                return [ Re, ye ];
            }([ E, $ ], P, M, w, O);
            W = X[0], z = X[1];
        } else if (w === "same") {
            W = Math.ceil(E / M), z = Math.ceil($ / F);
            let X = Math.max(0, (W - 1) * M + P - E), q = Math.max(0, (z - 1) * F + L - $), Z = Math.floor(X / 2), Y = X - Z, te = Math.floor(q / 2);
            G = {
                top: Z,
                bottom: Y,
                left: te,
                right: q - te,
                type: "SAME"
            };
        } else if (w === "valid") G = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            type: "VALID"
        }, W = Math.ceil((E - P + 1) / M), z = Math.ceil(($ - L + 1) / F); else {
            if (typeof w != "object") throw Error(`Unknown padding parameter: ${w}`);
            {
                let X = B === "channelsLast" ? w[1][0] : w[2][0], q = B === "channelsLast" ? w[1][1] : w[2][1], Z = B === "channelsLast" ? w[2][0] : w[3][0], Y = B === "channelsLast" ? w[2][1] : w[3][1];
                G = {
                    top: X,
                    bottom: q,
                    left: Z,
                    right: Y,
                    type: X === 0 && q === 0 && Z === 0 && Y === 0 ? "VALID" : "EXPLICIT"
                }, W = Rd((E - P + X + q) / M + 1, O), z = Rd(($ - L + Z + Y) / F + 1, O);
            }
        }
        return {
            padInfo: G,
            outHeight: W,
            outWidth: z
        };
    }(r, p, u, g, y, b, v, s, l), R = i ? m * c : m;
    return l === "channelsFirst" ? d = [ o, R, N, T ] : l === "channelsLast" && (d = [ o, N, T, R ]), 
    {
        batchSize: o,
        dataFormat: l,
        inHeight: p,
        inWidth: u,
        inChannels: c,
        outHeight: N,
        outWidth: T,
        outChannels: R,
        padInfo: I,
        strideHeight: g,
        strideWidth: y,
        filterHeight: h,
        filterWidth: f,
        effectiveFilterHeight: b,
        effectiveFilterWidth: v,
        dilationHeight: A,
        dilationWidth: x,
        inShape: e,
        outShape: d,
        filterShape: t
    };
}

function lg(e, t, n, a, r, s = !1, i = "channelsLast", l) {
    let [ o, p, u, c, d ] = [ -1, -1, -1, -1, -1 ];
    if (i === "channelsLast") [ o, p, u, c, d ] = e; else {
        if (i !== "channelsFirst") throw new Error(`Unknown dataFormat ${i}`);
        [ o, d, p, u, c ] = e;
    }
    let h, [ f, m, g, , y ] = t, [ A, x, b ] = mf(n), [ v, I, N ] = mf(a), T = Yl(f, v), R = Yl(m, I), w = Yl(g, N), {
        padInfo: E,
        outDepth: $,
        outHeight: M,
        outWidth: F
    } = function(L, O, B, G, W, z, X, q, Z, Y, te) {
        let re, pe, ge, Re;
        if (L === "valid" && (L = 0), typeof L == "number") {
            re = {
                top: L,
                bottom: L,
                left: L,
                right: L,
                front: L,
                back: L,
                type: L === 0 ? "VALID" : "NUMBER"
            };
            let ye = function(Me, Ee, me, Oe, we, Be) {
                we == null && (we = ff(Me, Ee[0], Oe[0]));
                let nt = [ 0, 0, 0, me ];
                for (let Ve = 0; Ve < 3; Ve++) Me[Ve] + 2 * we >= Ee[Ve] && (nt[Ve] = Rd((Me[Ve] - Ee[Ve] + 2 * we) / Oe[Ve] + 1, Be));
                return nt;
            }([ O, B, G, 1 ], [ q, Z, Y ], 1, [ W, z, X ], L, te);
            pe = ye[0], ge = ye[1], Re = ye[2];
        } else {
            if (L !== "same") throw Error(`Unknown padding parameter: ${L}`);
            {
                pe = Math.ceil(O / W), ge = Math.ceil(B / z), Re = Math.ceil(G / X);
                let ye = (pe - 1) * W + q - O, Me = (ge - 1) * z + Z - B, Ee = (Re - 1) * X + Y - G, me = Math.floor(ye / 2), Oe = ye - me, we = Math.floor(Me / 2), Be = Me - we, nt = Math.floor(Ee / 2);
                re = {
                    top: we,
                    bottom: Be,
                    left: nt,
                    right: Ee - nt,
                    front: me,
                    back: Oe,
                    type: "SAME"
                };
            }
        }
        return {
            padInfo: re,
            outDepth: pe,
            outHeight: ge,
            outWidth: Re
        };
    }(r, p, u, c, A, x, b, T, R, w, l), P = s ? y * d : y;
    return i === "channelsFirst" ? h = [ o, P, $, M, F ] : i === "channelsLast" && (h = [ o, $, M, F, P ]), 
    {
        batchSize: o,
        dataFormat: i,
        inDepth: p,
        inHeight: u,
        inWidth: c,
        inChannels: d,
        outDepth: $,
        outHeight: M,
        outWidth: F,
        outChannels: P,
        padInfo: E,
        strideDepth: A,
        strideHeight: x,
        strideWidth: b,
        filterDepth: f,
        filterHeight: m,
        filterWidth: g,
        effectiveFilterDepth: T,
        effectiveFilterHeight: R,
        effectiveFilterWidth: w,
        dilationDepth: v,
        dilationHeight: I,
        dilationWidth: N,
        inShape: e,
        outShape: h,
        filterShape: t
    };
}

function ff(e, t, n, a = 1) {
    let r = Yl(t, a);
    return Math.floor((e[0] * (n - 1) - n + r) / 2);
}

function Td(e) {
    return typeof e == "number" ? [ e, e, e ] : e.length === 2 ? [ e[0], e[1], 1 ] : e;
}

function mf(e) {
    return typeof e == "number" ? [ e, e, e ] : e;
}

function Yl(e, t) {
    return t <= 1 ? e : e + (e - 1) * (t - 1);
}

function Rd(e, t) {
    if (!t) return Math.trunc(e);
    switch (t) {
      case "round":
        return Math.round(e);

      case "ceil":
        return Math.ceil(e);

      case "floor":
        return Math.floor(e);

      default:
        throw new Error(`Unknown roundingMode ${t}`);
    }
}

function Ed(e) {
    let [ t, n, a ] = Td(e);
    return t === 1 && n === 1 && a === 1;
}

function Ja(e, t) {
    return Ed(e) || Ed(t);
}

function fo(e) {
    return Td(e).every(t => t > 0);
}

function ug(e) {
    if (e === "NHWC") return "channelsLast";
    if (e === "NCHW") return "channelsFirst";
    throw new Error(`Unknown dataFormat ${e}`);
}

function ia(e, t, n) {
    if (n != null) {
        if (typeof t == "string") throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);
        if (typeof t == "number") D(rl(t), () => `Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`); else {
            if (typeof t != "object") throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);
            t.forEach(a => {
                a.forEach(r => {
                    D(rl(r), () => `Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`);
                });
            });
        }
    }
}

var Q = V({
    reshape_: function(e, t) {
        let n = {
            x: _(e, "x", "reshape", "string_or_numeric")
        }, a = {
            shape: t
        };
        return U.runKernel(Ml, n, a);
    }
}), gf = V({
    avgPool_: function(e, t, n, a, r) {
        let s = _(e, "x", "avgPool", "float32");
        D(Ja(n, 1), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);
        let i = s, l = !1;
        s.rank === 3 && (l = !0, i = Q(s, [ 1, s.shape[0], s.shape[1], s.shape[2] ])), 
        D(i.rank === 4, () => `Error in avgPool: x must be rank 4 but got rank ${i.rank}.`), 
        ia("avgPool", a, r);
        let o = {
            x: i
        }, p = {
            filterSize: t,
            strides: n,
            pad: a,
            dimRoundingMode: r
        }, u = U.runKernel(ws, o, p);
        return u = Qe(u, s.dtype), l ? Q(u, [ u.shape[1], u.shape[2], u.shape[3] ]) : u;
    }
}), dg = V({
    avgPool3d_: function(e, t, n, a, r, s = "NDHWC") {
        let i = _(e, "x", "avgPool3d", "float32"), l = i, o = !1;
        i.rank === 4 && (o = !0, l = Q(i, [ 1, i.shape[0], i.shape[1], i.shape[2], i.shape[3] ])), 
        D(l.rank === 5, () => `Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`), 
        D(s === "NDHWC", () => `Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`), 
        D(typeof n == "number" && n > 0 || Array.isArray(n) && n[0] > 0 && n[1] > 0 && n[2] > 0, () => `Error in avgPool3d: Stride must be > 0, but got '${n}'`), 
        ia("avgPool3d", a, r);
        let p = {
            x: l
        }, u = {
            filterSize: t,
            strides: n,
            pad: a,
            dimRoundingMode: r,
            dataFormat: s
        }, c = U.runKernel(dl, p, u);
        return c = Qe(c, l.dtype), o ? Q(c, [ c.shape[1], c.shape[2], c.shape[3], c.shape[4] ]) : c;
    }
}), yt = V({
    concat_: function(e, t = 0) {
        D(e.length >= 1, () => "Pass at least one tensor to concat");
        let n = Sd(e, "tensors", "concat", "string_or_numeric");
        if (n[0].dtype === "complex64" && n.forEach(s => {
            if (s.dtype !== "complex64") throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `);
        }), n.length === 1) return wn(n[0]);
        let a = n, r = {
            axis: t
        };
        return U.runKernel(fl, a, r);
    }
}), ut = V({
    matMul_: function(e, t, n = !1, a = !1) {
        let r = _(e, "a", "matMul"), s = _(t, "b", "matMul");
        [ r, s ] = It(r, s);
        let i = {
            a: r,
            b: s
        }, l = {
            transposeA: n,
            transposeB: a
        };
        return U.runKernel(ks, i, l);
    }
}), va = V({
    sigmoid_: function(e) {
        let t = {
            x: _(e, "x", "sigmoid", "float32")
        };
        return U.runKernel(Hi, t);
    }
}), He = V({
    slice_: function(e, t, n) {
        let a = _(e, "x", "slice", "string_or_numeric");
        if (a.rank === 0) throw new Error("Slicing scalar is not possible");
        let r = {
            x: a
        }, s = {
            begin: t,
            size: n
        };
        return U.runKernel(Pl, r, s);
    }
}), Yp = V({
    tanh_: function(e) {
        let t = {
            x: _(e, "x", "tanh", "float32")
        };
        return U.runKernel(to, t);
    }
}), pg = V({
    basicLSTMCell_: function(e, t, n, a, r, s) {
        let i = _(e, "forgetBias", "basicLSTMCell"), l = _(t, "lstmKernel", "basicLSTMCell"), o = _(n, "lstmBias", "basicLSTMCell"), p = _(a, "data", "basicLSTMCell"), u = _(r, "c", "basicLSTMCell"), c = _(s, "h", "basicLSTMCell"), d = yt([ p, c ], 1), h = ut(d, l), f = _e(h, o), m = f.shape[0], g = f.shape[1] / 4, y = [ m, g ], A = He(f, [ 0, 0 ], y), x = He(f, [ 0, g ], y), b = He(f, [ 0, 2 * g ], y), v = He(f, [ 0, 3 * g ], y), I = _e(ne(va(A), Yp(x)), ne(u, va(_e(i, b))));
        return [ I, ne(Yp(I), va(v)) ];
    }
}), yf = V({
    batchToSpaceND_: function(e, t, n) {
        let a = _(e, "x", "batchToSpaceND"), r = t.reduce((l, o) => l * o);
        D(a.rank >= 1 + t.length, () => `input rank is ${a.rank} but should be > than blockShape.length ${t.length}`), 
        D(n.length === t.length, () => `crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`), 
        D(a.shape[0] % r == 0, () => `input tensor batch is ${a.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);
        let s = {
            x: a
        }, i = {
            blockShape: t,
            crops: n
        };
        return U.runKernel(pl, s, i);
    }
});

function lS(e) {
    let t;
    return t = e.rank === 0 || e.rank === 1 ? Q(e, [ 1, 1, 1, e.size ]) : e.rank === 2 ? Q(e, [ 1, 1, e.shape[0], e.shape[1] ]) : e.rank === 3 ? Q(e, [ 1, e.shape[0], e.shape[1], e.shape[2] ]) : e, 
    t;
}

var $d = V({
    batchNorm_: function(e, t, n, a, r, s) {
        s == null && (s = .001);
        let i, l, o = _(e, "x", "batchNorm"), p = _(t, "mean", "batchNorm"), u = _(n, "variance", "batchNorm");
        r != null && (i = _(r, "scale", "batchNorm")), a != null && (l = _(a, "offset", "batchNorm")), 
        D(p.rank === u.rank, () => "Batch normalization gradient requires mean and variance to have equal ranks."), 
        D(l == null || p.rank === l.rank, () => "Batch normalization gradient requires mean and offset to have equal ranks."), 
        D(i == null || p.rank === i.rank, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
        let c = {
            x: lS(o),
            scale: i,
            offset: l,
            mean: p,
            variance: u
        }, d = {
            varianceEpsilon: s
        }, h = U.runKernel(Xs, c, d);
        return Q(h, o.shape);
    }
}), cg = V({
    batchNorm2d_: function(e, t, n, a, r, s) {
        let i, l, o = _(e, "x", "batchNorm"), p = _(t, "mean", "batchNorm"), u = _(n, "variance", "batchNorm");
        return r != null && (i = _(r, "scale", "batchNorm")), a != null && (l = _(a, "offset", "batchNorm")), 
        D(o.rank === 2, () => `Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`), 
        D(p.rank === 2 || p.rank === 1, () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${p.rank}.`), 
        D(u.rank === 2 || u.rank === 1, () => `Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`), 
        i != null && D(i.rank === 2 || i.rank === 1, () => `Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`), 
        l != null && D(l.rank === 2 || l.rank === 1, () => `Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`), 
        $d(o, p, u, l, i, s);
    }
}), hg = V({
    batchNorm3d_: function(e, t, n, a, r, s) {
        let i, l, o = _(e, "x", "batchNorm"), p = _(t, "mean", "batchNorm"), u = _(n, "variance", "batchNorm");
        return r != null && (i = _(r, "scale", "batchNorm")), a != null && (l = _(a, "offset", "batchNorm")), 
        D(o.rank === 3, () => `Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`), 
        D(p.rank === 3 || p.rank === 1, () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${p.rank}.`), 
        D(u.rank === 3 || u.rank === 1, () => `Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`), 
        i != null && D(i.rank === 3 || i.rank === 1, () => `Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`), 
        l != null && D(l.rank === 3 || l.rank === 1, () => `Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`), 
        $d(o, p, u, l, i, s);
    }
}), fg = V({
    batchNorm4d_: function(e, t, n, a, r, s) {
        let i, l, o = _(e, "x", "batchNorm"), p = _(t, "mean", "batchNorm"), u = _(n, "variance", "batchNorm");
        return r != null && (i = _(r, "scale", "batchNorm")), a != null && (l = _(a, "offset", "batchNorm")), 
        D(o.rank === 4, () => `Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`), 
        D(p.rank === 4 || p.rank === 1, () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${p.rank}.`), 
        D(u.rank === 4 || u.rank === 1, () => `Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`), 
        i != null && D(i.rank === 4 || i.rank === 1, () => `Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`), 
        l != null && D(l.rank === 4 || l.rank === 1, () => `Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`), 
        $d(o, p, u, l, i, s);
    }
}), Af = V({
    bincount_: function(e, t, n) {
        let a = _(e, "x", "bincount"), r = _(t, "weights", "bincount");
        D(a.dtype === "int32", () => `Error in bincount: input dtype must be int32, but got ${a.dtype}`), 
        D(n >= 0, () => `size must be non-negative, but got ${n}.`), D(r.size === a.size || r.size === 0, () => `Error in bincount: weights must have the same size as input or0-length, but got input shape: ${a.shape}, weights shape: ${r.shape}.`);
        let s = {
            x: a,
            weights: r
        }, i = {
            size: n
        };
        return U.runKernel(Is, s, i);
    }
}), mg = V({
    bitwiseAnd_: function(e, t) {
        let n = _(e, "x", "bitwiseAnd"), a = _(t, "y", "bitwiseAnd");
        if (!qa(n.shape, a.shape)) throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${a.shape}`);
        if (n.dtype !== "int32" || a.dtype !== "int32") throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${a.dtype}`);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(cl, r);
    }
}), gg = V({
    broadcastArgs_: function(e, t) {
        let n = _(e, "s0", "broadcastArgs", "int32"), a = _(t, "s1", "broadcastArgs", "int32");
        if (n.rank !== 1) throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);
        if (a.rank !== 1) throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${a.rank}`);
        let r = {
            s0: n,
            s1: a
        };
        return U.runKernel(hl, r);
    }
}), Jl = V({
    broadcastTo_: function(e, t) {
        let n = _(e, "broadcastTo", "x"), a = n.shape;
        if (zn(t), t.length < n.rank) throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);
        if (t.length > n.rank) {
            let o = n.shape.slice();
            for (;o.length < t.length; ) o.unshift(1);
            n = Q(n, o);
        }
        let r = n.shape, s = Array.from(t);
        for (let o = t.length - 1; o >= 0; o--) if (r[o] === t[o]) s[o] = 1; else if (n.shape[o] !== 1) throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${t}].`);
        if (s.map((o, p) => o > 1 ? p : -1).filter(o => o >= 0).length === 0) return wn(n);
        let i = {
            x: n
        }, l = {
            reps: s
        };
        return U.runKernel(br, i, l);
    }
}), yg = V({
    ceil_: function(e) {
        let t = {
            x: _(e, "x", "ceil", "float32")
        };
        return U.runKernel(Ns, t);
    }
});

function Qa(e, t, n) {
    zn(e);
    let a = {
        shape: e,
        value: t,
        dtype: n = n || Gu(t)
    };
    return U.runKernel(wl, {}, a);
}

var Ag = V({
    clipByValue_: function(e, t, n) {
        let a = _(e, "x", "clipByValue");
        if (D(t <= n, () => `Error in clip: min (${t}) must be less than or equal to max (${n}).`), 
        t === n) return Qa(a.shape, t, a.dtype);
        let r = {
            x: a
        }, s = {
            clipValueMin: t,
            clipValueMax: n
        };
        return U.runKernel(xr, r, s);
    }
}), xg = V({
    concat1d_: function(e) {
        return yt(e, 0);
    }
}), Jp = V({
    concat2d_: function(e, t) {
        return yt(e, t);
    }
}), bg = V({
    concat3d_: function(e, t) {
        return yt(e, t);
    }
}), vg = V({
    concat4d_: function(e, t) {
        return yt(e, t);
    }
}), Md = V({
    conv2d_: function(e, t, n, a, r = "NHWC", s = [ 1, 1 ], i) {
        let l = _(e, "x", "conv2d", "float32"), o = _(t, "filter", "conv2d", "float32"), p = l, u = !1;
        l.rank === 3 && (u = !0, p = Q(l, [ 1, l.shape[0], l.shape[1], l.shape[2] ])), 
        D(p.rank === 4, () => `Error in conv2d: input must be rank 4, but got rank ${p.rank}.`), 
        D(o.rank === 4, () => `Error in conv2d: filter must be rank 4, but got rank ${o.rank}.`), 
        ia("conv2d", a, i);
        let c = r === "NHWC" ? p.shape[3] : p.shape[1];
        D(c === o.shape[2], () => `Error in conv2d: depth of input (${c}) must match input depth for filter ${o.shape[2]}.`), 
        D(Ja(n, s), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`), 
        D(fo(s), () => "Error in conv2D: Dilated rates should be larger than 0."), 
        D(fo(n), () => "Error in conv2D: Strides should be larger than 0.");
        let d = {
            x: p,
            filter: o
        }, h = {
            strides: n,
            pad: a,
            dataFormat: r,
            dilations: s,
            dimRoundingMode: i
        }, f = U.runKernel(Cs, d, h);
        return u ? Q(f, [ f.shape[1], f.shape[2], f.shape[3] ]) : f;
    }
}), wg = V({
    conv1d_: function(e, t, n, a, r = "NWC", s = 1, i) {
        let l = _(e, "x", "conv1d"), o = _(t, "filter", "conv1d"), p = l, u = !1;
        l.rank === 2 && (u = !0, p = Q(l, [ 1, l.shape[0], l.shape[1] ])), D(p.rank === 3, () => `Error in conv1d: input must be rank 3, but got rank ${p.rank}.`), 
        D(o.rank === 3, () => `Error in conv1d: filter must be rank 3, but got rank ${o.rank}.`), 
        ia("conv1d", a, i), D(p.shape[2] === o.shape[1], () => `Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${o.shape[1]}.`), 
        D(Ja(n, s), () => `Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`), 
        D(fo(s), () => "Error in conv1D: Dilated rates should be larger than 0."), 
        D(fo(n), () => "Error in conv1D: Stride should be larger than 0."), D(r === "NWC", () => `Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);
        let c = Q(o, [ 1, o.shape[0], o.shape[1], o.shape[2] ]), d = Q(p, [ p.shape[0], 1, p.shape[1], p.shape[2] ]), h = Md(d, c, [ 1, n ], a, "NHWC", [ 1, s ], i);
        return Q(h, u ? [ h.shape[2], h.shape[3] ] : [ h.shape[0], h.shape[2], h.shape[3] ]);
    }
}), kg = V({
    conv2DBackpropInput_: function(e, t, n, a, r, s = "NHWC", i) {
        D(e.length === t.rank, () => `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);
        let l = e, o = t, p = !1;
        t.rank === 3 && (p = !0, o = Q(t, [ 1, t.shape[0], t.shape[1], t.shape[2] ]), 
        l = [ 1, e[0], e[1], e[2] ]), D(l.length === 4, () => `Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`), 
        D(o.rank === 4, () => `Error in conv2dDerInput: dy must be rank 4, but got rank ${o.rank}`), 
        D(n.rank === 4, () => `Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);
        let u = s === "NHWC" ? l[3] : l[1], c = s === "NHWC" ? o.shape[3] : o.shape[1];
        D(u === n.shape[2], () => `Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`), 
        D(c === n.shape[3], () => `Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`), 
        ia("conv2dDerInput", r, i);
        let d = {
            dy: o,
            filter: n
        }, h = {
            strides: a,
            pad: r,
            dataFormat: s,
            dimRoundingMode: i,
            inputShape: l
        }, f = U.runKernel(Ts, d, h);
        return p ? Q(f, [ f.shape[1], f.shape[2], f.shape[3] ]) : f;
    }
}), Ig = V({
    conv2dTranspose_: function(e, t, n, a, r, s) {
        let i = _(e, "x", "conv2dTranspose"), l = _(t, "filter", "conv2dTranspose");
        return kg(n, i, l, a, r, "NHWC", s);
    }
}), Sg = V({
    conv3d_: function(e, t, n, a, r = "NDHWC", s = [ 1, 1, 1 ]) {
        let i = _(e, "x", "conv3d"), l = _(t, "filter", "conv3d"), o = i, p = !1;
        i.rank === 4 && (p = !0, o = Q(i, [ 1, i.shape[0], i.shape[1], i.shape[2], i.shape[3] ])), 
        D(o.rank === 5, () => `Error in conv3d: input must be rank 5, but got rank ${o.rank}.`), 
        D(l.rank === 5, () => `Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`), 
        D(o.shape[4] === l.shape[3], () => `Error in conv3d: depth of input (${o.shape[4]}) must match input depth for filter ${l.shape[3]}.`), 
        D(Ja(n, s), () => `Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`), 
        D(r === "NDHWC", () => `Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`), 
        D(fo(s), () => "Error in conv3D: Dilated rates should be larger than 0."), 
        D(fo(n), () => "Error in conv3D: Strides should be larger than 0.");
        let u = {
            x: o,
            filter: l
        }, c = {
            strides: n,
            pad: a,
            dataFormat: r,
            dilations: s
        }, d = U.runKernel(Rs, u, c);
        return p ? Q(d, [ d.shape[1], d.shape[2], d.shape[3], d.shape[4] ]) : d;
    }
}), uS = V({
    conv3DBackpropInput_: function(e, t, n, a, r) {
        D(e.length === t.rank, () => `Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);
        let s = e, i = t, l = !1;
        t.rank === 4 && (l = !0, i = Q(t, [ 1, t.shape[0], t.shape[1], t.shape[2], t.shape[3] ]), 
        s = [ 1, e[0], e[1], e[2], e[3] ]);
        let o = s[4], p = i.shape[4];
        D(s.length === 5, () => `Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`), 
        D(i.rank === 5, () => `Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`), 
        D(n.rank === 5, () => `Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`), 
        D(o === n.shape[3], () => `Error in conv3dDerInput: depth of input (${o}) must match input depth for filter ${n.shape[3]}.`), 
        D(p === n.shape[4], () => `Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[4]}.`);
        let u = {
            dy: i,
            filter: n
        }, c = {
            pad: r,
            strides: a,
            inputShape: s
        }, d = U.runKernel(Es, u, c);
        return l ? Q(d, [ d.shape[1], d.shape[2], d.shape[3], d.shape[4] ]) : d;
    }
}), Ng = V({
    conv3dTranspose_: function(e, t, n, a, r) {
        let s = _(e, "x", "conv3dTranspose"), i = _(t, "filter", "conv3dTranspose");
        return uS(n, s, i, a, r);
    }
}), Cg = V({
    cos_: function(e) {
        let t = {
            x: _(e, "x", "cos", "float32")
        };
        return U.runKernel($s, t);
    }
}), Tg = V({
    cosh_: function(e) {
        let t = {
            x: _(e, "x", "cosh", "float32")
        };
        return U.runKernel(Ms, t);
    }
}), Rg = V({
    cumprod_: function(e, t = 0, n = !1, a = !1) {
        let r = {
            x: _(e, "x", "cumprod")
        }, s = {
            axis: t,
            exclusive: n,
            reverse: a
        };
        return U.runKernel(Fs, r, s);
    }
}), Eg = V({
    cumsum_: function(e, t = 0, n = !1, a = !1) {
        let r = {
            x: _(e, "x", "cumsum")
        }, s = {
            axis: t,
            exclusive: n,
            reverse: a
        };
        return U.runKernel(_s, r, s);
    }
}), $g = V({
    denseBincount_: function(e, t, n, a = !1) {
        let r = _(e, "x", "denseBincount"), s = _(t, "weights", "denseBincount");
        D(r.dtype === "int32", () => `Error in denseBincount: input dtype must be int32, but got ${r.dtype}`), 
        D(r.rank <= 2, () => `Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`), 
        D(n >= 0, () => `size must be non-negative, but got ${n}.`), D(s.size === r.size || s.size === 0, () => `Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);
        let i = {
            x: r,
            weights: s
        }, l = {
            size: n,
            binaryOutput: a
        };
        return U.runKernel(gl, i, l);
    }
}), Mg = V({
    depthToSpace_: function(e, t, n = "NHWC") {
        let a = _(e, "x", "depthToSpace", "float32"), r = n === "NHWC" ? a.shape[1] : a.shape[2], s = n === "NHWC" ? a.shape[2] : a.shape[3], i = n === "NHWC" ? a.shape[3] : a.shape[1];
        D(t > 1, () => `blockSize should be > 1 for depthToSpace, but was: ${t}`), 
        D(r * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${a.shape}`), D(s * t >= 0, () => `Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${a.shape}`), D(i % (t * t) == 0, () => `Dimension size must be evenly divisible by ${t * t} but is ${i} for depthToSpace with input shape ${a.shape}`);
        let l = {
            x: a
        }, o = {
            blockSize: t,
            dataFormat: n
        };
        return U.runKernel(Ps, l, o);
    }
}), Qp = V({
    depthwiseConv2d_: function(e, t, n, a, r = "NHWC", s = [ 1, 1 ], i) {
        let l = _(e, "x", "depthwiseConv2d", "float32"), o = _(t, "filter", "depthwiseConv2d", "float32"), p = l, u = !1;
        l.rank === 3 && (u = !0, p = Q(l, [ 1, l.shape[0], l.shape[1], l.shape[2] ])), 
        D(p.rank === 4, () => `Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`), 
        D(o.rank === 4, () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ${o.rank}.`);
        let c = r === "NHWC" ? p.shape[3] : p.shape[1];
        D(c === o.shape[2], () => `Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${o.shape[2]}.`), 
        ia("depthwiseConv2d", a, i);
        let d = {
            x: p,
            filter: o
        }, h = {
            strides: n,
            pad: a,
            dataFormat: r,
            dilations: s,
            dimRoundingMode: i
        }, f = U.runKernel(Ds, d, h);
        return u ? Q(f, [ f.shape[1], f.shape[2], f.shape[3] ]) : f;
    }
}), Fg = V({
    diag_: function(e) {
        let t = {
            x: _(e, "x", "diag")
        };
        return U.runKernel(yl, t);
    }
}), _g = V({
    dilation2d_: function(e, t, n, a, r = [ 1, 1 ], s = "NHWC") {
        let i = _(e, "x", "dilation2d"), l = _(t, "filter", "dilation2d");
        D(i.rank === 3 || i.rank === 4, () => `Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`), 
        D(l.rank === 3, () => `Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`), 
        D(s === "NHWC", () => `Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);
        let o = i, p = !1;
        i.rank === 3 && (o = Q(i, [ 1, i.shape[0], i.shape[1], i.shape[2] ]), p = !0), 
        D(o.shape[3] === l.shape[2], () => `Error in dilation2d:  input and filter must have the same depth: ${o.shape[3]} vs ${l.shape[2]}`);
        let u = {
            x: o,
            filter: l
        }, c = {
            strides: n,
            pad: a,
            dilations: r
        }, d = U.runKernel(zs, u, c);
        return p ? Q(d, [ d.shape[1], d.shape[2], d.shape[3] ]) : d;
    }
}), mo = {};

function Og(e, t) {
    let n = e.length, a = [];
    for (let r = 0; r < n; r++) {
        let s = n - 1 - r, i = e[s] || 1;
        (t[t.length - 1 - r] || 1) > 1 && i === 1 && a.unshift(s);
    }
    return a;
}

function xf(e, t) {
    let n = [];
    for (let a = 0; a < t.length; a++) {
        let r = e[e.length - a - 1], s = t.length - a - 1, i = t[s];
        (r == null || r === 1 && i > 1) && n.unshift(s);
    }
    return n;
}

function Ft(e, t) {
    let n = Math.max(e.length, t.length), a = new Array(n);
    for (let r = 0; r < n; r++) {
        let s = e[e.length - r - 1];
        s == null && (s = 1);
        let i = t[t.length - r - 1];
        if (i == null && (i = 1), s === 1) a[n - r - 1] = i; else if (i === 1) a[n - r - 1] = s; else {
            if (s !== i) throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);
            a[n - r - 1] = s;
        }
    }
    return a;
}

Ze(mo, {
    assertAndGetBroadcastShape: () => Ft,
    getBroadcastDims: () => Og,
    getReductionAxes: () => xf
});

var bf = V({
    equal_: function(e, t) {
        let n = _(e, "a", "equal", "string_or_numeric"), a = _(t, "b", "equal", "string_or_numeric");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Vs, r);
    }
}), er = V({
    where_: function(e, t, n) {
        let a = _(t, "a", "where"), r = _(n, "b", "where"), s = _(e, "condition", "where", "bool"), i = Ft(Ft(s.shape, a.shape), r.shape), l = {
            condition: Jl(s, i),
            t: Jl(a, i),
            e: Jl(r, i)
        };
        return U.runKernel(Ol, l);
    }
}), Wn = V({
    zerosLike_: function(e) {
        let t = {
            x: _(e, "x", "zerosLike")
        };
        return U.runKernel(Gl, t);
    }
}), Pg = V({
    divNoNan_: function(e, t) {
        let n = _(e, "a", "div"), a = _(t, "b", "div");
        [ n, a ] = It(n, a);
        let r = ze(n, a), s = Wn(r), i = bf(a, s);
        return er(i, s, r);
    }
}), Dg = V({
    dot_: function(e, t) {
        let n = _(e, "t1", "dot"), a = _(t, "t2", "dot");
        D(!(n.rank !== 1 && n.rank !== 2 || a.rank !== 1 && a.rank !== 2), () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${a.rank}.`);
        let r = n.rank === 1 ? n.size : n.shape[1], s = a.rank === 1 ? a.size : a.shape[0];
        if (D(r === s, () => `Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`), 
        n.rank === 1 && a.rank === 1) {
            let i = Q(n, [ 1, -1 ]), l = Q(a, [ -1, 1 ]), o = ut(i, l);
            return Q(o, []);
        }
        if (n.rank === 1 && a.rank === 2) {
            let i = Q(n, [ 1, -1 ]), l = Q(a, [ a.shape[0], a.shape[1] ]), o = ut(i, l);
            return Q(o, [ o.size ]);
        }
        if (n.rank === 2 && a.rank === 1) {
            let i = Q(a, [ -1, 1 ]), l = ut(n, i);
            return Q(l, [ l.size ]);
        }
        {
            let i = Q(a, [ a.shape[0], a.shape[1] ]);
            return ut(n, i);
        }
    }
}), go = V({
    einsum_: function(e, ...t) {
        let n = t.map((r, s) => _(r, `tensors${s}`, "einsum")), a = {
            equation: e
        };
        return U.runKernel(Qu, n, a);
    }
}), vf = V({
    elu_: function(e) {
        let t = {
            x: _(e, "x", "elu", "float32")
        };
        return U.runKernel(Ws, t);
    }
}), zg = V({
    ensureShape_: function(e, t) {
        let n = _(e, "x", "ensureShape", "string_or_numeric");
        if (!n0(n.shape, t)) throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);
        return e;
    }
}), Lg = V({
    erf_: function(e) {
        let t = _(e, "x", "erf");
        D(t.dtype === "int32" || t.dtype === "float32", () => "Input dtype must be `int32` or `float32`."), 
        t.dtype === "int32" && (t = Qe(t, "float32"));
        let n = {
            x: t
        };
        return U.runKernel(Bs, n);
    }
});

function wf(e, t) {
    for (let n = 0; n < e.length; ++n) if (e[e.length - n - 1] !== t - 1 - n) return !1;
    return !0;
}

function Wg(e, t, n) {
    let a = e.length + t.length, r = [], s = 0, i = 0;
    for (let l = 0; l < a; l++) n.indexOf(l) === -1 ? r.push(e[s++]) : r.push(t[i++]);
    return r;
}

function dS(e, t) {
    let n = [], a = e.length;
    for (let r = 0; r < a; r++) t.indexOf(r) === -1 && n.push(e[r]);
    return [ n, t.map(r => e[r]) ];
}

function Fd(e, t) {
    return Wg(e, t.map(n => 1), t);
}

function pS(e, t, n) {
    D(wf(t, n), () => `${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`);
}

function cS(e, t) {
    if (wf(e, t)) return null;
    let n = [];
    for (let a = 0; a < t; ++a) e.indexOf(a) === -1 && n.push(a);
    return e.forEach(a => n.push(a)), n;
}

function hS(e) {
    return e.map((t, n) => [ n, t ]).sort((t, n) => t[1] - n[1]).map(t => t[0]);
}

function fS(e, t) {
    let n = [];
    for (let a = t - e; a < t; ++a) n.push(a);
    return n;
}

var Jn = V({
    max_: function(e, t = null, n = !1) {
        let a = {
            x: _(e, "x", "max")
        }, r = {
            reductionIndices: t,
            keepDims: n
        };
        return U.runKernel(ci, a, r);
    }
}), yo = V({
    min_: function(e, t = null, n = !1) {
        let a = {
            x: _(e, "x", "min")
        }, r = {
            axis: t,
            keepDims: n
        };
        return U.runKernel(gi, a, r);
    }
}), Ql = V({
    pow_: function(e, t) {
        let n = _(e, "base", "pow"), a = _(t, "exp", "pow");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Ci, r);
    }
});

function je(e, t) {
    if ((Gt(e) && t !== "string" || Array.isArray(e)) && t !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
    if (t === "string" && Gt(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
    return Tr(e, [], [], t);
}

var Pa = V({
    sqrt_: function(e) {
        let t = {
            x: _(e, "x", "sqrt", "float32")
        };
        return U.runKernel(qi, t);
    }
}), oa = V({
    square_: function(e) {
        let t = _(e, "x", "square");
        return U.runKernel("Square", {
            x: t
        }, {});
    }
}), dt = V({
    sum_: function(e, t = null, n = !1) {
        let a = _(e, "x", "sum");
        a.dtype === "bool" && (a = Qe(a, "int32"));
        let r = {
            x: a
        }, s = {
            axis: t,
            keepDims: n
        };
        return U.runKernel(Xi, r, s);
    }
});

function Bg(e, t, n = null) {
    if (e.rank === 0) return Ln(e);
    if (e.rank !== 1 && n === null) return Bg(Q(e, [ -1 ]), t, n);
    if (e.rank === 1 || typeof n == "number" || Array.isArray(n) && n.length === 1) {
        if (t === 1) return dt(Ln(e), n);
        if (t === 1 / 0) return Jn(Ln(e), n);
        if (t === -1 / 0) return yo(Ln(e), n);
        if (t === "euclidean" || t === 2) return Pa(dt(Ql(Ln(e), je(2, "int32")), n));
        throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    if (Array.isArray(n) && n.length === 2) {
        if (t === 1) return Jn(dt(Ln(e), n[0]), n[1] - 1);
        if (t === 1 / 0) return Jn(dt(Ln(e), n[1]), n[0]);
        if (t === -1 / 0) return yo(dt(Ln(e), n[1]), n[0]);
        if (t === "fro" || t === "euclidean") return Pa(dt(oa(e), n));
        throw new Error(`Error in norm: invalid ord value: ${t}`);
    }
    throw new Error(`Error in norm: invalid axis: ${n}`);
}

var _d = V({
    norm_: function(e, t = "euclidean", n = null, a = !1) {
        let r = Bg(e = _(e, "x", "norm"), t, n), s = r.shape;
        if (a) {
            let i = Uu(n, e.shape);
            s = Fd(r.shape, i);
        }
        return Q(r, s);
    }
}), Vg = V({
    euclideanNorm_: function(e, t = null, n = !1) {
        return _d(e, "euclidean", t, n);
    }
}), Fr = V({
    exp_: function(e) {
        let t = {
            x: _(e, "x", "exp")
        };
        return U.runKernel(Us, t);
    }
}), pn = V({
    expandDims_: function(e, t = 0) {
        let n = _(e, "x", "expandDims", "string_or_numeric");
        D(t <= n.rank, () => "Axis must be <= rank of the tensor");
        let a = {
            input: n
        }, r = {
            dim: t
        };
        return U.runKernel(vl, a, r);
    }
}), Ug = V({
    expm1_: function(e) {
        let t = {
            x: _(e, "x", "expm1")
        };
        return U.runKernel(Gs, t);
    }
}), Ao = V({
    tile_: function(e, t) {
        let n = _(e, "x", "tile", "string_or_numeric");
        D(n.rank === t.length, () => `Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);
        let a = {
            x: n
        }, r = {
            reps: t
        };
        return U.runKernel(br, a, r);
    }
}), kf = V({
    eye_: function(e, t, n, a = "float32") {
        t == null && (t = e);
        let r = We([ e, t ], a), s = e <= t ? e : t;
        for (let l = 0; l < s; ++l) r.set(1, l, l);
        let i = Q(r.toTensor(), [ e, t ]);
        if (n == null) return i;
        if (n.length === 1) return Ao(pn(i, 0), [ n[0], 1, 1 ]);
        if (n.length === 2) return Ao(pn(pn(i, 0), 0), [ n[0], n[1], 1, 1 ]);
        if (n.length === 3) return Ao(pn(pn(pn(i, 0), 0), 0), [ n[0], n[1], n[2], 1, 1 ]);
        throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`);
    }
}), If = V({
    floor_: function(e) {
        let t = {
            x: _(e, "x", "floor", "float32")
        };
        return U.runKernel(js, t);
    }
}), Sf = V({
    gather_: function(e, t, n = 0, a = 0) {
        let r = {
            x: _(e, "x", "gather"),
            indices: _(t, "indices", "gather", "int32")
        }, s = {
            axis: n,
            batchDims: a
        };
        return U.runKernel(kl, r, s);
    }
}), Od = V({
    greater_: function(e, t) {
        let n = _(e, "a", "greater", "string_or_numeric"), a = _(t, "b", "greater", "string_or_numeric");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Zs, r);
    }
}), Nf = V({
    greaterEqual_: function(e, t) {
        let n = _(e, "a", "greaterEqual", "string_or_numeric"), a = _(t, "b", "greaterEqual", "string_or_numeric");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Ys, r);
    }
}), Pd = V({
    imag_: function(e) {
        let t = {
            input: _(e, "input", "imag")
        };
        return U.runKernel(nd, t);
    }
}), Gg = V({
    isFinite_: function(e) {
        let t = {
            x: _(e, "x", "isFinite")
        };
        return U.runKernel(Qs, t);
    }
}), Hg = V({
    isInf_: function(e) {
        let t = {
            x: _(e, "x", "isInf")
        };
        return U.runKernel(ei, t);
    }
}), jg = V({
    isNaN_: function(e) {
        let t = {
            x: _(e, "x", "isNaN")
        };
        return U.runKernel(ti, t);
    }
}), Cf = V({
    leakyRelu_: function(e, t = .2) {
        let n = {
            x: _(e, "x", "leakyRelu")
        }, a = {
            alpha: t
        };
        return U.runKernel(ni, n, a);
    }
}), ec = V({
    less_: function(e, t) {
        let n = _(e, "a", "less", "string_or_numeric"), a = _(t, "b", "less", "string_or_numeric");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(ai, r);
    }
}), tc = V({
    lessEqual_: function(e, t) {
        let n = _(e, "a", "lessEqual", "string_or_numeric"), a = _(t, "b", "lessEqual", "string_or_numeric");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(ri, r);
    }
});

function qg(e, t, n) {
    if (n <= 0) throw new Error("The number of values should be positive.");
    let a = {
        start: e,
        stop: t,
        num: n
    };
    return U.runKernel(si, {}, a);
}

var Xg = V({
    localResponseNormalization_: function(e, t = 5, n = 1, a = 1, r = .5) {
        let s = _(e, "x", "localResponseNormalization");
        D(s.rank === 4 || s.rank === 3, () => `Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`), D(rl(t), () => `Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);
        let i = s, l = !1;
        s.rank === 3 && (l = !0, i = Q(s, [ 1, s.shape[0], s.shape[1], s.shape[2] ]));
        let o = {
            x: i
        }, p = {
            depthRadius: t,
            bias: n,
            alpha: a,
            beta: r
        }, u = U.runKernel(pi, o, p);
        return l ? Q(u, [ u.shape[1], u.shape[2], u.shape[3] ]) : u;
    }
}), eu = V({
    log_: function(e) {
        let t = {
            x: _(e, "x", "log", "float32")
        };
        return U.runKernel(ii, t);
    }
}), Tf = V({
    log1p_: function(e) {
        let t = {
            x: _(e, "x", "log1p")
        };
        return U.runKernel(oi, t);
    }
});

function mS(e) {
    return D(yr(e), () => "The f passed in grad(f) must be a function"), (t, n) => {
        let a = _(t, "x", "tf.grad", "string_or_numeric"), r = n != null ? _(n, "dy", "tf.grad") : null;
        return U.tidy(() => {
            let {
                value: s,
                grads: i
            } = U.gradients(() => e(a), [ a ], r);
            return r != null && ln(s.shape, r.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), 
            nc(i), i[0];
        });
    };
}

function gS(e) {
    return D(yr(e), () => "The f passed in grads(f) must be a function"), (t, n) => {
        D(Array.isArray(t), () => "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");
        let a = Sd(t, "args", "tf.grads", "string_or_numeric"), r = n != null ? _(n, "dy", "tf.grads") : null;
        return U.tidy(() => {
            let {
                value: s,
                grads: i
            } = U.gradients(() => e(...a), a, r);
            return r != null && ln(s.shape, r.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), 
            nc(i), i;
        });
    };
}

function yS(e) {
    return D(yr(e), () => "The f passed in valueAndGrad(f) must be a function"), 
    (t, n) => {
        D(t instanceof vt, () => "The x passed in valueAndGrad(f)(x) must be a tensor"), 
        D(n == null || n instanceof vt, () => "The dy passed in valueAndGrad(f)(x, dy) must be a tensor");
        let {
            grads: a,
            value: r
        } = U.gradients(() => e(t), [ t ], n);
        return nc(a), {
            grad: a[0],
            value: r
        };
    };
}

function AS(e) {
    return D(yr(e), () => "The f passed in valueAndGrads(f) must be a function"), 
    (t, n) => {
        D(Array.isArray(t) && t.every(r => r instanceof vt), () => "The args passed in valueAndGrads(f)(args) must be array of tensors"), 
        D(n == null || n instanceof vt, () => "The dy passed in valueAndGrads(f)(args, dy) must be a tensor");
        let a = U.gradients(() => e(...t), t, n);
        return n != null && ln(a.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), 
        nc(a.grads), a;
    };
}

function Kg(e, t) {
    D(yr(e), () => "The f passed in variableGrads(f) must be a function"), D(t == null || Array.isArray(t) && t.every(o => o instanceof wd), () => "The varList passed in variableGrads(f, varList) must be an array of variables");
    let n = t != null;
    if (!n) {
        t = [];
        for (let o in U.registeredVariables) t.push(U.registeredVariables[o]);
    }
    let a = n ? t.filter(o => !o.trainable) : null, r = t.length;
    D((t = t.filter(o => o.trainable)).length > 0, () => `variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);
    let {
        value: s,
        grads: i
    } = U.gradients(e, t, null, !0);
    D(i.some(o => o != null), () => "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."), 
    D(s.rank === 0, () => `The f passed in variableGrads(f) must return a scalar, but it returned a rank-${s.rank} tensor`);
    let l = {};
    return t.forEach((o, p) => {
        i[p] != null && (l[o.name] = i[p]);
    }), a != null && a.forEach(o => l[o.name] = null), {
        value: s,
        grads: l
    };
}

function Da(e) {
    return U.customGrad(e);
}

function nc(e) {
    if (e.filter(t => t == null).length > 0) throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`);
}

var wa = V({
    neg_: function(e) {
        let t = {
            x: _(e, "x", "neg")
        };
        return U.runKernel(Cl, t);
    }
}), Rf = V({
    softplus_: function(e) {
        let t = {
            x: _(e, "x", "softplus")
        };
        return U.runKernel(ji, t);
    }
}), Zg = V({
    logSigmoid_: function(e) {
        let t = _(e, "x", "logSigmoid");
        return Da(n => ({
            value: wa(Rf(wa(n))),
            gradFunc: a => ne(a, va(wa(n)))
        }))(t);
    }
}), $e = V({
    sub_: function(e, t) {
        let n = _(e, "a", "sub"), a = _(t, "b", "sub");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Qi, r);
    }
}), Yg = V({
    logSoftmax_: function(e, t = -1) {
        let n = _(e, "logits", "logSoftmax");
        if (t === -1 && (t = n.rank - 1), t !== n.rank - 1) throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);
        return Da((a, r) => {
            let s = Jn(a, t, !0), i = $e(a, s), l = $e(Qe(i, "float32"), eu(dt(Fr(i), t, !0)));
            return r([ l ]), {
                value: l,
                gradFunc: (o, p) => {
                    let [ u ] = p, c = Fr(u);
                    return $e(o, ne(dt(o, t, !0), c));
                }
            };
        })(n);
    }
}), Ef = V({
    logSumExp_: function(e, t = null, n = !1) {
        let a = _(e, "x", "logSumExp"), r = Uu(t, a.shape), s = Jn(a, r, !0), i = $e(a, s), l = Fr(i), o = dt(l, r), p = eu(o), u = _e(Q(s, p.shape), p);
        if (n) {
            let c = Fd(u.shape, r);
            return Q(u, c);
        }
        return u;
    }
}), Dd = V({
    logicalAnd_: function(e, t) {
        let n = _(e, "a", "logicalAnd", "bool"), a = _(t, "b", "logicalAnd", "bool");
        Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(li, r);
    }
}), $f = V({
    logicalNot_: function(e) {
        let t = {
            x: _(e, "x", "logicalNot", "bool")
        };
        return U.runKernel(ui, t);
    }
}), Mf = V({
    logicalOr_: function(e, t) {
        let n = _(e, "a", "logicalOr", "bool"), a = _(t, "b", "logicalOr", "bool");
        Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(di, r);
    }
}), Jg = V({
    logicalXor_: function(e, t) {
        let n = _(e, "a", "logicalXor", "bool"), a = _(t, "b", "logicalXor", "bool");
        return Ft(n.shape, a.shape), Dd(Mf(e, t), $f(Dd(e, t)));
    }
}), ac = 2147483648, rc = V({
    searchSorted_: function(e, t, n = "left") {
        let a = _(e, "sortedSequence", "searchSorted"), r = _(t, "values", "searchSorted"), s = a.shape[a.shape.length - 1], i = r.shape[r.shape.length - 1], l = Q(a, [ -1, s ]), o = Q(r, [ -1, i ]);
        if (l.rank < 2) throw new Error("Sorted input argument must be at least 2-dimensional");
        if (l.shape[0] !== o.shape[0]) throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
        if (ht(o.shape) >= ac) throw new Error(`values tensor size must less than ${ac}`);
        if (l.shape[1] >= ac) throw new Error(`trailing dim_size must less than ${ac} for int32 output type, was ${l.shape[1]}`);
        let p = {
            sortedSequence: l,
            values: o
        }, u = {
            side: n
        };
        return U.runKernel(Wi, p, u);
    }
});

function Qg(e, t) {
    return rc(e, t, "left");
}

var Ff = V({
    maxPool_: function(e, t, n, a, r) {
        let s = _(e, "x", "maxPool"), i = s, l = !1;
        s.rank === 3 && (l = !0, i = Q(s, [ 1, s.shape[0], s.shape[1], s.shape[2] ])), 
        D(i.rank === 4, () => `Error in maxPool: input must be rank 4 but got rank ${i.rank}.`), 
        D(Ja(n, 1), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`), 
        ia("maxPool", a, r);
        let o = {
            x: i
        }, p = {
            filterSize: t,
            strides: n,
            pad: a,
            dimRoundingMode: r
        }, u = U.runKernel(fi, o, p);
        return l ? Q(u, [ u.shape[1], u.shape[2], u.shape[3] ]) : u;
    }
}), ey = V({
    maxPool3d_: function(e, t = [ 1, 1, 1 ], n, a, r, s = "NDHWC") {
        let i = _(e, "x", "maxPool3d"), l = i, o = !1;
        i.rank === 4 && (o = !0, l = Q(i, [ 1, i.shape[0], i.shape[1], i.shape[2], i.shape[3] ])), 
        D(l.rank === 5, () => `Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`), 
        D(s === "NDHWC", () => `Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`), 
        ia("maxPool3d", a, r);
        let p = {
            x: l
        }, u = {
            filterSize: t,
            strides: n,
            pad: a,
            dimRoundingMode: r,
            dataFormat: s
        }, c = U.runKernel(Sl, p, u);
        return o ? Q(c, [ c.shape[1], c.shape[2], c.shape[3], c.shape[4] ]) : c;
    }
}), ty = V({
    maxPoolWithArgmax_: function(e, t, n, a, r = !1) {
        let s = {
            x: _(e, "x", "maxPoolWithArgmax")
        }, i = {
            filterSize: t,
            strides: n,
            pad: a,
            includeBatchInIndex: r
        }, l = U.runKernel(Nl, s, i);
        return {
            result: l[0],
            indexes: l[1]
        };
    }
}), _f = V({
    maximum_: function(e, t) {
        let n = _(e, "a", "maximum"), a = _(t, "b", "maximum");
        [ n, a ] = It(n, a), n.dtype === "bool" && (n = Qe(n, "int32"), a = Qe(a, "int32")), 
        Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(hi, r);
    }
}), zd = V({
    mean_: function(e, t = null, n = !1) {
        let a = {
            x: _(e, "x", "mean")
        }, r = {
            axis: t,
            keepDims: n
        };
        return U.runKernel(mi, a, r);
    }
});

function ka(e, t = "float32") {
    if (zn(e), t === "complex64") {
        let a = ka(e, "float32"), r = ka(e, "float32");
        return Ka(a, r);
    }
    let n = Lp(ht(e), t);
    return U.makeTensor(n, e, t);
}

function _r(e, t = "float32") {
    if (zn(e), t === "complex64") {
        let a = _r(e, "float32"), r = ka(e, "float32");
        return Ka(a, r);
    }
    let n = Wh(ht(e), t);
    return U.makeTensor(n, e, t);
}

function ny(e, t, {
    indexing: n = "xy"
} = {}) {
    if (n !== "xy" && n !== "ij") throw new TypeError(`${n} is not a valid third argument to meshgrid`);
    if (e === void 0) return [];
    let a = _(e, "x", "meshgrid", e instanceof vt ? e.dtype : "float32");
    if (t === void 0) return [ a ];
    let r = _(t, "y", "meshgrid", t instanceof vt ? t.dtype : "float32"), s = ht(a.shape), i = ht(r.shape);
    return n === "xy" ? (a = Q(a, [ 1, -1 ]), r = Q(r, [ -1, 1 ]), [ ut(_r([ i, 1 ], a.dtype), a), ut(r, _r([ 1, s ], r.dtype)) ]) : (a = Q(a, [ -1, 1 ]), 
    r = Q(r, [ 1, -1 ]), [ ut(a, _r([ 1, i ], a.dtype)), ut(_r([ s, 1 ], r.dtype), r) ]);
}

var Ld = V({
    minimum_: function(e, t) {
        let n = _(e, "a", "minimum"), a = _(t, "b", "minimum");
        [ n, a ] = It(n, a), n.dtype === "bool" && (n = Qe(n, "int32"), a = Qe(a, "int32")), 
        Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(yi, r);
    }
}), ay = V({
    mirrorPad_: function(e, t, n) {
        D(n === "reflect" || n === "symmetric", () => `Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);
        let a = _(e, "x", "mirrorPad");
        if (a.rank === 0) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
        D(t.length === a.rank, () => `Padding doesn't match input. Must be ${a.rank}. Got ${t.length}.`);
        let r = n === "reflect" ? 1 : 0;
        for (let l = 0; l < a.rank; l++) D(t[l].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), 
        D(t[l][0] >= 0 && t[l][0] <= a.shape[l] - r && t[l][1] >= 0 && t[l][1] <= a.shape[l] - r, () => `Padding in dimension ${l} cannot be greater than or equal to ${a.shape[l] - r} or less than 0 for input of shape ${a.shape}`);
        let s = {
            paddings: t,
            mode: n
        }, i = {
            x: a
        };
        return U.runKernel(Ai, i, s);
    }
}), sc = V({
    mod_: function(e, t) {
        let n = _(e, "a", "mod"), a = _(t, "b", "mod");
        [ n, a ] = It(n, a);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(xi, r);
    }
}), ry = V({
    moments_: function(e, t = null, n = !1) {
        let a = Uu(t, (e = _(e, "x", "moments")).shape), r = zd(e, a, n), s = r.shape;
        n || (s = Fd(r.shape, a));
        let i = oa($e(Qe(e, "float32"), Q(r, s)));
        return {
            mean: r,
            variance: zd(i, a, n)
        };
    }
}), sy = V({
    multiRNNCell_: function(e, t, n, a) {
        let r = _(t, "data", "multiRNNCell"), s = Sd(n, "c", "multiRNNCell"), i = Sd(a, "h", "multiRNNCell"), l = r, o = [];
        for (let c = 0; c < e.length; c++) {
            let d = e[c](l, s[c], i[c]);
            o.push(d[0]), o.push(d[1]), l = d[1];
        }
        let p = [], u = [];
        for (let c = 0; c < o.length; c += 2) p.push(o[c]), u.push(o[c + 1]);
        return [ p, u ];
    }
}), iy = V({
    multinomial_: function(e, t, n, a = !1) {
        let r = _(e, "logits", "multinomial"), s = r.size, i = r.rank;
        if (s < 2) throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);
        if (i > 2) throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);
        n = n || Math.random();
        let l = {
            logits: i === 1 ? Q(r, [ 1, -1 ]) : r
        }, o = {
            numSamples: t,
            seed: n,
            normalized: a
        }, p = U.runKernel(bi, l, o);
        return i === 1 ? Q(p, [ p.size ]) : p;
    }
}), Of = V({
    notEqual_: function(e, t) {
        let n = _(e, "a", "notEqual", "string_or_numeric"), a = _(t, "b", "notEqual", "string_or_numeric");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(wi, r);
    }
}), ic = V({
    oneHot_: function(e, t, n = 1, a = 0, r = "int32") {
        if (t < 2) throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);
        let s = {
            indices: _(e, "indices", "oneHot", "int32")
        }, i = {
            dtype: r,
            depth: t,
            onValue: n,
            offValue: a
        };
        return U.runKernel(Si, s, i);
    }
}), oy = V({
    onesLike_: function(e) {
        let t = {
            x: _(e, "x", "onesLike")
        };
        return U.runKernel(Rl, t);
    }
}), ly = V({
    outerProduct_: function(e, t) {
        let n = _(e, "v1", "outerProduct"), a = _(t, "v2", "outerProduct");
        D(n.rank === 1 && a.rank === 1, () => `Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${a.rank}.`);
        let r = Q(n, [ -1, 1 ]), s = Q(a, [ 1, -1 ]);
        return ut(r, s);
    }
}), Or = V({
    pad_: function(e, t, n = 0) {
        let a = _(e, "x", "pad");
        if (a.rank === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
        let r = {
            paddings: t,
            constantValue: n
        }, s = {
            x: a
        };
        return U.runKernel(Ni, s, r);
    }
}), uy = V({
    pad1d_: function(e, t, n = 0) {
        return D(t.length === 2, () => "Invalid number of paddings. Must be length of 2."), 
        Or(e, [ t ], n);
    }
}), dy = V({
    pad2d_: function(e, t, n = 0) {
        return D(t.length === 2 && t[0].length === 2 && t[1].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), 
        Or(e, t, n);
    }
}), py = V({
    pad3d_: function(e, t, n = 0) {
        return D(t.length === 3 && t[0].length === 2 && t[1].length === 2 && t[2].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), 
        Or(e, t, n);
    }
}), cy = V({
    pad4d_: function(e, t, n = 0) {
        return D(t.length === 4 && t[0].length === 2 && t[1].length === 2 && t[2].length === 2 && t[3].length === 2, () => "Invalid number of paddings. Must be length of 2 each."), 
        Or(e, t, n);
    }
}), Pf = V({
    spaceToBatchND_: function(e, t, n) {
        let a = _(e, "x", "spaceToBatchND");
        D(a.rank >= 1 + t.length, () => `input rank ${a.rank} should be > than [blockShape] ${t.length}`), 
        D(n.length === t.length, () => `paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`), 
        D(a.shape.reduce((i, l, o) => o > 0 && o <= t.length ? i && (l + n[o - 1][0] + n[o - 1][1]) % t[o - 1] == 0 : i, !0), () => `input spatial dimensions ${a.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);
        let r = {
            x: a
        }, s = {
            blockShape: t,
            paddings: n
        };
        return U.runKernel(Dl, r, s);
    }
}), hy = V({
    pool_: function(e, t, n, a, r, s, i) {
        r == null && (r = [ 1, 1 ]), s == null && (s = 1), a === 0 && (a = "valid");
        let l = _(e, "x", "maxPool"), o = l, p = !1;
        l.rank === 3 && (p = !0, o = Q(l, [ 1, l.shape[0], l.shape[1], l.shape[2] ])), 
        D(Ja(s, r), () => `Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);
        let u, c = og(o.shape, t, s, r, a), d = [ c.dilationHeight, c.dilationWidth ];
        u = a === "same" ? function(b, v) {
            let I = b.map((R, w) => R + (R - 1) * (v[w] - 1)).map(R => R - 1), N = I.map(R => Math.floor(R / 2)), T = I.map((R, w) => R - N[w]);
            return I.map((R, w) => [ N[w], T[w] ]);
        }([ c.filterHeight, c.filterWidth ], d) : [ [ 0, 0 ], [ 0, 0 ] ];
        let h = d[0] === 1 && d[1] === 1, [ f, m ] = function(b, v, I) {
            let N = I.map(F => F[0]), T = I.map(F => F[1]), R = b.concat(N, T), w = v.map((F, P) => (F - R[P] % F) % F), E = T.map((F, P) => F + w[P]), $ = v.map((F, P) => [ N[P], E[P] ]), M = v.map((F, P) => [ 0, w[P] ]);
            return [ $, M ];
        }([ c.inHeight, c.inWidth ], d, u), g = h ? a : "valid", y = h ? o : Pf(o, d, f), A = (n === "avg" ? () => gf(y, t, s, g, i) : () => Ff(y, t, s, g, i))(), x = h ? A : yf(A, d, m);
        return p ? Q(x, [ x.shape[1], x.shape[2], x.shape[3] ]) : x;
    }
}), Df = V({
    prelu_: function(e, t) {
        let n = {
            x: _(e, "x", "prelu"),
            alpha: _(t, "alpha", "prelu")
        };
        return U.runKernel(Ti, n);
    }
}), fy = V({
    prod_: function(e, t = null, n = !1) {
        let a = _(e, "x", "prod");
        a.dtype === "bool" && (a = Qe(a, "int32"));
        let r = {
            x: a
        }, s = {
            axis: t,
            keepDims: n
        };
        return U.runKernel(Ri, r, s);
    }
}), my = V({
    raggedGather_: function(e, t, n, a) {
        let r = {
            paramsNestedSplits: e.map((l, o) => _(l, `tensors${o}`, "raggedGather", "int32")),
            paramsDenseValues: _(t, "paramsDenseValues", "raggedGather"),
            indices: _(n, "indices", "raggedGather", "int32")
        }, s = {
            outputRaggedRank: a
        }, i = U.runKernel(Bp, r, s);
        return {
            outputNestedSplits: i.slice(0, i.length - 1),
            outputDenseValues: i[i.length - 1]
        };
    }
}), gy = V({
    raggedRange_: function(e, t, n) {
        let a = _(e, "starts", "raggedRange"), r = {
            starts: a,
            limits: _(t, "limits", "raggedRange", a.dtype),
            deltas: _(n, "deltas", "raggedRange", a.dtype)
        }, s = U.runKernel(Vp, r);
        return {
            rtNestedSplits: s[0],
            rtDenseValues: s[1]
        };
    }
}), yy = V({
    raggedTensorToTensor_: function(e, t, n, a, r) {
        let s = _(e, "shape", "raggedTensorToTensor", "int32"), i = _(t, "values", "raggedTensorToTensor"), l = {
            shape: s,
            values: i,
            defaultValue: _(n, "defaultValue", "raggedTensorToTensor", i.dtype),
            rowPartitionTensors: a.map((p, u) => _(p, `tensors${u}`, "raggedTensorToTensor", "int32"))
        }, o = {
            rowPartitionTypes: r
        };
        return U.runKernel(Up, l, o);
    }
}), Ay = V({
    rand_: function(e, t, n) {
        zn(e);
        let a = ht(e), r = null;
        if (n == null || n === "float32") r = new Float32Array(a); else if (n === "int32") r = new Int32Array(a); else {
            if (n !== "bool") throw new Error(`Unknown data type ${n}`);
            r = new Uint8Array(a);
        }
        for (let s = 0; s < a; s++) r[s] = t();
        return U.makeTensor(r, e, n);
    }
}), zf = nl(J2()), xy = {};

Ze(xy, {
    TEST_EPSILON_FLOAT16: () => by,
    createVideoElement: () => NS,
    encodeStrings: () => vy,
    expectArrayBuffersEqual: () => SS,
    expectArraysClose: () => bS,
    expectArraysEqual: () => wS,
    expectNumbersClose: () => kS,
    expectPromiseToFail: () => vS,
    expectValuesInRange: () => IS,
    play: () => CS,
    testEpsilon: () => Lf
});

var xS = .001, by = .1;

function bS(e, t, n) {
    return n == null && (n = Lf()), Wf(e, t, (a, r) => Bf(a, r, n));
}

function Lf() {
    return U.backend.floatPrecision() === 32 ? xS : by;
}

function Wf(e, t, n) {
    let a = !0;
    if ((Gt(e) || Gt(t)) && (a = !1), Gt(e) && Gt(t) && (a = !0), a) {
        let i = e.constructor.name, l = t.constructor.name;
        if (i !== l) throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${l}`);
    }
    if (Array.isArray(e) && Array.isArray(t)) {
        let i = Oa(e), l = Oa(t);
        if (!qa(i, l)) throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${l}]`);
    }
    let r = Gt(e) ? e : Cr(e), s = Gt(t) ? t : Cr(t);
    if (r.length !== s.length) throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);
    for (let i = 0; i < s.length; ++i) {
        let l = r[i], o = s[i];
        if (!n(l, o)) throw new Error(`Arrays differ: actual[${i}] = ${l}, expected[${i}] = ${o}.
Actual:   ${r}.
Expected: ${s}.`);
    }
    typeof expect < "u" && expect().nothing();
}

function vS(e, t) {
    e().then(() => t.fail(), () => t()), typeof expect < "u" && expect().nothing();
}

function wS(e, t) {
    let n = typeof t == "string" || typeof t == "number" || typeof t == "boolean" ? [ t ] : t;
    return gr(e) || gr(e[0]) || gr(t) || gr(t[0]) ? Wf(e, n, (a, r) => a == r) : Wf(e, t, (a, r) => Bf(a, r, 0));
}

function kS(e, t, n) {
    if (n == null && (n = Lf()), !Bf(e, t, n)) throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);
    typeof expect < "u" && expect().nothing();
}

function Bf(e, t, n) {
    return !isFinite(e) && !isFinite(t) || !(isNaN(e) || isNaN(t) || Math.abs(e - t) > n);
}

function IS(e, t, n) {
    for (let a = 0; a < e.length; a++) if (e[a] < t || e[a] > n) throw new Error(`Value out of range:${e[a]} low: ${t}, high: ${n}`);
}

function SS(e, t) {
    let n = new Float32Array(e), a = new Float32Array(t);
    if (n.length !== a.length) throw new Error(`Expected ArrayBuffer to be of length ${a.length}, but it was ${n.length}`);
    for (let r = 0; r < a.length; r++) if (n[r] !== a[r]) throw new Error(`Expected ArrayBuffer value at ${r} to be ${a[r]} but got ${n[r]} instead`);
}

function vy(e) {
    for (let t = 0; t < e.length; t++) {
        let n = e[t];
        Array.isArray(n) ? vy(n) : e[t] = Ad(n);
    }
    return e;
}

function NS(e) {
    let t = document.createElement("video");
    return "playsInline" in t && (t.playsInline = !0), t.muted = !0, t.loop = !0, 
    t.style.position = "fixed", t.style.left = "0px", t.style.top = "0px", t.preload = "auto", 
    t.appendChild(e), new Promise(n => {
        t.addEventListener("loadeddata", a => n(t)), t.load();
    });
}

async function CS(e) {
    await e.play(), "requestVideoFrameCallback" in e && await new Promise(t => {
        e.requestVideoFrameCallback(t);
    });
}

var Vf = class {
    constructor(e, t, n, a, r) {
        this.mean = e, this.stdDev = t, this.dtype = n, this.nextVal = NaN, this.truncated = a, 
        this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
        let s = r || Math.random();
        this.random = zf.alea(s.toString());
    }
    nextValue() {
        if (!isNaN(this.nextVal)) {
            let a = this.nextVal;
            return this.nextVal = NaN, a;
        }
        let e, t, n = !1;
        for (;!n; ) {
            let a, r, s;
            do {
                a = 2 * this.random() - 1, r = 2 * this.random() - 1, s = a * a + r * r;
            } while (s >= 1 || s === 0);
            let i = Math.sqrt(-2 * Math.log(s) / s);
            e = this.mean + this.stdDev * a * i, t = this.mean + this.stdDev * r * i, 
            (!this.truncated || this.isValidTruncated(e)) && (n = !0);
        }
        return (!this.truncated || this.isValidTruncated(t)) && (this.nextVal = this.convertValue(t)), 
        this.convertValue(e);
    }
    convertValue(e) {
        return this.dtype == null || this.dtype === "float32" ? e : Math.round(e);
    }
    isValidTruncated(e) {
        return e <= this.upper && e >= this.lower;
    }
}, TS = class {
    constructor(e, t, n, a) {
        this.alpha = e, this.beta = 1 / t, this.dtype = n;
        let r = a || Math.random();
        this.randu = zf.alea(r.toString()), this.randn = new Vf(0, 1, n, !1, this.randu()), 
        this.d = e < 1 ? e + 2 / 3 : e - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);
    }
    nextValue() {
        let e, t, n, a, r, s;
        for (;;) {
            do {
                a = this.randn.nextValue(), s = 1 + this.c * a;
            } while (s <= 0);
            if (s *= s * s, e = a * a, t = 1 - .331 * e * e, n = .5 * e + this.d * (1 - s + Math.log(s)), 
            r = this.randu(), r < t || Math.log(r) < n) break;
        }
        return s = 1 / this.beta * this.d * s, this.alpha < 1 && (s *= Math.pow(this.randu(), 1 / this.alpha)), 
        this.convertValue(s);
    }
    convertValue(e) {
        return this.dtype === "float32" ? e : Math.round(e);
    }
}, RS = class {
    constructor(e = 0, t = 1, n, a) {
        if (this.canReturnFloat = () => this.dtype == null || this.dtype === "float32", 
        this.min = e, this.range = t - e, this.dtype = n, a == null && (a = Math.random()), 
        typeof a == "number" && (a = a.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);
        this.random = zf.alea(a);
    }
    convertValue(e) {
        return this.canReturnFloat() ? e : Math.round(e);
    }
    nextValue() {
        return this.convertValue(this.min + this.range * this.random());
    }
}, wy = V({
    randomGamma_: function(e, t, n = 1, a = "float32", r) {
        if (zn(e), n == null && (n = 1), a == null && (a = "float32"), a !== "float32" && a !== "int32") throw new Error(`Unsupported data type ${a}`);
        let s = new TS(t, n, a, r), i = We(e, a);
        for (let l = 0; l < i.values.length; l++) i.values[l] = s.nextValue();
        return i.toTensor();
    }
}), Uf = V({
    randomNormal_: function(e, t = 0, n = 1, a, r) {
        if (zn(e), a != null && a === "bool") throw new Error(`Unsupported data type ${a}`);
        let s = new Vf(t, n, a, !1, r), i = We(e, a);
        for (let l = 0; l < i.values.length; l++) i.values[l] = s.nextValue();
        return i.toTensor();
    }
}), ky = V({
    randomStandardNormal_: function(e, t, n) {
        if (t != null && t === "bool") throw new Error(`Unsupported data type ${t}`);
        return Uf(e, 0, 1, t, n);
    }
}), oc = V({
    randomUniform_: function(e, t = 0, n = 1, a = "float32", r) {
        zn(e);
        let s = We(e, a), i = new RS(t, n, null, r);
        for (let l = 0; l < s.values.length; l++) s.values[l] = i.nextValue();
        return s.toTensor();
    }
}), Iy = V({
    randomUniformInt_: function(e, t, n, a) {
        return oc(e, t, n, "int32", a);
    }
});

function tu(e, t, n = 1, a = "float32") {
    if (n === 0) throw new Error("Cannot have a step of zero");
    let r = {
        start: e,
        stop: t,
        step: n,
        dtype: a
    };
    return U.runKernel($l, {}, r);
}

var nu = V({
    real_: function(e) {
        let t = {
            input: _(e, "input", "real")
        };
        return U.runKernel(sd, t);
    }
}), Sy = V({
    reciprocal_: function(e) {
        let t = {
            x: _(e, "x", "reciprocal")
        };
        return U.runKernel(Ei, t);
    }
}), Wd = V({
    relu_: function(e) {
        let t = {
            x: _(e, "x", "relu")
        };
        return U.runKernel($i, t);
    }
}), Gf = V({
    relu6_: function(e) {
        let t = {
            x: _(e, "x", "relu6")
        };
        return U.runKernel(_i, t);
    }
}), Pr = V({
    reverse_: function(e, t) {
        let n = {
            x: _(e, "x", "reverse")
        }, a = {
            dims: t
        };
        return U.runKernel(Oi, n, a);
    }
}), Ny = V({
    reverse1d_: function(e) {
        let t = _(e, "x", "reverse");
        return D(t.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`), 
        Pr(t, 0);
    }
}), Cy = V({
    reverse2d_: function(e, t) {
        let n = _(e, "x", "reverse");
        return D(n.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`), 
        Pr(n, t);
    }
}), Ty = V({
    reverse3d_: function(e, t) {
        let n = _(e, "x", "reverse");
        return D(n.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`), 
        Pr(n, t);
    }
}), Ry = V({
    reverse4d_: function(e, t) {
        let n = _(e, "x", "reverse");
        return D(n.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`), 
        Pr(n, t);
    }
}), Hf = V({
    round_: function(e) {
        let t = {
            x: _(e, "x", "round")
        };
        return U.runKernel(Pi, t);
    }
}), Ey = V({
    rsqrt_: function(e) {
        let t = {
            x: _(e, "x", "rsqrt", "float32")
        };
        return U.runKernel(Di, t);
    }
}), $y = V({
    selu_: function(e) {
        let t = {
            x: _(e, "x", "selu")
        };
        return U.runKernel(Bi, t);
    }
}), My = V({
    separableConv2d_: function(e, t, n, a, r, s = [ 1, 1 ], i = "NHWC") {
        let l = _(e, "x", "separableConv2d"), o = _(t, "depthwiseFilter", "separableConv2d"), p = _(n, "pointwiseFilter", "separableConv2d"), u = l, c = !1;
        if (l.rank === 3 && (c = !0, u = Q(l, [ 1, l.shape[0], l.shape[1], l.shape[2] ])), 
        i === "NCHW") throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
        D(u.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`), 
        D(o.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but got rank ${o.rank}.`), 
        D(p.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but got rank ${o.rank}.`), 
        D(p.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`), 
        D(p.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);
        let d = o.shape[2], h = o.shape[3];
        D(p.shape[2] === d * h, () => `Error in separableConv2d: the third dimension of pointwise filter must be ${d * h}, but got ${p.shape[2]}.`);
        let f = Qp(u, o, a, r, i, s), m = Md(f, p, 1, "valid", i);
        return c ? Q(m, [ m.shape[1], m.shape[2], m.shape[3] ]) : m;
    }
}), Fy = async function(e, t) {
    let n = _(e, "x", "setdiff1d"), a = _(t, "y", "setdiff1d");
    D(n.dtype === a.dtype, () => `x and y should have the same dtype, but got x (${n.dtype}) and y (${a.dtype}).`), 
    D(n.rank === 1, () => `x should be 1D tensor, but got x (${n.shape}).`), D(a.rank === 1, () => `y should be 1D tensor, but got y (${a.shape}).`);
    let r = await n.data(), s = await a.data(), i = new Set(s), l = 0;
    for (let u = 0; u < r.length; u++) i.has(r[u]) || l++;
    let o = new $t([ l ], n.dtype), p = new $t([ l ], "int32");
    for (let u = 0, c = 0; u < r.length; u++) i.has(r[u]) || (o.values[c] = r[u], 
    p.values[c] = u, c++);
    return [ o.toTensor(), p.toTensor() ];
}, _y = V({
    sign_: function(e) {
        let t = {
            x: _(e, "x", "sign")
        };
        return U.runKernel(Gi, t);
    }
}), Oy = V({
    sin_: function(e) {
        let t = {
            x: _(e, "x", "sin", "float32")
        };
        return U.runKernel(Vi, t);
    }
}), Py = V({
    sinh_: function(e) {
        let t = {
            x: _(e, "x", "sinh")
        };
        return U.runKernel(Ui, t);
    }
}), Dy = V({
    slice1d_: function(e, t, n) {
        let a = _(e, "x", "slice1d");
        return D(a.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${a.rank} tensor`), 
        He(a, [ t ], [ n ]);
    }
}), zy = V({
    slice2d_: function(e, t, n) {
        let a = _(e, "x", "slice2d");
        return D(a.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${a.rank} tensor`), 
        He(a, t, n);
    }
}), lc = V({
    slice3d_: function(e, t, n) {
        let a = _(e, "x", "slice3d");
        return D(a.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${a.rank} tensor`), 
        He(a, t, n);
    }
}), jf = V({
    slice4d_: function(e, t, n) {
        let a = _(e, "x", "slice4d");
        return D(a.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${a.rank} tensor`), 
        He(a, t, n);
    }
}), qf = V({
    softmax_: function(e, t = -1) {
        let n = _(e, "logits", "softmax", "float32");
        if (t === -1 && (t = n.rank - 1), t !== n.rank - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);
        let a = {
            logits: n
        }, r = {
            dim: t
        };
        return U.runKernel(Ki, a, r);
    }
}), uc = V({
    fft_: function(e) {
        D(e.dtype === "complex64", () => `The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);
        let t = {
            input: e
        };
        return U.runKernel(ed, t);
    }
}), Bd = V({
    ifft_: function(e) {
        D(e.dtype === "complex64", () => `The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);
        let t = {
            input: e
        };
        return U.runKernel(td, t);
    }
}), Xf = V({
    irfft_: function(e) {
        let t, n = e.shape[e.shape.length - 1], a = e.size / n;
        if (n <= 2) {
            let r = Q(e, [ a, n ]);
            t = Bd(r);
        } else {
            let r = [ a, 2 * (n - 1) ], s = Q(nu(e), [ a, n ]), i = Q(Pd(e), [ a, n ]), l = Pr(He(s, [ 0, 1 ], [ a, n - 2 ]), 1), o = ne(Pr(He(i, [ 0, 1 ], [ a, n - 2 ]), 1), je(-1)), p = yt([ s, l ], 1), u = yt([ i, o ], 1), c = Q(Ka(p, u), [ r[0], r[1] ]);
            t = Bd(c);
        }
        if (t = nu(t), e.rank === 3 && e.shape[0] !== 0) {
            let r = t, s = e.shape[0];
            t = Q(t, [ s, t.shape[0] / s, t.shape[1] ]), r.dispose();
        }
        return t;
    }
}), Ia = V({
    split_: function(e, t, n = 0) {
        let a = {
            x: _(e, "x", "split")
        }, r = {
            numOrSizeSplits: t,
            axis: n
        };
        return U.runKernel(zl, a, r);
    }
}), dc = V({
    rfft_: function(e, t) {
        D(e.dtype === "float32", () => `The dtype for rfft() must be real value but got ${e.dtype}`);
        let n, a = e.shape[e.shape.length - 1], r = e.size / a;
        if (t != null && t < a) {
            let f = e.shape.map(g => 0), m = e.shape.map(g => g);
            m[e.shape.length - 1] = t, n = He(e, f, m), a = t;
        } else if (t != null && t > a) {
            let f = e.shape.map(m => m);
            f[e.shape.length - 1] = t - a, n = yt([ e, ka(f) ], e.shape.length - 1), 
            a = t;
        } else n = e;
        let s = Wn(n), i = Q(Ka(n, s), [ r, a ]), l = uc(i), o = Math.floor(a / 2) + 1, p = nu(l), u = Pd(l), c = Ia(p, [ o, a - o ], p.shape.length - 1), d = Ia(u, [ o, a - o ], u.shape.length - 1), h = n.shape.slice();
        return h[n.shape.length - 1] = o, Q(Ka(c[0], d[0]), h);
    }
}), Kf = V({
    squaredDifference_: function(e, t) {
        let n = _(e, "a", "squaredDifference"), a = _(t, "b", "squaredDifference");
        [ n, a ] = It(n, a), Ft(n.shape, a.shape);
        let r = {
            a: n,
            b: a
        };
        return U.runKernel(Yi, r, {});
    }
}), at = V({
    squeeze_: function(e, t) {
        let n = _(e, "x", "squeeze", "string_or_numeric");
        return Q(n, a0(n.shape, t).newShape);
    }
}), Bn = V({
    stack_: function(e, t = 0) {
        let n = Sd(e, "tensors", "stack", "string_or_numeric");
        D(n.length >= 1, () => "Pass at least one tensor to tf.stack"), n.length > 0 && D(t <= n[0].rank, () => "Axis must be <= rank of the tensor");
        let a = n, r = {
            axis: t
        };
        return U.runKernel(El, a, r);
    }
}), Zf = V({
    step_: function(e, t = 0) {
        let n = {
            x: _(e, "x", "step")
        }, a = {
            alpha: t
        };
        return U.runKernel(vr, n, a);
    }
}), Ly = V({
    stridedSlice_: function(e, t, n, a, r = 0, s = 0, i = 0, l = 0, o = 0) {
        let p = {
            x: _(e, "x", "stridedSlice", "string_or_numeric")
        }, u = {
            begin: t,
            end: n,
            strides: a,
            beginMask: r,
            endMask: s,
            ellipsisMask: i,
            newAxisMask: l,
            shrinkAxisMask: o
        };
        return U.runKernel(Ji, p, u);
    }
}), Wy = V({
    tan_: function(e) {
        let t = {
            x: _(e, "x", "tan", "float32")
        };
        return U.runKernel(eo, t);
    }
});

function Yt(e, t) {
    ps(e);
    let n = Oa(e, t);
    if (n.length !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
    return Tr(e, null, n, t);
}

function Dr(e, t, n) {
    if (ps(e), t != null && t.length !== 2) throw new Error("tensor2d() requires shape to have two numbers");
    let a = Oa(e, n);
    if (a.length !== 2 && a.length !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
    if (a.length === 1 && t == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
    return Tr(e, t, a, n);
}

function Yf(e, t, n) {
    if (ps(e), t != null && t.length !== 3) throw new Error("tensor3d() requires shape to have three numbers");
    let a = Oa(e, n);
    if (a.length !== 3 && a.length !== 1) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
    if (a.length === 1 && t == null) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
    return Tr(e, t, a, n);
}

function By(e, t, n) {
    if (ps(e), t != null && t.length !== 4) throw new Error("tensor4d() requires shape to have four numbers");
    let a = Oa(e, n);
    if (a.length !== 4 && a.length !== 1) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
    if (a.length === 1 && t == null) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
    return Tr(e, t, a, n);
}

function Vy(e, t, n) {
    if (ps(e), t != null && t.length !== 5) throw new Error("tensor5d() requires shape to have five numbers");
    let a = Oa(e, n);
    if (a.length !== 5 && a.length !== 1) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
    if (a.length === 1 && t == null) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
    return Tr(e, t, a, n);
}

function Uy(e, t, n) {
    if (ps(e), t != null && t.length !== 6) throw new Error("tensor6d() requires shape to have six numbers");
    let a = Oa(e, n);
    if (a.length !== 6 && a.length !== 1) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
    if (a.length === 1 && t == null) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
    return Tr(e, t = t || a, a, n);
}

var pc = {};

function Jf(e, t, n) {
    let a = t.rank > 1 ? t.shape[t.rank - 1] : 1, r = t.rank > 1 ? t.rank - 1 : 1, s = `Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${a}, and batchDim: ${r}.`;
    if (n.rank < r) throw new Error(s + ` update.rank < ${r}. `);
    if (e.length < a + (n.rank - r)) throw new Error(s + ` Output shape length < ${a + (n.rank - r)}`);
    if (n.rank !== r + e.length - a) throw new Error(s + " update.rank != " + (r + e.length - a));
    for (let i = 0; i < r; ++i) if (n.shape[i] !== t.shape[i]) throw new Error(s + ` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);
    for (let i = 0; i < n.rank - r; ++i) if (n.shape[i + r] !== e[i + a]) throw new Error(s + ` updates.shape[${i + r}] (${n.shape[i + r]}) != shape[${i + r}] (${e[i + r]})`);
}

function cc(e, t, n) {
    if (t.rank < 1) throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);
    if (e.rank < 1) throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);
    if (t.dtype !== "int32") throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);
    if (n.length < 1) throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);
    if (n.length === 0) {
        if (t.size === 0) throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);
        if (e.size === 0) throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`);
    }
    Jf(n, t, e);
}

function Gy(e, t, n) {
    let a = t.shape.length, r = a > 1 ? t.shape[a - 1] : 1, s = n.length, i = 1;
    for (let o = r; o < s; ++o) i *= n[o];
    let l = r < 1 ? 1 : r;
    return {
        sliceRank: r,
        numUpdates: ht(t.shape) / l,
        sliceSize: i,
        strides: [ ...sl(n.slice(0, r)), 1 ],
        outputSize: ht(n)
    };
}

Ze(pc, {
    calculateShapes: () => Gy,
    validateInput: () => cc,
    validateUpdateShape: () => Jf
});

var Hy = V({
    tensorScatterUpdate_: function(e, t, n) {
        let a = _(e, "tensor", "tensorScatterupdate"), r = _(t, "indices", "tensorScatterupdate", "int32"), s = _(n, "updates", "tensorScatterupdate");
        if (cc(s, r, a.shape), a.dtype !== s.dtype) throw new Error(`tensor and updates must have the same dtype, instead they are ${a.dtype} and ${s.dtype}.`);
        let i = {
            tensor: a,
            indices: r,
            updates: s
        };
        return U.runKernel(Li, i, {});
    }
}), jy = V({
    topk_: function(e, t = 1, n = !0) {
        let a = _(e, "x", "topk");
        if (a.rank === 0) throw new Error("topk() expects the input to be of rank 1 or higher");
        let r = a.shape[a.shape.length - 1];
        if (t < 0) throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);
        if (t > r) throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);
        let s = {
            x: a
        }, i = {
            k: t,
            sorted: n
        }, [ l, o ] = U.runKernel(no, s, i);
        return {
            values: l,
            indices: o
        };
    }
}), qy = V({
    truncatedNormal_: function(e, t = 0, n = 1, a, r) {
        if (zn(e), a != null && a === "bool") throw new Error("Unsupported data type $ { dtype }");
        let s = new Vf(t, n, a, !0, r), i = We(e, a);
        for (let l = 0; l < i.values.length; l++) i.values[l] = s.nextValue();
        return i.toTensor();
    }
}), Xy = V({
    unique_: function(e, t = 0) {
        let n = _(e, "x", "unique", "string_or_numeric");
        D(n.rank > 0, () => "The input tensor must be at least 1D");
        let a = {
            x: n
        }, r = {
            axis: t
        }, [ s, i ] = U.runKernel(pd, a, r);
        return {
            values: s,
            indices: i
        };
    }
}), Ky = V({
    unsortedSegmentSum_: function(e, t, n) {
        let a = _(e, "x", "unsortedSegmentSum"), r = _(t, "segmentIds", "unsortedSegmentSum", "int32");
        D(rl(n), () => "numSegments must be of dtype int");
        let s = {
            x: a,
            segmentIds: r
        }, i = {
            numSegments: n
        };
        return U.runKernel(cd, s, i);
    }
}), la = V({
    unstack_: function(e, t = 0) {
        let n = _(e, "x", "unstack", "string_or_numeric");
        D(t >= -n.shape.length && t < n.shape.length, () => `Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);
        let a = {
            value: n
        }, r = {
            axis: t
        };
        return U.runKernel(Ul, a, r);
    }
});

function Zy(e, t) {
    return rc(e, t, "right");
}

function Yy(e, t = !0, n, a) {
    return U.makeVariable(e, t, n, a);
}

function Jy(e, t) {
    let n = [];
    for (let s = 0; s < t.length; s++) t[s] && n.push(s);
    let a = We(e, "int32"), r = We([ n.length, e.length ], "int32");
    for (let s = 0; s < n.length; s++) {
        let i = a.indexToLoc(n[s]), l = s * e.length;
        r.values.set(i, l);
    }
    return r.toTensor();
}

var Qf = async function(e) {
    let t = _(e, "condition", "whereAsync", "bool"), n = await t.data(), a = Jy(t.shape, n);
    return e !== t && t.dispose(), a;
}, Qy = async function(e, t, n) {
    let a = _(e, "tensor", "boolMask"), r = _(t, "mask", "boolMask", "bool"), s = n ?? 0, i = r.rank, l = a.shape;
    D(i > 0, () => "mask cannot be scalar"), ln(l.slice(s, s + i), r.shape, "mask's shape must match the first K dimensions of tensor's shape,");
    let o = 1;
    for (let m = s; m < s + i; m++) o *= l[m];
    let p = l.slice(0, s).concat([ o ], l.slice(s + i)), u = Q(a, p), c = Q(r, [ -1 ]), d = await Qf(c), h = at(d, [ 1 ]), f = Sf(u, h, s);
    return e !== a && a.dispose(), t !== r && r.dispose(), h.dispose(), u.dispose(), 
    c.dispose(), d.dispose(), f;
}, au = V({
    transpose_: function(e, t, n) {
        let a = _(e, "x", "transpose");
        if (t == null && (t = a.shape.map((i, l) => l).reverse()), D(a.rank === t.length, () => `Error in transpose: rank of input ${a.rank} must match length of perm ${t}.`), 
        t.forEach(i => {
            D(i >= 0 && i < a.rank, () => `All entries in 'perm' must be between 0 and ${a.rank - 1} but got ${t}`);
        }), a.rank <= 1) return a.clone();
        let r = {
            x: a
        }, s = {
            perm: t
        };
        return a.dtype === "complex64" ? qe(() => {
            let i = nu(a), l = Pd(a);
            return i = U.runKernel(Xa, {
                x: i
            }, s), l = U.runKernel(Xa, {
                x: l
            }, s), n && (l = wa(l)), Ka(i, l);
        }) : U.runKernel(Xa, r, s);
    }
}), eA = V({
    movingAverage_: function(e, t, n, a, r = !0) {
        let s = _(e, "v", "movingAverage"), i = _(t, "x", "movingAverage"), l = _(n, "decay", "movingAverage");
        N0(s, i), D(qa(s.shape, i.shape), () => "Shape mismatch in v and x");
        let o = je(1), p = $e(o, l), u = ne($e(i, s), p);
        if (r) {
            D(a != null, () => "When using zeroDebias: true, step is required.");
            let c = _(a, "step", "movingAverage");
            u = ze(u, $e(o, Ql(l, c)));
        }
        return _e(s, u);
    }
}), tA = V({
    scatterND_: function(e, t, n) {
        zn(n);
        let a = _(e, "indices", "scatterND", "int32"), r = _(t, "updates", "scatterND");
        cc(r, a, n);
        let s = {
            indices: a,
            updates: r
        }, i = {
            shape: n
        };
        return U.runKernel(zi, s, i);
    }
}), nA = V({
    sparseToDense_: function(e, t, n, a = 0) {
        zn(n);
        let r = _(e, "sparseIndices", "sparseToDense", "int32"), s = _(t, "sparseValues", "sparseToDense", "string_or_numeric"), i = _(a, "defaultValue", "sparseToDense", s.dtype);
        (function(p, u, c, d) {
            if (p.dtype !== "int32") throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${p.dtype}.`);
            if (p.rank > 2) throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${p.shape}.`);
            let h = p.rank > 0 ? p.shape[0] : 1, f = p.rank > 1 ? p.shape[1] : 1;
            if (c.length !== f) throw new Error(`outputShape has incorrect number of elements:, ${c.length}, should be: ${f}.`);
            let m = u.size;
            if (u.rank !== 0 && (u.rank !== 1 || m !== h)) throw new Error(`sparseValues has incorrect shape ${u.shape}, should be [] or [${h}]`);
            if (u.dtype !== d.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype");
        })(r, s, n, i);
        let l = {
            sparseIndices: r,
            sparseValues: s,
            defaultValue: i
        }, o = {
            outputShape: n
        };
        return U.runKernel(Zi, l, o);
    }
}), aA = V({
    gatherND_: function(e, t) {
        let n = _(t, "indices", "gatherND", "int32"), a = {
            params: _(e, "x", "gatherND", "string_or_numeric"),
            indices: n
        };
        return U.runKernel(Ks, a);
    }
}), rA = V({
    dropout_: function(e, t, n, a) {
        let r = _(e, "x", "dropout");
        if (D(r.dtype === "float32", () => `x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`), 
        D(t >= 0 && t < 1, () => `rate must be a float in the range [0, 1), but got ${t}.`), 
        t === 0) return e instanceof vt ? r.clone() : r;
        let s = function(o, p) {
            if (p == null) return o.shape.slice();
            if (qa(o.shape, p)) return p;
            if (o.shape.length === p.length) {
                let u = [];
                for (let c = 0; c < o.shape.length; c++) p[c] == null && o.shape[c] != null ? u.push(o.shape[c]) : u.push(p[c]);
                return u;
            }
            return p;
        }(r, n), i = 1 - t, l = ze(If(_e(oc(s, 0, 1, "float32", a), i)), i);
        return ne(r, l);
    }
});

function em(e) {
    return Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2))));
}

function hc(e, t, n) {
    let a = 1 - e % 2, r = new Float32Array(e);
    for (let s = 0; s < e; ++s) {
        let i = 2 * Math.PI * s / (e + a - 1);
        r[s] = t - n * Math.cos(i);
    }
    return Yt(r, "float32");
}

var sA = async function(e, t, n = 1) {
    let a = _(e, "predictions", "inTopK"), r = _(t, "targets", "inTopK");
    D(a.rank > 1, () => `inTopK() expects the predictions to be of rank 2 or higher, but got ${a.rank}`), 
    D(a.rank - 1 === r.rank, () => `predictions rank should be 1 larger than targets rank, but got predictions rank ${a.rank} and targets rank ${r.rank}`), 
    ln(a.shape.slice(0, a.shape.length - 1), r.shape, "predictions's shape should be align with the targets' shape, except the last dimension.");
    let s = a.shape[a.shape.length - 1];
    D(n > 0 && n <= s, () => `'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);
    let i = await a.data(), l = await r.data(), [ o, p ] = [ i.length / s, s ], u = r0("bool", o);
    for (let c = 0; c < o; c++) {
        let d = c * p, h = i.subarray(d, d + p), f = [];
        for (let m = 0; m < h.length; m++) f.push({
            value: h[m],
            index: m
        });
        f.sort((m, g) => g.value - m.value), u[c] = 0;
        for (let m = 0; m < n; m++) if (f[m].index === l[c]) {
            u[c] = 1;
            break;
        }
    }
    return e !== a && a.dispose(), t !== r && r.dispose(), Ye(u, r.shape, "bool");
}, tm = {};

Ze(tm, {
    conv2d: () => $S,
    depthwiseConv2d: () => _S,
    matMul: () => OS
});

var ES = V({
    conv2DBackpropFilter_: function(e, t, n, a, r, s = "NHWC", i) {
        let l = e;
        e.rank === 3 && (l = Q(e, [ 1, e.shape[0], e.shape[1], e.shape[2] ]));
        let o = t;
        o.rank === 3 && (o = Q(t, [ 1, t.shape[0], t.shape[1], t.shape[2] ])), D(l.rank === 4, () => `Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`), 
        D(o.rank === 4, () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ${o.shape}.`), 
        D(n.length === 4, () => `Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);
        let p = s === "NHWC" ? l.shape[3] : l.shape[1], u = s === "NHWC" ? o.shape[3] : o.shape[1];
        D(p === n[2], () => `Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${n[2]}.`), 
        D(u === n[3], () => `Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`), 
        ia("conv2dDerFilter", r, i);
        let c = {
            x: l,
            dy: o
        }, d = {
            strides: a,
            pad: r,
            dataFormat: s,
            dimRoundingMode: i,
            filterShape: n
        };
        return U.runKernel(Ku, c, d);
    }
});

function fc(e, t, n) {
    if (n == null || n === "linear") return e;
    if (n === "relu") return ne(e, Zf(t));
    throw new Error(`Cannot compute gradient for fused activation ${n}.`);
}

function mc(e, t) {
    let n = t, a = xf(e.shape, t.shape);
    return a.length > 0 && (n = dt(n, a)), Q(n, e.shape);
}

function gc(e, t, n, a) {
    if (t === "linear") return e;
    if (t === "relu") return Wd(e);
    if (t === "elu") return vf(e);
    if (t === "relu6") return Gf(e);
    if (t === "prelu") return Df(e, n);
    if (t === "leakyrelu") return Cf(e, a);
    if (t === "sigmoid") return va(e);
    throw new Error(`Unknown fused activation ${t}.`);
}

var yc = (e, t) => !(e > 0) || t === "linear", $S = V({
    fusedConv2d_: function({
        x: e,
        filter: t,
        strides: n,
        pad: a,
        dataFormat: r = "NHWC",
        dilations: s = [ 1, 1 ],
        dimRoundingMode: i,
        bias: l,
        activation: o = "linear",
        preluActivationWeights: p,
        leakyreluAlpha: u
    }) {
        if (o = o || "linear", yc(U.state.gradientDepth, o) === !1) {
            D(r === "NHWC", () => `Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);
            let I = Md(e, t, n, a, r, s, i);
            return l != null && (I = _e(I, l)), gc(I, o, p, u);
        }
        let c = _(e, "x", "conv2d", "float32"), d = _(t, "filter", "conv2d", "float32"), h = c, f = !1;
        c.rank === 3 && (f = !0, h = Q(c, [ 1, c.shape[0], c.shape[1], c.shape[2] ])), 
        D(h.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`), 
        D(d.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`), 
        ia("fused conv2d", a, i);
        let m = r === "NHWC" ? h.shape[3] : h.shape[1];
        D(d.shape[2] === m, () => `Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`), 
        D(Ja(n, s), () => `Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);
        let g, y, A = Cd(h.shape, d.shape, n, s, a, i);
        if (l != null && (g = _(l, "bias", "fused conv2d"), [ g ] = It(g, c), r === "NHWC" ? Ft(A.outShape, g.shape) : (D(g.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`), 
        D(g.shape.length === 0 || g.shape[0] === A.outChannels || g.shape[0] === 1, () => `Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${A.outChannels})`))), 
        p != null) {
            let I = p.shape;
            if (D(I.length <= 1 || I.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`), 
            I.length === 1) D(I[0] === 1 || I[0] === A.outChannels, () => `Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${A.outChannels}).`); else if (I.length === 3) try {
                Ft(I, A.outShape);
            } catch {
                let T = `Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${A.outShape}).`;
                throw Error(T);
            }
            y = _(p, "prelu weights", "fused conv2d");
        }
        let x = (I, N) => {
            D(r === "NHWC", () => `Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);
            let [ T, R, w, E ] = N, $ = fc(I, w, o);
            D(Ed(s), () => `Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);
            let M = [ kg(R.shape, $, T, n, a), ES(R, $, T.shape, n, a) ];
            if (E != null) {
                let F = mc(E, $);
                M.push(F);
            }
            return M;
        }, b = {
            x: h,
            filter: d,
            bias: g,
            preluActivationWeights: y
        }, v = {
            strides: n,
            pad: a,
            dataFormat: r,
            dilations: s,
            dimRoundingMode: i,
            activation: o,
            leakyreluAlpha: u
        };
        return l == null ? Da((I, N, T) => {
            let R = U.runKernel(kr, b, v);
            return T([ N, I, R ]), f && (R = Q(R, [ R.shape[1], R.shape[2], R.shape[3] ])), 
            {
                value: R,
                gradFunc: x
            };
        })(h, d) : Da((I, N, T, R) => {
            let w = U.runKernel(kr, b, v);
            return R([ N, I, w, T ]), f && (w = Q(w, [ w.shape[1], w.shape[2], w.shape[3] ])), 
            {
                value: w,
                gradFunc: x
            };
        })(h, d, g);
    }
}), MS = V({
    depthwiseConv2dNativeBackpropFilter_: function(e, t, n, a, r, s = [ 1, 1 ], i) {
        let l = e;
        e.rank === 3 && (l = Q(e, [ 1, e.shape[0], e.shape[1], e.shape[2] ]));
        let o = t;
        o.rank === 3 && (o = Q(t, [ 1, t.shape[0], t.shape[1], t.shape[2] ]));
        let p = {
            x: l,
            dy: o
        }, u = {
            strides: a,
            pad: r,
            dimRoundingMode: i,
            dilations: s,
            filterShape: n
        };
        return U.runKernel(Zu, p, u);
    }
}), FS = V({
    depthwiseConv2dNativeBackpropInput_: function(e, t, n, a, r, s = [ 1, 1 ], i) {
        let l = t, o = !1;
        t.rank === 3 && (o = !0, l = Q(t, [ 1, t.shape[0], t.shape[1], t.shape[2] ]));
        let p = {
            dy: l,
            filter: n
        }, u = {
            strides: a,
            pad: r,
            dimRoundingMode: i,
            dilations: s,
            inputShape: e
        }, c = U.runKernel(Yu, p, u);
        return o ? Q(c, [ c.shape[1], c.shape[2], c.shape[3] ]) : c;
    }
}), _S = V({
    fusedDepthwiseConv2d_: function({
        x: e,
        filter: t,
        strides: n,
        pad: a,
        dataFormat: r = "NHWC",
        dilations: s = [ 1, 1 ],
        dimRoundingMode: i,
        bias: l,
        activation: o = "linear",
        preluActivationWeights: p,
        leakyreluAlpha: u
    }) {
        if (yc(U.state.gradientDepth, o) === !1) {
            let v = Qp(e, t, n, a, r, s, i);
            return l != null && (v = _e(v, l)), gc(v, o, p, u);
        }
        let c = _(e, "x", "depthwiseConv2d", "float32"), d = _(t, "filter", "depthwiseConv2d", "float32"), h = c, f = !1;
        c.rank === 3 && (f = !0, h = Q(c, [ 1, c.shape[0], c.shape[1], c.shape[2] ])), 
        D(h.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`), 
        D(d.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`), 
        D(h.shape[3] === d.shape[2], () => `Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`), 
        s == null && (s = [ 1, 1 ]), D(Ja(n, s), () => `Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`), 
        ia("fused depthwiseConv2d", a, i);
        let m, g, y = Cd(h.shape, d.shape, n, s, a, i, !0);
        l != null && (m = _(l, "bias", "fused conv2d"), [ m ] = It(m, c), Ft(y.outShape, m.shape)), 
        p != null && (g = _(p, "prelu weights", "fused depthwiseConv2d"));
        let A = (v, I) => {
            D(Ed(s), () => `Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);
            let [ N, T, R, w ] = I, E = fc(v, R, o), $ = FS(T.shape, E, N, n, a, s, i), M = MS(T, E, N.shape, n, a, s, i);
            return w != null ? [ $, M, mc(m, E) ] : [ $, M ];
        }, x = {
            x: h,
            filter: d,
            bias: m,
            preluActivationWeights: g
        }, b = {
            strides: n,
            pad: a,
            dataFormat: r,
            dilations: s,
            dimRoundingMode: i,
            activation: o,
            leakyreluAlpha: u
        };
        return l == null ? Da((v, I, N) => {
            let T = U.runKernel(Ir, x, b);
            return N([ I, v, T ]), f && (T = Q(T, [ T.shape[1], T.shape[2], T.shape[3] ])), 
            {
                value: T,
                gradFunc: A
            };
        })(h, d) : Da((v, I, N, T) => {
            let R = U.runKernel(Ir, x, b);
            return T([ I, v, R, N ]), f && (R = Q(R, [ R.shape[1], R.shape[2], R.shape[3] ])), 
            {
                value: R,
                gradFunc: A
            };
        })(h, d, m);
    }
}), OS = V({
    fusedMatMul_: function({
        a: e,
        b: t,
        transposeA: n = !1,
        transposeB: a = !1,
        bias: r,
        activation: s = "linear",
        preluActivationWeights: i,
        leakyreluAlpha: l = .2
    }) {
        if (yc(U.state.gradientDepth, s) === !1) {
            let w = ut(e, t, n, a);
            return r != null && (w = _e(w, r)), gc(w, s, i, l);
        }
        let o = _(e, "a", "fused matMul"), p = _(t, "b", "fused matMul");
        [ o, p ] = It(o, p);
        let u = n ? o.shape[o.rank - 2] : o.shape[o.rank - 1], c = a ? p.shape[p.rank - 1] : p.shape[p.rank - 2], d = n ? o.shape[o.rank - 1] : o.shape[o.rank - 2], h = a ? p.shape[p.rank - 2] : p.shape[p.rank - 1], f = o.shape.slice(0, -2), m = p.shape.slice(0, -2), g = ht(f), y = ht(m);
        D(u === c, () => `Error in fused matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${o.shape} and ${p.shape} and transposeA=${n} and transposeB=${a} must match.`);
        let A, x, b = Ft(o.shape.slice(0, -2), p.shape.slice(0, -2)).concat([ d, h ]), v = Q(o, n ? [ g, u, d ] : [ g, d, u ]), I = Q(p, a ? [ y, h, c ] : [ y, c, h ]);
        r != null && (A = _(r, "bias", "fused matMul"), [ A ] = It(A, o), Ft(b, A.shape)), 
        i != null && (x = _(i, "prelu weights", "fused matMul"));
        let N = (w, E) => {
            let $, M, [ F, P, L, O ] = E, B = fc(Q(w, L.shape), L, s);
            return n || a ? !n && a ? ($ = ut(B, P, !1, !1), M = ut(B, F, !0, !1)) : n && !a ? ($ = ut(P, B, !1, !0), 
            M = ut(F, B, !1, !1)) : ($ = ut(P, B, !0, !0), M = ut(B, F, !0, !0)) : ($ = ut(B, P, !1, !0), 
            M = ut(F, B, !0, !1)), r != null ? [ $, M, mc(O, B) ] : [ $, M ];
        }, T = {
            a: v,
            b: I,
            bias: A,
            preluActivationWeights: x
        }, R = {
            transposeA: n,
            transposeB: a,
            activation: s,
            leakyreluAlpha: l
        };
        return r == null ? Da((w, E, $) => {
            let M = U.runKernel(wr, T, R);
            return $([ w, E, M ]), {
                value: Q(M, b),
                gradFunc: N
            };
        })(v, I) : Da((w, E, $, M) => {
            let F = U.runKernel(wr, T, R);
            return M([ w, E, F, $ ]), {
                value: Q(F, b),
                gradFunc: N
            };
        })(v, I, A);
    }
}), PS = V({
    hammingWindow_: function(e) {
        return hc(e, .54, .46);
    }
}), iA = V({
    hannWindow_: function(e) {
        return hc(e, .5, .5);
    }
}), oA = V({
    frame_: function(e, t, n, a = !1, r = 0) {
        let s = 0, i = [];
        for (;s + t <= e.size; ) i.push(He(e, s, t)), s += n;
        if (a) for (;s < e.size; ) {
            let l = s + t - e.size, o = yt([ He(e, s, t - l), Qa([ l ], r) ]);
            i.push(o), s += n;
        }
        return i.length === 0 ? Dr([], [ 0, t ]) : Q(yt(i), [ i.length, t ]);
    }
}), DS = V({
    stft_: function(e, t, n, a, r = iA) {
        a == null && (a = em(t));
        let s = oA(e, t, n), i = ne(s, r(t));
        return dc(i, a);
    }
}), zS = V({
    cropAndResize_: function(e, t, n, a, r = "bilinear", s = 0) {
        let i = _(e, "image", "cropAndResize"), l = _(t, "boxes", "cropAndResize", "float32"), o = _(n, "boxInd", "cropAndResize", "int32"), p = l.shape[0];
        D(i.rank === 4, () => `Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`), 
        D(l.rank === 2 && l.shape[1] === 4, () => `Error in cropAndResize: boxes must be have size [${p},4] but had shape ${l.shape}.`), 
        D(o.rank === 1 && o.shape[0] === p, () => `Error in cropAndResize: boxInd must be have size [${p}] but had shape ${l.shape}.`), 
        D(a.length === 2, () => `Error in cropAndResize: cropSize must be of length 2, but got length ${a.length}.`), 
        D(a[0] >= 1 && a[1] >= 1, () => `cropSize must be atleast [1,1], but was ${a}`), 
        D(r === "bilinear" || r === "nearest", () => `method must be bilinear or nearest, but was ${r}`);
        let u = {
            image: i,
            boxes: l,
            boxInd: o
        }, c = {
            method: r,
            extrapolationValue: s,
            cropSize: a
        };
        return U.runKernel(Os, u, c);
    }
}), LS = V({
    flipLeftRight_: function(e) {
        let t = _(e, "image", "flipLeftRight", "float32");
        D(t.rank === 4, () => `Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);
        let n = {
            image: t
        };
        return U.runKernel(Hs, n, {});
    }
}), WS = V({
    grayscaleToRGB_: function(e) {
        let t = _(e, "image", "grayscaleToRGB"), n = t.rank - 1, a = t.shape[n];
        D(t.rank >= 2, () => `Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`), 
        D(a === 1, () => `Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${a}.`);
        let r = new Array(t.rank);
        return r.fill(1, 0, n), r[n] = 3, Ao(t, r);
    }
}), BS = V({
    rgbToGrayscale_: function(e) {
        let t = _(e, "image", "RGBToGrayscale"), n = t.rank - 1, a = t.shape[n];
        D(t.rank >= 2, () => `Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`), 
        D(a === 3, () => `Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${a}.`);
        let r, s = t.dtype, i = Qe(t, "float32"), l = Yt([ .2989, .587, .114 ]);
        switch (t.rank) {
          case 2:
            r = go("ij,j->i", i, l);
            break;

          case 3:
            r = go("ijk,k->ij", i, l);
            break;

          case 4:
            r = go("ijkl,l->ijk", i, l);
            break;

          case 5:
            r = go("ijklm,m->ijkl", i, l);
            break;

          case 6:
            r = go("ijklmn,n->ijklm", i, l);
            break;

          default:
            throw new Error("Not a valid tensor rank.");
        }
        return r = pn(r, -1), Qe(r, s);
    }
}), VS = V({
    rotateWithOffset_: function(e, t, n = 0, a = .5) {
        let r = _(e, "image", "rotateWithOffset", "float32");
        D(r.rank === 4, () => `Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);
        let s = {
            image: r
        }, i = {
            radians: t,
            fillValue: n,
            center: a
        };
        return U.runKernel(ro, s, i);
    }
});

function ru(e, t, n, a, r, s) {
    a == null && (a = .5), r == null && (r = Number.NEGATIVE_INFINITY), s == null && (s = 0);
    let i = e.shape[0];
    return n = Math.min(n, i), D(0 <= a && a <= 1, () => `iouThreshold must be in [0, 1], but was '${a}'`), 
    D(e.rank === 2, () => `boxes must be a 2D tensor, but was of rank '${e.rank}'`), 
    D(e.shape[1] === 4, () => `boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`), 
    D(t.rank === 1, () => "scores must be a 1D tensor"), D(t.shape[0] === i, () => `scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`), 
    D(0 <= s && s <= 1, () => `softNmsSigma must be in [0, 1], but was '${s}'`), 
    {
        maxOutputSize: n,
        iouThreshold: a,
        scoreThreshold: r,
        softNmsSigma: s
    };
}

var US = V({
    nonMaxSuppression_: function(e, t, n, a = .5, r = Number.NEGATIVE_INFINITY) {
        let s = _(e, "boxes", "nonMaxSuppression", "float32"), i = _(t, "scores", "nonMaxSuppression", "float32"), l = ru(s, i, n, a, r), o = {
            maxOutputSize: n = l.maxOutputSize,
            iouThreshold: a = l.iouThreshold,
            scoreThreshold: r = l.scoreThreshold
        };
        return U.runKernel(ki, {
            boxes: s,
            scores: i
        }, o);
    }
});

function GS(e, t, n) {
    let a = function(s, i, l) {
        return function(o, p, u) {
            let c = 0, d = o.length, h = 0, f = !1;
            for (;c < d; ) {
                h = c + (d - c >>> 1);
                let m = u(p, o[h]);
                m > 0 ? c = h + 1 : (d = h, f = !m);
            }
            return f ? c : -c - 1;
        }(s, i, l || HS);
    }(e, t, n), r = a < 0 ? -(a + 1) : a;
    e.splice(r, 0, t);
}

function HS(e, t) {
    return e > t ? 1 : e < t ? -1 : 0;
}

function lA(e, t, n, a, r) {
    return nm(e, t, n, a, r, 0);
}

function uA(e, t, n, a, r, s) {
    return nm(e, t, n, a, r, 0, !1, s, !0);
}

function dA(e, t, n, a, r, s) {
    return nm(e, t, n, a, r, s, !0);
}

function nm(e, t, n, a, r, s, i = !1, l = !1, o = !1) {
    let p = [];
    for (let g = 0; g < t.length; g++) t[g] > r && p.push({
        score: t[g],
        boxIndex: g,
        suppressBeginIndex: 0
    });
    p.sort(pA);
    let u = s > 0 ? -.5 / s : 0, c = [], d = [];
    for (;c.length < n && p.length > 0; ) {
        let g = p.pop(), {
            score: y,
            boxIndex: A,
            suppressBeginIndex: x
        } = g;
        if (y < r) break;
        let b = !1;
        for (let v = c.length - 1; v >= x; --v) {
            let I = jS(e, A, c[v]);
            if (I >= a) {
                b = !0;
                break;
            }
            if (g.score = g.score * qS(a, u, I), g.score <= r) break;
        }
        g.suppressBeginIndex = c.length, b || (g.score === y ? (c.push(A), d.push(g.score)) : g.score > r && GS(p, g, pA));
    }
    let h = c.length, f = n - h;
    l && f > 0 && (c.push(...new Array(f).fill(0)), d.push(...new Array(f).fill(0)));
    let m = {
        selectedIndices: c
    };
    return i && (m.selectedScores = d), o && (m.validOutputs = h), m;
}

function jS(e, t, n) {
    let a = e.subarray(4 * t, 4 * t + 4), r = e.subarray(4 * n, 4 * n + 4), s = Math.min(a[0], a[2]), i = Math.min(a[1], a[3]), l = Math.max(a[0], a[2]), o = Math.max(a[1], a[3]), p = Math.min(r[0], r[2]), u = Math.min(r[1], r[3]), c = Math.max(r[0], r[2]), d = Math.max(r[1], r[3]), h = (l - s) * (o - i), f = (c - p) * (d - u);
    if (h <= 0 || f <= 0) return 0;
    let m = Math.max(s, p), g = Math.max(i, u), y = Math.min(l, c), A = Math.min(o, d), x = Math.max(y - m, 0) * Math.max(A - g, 0);
    return x / (h + f - x);
}

function qS(e, t, n) {
    let a = Math.exp(t * n * n);
    return n <= e ? a : 0;
}

function pA(e, t) {
    return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex;
}

var XS = async function(e, t, n, a = .5, r = Number.NEGATIVE_INFINITY) {
    let s = _(e, "boxes", "nonMaxSuppressionAsync"), i = _(t, "scores", "nonMaxSuppressionAsync"), l = ru(s, i, n, a, r);
    n = l.maxOutputSize, a = l.iouThreshold, r = l.scoreThreshold;
    let o = await Promise.all([ s.data(), i.data() ]), p = o[0], u = o[1], {
        selectedIndices: c
    } = lA(p, u, n, a, r);
    return s !== e && s.dispose(), i !== t && i.dispose(), Yt(c, "int32");
}, KS = V({
    nonMaxSuppressionWithScore_: function(e, t, n, a = .5, r = Number.NEGATIVE_INFINITY, s = 0) {
        let i = _(e, "boxes", "nonMaxSuppression"), l = _(t, "scores", "nonMaxSuppression"), o = ru(i, l, n, a, r, s), p = {
            boxes: i,
            scores: l
        }, u = {
            maxOutputSize: n = o.maxOutputSize,
            iouThreshold: a = o.iouThreshold,
            scoreThreshold: r = o.scoreThreshold,
            softNmsSigma: s = o.softNmsSigma
        }, c = U.runKernel(Ii, p, u);
        return {
            selectedIndices: c[0],
            selectedScores: c[1]
        };
    }
}), ZS = async function(e, t, n, a = .5, r = Number.NEGATIVE_INFINITY, s = 0) {
    let i = _(e, "boxes", "nonMaxSuppressionAsync"), l = _(t, "scores", "nonMaxSuppressionAsync"), o = ru(i, l, n, a, r, s);
    n = o.maxOutputSize, a = o.iouThreshold, r = o.scoreThreshold, s = o.softNmsSigma;
    let p = await Promise.all([ i.data(), l.data() ]), u = p[0], c = p[1], {
        selectedIndices: d,
        selectedScores: h
    } = dA(u, c, n, a, r, s);
    return i !== e && i.dispose(), l !== t && l.dispose(), {
        selectedIndices: Yt(d, "int32"),
        selectedScores: Yt(h)
    };
}, YS = V({
    nonMaxSuppressionPadded_: function(e, t, n, a = .5, r = Number.NEGATIVE_INFINITY, s = !1) {
        let i = _(e, "boxes", "nonMaxSuppression"), l = _(t, "scores", "nonMaxSuppression"), o = ru(i, l, n, a, r, null), p = {
            boxes: i,
            scores: l
        }, u = {
            maxOutputSize: o.maxOutputSize,
            iouThreshold: o.iouThreshold,
            scoreThreshold: o.scoreThreshold,
            padToMaxOutputSize: s
        }, c = U.runKernel(Tl, p, u);
        return {
            selectedIndices: c[0],
            validOutputs: c[1]
        };
    }
}), JS = async function(e, t, n, a = .5, r = Number.NEGATIVE_INFINITY, s = !1) {
    let i = _(e, "boxes", "nonMaxSuppressionAsync"), l = _(t, "scores", "nonMaxSuppressionAsync"), o = ru(i, l, n, a, r, null), p = o.maxOutputSize, u = o.iouThreshold, c = o.scoreThreshold, [ d, h ] = await Promise.all([ i.data(), l.data() ]), {
        selectedIndices: f,
        validOutputs: m
    } = uA(d, h, p, u, c, s);
    return i !== e && i.dispose(), l !== t && l.dispose(), {
        selectedIndices: Yt(f, "int32"),
        validOutputs: je(m, "int32")
    };
}, QS = V({
    resizeBilinear_: function(e, t, n = !1, a = !1) {
        let r = _(e, "images", "resizeBilinear");
        D(r.rank === 3 || r.rank === 4, () => `Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`), 
        D(t.length === 2, () => `Error in resizeBilinear: new shape must 2D, but got shape ${t}.`), 
        D(a === !1 || n === !1, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
        let s = r, i = !1;
        r.rank === 3 && (i = !0, s = Q(r, [ 1, r.shape[0], r.shape[1], r.shape[2] ]));
        let l = {
            images: s
        }, o = {
            alignCorners: n,
            halfPixelCenters: a,
            size: t
        }, p = U.runKernel(Fi, l, o);
        return i ? Q(p, [ p.shape[1], p.shape[2], p.shape[3] ]) : p;
    }
}), e8 = V({
    resizeNearestNeighbor_: function(e, t, n = !1, a = !1) {
        let r = _(e, "images", "resizeNearestNeighbor");
        D(r.rank === 3 || r.rank === 4, () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`), 
        D(t.length === 2, () => `Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`), 
        D(r.dtype === "float32" || r.dtype === "int32", () => "`images` must have `int32` or `float32` as dtype"), 
        D(a === !1 || n === !1, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
        let s = r, i = !1;
        r.rank === 3 && (i = !0, s = Q(r, [ 1, r.shape[0], r.shape[1], r.shape[2] ]));
        let l = {
            images: s
        }, o = {
            alignCorners: n,
            halfPixelCenters: a,
            size: t
        }, p = U.runKernel(Mi, l, o);
        return i ? Q(p, [ p.shape[1], p.shape[2], p.shape[3] ]) : p;
    }
}), t8 = V({
    threshold_: function(e, t = "binary", n = !1, a = .5) {
        let r, s, i, l, o = _(e, "image", "threshold"), p = o.shape[0] * o.shape[1], u = ne(Yt([ a ]), 255);
        if (D(o.rank === 3, () => `Error in threshold: image must be rank 3,but got rank ${o.rank}.`), 
        D(o.shape[2] === 3 || o.shape[2] === 1, () => `Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`), 
        D(o.dtype === "int32" || o.dtype === "float32", () => `Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`), 
        D(t === "otsu" || t === "binary", () => `Method must be binary or otsu, but was ${t}`), 
        o.shape[2] === 3) {
            [ r, s, i ] = Ia(o, [ 1, 1, 1 ], -1);
            let d = ne(r, .2989), h = ne(s, .587), f = ne(i, .114);
            l = _e(_e(d, h), f);
        } else l = e;
        t === "otsu" && (u = function(d, h) {
            let f, m, g, y, A, x, b = Yt([ -1 ]), v = Yt([ 0 ]), I = Yt([ 0 ]);
            for (let N = 0; N < d.size - 1; N++) {
                f = He(d, 0, N + 1), m = He(d, N + 1), A = ze(dt(f), h), x = ze(dt(m), h);
                let T = dt(ne(f, tu(0, f.size)));
                g = ze(T, dt(f));
                let R = Qa(m.shape, f.size), w = _e(tu(0, m.size), R), E = ne(m, w);
                y = ze(dt(E), dt(m));
                let $ = $e(g, y), M = $e(g, y), F = ne(A, x);
                I = ne(ne(F, $), M);
                let P = Od(I, v);
                v = er(P, I, v), b = er(P, Yt([ N ]), b);
            }
            return b;
        }(Af(Qe(Hf(l), "int32"), Ye([]), 256), p));
        let c = n ? tc(l, u) : Od(l, u);
        return Qe(ne(c, 255), "int32");
    }
}), n8 = V({
    transform_: function(e, t, n = "nearest", a = "constant", r = 0, s) {
        let i = _(e, "image", "transform", "float32"), l = _(t, "transforms", "transform", "float32");
        D(i.rank === 4, () => `Error in transform: image must be rank 4,but got rank ${i.rank}.`), 
        D(l.rank === 2 && (l.shape[0] === i.shape[0] || l.shape[0] === 1) && l.shape[1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), 
        D(s == null || s.length === 2, () => `Error in transform: outputShape must be [height, width] or null, but got ${s}.`);
        let o = {
            image: i,
            transforms: l
        }, p = {
            interpolation: n,
            fillMode: a,
            fillValue: r,
            outputShape: s
        };
        return U.runKernel(ao, o, p);
    }
}), a8 = V({
    bandPart_: function(e, t, n) {
        let a = _(e, "a", "bandPart");
        D(a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${a.rank}.`);
        let r, s, i = a.shape, [ l, o ] = a.shape.slice(-2);
        typeof t == "number" ? (D(t % 1 == 0, () => `bandPart(): numLower must be an integer, got ${t}.`), 
        D(t <= l, () => `bandPart(): numLower (${t}) must not be greater than the number of rows (${l}).`), 
        r = _(t < 0 ? l : t, "numLower", "bandPart")) : (D(t.dtype === "int32", () => "bandPart(): numLower's dtype must be an int32."), 
        r = er(ec(t, 0), l, Ld(t, l))), typeof n == "number" ? (D(n % 1 == 0, () => `bandPart(): numUpper must be an integer, got ${n}.`), 
        D(n <= o, () => `bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`), 
        s = _(n < 0 ? o : n, "numUpper", "bandPart")) : (D(n.dtype === "int32", () => "bandPart(): numUpper's dtype must be an int32."), 
        s = er(ec(n, 0), o, Ld(n, o)));
        let p = Q(tu(0, l, 1, "int32"), [ -1, 1 ]), u = tu(0, o, 1, "int32"), c = $e(p, u), d = Dd(tc(c, r), Nf(c, wa(s))), h = ka([ l, o ], a.dtype);
        return Q(Bn(la(Q(a, [ -1, l, o ])).map(f => er(d, f, h))), i);
    }
}), r8 = V({
    gramSchmidt_: function(e) {
        let t;
        if (Array.isArray(e)) {
            t = !1, D(e != null && e.length > 0, () => "Gram-Schmidt process: input must not be null, undefined, or empty");
            let r = e[0].shape[0];
            for (let s = 1; s < e.length; ++s) D(e[s].shape[0] === r, () => `Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`);
        } else t = !0, e = Ia(e, e.shape[0], 0).map(r => at(r, [ 0 ]));
        D(e.length <= e[0].shape[0], () => `Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);
        let n = [], a = e;
        for (let r = 0; r < e.length; ++r) n.push(U.tidy(() => {
            let s = a[r];
            if (r > 0) for (let i = 0; i < r; ++i) {
                let l = ne(dt(ne(n[i], s)), n[i]);
                s = $e(s, l);
            }
            return ze(s, _d(s, "euclidean"));
        }));
        return t ? Bn(n, 0) : n;
    }
});

function cA(e, t = !1) {
    return U.tidy(() => {
        D(e.shape.length === 2, () => `qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);
        let n = e.shape[0], a = e.shape[1], r = kf(n), s = wn(e), i = Dr([ [ 1 ] ], [ 1, 1 ]), l = wn(i), o = n >= a ? a : n;
        for (let p = 0; p < o; ++p) {
            let u = s, c = l, d = r;
            [ l, s, r ] = U.tidy(() => {
                let h = He(s, [ p, p ], [ n - p, 1 ]), f = _d(h), m = He(s, [ p, p ], [ 1, 1 ]), g = er(Od(m, 0), Dr([ [ -1 ] ]), Dr([ [ 1 ] ])), y = $e(m, ne(g, f)), A = ze(h, y);
                l = A.shape[0] === 1 ? wn(i) : yt([ i, He(A, [ 1, 0 ], [ A.shape[0] - 1, A.shape[1] ]) ], 0);
                let x = wa(ze(ut(g, y), f)), b = He(s, [ p, 0 ], [ n - p, a ]), v = ne(x, l), I = au(l);
                if (p === 0) s = $e(b, ut(v, ut(I, b))); else {
                    let R = $e(b, ut(v, ut(I, b)));
                    s = yt([ He(s, [ 0, 0 ], [ p, a ]), R ], 0);
                }
                let N = au(v), T = He(r, [ 0, p ], [ n, r.shape[1] - p ]);
                if (p === 0) r = $e(T, ut(ut(T, l), N)); else {
                    let R = $e(T, ut(ut(T, l), N));
                    r = yt([ He(r, [ 0, 0 ], [ n, p ]), R ], 1);
                }
                return [ l, s, r ];
            }), ae([ u, c, d ]);
        }
        return !t && n > a && (r = He(r, [ 0, 0 ], [ n, a ]), s = He(s, [ 0, 0 ], [ a, a ])), 
        [ r, s ];
    });
}

var cn, s8 = V({
    qr_: function(e, t = !1) {
        if (D(e.rank >= 2, () => `qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`), 
        e.rank === 2) return cA(e, t);
        {
            let n = e.shape.slice(0, e.shape.length - 2).reduce((i, l) => i * l), a = la(Q(e, [ n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1] ]), 0), r = [], s = [];
            return a.forEach(i => {
                let [ l, o ] = cA(i, t);
                r.push(l), s.push(o);
            }), [ Q(Bn(r, 0), e.shape), Q(Bn(s, 0), e.shape) ];
        }
    }
});

(function(e) {
    e[e.NONE = 0] = "NONE", e[e.MEAN = 1] = "MEAN", e[e.SUM = 2] = "SUM", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(cn || (cn = {}));

var tr = V({
    computeWeightedLoss_: function(e, t, n = cn.SUM_BY_NONZERO_WEIGHTS) {
        let a = _(e, "losses", "computeWeightedLoss"), r = null;
        t != null && (r = _(t, "weights", "computeWeightedLoss"));
        let s = r == null ? a : ne(a, r);
        if (n === cn.NONE) return s;
        if (n === cn.SUM) return dt(s);
        if (n === cn.MEAN) {
            if (r == null) return zd(s);
            {
                let i = a.size / r.size, l = ze(dt(s), dt(r));
                return i > 1 ? ze(l, je(i)) : l;
            }
        }
        if (n === cn.SUM_BY_NONZERO_WEIGHTS) {
            if (r == null) return ze(dt(s), je(a.size));
            {
                let i = ne(r, _r(a.shape)), l = Qe(dt(Of(i, je(0))), "float32");
                return ze(dt(s), l);
            }
        }
        throw Error(`Unknown reduction: ${n}`);
    }
}), i8 = V({
    absoluteDifference_: function(e, t, n, a = cn.SUM_BY_NONZERO_WEIGHTS) {
        let r = _(e, "labels", "absoluteDifference"), s = _(t, "predictions", "absoluteDifference"), i = null;
        n != null && (i = _(n, "weights", "absoluteDifference")), ln(r.shape, s.shape, "Error in absoluteDifference: ");
        let l = Ln($e(r, s));
        return tr(l, i, a);
    }
}), o8 = V({
    cosineDistance_: function(e, t, n, a, r = cn.SUM_BY_NONZERO_WEIGHTS) {
        let s = _(e, "labels", "cosineDistance"), i = _(t, "predictions", "cosineDistance"), l = null;
        a != null && (l = _(a, "weights", "cosineDistance")), ln(s.shape, i.shape, "Error in cosineDistance: ");
        let o = je(1), p = $e(o, dt(ne(s, i), n, !0));
        return tr(p, l, r);
    }
}), l8 = V({
    hingeLoss_: function(e, t, n, a = cn.SUM_BY_NONZERO_WEIGHTS) {
        let r = _(e, "labels", "hingeLoss"), s = _(t, "predictions", "hingeLoss"), i = null;
        n != null && (i = _(n, "weights", "hingeLoss")), ln(r.shape, s.shape, "Error in hingeLoss: ");
        let l = je(1);
        r = $e(ne(je(2), r), l);
        let o = Wd($e(l, ne(r, s)));
        return tr(o, i, a);
    }
}), u8 = V({
    huberLoss_: function(e, t, n, a = 1, r = cn.SUM_BY_NONZERO_WEIGHTS) {
        let s = _(e, "labels", "huberLoss"), i = _(t, "predictions", "huberLoss"), l = null;
        n != null && (l = _(n, "weights", "huberLoss")), ln(s.shape, i.shape, "Error in huberLoss: ");
        let o = je(a), p = Ln($e(i, s)), u = Ld(p, o), c = $e(p, u), d = _e(ne(je(.5), oa(u)), ne(o, c));
        return tr(d, l, r);
    }
}), d8 = V({
    logLoss_: function(e, t, n, a = 1e-7, r = cn.SUM_BY_NONZERO_WEIGHTS) {
        let s = _(e, "labels", "logLoss"), i = _(t, "predictions", "logLoss"), l = null;
        n != null && (l = _(n, "weights", "logLoss")), ln(s.shape, i.shape, "Error in logLoss: ");
        let o = je(1), p = je(a), u = wa(ne(s, eu(_e(i, p)))), c = ne($e(o, s), eu(_e($e(o, i), p))), d = $e(u, c);
        return tr(d, l, r);
    }
}), p8 = V({
    meanSquaredError_: function(e, t, n, a = cn.SUM_BY_NONZERO_WEIGHTS) {
        let r = _(e, "labels", "meanSquaredError"), s = _(t, "predictions", "meanSquaredError"), i = null;
        n != null && (i = _(n, "weights", "meanSquaredError")), ln(r.shape, s.shape, "Error in meanSquaredError: ");
        let l = Kf(r, s);
        return tr(l, i, a);
    }
}), c8 = V({
    sigmoidCrossEntropy_: function(e, t, n, a = 0, r = cn.SUM_BY_NONZERO_WEIGHTS) {
        let s = _(e, "multiClassLabels", "sigmoidCrossEntropy"), i = _(t, "logits", "sigmoidCrossEntropy"), l = null;
        if (n != null && (l = _(n, "weights", "sigmoidCrossEntropy")), ln(s.shape, i.shape, "Error in sigmoidCrossEntropy: "), 
        a > 0) {
            let p = je(a), u = je(1), c = je(.5);
            s = _e(ne(s, $e(u, p)), ne(c, p));
        }
        let o = function(p, u) {
            let c = _(p, "labels", "sigmoidCrossEntropyWithLogits"), d = _(u, "logits", "sigmoidCrossEntropyWithLogits");
            ln(c.shape, d.shape, "Error in sigmoidCrossEntropyWithLogits: ");
            let h = Wd(d), f = ne(d, c), m = Tf(Fr(wa(Ln(d))));
            return _e($e(h, f), m);
        }(s, i);
        return tr(o, l, r);
    }
}), h8 = V({
    softmaxCrossEntropy_: function(e, t, n, a = 0, r = cn.SUM_BY_NONZERO_WEIGHTS) {
        let s = _(e, "onehotLabels", "softmaxCrossEntropy"), i = _(t, "logits", "softmaxCrossEntropy"), l = null;
        if (n != null && (l = _(n, "weights", "softmaxCrossEntropy")), ln(s.shape, i.shape, "Error in softmaxCrossEntropy: "), 
        a > 0) {
            let p = je(a), u = je(1), c = je(s.shape[1]);
            s = _e(ne(s, $e(u, p)), ze(p, c));
        }
        let o = function(p, u, c = -1) {
            if (c === -1 && (c = u.rank - 1), c !== u.rank - 1) throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${u.rank} and dim was ${c}`);
            return Da((d, h, f) => {
                let m = Ef(h, [ c ], !0), g = $e(Qe(h, "float32"), m);
                f([ d, g ]);
                let y = wa(ne(g, d));
                return {
                    value: dt(y, [ c ]),
                    gradFunc: (A, x) => {
                        let [ b, v ] = x, I = Fd(A.shape, [ c ]);
                        return [ ne(Q(A, I), $e(Qe(b, "float32"), Fr(v))), ne(Q(A, I), $e(Fr(v), Qe(b, "float32"))) ];
                    }
                };
            })(p, u);
        }(s, i);
        return tr(o, l, r);
    }
}), f8 = V({
    sparseFillEmptyRows_: function(e, t, n, a) {
        let r = _(e, "indices", "sparseFillEmptyRows", "int32"), s = _(t, "values", "sparseFillEmptyRows"), i = _(n, "denseShape", "sparseFillEmptyRows", "int32"), l = _(a, "defaultValue", "sparseFillEmptyRows", s.dtype);
        if (r.rank !== 2) throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);
        if (s.rank !== 1) throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);
        if (i.rank !== 1) throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);
        if (l.rank !== 0) throw new Error(`Default value should be a scalar but received shape ${l.shape}`);
        let o = {
            indices: r,
            values: s,
            denseShape: i,
            defaultValue: l
        }, p = U.runKernel(id, o);
        return {
            outputIndices: p[0],
            outputValues: p[1],
            emptyRowIndicator: p[2],
            reverseIndexMap: p[3]
        };
    }
}), m8 = V({
    sparseReshape_: function(e, t, n) {
        let a = _(e, "inputIndices", "sparseReshape", "int32"), r = _(t, "inputShape", "sparseReshape", "int32"), s = _(n, "newShape", "sparseReshape", "int32");
        if (a.rank !== 2) throw new Error(`Input indices should be Tensor2D but received shape
        ${a.shape}`);
        if (r.rank !== 1) throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);
        if (s.rank !== 1) throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);
        let i = {
            inputIndices: a,
            inputShape: r,
            newShape: s
        }, l = U.runKernel(Ll, i);
        return {
            outputIndices: l[0],
            outputShape: l[1]
        };
    }
}), g8 = V({
    sparseSegmentMean_: function(e, t, n) {
        let a = _(e, "data", "sparseSegmentMean"), r = _(t, "indices", "sparseSegmentMean", "int32"), s = _(n, "segmentIds", "sparseSegmentMean", "int32");
        if (a.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (r.rank !== 1) throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);
        if (s.rank !== 1) throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);
        let i = {
            data: a,
            indices: r,
            segmentIds: s
        };
        return U.runKernel(Wl, i);
    }
}), y8 = V({
    sparseSegmentSum_: function(e, t, n) {
        let a = _(e, "data", "sparseSegmentSum"), r = _(t, "indices", "sparseSegmentSum", "int32"), s = _(n, "segmentIds", "sparseSegmentSum", "int32");
        if (a.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (r.rank !== 1) throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);
        if (s.rank !== 1) throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);
        let i = {
            data: a,
            indices: r,
            segmentIds: s
        };
        return U.runKernel(Bl, i);
    }
}), A8 = V({
    stringNGrams_: function(e, t, n, a, r, s, i, l) {
        let o = _(e, "data", "stringNGrams", "string");
        if (o.dtype !== "string") throw new Error("Data must be of datatype string");
        if (o.shape.length !== 1) throw new Error(`Data must be a vector, saw: ${o.shape}`);
        let p = _(t, "dataSplits", "stringNGrams");
        if (p.dtype !== "int32") throw new Error("Data splits must be of datatype int32");
        let u = {
            separator: n,
            nGramWidths: a,
            leftPad: r,
            rightPad: s,
            padWidth: i,
            preserveShortSequences: l
        }, c = {
            data: o,
            dataSplits: p
        }, d = U.runKernel(Vl, c, u);
        return {
            nGrams: d[0],
            nGramsSplits: d[1]
        };
    }
}), x8 = V({
    stringSplit_: function(e, t, n = !0) {
        let a = _(e, "input", "stringSplit", "string"), r = _(t, "delimiter", "stringSplit", "string");
        if (a.rank !== 1) throw new Error(`Input should be Tensor1D but received shape ${a.shape}`);
        if (r.rank !== 0) throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);
        let s = {
            skipEmpty: n
        }, i = {
            input: a,
            delimiter: r
        }, l = U.runKernel(ud, i, s);
        return {
            indices: l[0],
            values: l[1],
            shape: l[2]
        };
    }
}), b8 = V({
    stringToHashBucketFast_: function(e, t) {
        let n = _(e, "input", "stringToHashBucketFast", "string"), a = {
            numBuckets: t
        };
        if (t <= 0) throw new Error("Number of buckets must be at least 1");
        let r = {
            input: n
        };
        return U.runKernel(dd, r, a);
    }
}), v8 = V({
    staticRegexReplace_: function(e, t, n, a = !0) {
        let r = _(e, "input", "staticRegexReplace", "string"), s = {
            pattern: t,
            rewrite: n,
            replaceGlobal: a
        };
        return U.runKernel(ld, {
            x: r
        }, s);
    }
}), hA = {
    fft: uc,
    ifft: Bd,
    rfft: dc,
    irfft: Xf
}, fA = {
    hammingWindow: PS,
    hannWindow: iA,
    frame: oA,
    stft: DS
}, Ue = {
    flipLeftRight: LS,
    grayscaleToRGB: WS,
    resizeNearestNeighbor: e8,
    resizeBilinear: QS,
    rgbToGrayscale: BS,
    rotateWithOffset: VS,
    cropAndResize: zS,
    nonMaxSuppression: US,
    nonMaxSuppressionAsync: XS,
    nonMaxSuppressionWithScore: KS,
    nonMaxSuppressionWithScoreAsync: ZS,
    nonMaxSuppressionPadded: YS,
    nonMaxSuppressionPaddedAsync: JS,
    threshold: t8,
    transform: n8
}, mA = {
    bandPart: a8,
    gramSchmidt: r8,
    qr: s8
}, gA = {
    absoluteDifference: i8,
    computeWeightedLoss: tr,
    cosineDistance: o8,
    hingeLoss: l8,
    huberLoss: u8,
    logLoss: d8,
    meanSquaredError: p8,
    sigmoidCrossEntropy: c8,
    softmaxCrossEntropy: h8
}, yA = {
    sparseFillEmptyRows: f8,
    sparseReshape: m8,
    sparseSegmentMean: g8,
    sparseSegmentSum: y8
}, AA = {
    stringNGrams: A8,
    stringSplit: x8,
    stringToHashBucketFast: b8,
    staticRegexReplace: v8
}, xA = {};

Ze(xA, {
    Serializable: () => bA,
    SerializationMap: () => vA,
    getRegisteredName: () => k8,
    registerClass: () => wA
});

var w8 = new Map(), am = new Map(), bA = class {
    getClassName() {
        return this.constructor.className;
    }
    static fromConfig(e, t) {
        return new e(t);
    }
}, vA = class Pu {
    constructor() {
        this.classNameMap = {};
    }
    static getMap() {
        return Pu.instance == null && (Pu.instance = new Pu()), Pu.instance;
    }
    static register(t) {
        Pu.getMap().classNameMap[t.className] = [ t, t.fromConfig ];
    }
};

function wA(e, t, n) {
    D(e.className != null, () => "Class being registered does not have the static className property defined."), 
    D(typeof e.className == "string", () => "className is required to be a string, but got type " + typeof e.className), 
    D(e.className.length > 0, () => "Class being registered has an empty-string as its className, which is disallowed."), 
    t === void 0 && (t = "Custom"), n === void 0 && (n = e.className);
    let a = t + ">" + n;
    return vA.register(e), w8.set(a, e), am.set(e, a), e;
}

function k8(e) {
    return am.has(e) ? am.get(e) : e.className;
}

var zr = class extends bA {
    minimize(e, t = !1, n) {
        let {
            value: a,
            grads: r
        } = this.computeGradients(e, n);
        if (n != null) {
            let s = n.map(i => ({
                name: i.name,
                tensor: r[i.name]
            }));
            this.applyGradients(s);
        } else this.applyGradients(r);
        return ae(r), t ? a : (a.dispose(), null);
    }
    get iterations() {
        return this.iterations_ == null && (this.iterations_ = 0), this.iterations_;
    }
    incrementIterations() {
        this.iterations_ = this.iterations + 1;
    }
    computeGradients(e, t) {
        return Kg(e, t);
    }
    dispose() {
        this.iterations_ != null && ae(this.iterations_);
    }
    async saveIterations() {
        return this.iterations_ == null && (this.iterations_ = 0), {
            name: "iter",
            tensor: je(this.iterations_, "int32")
        };
    }
    async getWeights() {
        throw new Error("getWeights() is not implemented for this optimizer yet.");
    }
    async setWeights(e) {
        throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`);
    }
    async extractIterations(e) {
        return this.iterations_ = (await e[0].tensor.data())[0], e.slice(1);
    }
};

Object.defineProperty(zr, Symbol.hasInstance, {
    value: e => e.minimize != null && e.computeGradients != null && e.applyGradients != null
});

var rm = class extends zr {
    static get className() {
        return "Adadelta";
    }
    constructor(e, t, n = null) {
        super(), this.learningRate = e, this.rho = t, this.epsilon = n, this.accumulatedGrads = [], 
        this.accumulatedUpdates = [], n == null && (this.epsilon = U.backend.epsilon());
    }
    applyGradients(e) {
        (Array.isArray(e) ? e.map(t => t.name) : Object.keys(e)).forEach((t, n) => {
            let a = U.registeredVariables[t], r = !1;
            this.accumulatedGrads[n] == null && (this.accumulatedGrads[n] = {
                originalName: `${t}/accum_grad`,
                variable: qe(() => Wn(a).variable(r))
            }), this.accumulatedUpdates[n] == null && (this.accumulatedUpdates[n] = {
                originalName: `${t}/accum_var`,
                variable: qe(() => Wn(a).variable(r))
            });
            let s = Array.isArray(e) ? e[n].tensor : e[t];
            if (s == null) return;
            let i = this.accumulatedGrads[n].variable, l = this.accumulatedUpdates[n].variable;
            qe(() => {
                let o = _e(ne(i, this.rho), ne(oa(s), 1 - this.rho)), p = ne(ze(Pa(_e(l, this.epsilon)), Pa(_e(i, this.epsilon))), s), u = _e(ne(l, this.rho), ne(oa(p), 1 - this.rho));
                i.assign(o), l.assign(u);
                let c = _e(ne(p, -this.learningRate), a);
                a.assign(c);
            });
        }), this.incrementIterations();
    }
    dispose() {
        this.accumulatedUpdates != null && (ae(this.accumulatedGrads.map(e => e.variable)), 
        ae(this.accumulatedUpdates.map(e => e.variable)));
    }
    async getWeights() {
        let e = [ ...this.accumulatedGrads, ...this.accumulatedUpdates ];
        return [ await this.saveIterations() ].concat(e.map(t => ({
            name: t.originalName,
            tensor: t.variable
        })));
    }
    async setWeights(e) {
        let t = (e = await this.extractIterations(e)).length / 2, n = !1;
        this.accumulatedGrads = e.slice(0, t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        })), this.accumulatedUpdates = e.slice(t, 2 * t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        }));
    }
    getConfig() {
        return {
            learningRate: this.learningRate,
            rho: this.rho,
            epsilon: this.epsilon
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate, t.rho, t.epsilon);
    }
}, sm = class extends zr {
    static get className() {
        return "Adagrad";
    }
    constructor(e, t = .1) {
        super(), this.learningRate = e, this.initialAccumulatorValue = t, this.accumulatedGrads = [];
    }
    applyGradients(e) {
        (Array.isArray(e) ? e.map(t => t.name) : Object.keys(e)).forEach((t, n) => {
            let a = U.registeredVariables[t];
            this.accumulatedGrads[n] == null && (this.accumulatedGrads[n] = {
                originalName: `${t}/accumulator`,
                variable: qe(() => Qa(a.shape, this.initialAccumulatorValue).variable(!1))
            });
            let r = Array.isArray(e) ? e[n].tensor : e[t];
            if (r == null) return;
            let s = this.accumulatedGrads[n].variable;
            qe(() => {
                let i = _e(s, oa(r));
                s.assign(i);
                let l = _e(ne(ze(r, Pa(_e(i, U.backend.epsilon()))), -this.learningRate), a);
                a.assign(l);
            });
        }), this.incrementIterations();
    }
    dispose() {
        this.accumulatedGrads != null && ae(this.accumulatedGrads.map(e => e.variable));
    }
    async getWeights() {
        return [ await this.saveIterations() ].concat(this.accumulatedGrads.map(e => ({
            name: e.originalName,
            tensor: e.variable
        })));
    }
    async setWeights(e) {
        e = await this.extractIterations(e), this.accumulatedGrads = e.map(t => ({
            originalName: t.name,
            variable: t.tensor.variable(!1)
        }));
    }
    getConfig() {
        return {
            learningRate: this.learningRate,
            initialAccumulatorValue: this.initialAccumulatorValue
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate, t.initialAccumulatorValue);
    }
}, im = class extends zr {
    static get className() {
        return "Adam";
    }
    constructor(e, t, n, a = null) {
        super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = a, 
        this.accumulatedFirstMoment = [], this.accumulatedSecondMoment = [], qe(() => {
            this.accBeta1 = je(t).variable(), this.accBeta2 = je(n).variable();
        }), a == null && (this.epsilon = U.backend.epsilon());
    }
    applyGradients(e) {
        let t = Array.isArray(e) ? e.map(n => n.name) : Object.keys(e);
        qe(() => {
            let n = $e(1, this.accBeta1), a = $e(1, this.accBeta2);
            t.forEach((r, s) => {
                let i = U.registeredVariables[r], l = !1;
                this.accumulatedFirstMoment[s] == null && (this.accumulatedFirstMoment[s] = {
                    originalName: `${r}/m`,
                    variable: qe(() => Wn(i).variable(l))
                }), this.accumulatedSecondMoment[s] == null && (this.accumulatedSecondMoment[s] = {
                    originalName: `${r}/v`,
                    variable: qe(() => Wn(i).variable(l))
                });
                let o = Array.isArray(e) ? e[s].tensor : e[r];
                if (o == null) return;
                let p = this.accumulatedFirstMoment[s].variable, u = this.accumulatedSecondMoment[s].variable, c = _e(ne(p, this.beta1), ne(o, 1 - this.beta1)), d = _e(ne(u, this.beta2), ne(oa(o), 1 - this.beta2)), h = ze(c, n), f = ze(d, a);
                p.assign(c), u.assign(d);
                let m = _e(ne(ze(h, _e(Pa(f), this.epsilon)), -this.learningRate), i);
                i.assign(m);
            }), this.accBeta1.assign(ne(this.accBeta1, this.beta1)), this.accBeta2.assign(ne(this.accBeta2, this.beta2));
        }), this.incrementIterations();
    }
    dispose() {
        this.accBeta1.dispose(), this.accBeta2.dispose(), this.accumulatedFirstMoment != null && ae(this.accumulatedFirstMoment.map(e => e.variable)), 
        this.accumulatedSecondMoment != null && ae(this.accumulatedSecondMoment.map(e => e.variable));
    }
    async getWeights() {
        let e = [ ...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment ];
        return [ await this.saveIterations() ].concat(e.map(t => ({
            name: t.originalName,
            tensor: t.variable
        })));
    }
    async setWeights(e) {
        e = await this.extractIterations(e), qe(() => {
            this.accBeta1.assign(Ql(this.beta1, this.iterations_ + 1)), this.accBeta2.assign(Ql(this.beta2, this.iterations_ + 1));
        });
        let t = e.length / 2, n = !1;
        this.accumulatedFirstMoment = e.slice(0, t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        })), this.accumulatedSecondMoment = e.slice(t, 2 * t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        }));
    }
    getConfig() {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);
    }
}, om = class extends zr {
    static get className() {
        return "Adamax";
    }
    constructor(e, t, n, a = null, r = 0) {
        super(), this.learningRate = e, this.beta1 = t, this.beta2 = n, this.epsilon = a, 
        this.decay = r, this.accumulatedFirstMoment = [], this.accumulatedWeightedInfNorm = [], 
        qe(() => {
            this.iteration = je(0).variable(), this.accBeta1 = je(t).variable();
        }), a == null && (this.epsilon = U.backend.epsilon());
    }
    applyGradients(e) {
        let t = Array.isArray(e) ? e.map(n => n.name) : Object.keys(e);
        qe(() => {
            let n = $e(1, this.accBeta1), a = ze(-this.learningRate, _e(ne(this.iteration, this.decay), 1));
            t.forEach((r, s) => {
                let i = U.registeredVariables[r], l = !1;
                this.accumulatedFirstMoment[s] == null && (this.accumulatedFirstMoment[s] = {
                    originalName: `${r}/m`,
                    variable: Wn(i).variable(l)
                }), this.accumulatedWeightedInfNorm[s] == null && (this.accumulatedWeightedInfNorm[s] = {
                    originalName: `${r}/v`,
                    variable: Wn(i).variable(l)
                });
                let o = Array.isArray(e) ? e[s].tensor : e[r];
                if (o == null) return;
                let p = this.accumulatedFirstMoment[s].variable, u = this.accumulatedWeightedInfNorm[s].variable, c = _e(ne(p, this.beta1), ne(o, 1 - this.beta1)), d = ne(u, this.beta2), h = Ln(o), f = _f(d, h);
                p.assign(c), u.assign(f);
                let m = _e(ne(ze(a, n), ze(c, _e(f, this.epsilon))), i);
                i.assign(m);
            }), this.iteration.assign(_e(this.iteration, 1)), this.accBeta1.assign(ne(this.accBeta1, this.beta1));
        }), this.incrementIterations();
    }
    dispose() {
        this.accBeta1.dispose(), this.iteration.dispose(), this.accumulatedFirstMoment != null && ae(this.accumulatedFirstMoment.map(e => e.variable)), 
        this.accumulatedWeightedInfNorm != null && ae(this.accumulatedWeightedInfNorm.map(e => e.variable));
    }
    async getWeights() {
        throw new Error("getWeights() is not implemented for Adamax yet.");
    }
    async setWeights(e) {
        throw new Error("setWeights() is not implemented for Adamax yet.");
    }
    getConfig() {
        return {
            learningRate: this.learningRate,
            beta1: this.beta1,
            beta2: this.beta2,
            epsilon: this.epsilon,
            decay: this.decay
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);
    }
}, Ac = class extends zr {
    static get className() {
        return "SGD";
    }
    constructor(e) {
        super(), this.learningRate = e, this.setLearningRate(e);
    }
    applyGradients(e) {
        (Array.isArray(e) ? e.map(t => t.name) : Object.keys(e)).forEach((t, n) => {
            let a = Array.isArray(e) ? e[n].tensor : e[t];
            if (a == null) return;
            let r = U.registeredVariables[t];
            qe(() => {
                let s = _e(ne(this.c, a), r);
                r.assign(s);
            });
        }), this.incrementIterations();
    }
    setLearningRate(e) {
        this.learningRate = e, this.c != null && this.c.dispose(), this.c = ba(je(-e));
    }
    dispose() {
        this.c.dispose();
    }
    async getWeights() {
        return [ await this.saveIterations() ];
    }
    async setWeights(e) {
        if ((e = await this.extractIterations(e)).length !== 0) throw new Error("SGD optimizer does not have settable weights.");
    }
    getConfig() {
        return {
            learningRate: this.learningRate
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate);
    }
}, lm = class extends Ac {
    static get className() {
        return "Momentum";
    }
    constructor(e, t, n = !1) {
        super(e), this.learningRate = e, this.momentum = t, this.useNesterov = n, 
        this.accumulations = [], this.m = je(this.momentum);
    }
    applyGradients(e) {
        (Array.isArray(e) ? e.map(t => t.name) : Object.keys(e)).forEach((t, n) => {
            let a = U.registeredVariables[t];
            this.accumulations[n] == null && (this.accumulations[n] = {
                originalName: `${t}/momentum`,
                variable: qe(() => Wn(a).variable(!1))
            });
            let r = this.accumulations[n].variable, s = Array.isArray(e) ? e[n].tensor : e[t];
            s != null && qe(() => {
                let i, l = _e(ne(this.m, r), s);
                i = this.useNesterov ? _e(ne(this.c, _e(s, ne(l, this.m))), a) : _e(ne(this.c, l), a), 
                r.assign(l), a.assign(i);
            });
        }), this.incrementIterations();
    }
    dispose() {
        this.m.dispose(), this.accumulations != null && ae(this.accumulations.map(e => e.variable));
    }
    setMomentum(e) {
        this.momentum = e;
    }
    async getWeights() {
        return [ await this.saveIterations() ].concat(this.accumulations.map(e => ({
            name: e.originalName,
            tensor: e.variable
        })));
    }
    async setWeights(e) {
        e = await this.extractIterations(e), this.accumulations = e.map(t => ({
            originalName: t.name,
            variable: t.tensor.variable(!1)
        }));
    }
    getConfig() {
        return {
            learningRate: this.learningRate,
            momentum: this.momentum,
            useNesterov: this.useNesterov
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate, t.momentum, t.useNesterov);
    }
}, um = class extends zr {
    static get className() {
        return "RMSProp";
    }
    constructor(e, t = .9, n = 0, a = null, r = !1) {
        if (super(), this.learningRate = e, this.decay = t, this.momentum = n, this.epsilon = a, 
        this.accumulatedMeanSquares = [], this.accumulatedMoments = [], this.accumulatedMeanGrads = [], 
        this.centered = r, a == null && (this.epsilon = U.backend.epsilon()), e == null) throw new Error("learningRate for RMSPropOptimizer must be defined.");
    }
    applyGradients(e) {
        (Array.isArray(e) ? e.map(t => t.name) : Object.keys(e)).forEach((t, n) => {
            let a = U.registeredVariables[t], r = !1;
            this.accumulatedMeanSquares[n] == null && (this.accumulatedMeanSquares[n] = {
                originalName: `${t}/rms`,
                variable: qe(() => Wn(a).variable(r))
            }), this.accumulatedMoments[n] == null && (this.accumulatedMoments[n] = {
                originalName: `${t}/momentum`,
                variable: qe(() => Wn(a).variable(r))
            }), this.accumulatedMeanGrads[n] == null && this.centered && (this.accumulatedMeanGrads[n] = {
                originalName: `${t}/mg`,
                variable: qe(() => Wn(a).variable(r))
            });
            let s = Array.isArray(e) ? e[n].tensor : e[t];
            if (s == null) return;
            let i = this.accumulatedMeanSquares[n].variable, l = this.accumulatedMoments[n].variable;
            qe(() => {
                let o = _e(ne(i, this.decay), ne(oa(s), 1 - this.decay));
                if (this.centered) {
                    let p = this.accumulatedMeanGrads[n].variable, u = _e(ne(p, this.decay), ne(s, 1 - this.decay)), c = ze(ne(s, this.learningRate), Pa($e(o, _e(oa(u), this.epsilon)))), d = _e(ne(l, this.momentum), c);
                    i.assign(o), p.assign(u), l.assign(d);
                    let h = $e(a, d);
                    a.assign(h);
                } else {
                    let p = _e(ne(i, this.decay), ne(oa(s), 1 - this.decay)), u = _e(ne(l, this.momentum), ze(ne(s, this.learningRate), Pa(_e(p, this.epsilon))));
                    i.assign(p), l.assign(u);
                    let c = $e(a, u);
                    a.assign(c);
                }
            });
        }), this.incrementIterations();
    }
    dispose() {
        this.accumulatedMeanSquares != null && ae(this.accumulatedMeanSquares.map(e => e.variable)), 
        this.accumulatedMeanGrads != null && this.centered && ae(this.accumulatedMeanGrads.map(e => e.variable)), 
        this.accumulatedMoments != null && ae(this.accumulatedMoments.map(e => e.variable));
    }
    async getWeights() {
        let e = [ ...this.accumulatedMeanSquares, ...this.accumulatedMoments ];
        return this.centered && e.push(...this.accumulatedMeanGrads), [ await this.saveIterations() ].concat(e.map(t => ({
            name: t.originalName,
            tensor: t.variable
        })));
    }
    async setWeights(e) {
        e = await this.extractIterations(e);
        let t = this.centered ? e.length / 3 : e.length / 2, n = !1;
        this.accumulatedMeanSquares = e.slice(0, t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        })), this.accumulatedMoments = e.slice(t, 2 * t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        })), this.centered && (this.accumulatedMeanGrads = e.slice(2 * t, 3 * t).map(a => ({
            originalName: a.name,
            variable: a.tensor.variable(n)
        })));
    }
    getConfig() {
        return {
            learningRate: this.learningRate,
            decay: this.decay,
            momentum: this.momentum,
            epsilon: this.epsilon,
            centered: this.centered
        };
    }
    static fromConfig(e, t) {
        return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);
    }
}, I8 = [ rm, sm, im, om, lm, um, Ac ], nr = {};

Ze(nr, {
    CompositeArrayBuffer: () => Za,
    browserFiles: () => N8,
    browserHTTPRequest: () => T8,
    concatenateArrayBuffers: () => HI,
    copyModel: () => aS,
    decodeWeights: () => P0,
    decodeWeightsStream: () => L0,
    encodeWeights: () => BI,
    fromMemory: () => E8,
    fromMemorySync: () => RA,
    getLoadHandlers: () => KI,
    getModelArtifactsForJSON: () => of,
    getModelArtifactsForJSONSync: () => U0,
    getModelArtifactsInfoForJSON: () => Nd,
    getSaveHandlers: () => XI,
    getWeightSpecs: () => lf,
    http: () => cm,
    isHTTPScheme: () => pm,
    listModels: () => tS,
    loadWeights: () => C8,
    moveModel: () => rS,
    registerLoadRouter: () => qI,
    registerSaveRouter: () => jI,
    removeModel: () => nS,
    weightsLoaderFactory: () => NA,
    withSaveHandler: () => $8,
    withSaveHandlerSync: () => M8
});

function kA(e) {
    return new Promise(t => setTimeout(t)).then(e);
}

var xc = class P2 {
    constructor(t) {
        if (!H().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
        t.startsWith(P2.URL_SCHEME) && (t = t.slice(P2.URL_SCHEME.length)), (t == null || t.length === 0) && (t = "model"), 
        this.modelJsonFileName = t + ".json", this.weightDataFileName = t + ".weights.bin";
    }
    async save(t) {
        if (typeof document > "u") throw new Error("Browser downloads are not supported in this environment since `document` is not present");
        let n = Za.join(t.weightData), a = window.URL.createObjectURL(new Blob([ n ], {
            type: "application/octet-stream"
        }));
        if (t.modelTopology instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
        {
            let r = V0(t, [ {
                paths: [ "./" + this.weightDataFileName ],
                weights: t.weightSpecs
            } ]), s = window.URL.createObjectURL(new Blob([ JSON.stringify(r) ], {
                type: "application/json"
            })), i = this.modelJsonAnchor == null ? document.createElement("a") : this.modelJsonAnchor;
            if (i.download = this.modelJsonFileName, i.href = s, await kA(() => i.dispatchEvent(new MouseEvent("click"))), 
            t.weightData != null) {
                let l = this.weightDataAnchor == null ? document.createElement("a") : this.weightDataAnchor;
                l.download = this.weightDataFileName, l.href = a, await kA(() => l.dispatchEvent(new MouseEvent("click")));
            }
            return {
                modelArtifactsInfo: Nd(t)
            };
        }
    }
};

xc.URL_SCHEME = "downloads://";

var S8 = class {
    constructor(e) {
        if (e == null || e.length < 1) throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);
        this.jsonFile = e[0], this.weightsFiles = e.slice(1);
    }
    async load() {
        return new Promise((e, t) => {
            let n = new FileReader();
            n.onload = a => {
                let r = JSON.parse(a.target.result), s = r.modelTopology;
                if (s == null) return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));
                if (r.weightsManifest == null) return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));
                if (this.weightsFiles.length === 0) return void e({
                    modelTopology: s
                });
                let i = of(r, l => this.loadWeights(l));
                e(i);
            }, n.onerror = a => t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`), 
            n.readAsText(this.jsonFile);
        });
    }
    loadWeights(e) {
        let t = [], n = [];
        for (let s of e) t.push(...s.weights), n.push(...s.paths);
        let a = this.checkManifestAndWeightFiles(e), r = n.map(s => this.loadWeightsFile(s, a[s]));
        return Promise.all(r).then(s => [ t, s ]);
    }
    loadWeightsFile(e, t) {
        return new Promise((n, a) => {
            let r = new FileReader();
            r.onload = s => {
                let i = s.target.result;
                n(i);
            }, r.onerror = s => a(`Failed to weights data from file of path '${e}'.`), 
            r.readAsArrayBuffer(t);
        });
    }
    checkManifestAndWeightFiles(e) {
        let t = [], n = this.weightsFiles.map(r => B0(r.name)), a = {};
        for (let r of e) r.paths.forEach(s => {
            let i = B0(s);
            if (t.indexOf(i) !== -1) throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);
            if (t.push(i), n.indexOf(i) === -1) throw new Error(`Weight file with basename '${i}' is not provided.`);
            a[s] = this.weightsFiles[n.indexOf(i)];
        });
        if (t.length !== this.weightsFiles.length) throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);
        return a;
    }
};

function N8(e) {
    return new S8(e);
}

function IA(e, t, n, a) {
    var r;
    D((r = e) != null && Array.isArray(r) && r.length > 0, () => "promises must be a none empty array"), 
    function(i, l) {
        D(i >= 0 && i <= 1, () => `Progress fraction must be in range [0, 1], but got startFraction ${i}`), 
        D(l >= 0 && l <= 1, () => `Progress fraction must be in range [0, 1], but got endFraction ${l}`), 
        D(l >= i, () => `startFraction must be no more than endFraction, but got startFraction ${i} and endFraction ${l}`);
    }(n = n ?? 0, a = a ?? 1);
    let s = 0;
    return Promise.all(e.map(i => (i.then(l => {
        let o = n + ++s / e.length * (a - n);
        return t(o), l;
    }), i)));
}

async function SA(e, t) {
    t == null && (t = {});
    let n = t.fetchFunc == null ? H().platform.fetch : t.fetchFunc, a = e.map(s => n(s, t.requestInit, {
        isBinary: !0
    })), r = (t.onProgress == null ? await Promise.all(a) : await IA(a, t.onProgress, 0, .5)).map(s => s.arrayBuffer());
    return t.onProgress == null ? await Promise.all(r) : await IA(r, t.onProgress, .5, 1);
}

async function C8(e, t = "", n, a) {
    return NA(r => SA(r, {
        requestInit: a
    }))(e, t, n);
}

function NA(e) {
    return async (t, n = "", a) => {
        let r = t.map(() => !1), s = {}, i = a != null ? a.map(() => !1) : [], l = [];
        if (t.forEach((h, f) => {
            let m = 0;
            h.weights.forEach(g => {
                let y = "quantization" in g ? g.quantization.dtype : g.dtype, A = uo[y] * ht(g.shape), x = () => {
                    r[f] = !0, s[f] == null && (s[f] = []), s[f].push({
                        manifestEntry: g,
                        groupOffset: m,
                        sizeBytes: A
                    });
                };
                a != null ? a.forEach((b, v) => {
                    b === g.name && (x(), i[v] = !0);
                }) : x(), l.push(g.name), m += A;
            });
        }), !i.every(h => h)) {
            let h = a.filter((f, m) => !i[m]);
            throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${l.join(", ")}.`);
        }
        let o = r.reduce((h, f, m) => (f && h.push(m), h), []), p = [];
        o.forEach(h => {
            t[h].paths.forEach(f => {
                let m = n + (n.endsWith("/") ? "" : "/") + f;
                p.push(m);
            });
        });
        let u = await e(p), c = {}, d = 0;
        return o.forEach(h => {
            let f = t[h].paths.length, m = new Za(u.slice(d, d + f));
            s[h].forEach(g => {
                let y = P0(m.slice(g.groupOffset, g.groupOffset + g.sizeBytes), [ g.manifestEntry ]);
                for (let A in y) c[A] = y[A];
            }), d += f;
        }), c;
    };
}

Yn.registerSaveRouter(e => H().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(xc.URL_SCHEME) ? function(t = "model") {
    return new xc(t);
}(e.slice(xc.URL_SCHEME.length)) : null);

var dm = class {
    constructor(e, t) {
        if (this.DEFAULT_METHOD = "POST", t == null && (t = {}), this.weightPathPrefix = t.weightPathPrefix, 
        this.weightUrlConverter = t.weightUrlConverter, t.fetchFunc != null ? (D(typeof t.fetchFunc == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), 
        this.fetch = t.fetchFunc) : this.fetch = H().platform.fetch, D(e != null && e.length > 0, () => "URL path for http must not be null, undefined or empty."), 
        Array.isArray(e) && D(e.length === 2, () => `URL paths for http must have a length of 2, (actual length is ${e.length}).`), 
        this.path = e, t.requestInit != null && t.requestInit.body != null) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
        this.requestInit = t.requestInit || {}, this.loadOptions = t;
    }
    async save(e) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
        let t = Object.assign({
            method: this.DEFAULT_METHOD
        }, this.requestInit);
        t.body = new FormData();
        let n = V0(e, [ {
            paths: [ "./model.weights.bin" ],
            weights: e.weightSpecs
        } ]);
        if (t.body.append("model.json", new Blob([ JSON.stringify(n) ], {
            type: "application/json"
        }), "model.json"), e.weightData != null) {
            let r = Za.join(e.weightData);
            t.body.append("model.weights.bin", new Blob([ r ], {
                type: "application/octet-stream"
            }), "model.weights.bin");
        }
        let a = await this.fetch(this.path, t);
        if (a.ok) return {
            modelArtifactsInfo: Nd(e),
            responses: [ a ]
        };
        throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`);
    }
    async loadModelJSON() {
        let e, t = await this.fetch(this.path, this.requestInit);
        if (!t.ok) throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);
        try {
            e = await t.json();
        } catch {
            let s = `Failed to parse model JSON of response from ${this.path}.`;
            throw this.path.endsWith(".pb") ? s += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : s += " Please make sure the server is serving valid JSON for this request.", 
            new Error(s);
        }
        let n = e.modelTopology, a = e.weightsManifest;
        if (n == null && a == null) throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);
        return e;
    }
    async load() {
        return this.loadOptions.streamWeights ? this.loadStream() : of(await this.loadModelJSON(), e => this.loadWeights(e));
    }
    async loadStream() {
        let e = await this.loadModelJSON(), t = await this.getWeightUrls(e.weightsManifest), n = lf(e.weightsManifest);
        return Object.assign(Object.assign({}, e), {
            weightSpecs: n,
            getWeightStream: () => function(a, r) {
                var s;
                let i, l = r.fetchFunc == null ? H().platform.fetch : r.fetchFunc, o = 0;
                return (s = r.onProgress) === null || s === void 0 || s.call(r, 0), 
                new ReadableStream({
                    pull: async p => {
                        for (var u; o < a.length; ) {
                            i || (i = (await l(a[o], r.requestInit, {
                                isBinary: !0
                            })).body.getReader());
                            let {
                                done: c,
                                value: d
                            } = await i.read();
                            if (!c) return void p.enqueue(d);
                            o++, i = void 0, (u = r.onProgress) === null || u === void 0 || u.call(r, o / a.length);
                        }
                        p.close();
                    }
                });
            }(t, this.loadOptions)
        });
    }
    async getWeightUrls(e) {
        let t = Array.isArray(this.path) ? this.path[1] : this.path, [ n, a ] = function(l) {
            let o = l.lastIndexOf("/"), p = l.lastIndexOf("?"), u = l.substring(0, o), c = p > o ? l.substring(p) : "";
            return [ u + "/", c ];
        }(t), r = this.weightPathPrefix || n, s = [], i = [];
        for (let l of e) for (let o of l.paths) this.weightUrlConverter != null ? i.push(this.weightUrlConverter(o)) : s.push(r + o + a);
        return this.weightUrlConverter && s.push(...await Promise.all(i)), s;
    }
    async loadWeights(e) {
        let t = await this.getWeightUrls(e);
        return [ lf(e), await SA(t, this.loadOptions) ];
    }
};

function pm(e) {
    return e.match(dm.URL_SCHEME_REGEX) != null;
}

dm.URL_SCHEME_REGEX = /^https?:\/\//;

var CA = (e, t) => {
    if (typeof fetch > "u" && (t == null || t.fetchFunc == null)) return null;
    {
        let n = !0;
        if (n = Array.isArray(e) ? e.every(a => pm(a)) : pm(e), n) return cm(e, t);
    }
    return null;
};

function cm(e, t) {
    return new dm(e, t);
}

function T8(e, t) {
    return cm(e, t);
}

Yn.registerSaveRouter(CA), Yn.registerLoadRouter(CA);

var hm = class {
    constructor(e) {
        this.modelArtifacts = e;
    }
    load() {
        return this.modelArtifacts;
    }
}, TA = class {
    constructor(e) {
        this.saveHandler = e;
    }
    save(e) {
        return this.saveHandler(e);
    }
}, R8 = class {
    constructor(e) {
        e.load && (this.load = () => Promise.resolve(e.load())), e.save && (this.save = t => Promise.resolve(e.save(t)));
    }
};

function E8(e, t, n, a) {
    return new R8(RA(...arguments));
}

function RA(e, t, n, a) {
    return arguments.length === 1 ? e.modelTopology != null || e.weightSpecs != null ? new hm(e) : new hm({
        modelTopology: e
    }) : new hm({
        modelTopology: e,
        weightSpecs: t,
        weightData: n,
        trainingConfig: a
    });
}

function $8(e) {
    return new TA(e);
}

function M8(e) {
    return new TA(e);
}

var EA = {};

Ze(EA, {
    confusionMatrix: () => F8
});

var xo, F8 = V({
    confusionMatrix_: function(e, t, n) {
        let a = _(e, "labels", "confusionMatrix"), r = _(t, "predictions", "confusionMatrix");
        D(n == null || n > 0 && Number.isInteger(n), () => `If provided, numClasses must be a positive integer, but got ${n}`), 
        D(a.rank === 1, () => `Expected the rank of labels to be 1, but got ${a.rank}`), 
        D(r.rank === 1, () => `Expected the rank of predictions to be 1, but got ${r.rank}`), 
        D(a.shape[0] === r.shape[0], () => `Mismatch in the number of examples: ${a.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`), 
        D(n > 0 && Number.isInteger(n), () => `numClasses is required to be a positive integer, but got ${n}`);
        let s = ic(Qe(a, "int32"), n), i = ic(Qe(r, "int32"), n), l = au(s), o = ut(l, i);
        return Qe(o, "int32");
    }
}), Lr = {};

Ze(Lr, {
    draw: () => D8,
    fromPixels: () => z8,
    fromPixelsAsync: () => O8,
    toPixels: () => P8
});

var $A = !1;

function MA(e, t = 3) {
    if (t > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
    if (e == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
    let n = !1, a = !1, r = !1, s = !1, i = !1, l = !1;
    if (e.data instanceof Uint8Array) n = !0; else if (typeof ImageData < "u" && e instanceof ImageData) a = !0; else if (typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement) r = !0; else if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) s = !0; else if (e.getContext != null) i = !0; else {
        if (!(typeof ImageBitmap < "u" && e instanceof ImageBitmap)) throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);
        l = !0;
    }
    if (md(hd, U.backendName) != null) {
        let d = {
            pixels: e
        }, h = {
            numChannels: t
        };
        return U.runKernel(hd, d, h);
    }
    let o, p, [ u, c ] = r ? [ e.videoWidth, e.videoHeight ] : [ e.width, e.height ];
    if (i) o = e.getContext("2d").getImageData(0, 0, u, c).data; else if (a || n) o = e.data; else if (s || r || l) {
        if (xo == null) if (typeof document > "u") {
            if (typeof OffscreenCanvas > "u" || typeof OffscreenCanvasRenderingContext2D > "u") throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
            xo = new OffscreenCanvas(1, 1).getContext("2d");
        } else xo = document.createElement("canvas").getContext("2d", {
            willReadFrequently: !0
        });
        xo.canvas.width = u, xo.canvas.height = c, xo.drawImage(e, 0, 0, u, c), 
        o = xo.getImageData(0, 0, u, c).data;
    }
    if (t === 4) p = new Int32Array(o); else {
        let d = u * c;
        p = new Int32Array(d * t);
        for (let h = 0; h < d; h++) for (let f = 0; f < t; ++f) p[h * t + f] = o[4 * h + f];
    }
    return Yf(p, [ c, u, t ], "int32");
}

function _8(e) {
    return typeof window < "u" && typeof ImageBitmap < "u" && window.hasOwnProperty("createImageBitmap") && !(e instanceof ImageBitmap) && function(t) {
        return t != null && t.width !== 0 && t.height !== 0;
    }(e) && !function(t) {
        return t != null && t.data instanceof Uint8Array;
    }(e);
}

async function O8(e, t = 3) {
    let n = null;
    if (H().getBool("WRAP_TO_IMAGEBITMAP") && _8(e)) {
        let a;
        try {
            a = await createImageBitmap(e, {
                premultiplyAlpha: "none"
            });
        } catch {
            a = null;
        }
        n = a != null && a.width === e.width && a.height === e.height ? a : e;
    } else n = e;
    return MA(n, t);
}

function FA(e) {
    if (e.rank !== 2 && e.rank !== 3) throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);
    let t = e.rank === 2 ? 1 : e.shape[2];
    if (t > 4 || t === 2) throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);
    if (e.dtype !== "float32" && e.dtype !== "int32") throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);
}

async function P8(e, t) {
    let n = _(e, "img", "toPixels");
    if (!(e instanceof vt)) {
        let p = n;
        n = Qe(p, "int32"), p.dispose();
    }
    FA(n);
    let [ a, r ] = n.shape.slice(0, 2), s = n.rank === 2 ? 1 : n.shape[2], i = await n.data(), l = n.dtype === "float32" ? 255 : 1, o = new Uint8ClampedArray(r * a * 4);
    for (let p = 0; p < a * r; ++p) {
        let u = [ 0, 0, 0, 255 ];
        for (let d = 0; d < s; d++) {
            let h = i[p * s + d];
            if (n.dtype === "float32") {
                if (h < 0 || h > 1) throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`);
            } else if (n.dtype === "int32" && (h < 0 || h > 255)) throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);
            s === 1 ? (u[0] = h * l, u[1] = h * l, u[2] = h * l) : u[d] = h * l;
        }
        let c = 4 * p;
        o[c + 0] = Math.round(u[0]), o[c + 1] = Math.round(u[1]), o[c + 2] = Math.round(u[2]), 
        o[c + 3] = Math.round(u[3]);
    }
    if (t != null) {
        $A || md(Ju, U.backendName) != null && ($A = !0), t.width = r, t.height = a;
        let p = t.getContext("2d"), u = new ImageData(o, r, a);
        p.putImageData(u, 0, 0);
    }
    return n !== e && n.dispose(), o;
}

function D8(e, t, n) {
    let a = _(e, "img", "draw");
    if (!(e instanceof vt)) {
        let i = a;
        a = Qe(i, "int32"), i.dispose();
    }
    FA(a), function(i) {
        let l = (i == null ? void 0 : i.alpha) || 1;
        if (l > 1 || l < 0) throw new Error(`Alpha value ${l} is suppoed to be in range [0 - 1].`);
    }(n == null ? void 0 : n.imageOptions);
    let r = {
        image: a
    }, s = {
        canvas: t,
        options: n
    };
    U.runKernel(Ju, r, s);
}

var z8 = V({
    fromPixels_: MA
}), fm = {};

function _A(e, t) {
    let n = e.shape.length, a = t.shape.length;
    if (n < 1) throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);
    if (a < 1) throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${a}.`);
    if (t.dtype !== "int32") throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);
    if (t.shape[a - 1] > n) throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[a - 1]} vs. ${n}`);
    if (ht(e.shape) === 0) throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);
    let r = t.shape, s = r[r.length - 1], i = 1;
    for (let c = 0; c < r.length - 1; ++c) i *= r[c];
    let l = e.shape, o = r.slice();
    o.pop();
    let p = 1;
    for (let c = s; c < n; ++c) p *= l[c], o.push(l[c]);
    let u = [ ...sl(e.shape).map(c => c / p), 1 ].slice(0, s);
    return [ o, i, p, u ];
}

Ze(fm, {
    prepareAndValidate: () => _A
});

var St = {};

Ze(St, {
    assertParamsValid: () => W8,
    computeFlatOffset: () => H8,
    computeOutShape: () => V8,
    getNormalizedAxes: () => U8,
    isSliceContinous: () => G8,
    maskToAxes: () => B8,
    parseSliceParams: () => j8,
    sliceInfo: () => q8,
    startForAxis: () => BA,
    startIndicesWithElidedDims: () => zA,
    stopForAxis: () => VA,
    stopIndicesWithElidedDims: () => LA,
    stridesForAxis: () => WA,
    stridesWithElidedDims: () => OA
});

var mm = -2, L8 = -1;

function W8(e, t, n) {
    let a = e.shape.length;
    D(a === t.length, () => `Error in slice${a}D: Length of begin ${t} must match the rank of the array (${a}).`), 
    D(a === n.length, () => `Error in slice${a}D: Length of size ${n} must match the rank of the array (${a}).`);
    for (let r = 0; r < a; ++r) D(t[r] + n[r] <= e.shape[r], () => `Error in slice${a}D: begin[${r}] + size[${r}] (${t[r] + n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`);
}

function B8(e) {
    let t = [], n = 0;
    for (;e > 0; ) 1 & e && t.push(n), e /= 2, n++;
    return t;
}

function V8(e, t, n) {
    let a = [];
    for (let r = 0; r < e.length; r++) a[r] = Math.ceil((t[r] - e[r]) / n[r]);
    return a;
}

function OA(e, t, n, a) {
    let r = [ ...e ];
    for (let s = r.length; s < a.length; s++) r.push(1);
    for (let s = 0; s < n; s++) s === 0 ? r[t] = 1 : (r.splice(t, 0, 1), r.pop());
    return r;
}

function PA(e, t, n) {
    return n <= e ? n : n - (t - 1);
}

function DA(e, t) {
    let n = [];
    for (let a = 0; a < e; a++) n.push(t + a);
    return n;
}

function U8(e, t, n, a, r, s, i, l, o) {
    let p = e.length, u = new Array(p), c = new Array(p), d = new Array(p);
    if (t.length && n > 0) {
        let h = t[0], f = n + 1;
        u = zA(i, h, f, a, e), c = LA(l, h, f, r, e), d = OA(s, h, f, e);
    } else for (let h = 0; h < p; h++) u[h] = BA(i, a, s, e, h, o), c[h] = VA(l, r, s, e, h, o), 
    d[h] = WA(s, h, o);
    return {
        begin: u,
        end: c,
        strides: d
    };
}

function zA(e, t, n, a, r) {
    let s = [ ...r ], i = DA(n, t);
    for (let l = 0; l < s.length; l++) if (i.indexOf(l) > -1) s[l] = 0; else {
        let o = PA(t, n, l), p = a[o];
        e & 1 << o && (p = 0), s[l] = p;
    }
    return s;
}

function LA(e, t, n, a, r) {
    let s = [ ...r ], i = DA(n, t);
    for (let l = 0; l < s.length; l++) if (i.indexOf(l) > -1) s[l] = Number.MAX_SAFE_INTEGER; else {
        let o = PA(t, n, l), p = a[o];
        e & 1 << o && (p = Number.MAX_SAFE_INTEGER), s[l] = p;
    }
    for (let l = 0; l < s.length; l++) {
        let o = r[l];
        s[l] < 0 && (s[l] += o), s[l] = Bu(0, s[l], r[l]);
    }
    return s;
}

function WA(e, t, n) {
    let a = e[t];
    return (n & 1 << t || a == null) && (a = 1), a;
}

function BA(e, t, n, a, r, s) {
    let i = t[r], l = n[r] || 1;
    (e & 1 << r || s & 1 << r || i == null) && (i = l > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
    let o = a[r];
    return i < 0 && (i += o), i = Bu(0, i, o - 1), i;
}

function VA(e, t, n, a, r, s) {
    let i = t[r], l = n[r] || 1;
    (e & 1 << r || s & 1 << r || i == null) && (i = l > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
    let o = a[r];
    return i < 0 && (i += o), i = l > 0 ? Bu(0, i, o) : Bu(-1, i, o - 1), i;
}

function G8(e, t, n) {
    let a = n.length;
    for (let r = 0; r < n.length; r++) if (n[r] > 1) {
        a = r;
        break;
    }
    for (let r = a + 1; r < n.length; r++) if (t[r] > 0 || n[r] !== e[r]) return !1;
    return !0;
}

function H8(e, t) {
    let n = e.length > 0 ? e[e.length - 1] : 1;
    for (let a = 0; a < e.length - 1; a++) n += e[a] * t[a];
    return n;
}

function j8(e, t, n) {
    let a, r, s = e.shape.length;
    return a = typeof t == "number" ? [ t, ...new Array(s - 1).fill(0) ] : t.length < s ? t.concat(new Array(s - t.length).fill(0)) : t.slice(), 
    a.forEach(i => {
        D(i !== -1, () => "slice() does not support negative begin indexing.");
    }), r = n == null ? new Array(s).fill(-1) : typeof n == "number" ? [ n, ...new Array(s - 1).fill(-1) ] : n.length < s ? n.concat(new Array(s - n.length).fill(-1)) : n, 
    r = r.map((i, l) => i >= 0 ? i : (D(i === -1, () => `Negative size values should be exactly -1 but got ${i} for the slice() size at index ${l}.`), 
    e.shape[l] - a[l])), [ a, r ];
}

function q8(e, t, n, a, r, s, i, l, o) {
    let p;
    if (a == null ? (p = new Array(t.length), p.fill(1)) : p = a, i != null && i & i - 1) throw new Error("Multiple ellipses in slice is not allowed.");
    let u = !1, c = {
        dims: p.length,
        numAddAxisAfterEllipsis: 0,
        begin: t.slice(),
        end: n.slice(),
        strides: p.slice(),
        beginMask: r,
        endMask: s,
        ellipsisMask: i,
        newAxisMask: l,
        shrinkAxisMask: o
    };
    for (let A = 0; A < c.dims; A++) u && 1 << A & l && c.numAddAxisAfterEllipsis++, 
    1 << A & i && (u = !0);
    u || (c.ellipsisMask |= 1 << c.dims, c.dims++);
    let d = {
        dims: e.length,
        beginMask: 0,
        endMask: 0,
        beginValid: !1,
        endValid: !1
    };
    (function(A, x) {
        x.beginMask = 0, x.endMask = 0, x.shrinkAxisMask = 0;
        let b = 0;
        x.beginValid = A.begin != null, x.endValid = A.end != null, x.begin = new Array(x.dims), 
        x.end = new Array(x.dims), x.strides = new Array(x.dims), x.finalShapeGatherIndices = [], 
        x.finalShapeGatherIndicesSparse = [], x.inputShapeGatherIndicesSparse = new Array(x.dims);
        for (let v = 0; v < A.dims; v++) if (1 << v & A.ellipsisMask) {
            let I = Math.min(x.dims - (A.dims - v) + 1 + A.numAddAxisAfterEllipsis, x.dims);
            for (;b < I; b++) x.begin[b] = 0, x.end[b] = 0, x.strides[b] = 1, x.beginMask |= 1 << b, 
            x.endMask |= 1 << b, x.finalShapeGatherIndices.push(b), x.finalShapeGatherIndicesSparse.push(-1), 
            x.inputShapeGatherIndicesSparse[b] = v;
        } else if (1 << v & A.newAxisMask) x.finalShapeGatherIndices.push(mm), x.finalShapeGatherIndicesSparse.push(-1); else {
            if (b === x.begin.length) throw Error(`Index out of range using input dim ${b}; input has only ${x.dims} dims, ${x.begin.length}.`);
            A.begin != null && (x.begin[b] = A.begin[v]), A.end != null && (x.end[b] = A.end[v]), 
            x.strides[b] = A.strides[v], A.beginMask & 1 << v && (x.beginMask |= 1 << b), 
            A.endMask & 1 << v && (x.endMask |= 1 << b), A.shrinkAxisMask & 1 << v ? (x.finalShapeGatherIndices.push(L8), 
            x.finalShapeGatherIndicesSparse.push(-1), x.shrinkAxisMask |= 1 << b) : (x.finalShapeGatherIndices.push(b), 
            x.finalShapeGatherIndicesSparse.push(v)), x.inputShapeGatherIndicesSparse[b] = v, 
            b++;
        }
    })(c, d);
    let h = !0, f = !0, m = !0, g = [], y = [];
    for (let A = 0; A < e.length; ++A) {
        if (d.strides[A] === 0) throw Error(`strides[${A}] must be non-zero`);
        let x = !!(d.shrinkAxisMask & 1 << A), b = e[A];
        if (b === -1) {
            g.push(x ? 1 : -1);
            continue;
        }
        let v = [ d.beginMask & 1 << A, d.endMask & 1 << A ], I = [ d.strides[A] > 0 ? 0 : -1, d.strides[A] > 0 ? b : b - 1 ];
        if (x && d.strides[A] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
        m = m && d.strides[A] === 1;
        let N = !!(d.beginMask & 1 << A && d.endMask & 1 << A);
        if (d.beginValid && d.endValid) {
            if (x) {
                let E = d.begin[A] < 0 ? b + d.begin[A] : d.begin[A];
                if (d.begin[A] = E, d.end[A] = d.begin[A] + 1, E < 0 || E >= b) throw Error(`slice index ${d.begin[A]} of dimension ${A} out of bounds.`);
            } else d.begin[A] = UA(d.begin[A], 0, d.strides[A], b, v, I), d.end[A] = UA(d.end[A], 1, d.strides[A], b, v, I);
            let w = d.strides[A] === 1 && d.begin[A] === 0 && d.end[A] === b;
            h = h && w, f = f && (A === 0 && d.strides[A] === 1 || w);
        } else h = h && d.strides[A] === 1 && N, f = f && (A === 0 && d.strides[A] === 1 || N);
        let T, R = !1;
        if (d.beginValid && d.endValid ? (T = d.end[A] - d.begin[A], R = !0) : x ? (T = 1, 
        R = !0) : N && b >= 0 && (T = d.strides[A] < 0 ? -b : b, R = !0), R) {
            let w;
            w = T === 0 || T < 0 != d.strides[A] < 0 ? 0 : Math.trunc(T / d.strides[A]) + (T % d.strides[A] != 0 ? 1 : 0), 
            g.push(w);
        } else g.push(-1);
    }
    for (let A = 0; A < d.finalShapeGatherIndices.length; ++A) {
        let x = d.finalShapeGatherIndices[A];
        x >= 0 ? y.push(g[x]) : x === mm && y.push(1);
    }
    return {
        finalShapeSparse: y.filter((A, x) => d.finalShapeGatherIndices[x] !== mm),
        finalShape: y,
        isIdentity: h,
        sliceDim0: f,
        isSimpleSlice: m,
        begin: d.begin,
        end: d.end,
        strides: d.strides
    };
}

function UA(e, t, n, a, r, s) {
    if (r[t]) return n > 0 ? s[t] : s[t + 1 & 1];
    {
        let i = e < 0 ? a + e : e;
        return i < s[0] ? s[0] : i > s[1] ? s[1] : i;
    }
}

var X8 = "4.17.0", GA = class {
    static sgd(e) {
        return new Ac(e);
    }
    static momentum(e, t, n = !1) {
        return new lm(e, t, n);
    }
    static rmsprop(e, t = .9, n = 0, a = null, r = !1) {
        return new um(e, t, n, a, r);
    }
    static adam(e = .001, t = .9, n = .999, a = null) {
        return new im(e, t, n, a);
    }
    static adadelta(e = .001, t = .95, n = null) {
        return new rm(e, t, n);
    }
    static adamax(e = .002, t = .9, n = .999, a = null, r = 0) {
        return new om(e, t, n, a, r);
    }
    static adagrad(e, t = .1) {
        return new sm(e, t);
    }
}, K8 = GA, Z8 = typeof requestAnimationFrame < "u" ? requestAnimationFrame : typeof setImmediate < "u" ? setImmediate : e => e();

function HA() {
    return new Promise(e => Z8(() => e()));
}

var za, C = {};

function Y8(e, t) {
    let n = e[0].length;
    e.forEach((r, s) => {
        D(r.length === n, () => `Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`);
    }), D(t >= 0 && t < n, () => `Error in concat${n}D: axis must be between 0 and ${n - 1}.`);
    let a = e[0];
    e.forEach((r, s) => {
        for (let i = 0; i < n; i++) D(i === t || r[i] === a[i], () => `Error in concat${n}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${a}) along the non-concatenated axis ${s}.`);
    });
}

function J8(e, t) {
    let n = e[0].slice();
    for (let a = 1; a < e.length; a++) n[t] += e[a][t];
    return n;
}

function Q8(e, t, n) {
    let a = new Array();
    if (n == null && t == null) return a;
    if (t == null) for (;a.length < e + n.length; ) a.push(-1); else a = t.slice();
    if (n == null) return a;
    if (e + n.length !== a.length) throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e + n.length}, but shape.rank = ${a.length}`);
    for (let r = 1; r < n.length; ++r) {
        let s = n[r], i = a[a.length - n.length + r], l = a[i];
        if (s >= 0) if (l >= 0) {
            if (l !== s) throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r + e}] = ${s} but shape[${r + e}] = ${l}`);
        } else a[i] = s;
    }
    return a;
}

function e9(e) {
    let t = {
        FIRST_DIM_SIZE: za.FIRST_DIM_SIZE,
        VALUE_ROWIDS: za.VALUE_ROWIDS,
        ROW_LENGTHS: za.ROW_LENGTHS,
        ROW_SPLITS: za.ROW_SPLITS,
        ROW_LIMITS: za.ROW_LIMITS,
        ROW_STARTS: za.ROW_STARTS
    }, n = [];
    for (let a of e) {
        if (!(a in t)) break;
        n.push(t[a]);
    }
    return n;
}

function t9(e) {
    return e.length === 0 ? 0 : e[0] === za.FIRST_DIM_SIZE ? e.length - 1 : e.length;
}

function n9(e, t) {
    if (e == null || t == null) return;
    let n = e.length, a = t.length;
    if (n >= a) throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${a})`);
    for (let r = 0; r < Math.min(n, a - 1); ++r) {
        let s = e[r], i = t[r + 1];
        if (s >= 0 && i >= 0 && s !== 1 && s !== i) throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r - e.length}] = ${s} but ragged tensor input.flatValues.shape[${r - e.length}] = ${i}`);
    }
}

Ze(C, {
    ERF_A1: () => h9,
    ERF_A2: () => f9,
    ERF_A3: () => m9,
    ERF_A4: () => g9,
    ERF_A5: () => y9,
    ERF_P: () => c9,
    PARALLELIZE_THRESHOLD: () => gm,
    RowPartitionType: () => za,
    SELU_SCALE: () => p9,
    SELU_SCALEALPHA: () => d9,
    applyActivation: () => gc,
    assertAndGetBroadcastShape: () => Ft,
    assertAxesAreInnerMostDims: () => pS,
    assertParamsConsistent: () => Y8,
    assignToTypedArray: () => k9,
    axesAreInnerMostDims: () => wf,
    calculateShapes: () => Gy,
    checkEinsumDimSizes: () => R9,
    checkPadOnDimRoundingMode: () => ia,
    combineLocations: () => Wg,
    combineRaggedTensorToTensorShapes: () => Q8,
    complexWithEvenIndex: () => b9,
    complexWithOddIndex: () => v9,
    computeConv2DInfo: () => Cd,
    computeConv3DInfo: () => lg,
    computeDefaultPad: () => ff,
    computeDilation2DInfo: () => iS,
    computeOptimalWindowSize: () => a9,
    computeOutAndReduceShapes: () => dS,
    computeOutShape: () => J8,
    computePool2DInfo: () => og,
    computePool3DInfo: () => oS,
    convertConv2DDataFormat: () => ug,
    decodeEinsumEquation: () => C9,
    eitherStridesOrDilationsAreOne: () => Ja,
    expandShapeToKeepDim: () => Fd,
    exponent: () => S9,
    exponents: () => I9,
    fromStringArrayToUint8: () => Z9,
    fromUint8ToStringArray: () => K9,
    getAxesPermutation: () => cS,
    getBroadcastDims: () => Og,
    getComplexWithIndex: () => w9,
    getEinsumComputePath: () => E9,
    getEinsumPermutation: () => T9,
    getFusedBiasGradient: () => mc,
    getFusedDyActivation: () => fc,
    getImageCenter: () => r9,
    getInnerMostAxes: () => fS,
    getPermuted: () => i9,
    getRaggedRank: () => t9,
    getReductionAxes: () => xf,
    getReshaped: () => s9,
    getReshapedPermuted: () => o9,
    getRowPartitionTypesHelper: () => e9,
    getSliceBeginCoords: () => l9,
    getSliceSize: () => u9,
    getSparseFillEmptyRowsIndicesDenseShapeMismatch: () => _9,
    getSparseFillEmptyRowsNegativeIndexErrorMessage: () => O9,
    getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: () => P9,
    getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: () => L9,
    getSparseReshapeInputOutputMismatchErrorMessage: () => B9,
    getSparseReshapeInputOutputMultipleErrorMessage: () => W9,
    getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: () => D9,
    getSparseReshapeNegativeOutputDimErrorMessage: () => z9,
    getSparseSegmentReductionIndicesOutOfRangeErrorMessage: () => H9,
    getSparseSegmentReductionNegativeSegmentIdsErrorMessage: () => V9,
    getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: () => U9,
    getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: () => G9,
    getUndoAxesPermutation: () => hS,
    isIdentityPermutation: () => $9,
    log: () => mI,
    mergeRealAndImagArrays: () => A9,
    prepareAndValidate: () => _A,
    prepareSplitSize: () => F9,
    segment_util: () => XA,
    shouldFuse: () => yc,
    slice_util: () => St,
    splitRealAndImagArrays: () => x9,
    stridesOrDilationsArePositive: () => fo,
    tupleValuesAreOne: () => Ed,
    upcastType: () => Zt,
    validateDefaultValueShape: () => n9,
    validateInput: () => cc,
    validateUpdateShape: () => Jf,
    warn: () => Sr
}), function(e) {
    e[e.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", e[e.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", 
    e[e.ROW_LENGTHS = 2] = "ROW_LENGTHS", e[e.ROW_SPLITS = 3] = "ROW_SPLITS", e[e.ROW_LIMITS = 4] = "ROW_LIMITS", 
    e[e.ROW_STARTS = 5] = "ROW_STARTS";
}(za || (za = {}));

var gm = 30;

function a9(e) {
    return e <= gm ? e : zp(e, Math.floor(Math.sqrt(e)));
}

function r9(e, t, n) {
    return [ n * (typeof e == "number" ? e : e[0]), t * (typeof e == "number" ? e : e[1]) ];
}

function s9(e, t, n, a = !0) {
    let r = [];
    if (a) r = r.concat(t.slice(0)), r.push(e[0] / n), r = r.concat(e.slice(1)); else {
        r = r.concat(e[0]);
        let s = t.length;
        for (let i = 0; i < s; ++i) r = r.concat([ e[i + 1] / t[i], t[i] ]);
        r = r.concat(e.slice(s + 1));
    }
    return r;
}

function i9(e, t, n = !0) {
    let a = [];
    if (n) {
        a.push(t);
        for (let r = t + 1; r < e; ++r) r <= 2 * t ? (a.push(r), a.push(r - (t + 1))) : a.push(r);
    } else {
        let r = [], s = [];
        for (let i = 1; i < e; ++i) i >= 2 * t + 1 || i % 2 == 1 ? s.push(i) : r.push(i);
        a.push(...r), a.push(0), a.push(...s);
    }
    return a;
}

function o9(e, t, n, a = !0) {
    let r = [];
    a ? r.push(e[0] / n) : r.push(e[0] * n);
    for (let s = 1; s < e.length; ++s) s <= t.length ? a ? r.push(t[s - 1] * e[s]) : r.push(e[s] / t[s - 1]) : r.push(e[s]);
    return r;
}

function l9(e, t) {
    let n = [ 0 ];
    for (let a = 0; a < t; ++a) n.push(e[a][0]);
    return n;
}

function u9(e, t, n) {
    let a = e.slice(0, 1);
    for (let r = 0; r < n; ++r) a.push(e[r + 1] - t[r][0] - t[r][1]);
    return a;
}

var d9 = 1.7580993408473768, p9 = 1.0507009873554805, c9 = .3275911, h9 = .254829592, f9 = -.284496736, m9 = 1.421413741, g9 = -1.453152027, y9 = 1.061405429;

function A9(e, t) {
    if (e.length !== t.length) throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);
    let n = new Float32Array(2 * e.length);
    for (let a = 0; a < n.length; a += 2) n[a] = e[a / 2], n[a + 1] = t[a / 2];
    return n;
}

function x9(e) {
    let t = new Float32Array(e.length / 2), n = new Float32Array(e.length / 2);
    for (let a = 0; a < e.length; a += 2) t[a / 2] = e[a], n[a / 2] = e[a + 1];
    return {
        real: t,
        imag: n
    };
}

function b9(e) {
    let t = Math.ceil(e.length / 4), n = new Float32Array(t), a = new Float32Array(t);
    for (let r = 0; r < e.length; r += 4) n[Math.floor(r / 4)] = e[r], a[Math.floor(r / 4)] = e[r + 1];
    return {
        real: n,
        imag: a
    };
}

function v9(e) {
    let t = Math.floor(e.length / 4), n = new Float32Array(t), a = new Float32Array(t);
    for (let r = 2; r < e.length; r += 4) n[Math.floor(r / 4)] = e[r], a[Math.floor(r / 4)] = e[r + 1];
    return {
        real: n,
        imag: a
    };
}

function w9(e, t) {
    return {
        real: e[2 * t],
        imag: e[2 * t + 1]
    };
}

function k9(e, t, n, a) {
    e[2 * a] = t, e[2 * a + 1] = n;
}

function I9(e, t) {
    let n = new Float32Array(e / 2), a = new Float32Array(e / 2);
    for (let r = 0; r < Math.ceil(e / 2); r++) {
        let s = (t ? 2 : -2) * Math.PI * (r / e);
        n[r] = Math.cos(s), a[r] = Math.sin(s);
    }
    return {
        real: n,
        imag: a
    };
}

function S9(e, t, n) {
    let a = (n ? 2 : -2) * Math.PI * (e / t);
    return {
        real: Math.cos(a),
        imag: Math.sin(a)
    };
}

var ym = "->", N9 = /->/g, jA = ",", qA = "...";

function C9(e, t) {
    let n = ((e = e.replace(/\s/g, "")).length - e.replace(N9, "").length) / ym.length;
    if (n < 1) throw new Error("Equations without an arrow are not supported.");
    if (n > 1) throw new Error(`Equation must contain exactly one arrow ("${ym}").`);
    let [ a, r ] = e.split(ym);
    D(a.indexOf(qA) === -1, () => `The ellipsis notation ("${qA}") is not supported yet.`);
    let s = a.split(jA), i = s.length;
    if (t !== i) throw new Error(`Expected ${i} input tensors, received ${t}`);
    if (i > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
    let l = [];
    for (let c = 0; c < r.length; ++c) {
        let d = r[c];
        if (!s.some(h => h.indexOf(d) !== -1)) throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);
        l.indexOf(d) === -1 && l.push(d);
    }
    for (let c = 0; c < a.length; ++c) {
        let d = a[c];
        l.indexOf(d) === -1 && d !== jA && l.push(d);
    }
    let o = new Array(s.length);
    for (let c = 0; c < i; ++c) {
        if (new Set(s[c].split("")).size !== s[c].length) throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);
        o[c] = [];
        for (let d = 0; d < s[c].length; ++d) o[c].push(l.indexOf(s[c][d]));
    }
    let p = l.length, u = [];
    for (let c = r.length; c < p; ++c) u.push(c);
    return {
        allDims: l,
        summedDims: u,
        idDims: o
    };
}

function T9(e, t) {
    let n = new Array(e);
    n.fill(-1);
    for (let r = 0; r < t.length; ++r) n[t[r]] = r;
    let a = [];
    for (let r = 0; r < e; ++r) n[r] === -1 && a.push(r);
    return n = n.filter(r => r !== -1), {
        permutationIndices: n,
        expandDims: a
    };
}

function R9(e, t, n) {
    let a = new Array(e);
    for (let r = 0; r < n.length; ++r) {
        let s = n[r].shape;
        for (let i = 0; i < t[r].length; ++i) a[t[r][i]] === void 0 ? a[t[r][i]] = s[i] : D(a[t[r][i]] === s[i], () => `Expected dimension ${a[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`);
    }
}

function E9(e, t) {
    let n = e, a = [], r = 0;
    e.length === 0 && n.push(-1), r = e.length + 1;
    for (let i = 0; i < r; ++i) a.push([]);
    let s = [];
    for (let i = 0; i < n.length; ++i) {
        let l = M9(t, n[i]);
        for (let o of l) s.indexOf(o) === -1 && (a[i].push(o), s.push(o));
    }
    return {
        path: n,
        steps: a
    };
}

function $9(e) {
    return e.every((t, n) => t === n);
}

function M9(e, t) {
    let n = [];
    for (let a = 0; a < e.length; ++a) (e[a].length === 0 || e[a].indexOf(t) !== -1 || t === -1) && n.push(a);
    return n;
}

function F9(e, t, n = 0) {
    let a = [];
    if (typeof t == "number") D(e.shape[n] % t == 0, () => "Number of splits must evenly divide the axis."), 
    a = new Array(t).fill(e.shape[n] / t); else {
        D(t.reduce((s, i) => (i === -1 && (s += 1), s), 0) <= 1, () => "There should be only one negative value in split array.");
        let r = t.indexOf(-1);
        if (r !== -1) {
            let s = t.reduce((i, l) => l > 0 ? i + l : i);
            t[r] = e.shape[n] - s;
        }
        D(e.shape[n] === t.reduce((s, i) => s + i), () => "The sum of sizes must match the size of the axis dimension."), 
        a = t;
    }
    return a;
}

function _9(e) {
    return `Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`;
}

function O9(e, t) {
    return `indices(${e}, 0) is invalid: ${t} < 0`;
}

function P9(e, t, n) {
    return `indices(${e}, 0) is invalid: ${t} >= ${n}`;
}

function D9(e, t) {
    return `only one output dimension may be -1, not both ${e} and ${t}`;
}

function z9(e, t) {
    return `size ${e} must be non-negative, not ${t}`;
}

function L9() {
    return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}

function W9(e, t) {
    return `Input to reshape is a SparseTensor with ${ht(e)}
  dense values, but the requested shape requires a multiple of ${ht(t)}. inputShape=${e} outputShape= ${t}`;
}

function B9(e, t) {
    return `Input to reshape is a tensor with ${ht(e)} dense values, but the requested shape has ${ht(t)}. inputShape=${e} outputShape=${t}`;
}

function V9() {
    return "segment ids must be >= 0";
}

function U9() {
    return "segment ids are not increasing";
}

function G9(e, t) {
    return `Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`;
}

function H9(e, t, n) {
    return `Bad: indices[${e}] == ${t} out of range [0, ${n})`;
}

var XA = {};

function j9(e, t) {
    let n, a = !1;
    for (e <= gm ? (n = e, a = !0) : n = zp(e, Math.floor(Math.sqrt(e))); !a; ) n > t || n === e ? a = !0 : n = zp(e, n + 1);
    return n;
}

function q9(e, t, n) {
    let a = [], r = e.length;
    for (let s = 0; s < r; s++) s !== t ? a.push(e[s]) : a.push(n);
    return a;
}

function X9(e, t, n, a) {
    let r = t.shape.length, s = e.shape.length;
    if (a !== 0 && (a < -r || a > r)) throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${a}`);
    if (a < 0 && (a += r), a > s) throw new Error(`batchDims (${a}) must be less than rank(x) (
    ${s}).`);
    if (n < a) throw new Error(`batchDims (${a}) must be less than or equal to axis (${n}).`);
    for (let c = 0; c < a; ++c) if (e.shape[c] !== t.shape[c]) throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);
    let i = e.shape[n], l = [], o = 1, p = 1, u = 1;
    for (let c = 0; c < a; ++c) l.push(e.shape[c]), o *= e.shape[c];
    for (let c = a; c < n; c++) l.push(e.shape[c]), p *= e.shape[c];
    for (let c = a; c < r; c++) l.push(t.shape[c]);
    for (let c = n + 1; c < s; c++) l.push(e.shape[c]), u *= e.shape[c];
    return {
        batchSize: o,
        sliceSize: u,
        outerSize: p,
        dimSize: i,
        outputShape: l
    };
}

function K9(e) {
    try {
        return e.map(t => jp(t));
    } catch (t) {
        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`);
    }
}

function Z9(e) {
    return e.map(t => Ad(t));
}

Ze(XA, {
    collectGatherOpShapeInfo: () => X9,
    computeOutShape: () => q9,
    segOpComputeOptimalWindowSize: () => j9
});

var Vn, KA, ua = {};

Ze(ua, {
    nonMaxSuppressionV3Impl: () => lA,
    nonMaxSuppressionV4Impl: () => uA,
    nonMaxSuppressionV5Impl: () => dA,
    whereImpl: () => Jy
}), function() {
    for (let e of I8) wA(e);
}(), H().registerFlag("KEEP_INTERMEDIATE_TENSORS", () => !1, e => {}), function(e) {
    e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", 
    e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", 
    e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", 
    e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", 
    e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", 
    e[e.DT_QINT16 = 15] = "DT_QINT16", e[e.DT_QUINT16 = 16] = "DT_QUINT16", e[e.DT_UINT16 = 17] = "DT_UINT16", 
    e[e.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e[e.DT_HALF = 19] = "DT_HALF", e[e.DT_RESOURCE = 20] = "DT_RESOURCE", 
    e[e.DT_VARIANT = 21] = "DT_VARIANT", e[e.DT_UINT32 = 22] = "DT_UINT32", e[e.DT_UINT64 = 23] = "DT_UINT64", 
    e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", 
    e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", 
    e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", 
    e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", 
    e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", 
    e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", 
    e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", 
    e[e.DT_QINT16_REF = 115] = "DT_QINT16_REF", e[e.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", 
    e[e.DT_UINT16_REF = 117] = "DT_UINT16_REF", e[e.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", 
    e[e.DT_HALF_REF = 119] = "DT_HALF_REF", e[e.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", 
    e[e.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e[e.DT_UINT32_REF = 122] = "DT_UINT32_REF", 
    e[e.DT_UINT64_REF = 123] = "DT_UINT64_REF";
}(Vn || (Vn = {})), function(e) {
    var t;
    (t = e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))[t.LEGACY = 0] = "LEGACY", 
    t[t.V1 = 1] = "V1", t[t.V2 = 2] = "V2";
}(KA || (KA = {}));

var Am = {};

function Y9(e, t) {
    let n = {
        tfOpName: e,
        category: "custom",
        inputs: [],
        attrs: [],
        customExecutor: t
    };
    Am[e] = n;
}

function ZA(e) {
    return Am[e];
}

function J9(e) {
    delete Am[e];
}

function S(e, t, n, a, r) {
    let s = t.inputParams[e];
    if (s && s.inputIndexStart !== void 0) {
        let l = s.inputIndexStart, o = s.inputIndexEnd === 0 ? void 0 : s.inputIndexEnd === void 0 ? l + 1 : s.inputIndexEnd, p = l < 0 ? t.inputNames.length + l : l;
        if (s.type === "tensor") return Jt(t.inputNames[p], n, a, r);
        if (s.type === "tensors") {
            let d = t.inputs.slice(l, o);
            return t.inputNames.slice(l, o).filter((h, f) => {
                var m;
                return ((m = d[f]) === null || m === void 0 ? void 0 : m.op) !== "NoOp";
            }).map(h => Jt(h, n, a, r));
        }
        let u = Jt(t.inputNames[p], n, a, r), c = u.dataSync();
        return s.type === "number" ? c[0] : k.toNestedArray(u.shape, c);
    }
    let i = t.attrParams[e];
    return i && i.value;
}

function Jt(e, t, n, a) {
    let [ r, s ] = Un(e, n);
    if (a != null) {
        let l = a.getHashTableHandleByName(r);
        if (l != null) return l;
    }
    let i = n.currentContextIds.find(l => !!t[bc(r, l)]);
    return i !== void 0 ? t[bc(r, i)][s] : void 0;
}

function YA(e, t, n) {
    return t[bc(e, n.currentContextId)];
}

function ar(e, t) {
    let [ n, a, r ] = Un(e, t);
    return [ bc(n, t && t.currentContextId), a, r ];
}

function bc(e, t) {
    return t ? `${e}-${t}` : e;
}

function Un(e, t) {
    if (e === "") return [ "", 0, void 0 ];
    let n = t != null && t.parseNodeNameCache != null;
    if (n) {
        let s = t.parseNodeNameCache.get(e);
        if (s != null) return s;
    }
    let a, r = e.split(":");
    if (r.length === 1) a = [ e, 0, void 0 ]; else {
        let s = r[0], i = r.length === 3 ? r[1] : void 0;
        a = [ s, Number(r[r.length - 1]), i ];
    }
    return n && t.parseNodeNameCache.set(e, a), a;
}

function vc(e, t, n) {
    let a = S("pad", e, t, n);
    if (a === "explicit") {
        a = S("explicitPaddings", e, t, n);
        let r = [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ];
        for (let s = 0; s < 4; s++) r[s][0] = a[2 * s], r[s][1] = a[2 * s + 1];
        return r;
    }
    return a;
}

function Wr(e) {
    return e.kept ? e : wn(e);
}

var JA = {};

Ze(JA, {
    json: () => Q9
});

var Q9 = [ {
    tfOpName: "Add",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "AddV2",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "AddN",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
    } ]
}, {
    tfOpName: "BiasAdd",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    } ]
}, {
    tfOpName: "Sub",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "RealDiv",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Div",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "DivNoNan",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "FloorDiv",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Mul",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Maximum",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Minimum",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Pow",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "SquaredDifference",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Mod",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "FloorMod",
    category: "arithmetic",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
} ], QA = {};

Ze(QA, {
    json: () => eN
});

var eN = [ {
    tfOpName: "Abs",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Acos",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Asin",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Atan",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Atan2",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "y",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Ceil",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "ClipByValue",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "clipValueMin",
        type: "number"
    }, {
        start: 2,
        name: "clipValueMax",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Complex",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "real",
        type: "tensor"
    }, {
        start: 1,
        name: "imag",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "ComplexAbs",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Cos",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Cosh",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Elu",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Exp",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Floor",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Log",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Imag",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Neg",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Real",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "Tout",
        name: "outputType",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Prelu",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "alpha",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Relu",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Relu6",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Selu",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Sigmoid",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Sin",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Sinh",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Sqrt",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Rsqrt",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Square",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Tan",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Tanh",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Sign",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Round",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Expm1",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Log1p",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Reciprocal",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Softplus",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Asinh",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Acosh",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Atanh",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Erf",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LeakyRelu",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: .2
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "IsNan",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "IsFinite",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "IsInf",
    category: "basic_math",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
} ], ex = {};

Ze(ex, {
    json: () => tN
});

var tN = [ {
    tfOpName: "EmptyTensorList",
    category: "control",
    inputs: [ {
        start: 0,
        name: "elementShape",
        type: "shape"
    }, {
        start: 1,
        name: "maxNumElements",
        type: "number"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "LoopCond",
    category: "control",
    inputs: [ {
        start: 0,
        name: "pred",
        type: "tensor"
    } ]
}, {
    tfOpName: "Switch",
    category: "control",
    inputs: [ {
        start: 0,
        name: "data",
        type: "tensor"
    }, {
        start: 1,
        name: "pred",
        type: "tensor"
    } ]
}, {
    tfOpName: "Merge",
    category: "control",
    inputs: [ {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
    } ]
}, {
    tfOpName: "Enter",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "frame_name",
        name: "frameName",
        type: "string"
    }, {
        tfName: "is_constant",
        name: "isConstant",
        type: "bool"
    } ]
}, {
    tfOpName: "Exit",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "NextIteration",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "TensorArrayV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "size",
        type: "number"
    } ],
    attrs: [ {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
    }, {
        tfName: "dynamic_size",
        name: "dynamicSize",
        type: "bool"
    }, {
        tfName: "clear_after_read",
        name: "clearAfterRead",
        type: "bool"
    }, {
        tfName: "identical_element_shapes",
        name: "identicalElementShapes",
        type: "bool"
    }, {
        tfName: "tensor_array_name",
        name: "name",
        type: "string"
    } ]
}, {
    tfOpName: "TensorArrayWriteV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "index",
        type: "number"
    }, {
        start: 2,
        name: "tensor",
        type: "tensor"
    }, {
        start: 3,
        name: "flowIn",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "TensorArrayReadV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "index",
        type: "number"
    }, {
        start: 2,
        name: "flowIn",
        type: "number"
    } ],
    attrs: [ {
        tfName: "dtype",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "TensorArrayGatherV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "number[]"
    }, {
        start: 2,
        name: "flowIn",
        type: "number"
    } ],
    attrs: [ {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
    } ]
}, {
    tfOpName: "TensorArrayScatterV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "number[]"
    }, {
        start: 2,
        name: "tensor",
        type: "tensor"
    }, {
        start: 3,
        name: "flowIn",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorArrayConcatV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "flowIn",
        type: "number"
    } ],
    attrs: [ {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "element_shape_except0",
        name: "elementShapeExcept0",
        type: "shape",
        notSupported: !0
    } ]
}, {
    tfOpName: "TensorArraySplitV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "tensor",
        type: "tensor"
    }, {
        start: 2,
        name: "lengths",
        type: "number[]"
    }, {
        start: 3,
        name: "flowIn",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorArraySizeV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    }, {
        start: 1,
        name: "flowIn",
        type: "number"
    } ]
}, {
    tfOpName: "TensorArrayCloseV3",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorArrayId",
        type: "tensor"
    } ]
}, {
    tfOpName: "StatelessIf",
    category: "control",
    inputs: [ {
        start: 0,
        name: "cond",
        type: "tensor"
    }, {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
    }, {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
    } ]
}, {
    tfOpName: "If",
    category: "control",
    inputs: [ {
        start: 0,
        name: "cond",
        type: "tensor"
    }, {
        start: 1,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "then_branch",
        name: "thenBranch",
        type: "func"
    }, {
        tfName: "else_branch",
        name: "elseBranch",
        type: "func"
    } ]
}, {
    tfOpName: "StatelessWhile",
    category: "control",
    inputs: [ {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "cond",
        name: "cond",
        type: "func"
    }, {
        tfName: "body",
        name: "body",
        type: "func"
    } ]
}, {
    tfOpName: "While",
    category: "control",
    inputs: [ {
        start: 0,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "cond",
        name: "cond",
        type: "func"
    }, {
        tfName: "body",
        name: "body",
        type: "func"
    } ]
}, {
    tfOpName: "TensorListScatter",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "number[]"
    }, {
        start: 2,
        name: "elementShape",
        type: "shape"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListScatterV2",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "number[]"
    }, {
        start: 2,
        name: "elementShape",
        type: "shape"
    }, {
        start: 3,
        name: "numElements",
        type: "number"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListGather",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "number[]"
    }, {
        start: 2,
        name: "elementShape",
        type: "shape"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListGetItem",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "index",
        type: "number"
    }, {
        start: 2,
        name: "elementShape",
        type: "shape"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListSetItem",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "index",
        type: "number"
    }, {
        start: 2,
        name: "tensor",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListReserve",
    category: "control",
    inputs: [ {
        start: 0,
        name: "elementShape",
        type: "shape"
    }, {
        start: 1,
        name: "numElements",
        type: "number"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListFromTensor",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    }, {
        start: 1,
        name: "elementShape",
        type: "shape"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListStack",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "elementShape",
        type: "shape"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    }, {
        tfName: "num_elements",
        name: "numElements",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListSplit",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    }, {
        start: 1,
        name: "elementShape",
        type: "shape"
    }, {
        start: 2,
        name: "lengths",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListConcat",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
    }, {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListConcatV2",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "element_shape",
        name: "elementShape",
        type: "shape"
    }, {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListPopBack",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "elementShape",
        type: "shape"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListPushBack",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "tensor",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "element_dtype",
        name: "elementDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "TensorListLength",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    } ]
}, {
    tfOpName: "TensorListResize",
    category: "control",
    inputs: [ {
        start: 0,
        name: "tensorListId",
        type: "tensor"
    }, {
        start: 1,
        name: "size",
        type: "number"
    } ]
} ], tx = {};

Ze(tx, {
    json: () => nN
});

var nN = [ {
    tfOpName: "AvgPool",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "MaxPool",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: [],
        notSupported: !0
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "MaxPoolWithArgmax",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
    }, {
        tfName: "include_batch_in_index",
        name: "includeBatchInIndex",
        type: "bool"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "AvgPool3D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "MaxPool3D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    }, {
        tfName: "ksize",
        name: "kernelSize",
        type: "number[]"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Conv1D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "stride",
        name: "stride",
        type: "number"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NWC"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "dilation",
        name: "dilation",
        type: "number",
        defaultValue: 1
    } ]
}, {
    tfOpName: "Conv2D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "useCudnnOnGpu",
        name: "useCudnnOnGpu",
        type: "bool"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
    } ]
}, {
    tfOpName: "_FusedConv2D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
    }, {
        tfName: "use_cudnn_on_gpu",
        name: "useCudnnOnGpu",
        type: "bool",
        defaultValue: !0
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [ 1, 1, 1, 1 ]
    }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
    }, {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
    }, {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: .2
    } ]
}, {
    tfOpName: "Conv2DBackpropInput",
    category: "convolution",
    inputs: [ {
        start: 2,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    }, {
        start: 0,
        name: "outputShape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        notSupported: !0
    } ]
}, {
    tfOpName: "DepthwiseConv2d",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "input",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
    } ]
}, {
    tfOpName: "DepthwiseConv2dNative",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "input",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
    } ]
}, {
    tfOpName: "FusedDepthwiseConv2dNative",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]",
        defaultValue: [ 1, 1, 1, 1 ]
    }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
    }, {
        tfName: "explicit_paddings",
        name: "explicitPaddings",
        type: "number[]",
        defaultValue: []
    } ]
}, {
    tfOpName: "Conv3D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        defaultValue: "NHWC"
    }, {
        tfName: "dilations",
        name: "dilations",
        type: "number[]"
    } ]
}, {
    tfOpName: "Dilation2D",
    category: "convolution",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "filter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "strides",
        name: "strides",
        type: "number[]"
    }, {
        tfName: "rates",
        name: "dilations",
        type: "number[]"
    }, {
        tfName: "padding",
        name: "pad",
        type: "string"
    } ]
} ], nx = {};

Ze(nx, {
    json: () => aN
});

var aN = [ {
    tfOpName: "Fill",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    }, {
        start: 1,
        name: "value",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "LinSpace",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "start",
        type: "number"
    }, {
        start: 1,
        name: "stop",
        type: "number"
    }, {
        start: 2,
        name: "num",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "OneHot",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "indices",
        type: "tensor"
    }, {
        start: 1,
        name: "depth",
        type: "number"
    }, {
        start: 2,
        name: "onValue",
        type: "number",
        defaultValue: 1
    }, {
        start: 3,
        name: "offValue",
        type: "number",
        defaultValue: 0
    } ],
    attrs: [ {
        tfName: "axis",
        name: "axis",
        type: "number",
        notSupported: !0
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "Ones",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "OnesLike",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "RandomStandardNormal",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
    }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
    } ]
}, {
    tfOpName: "RandomUniform",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "minval",
        name: "minval",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "maxval",
        name: "maxval",
        type: "number",
        defaultValue: 1
    }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
    }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
    } ]
}, {
    tfOpName: "RandomUniformInt",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "minval",
        name: "minval",
        type: "number"
    }, {
        tfName: "maxval",
        name: "maxval",
        type: "number"
    }, {
        tfName: "seed",
        name: "seed",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
    } ]
}, {
    tfOpName: "Range",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "start",
        type: "number"
    }, {
        start: 1,
        name: "stop",
        type: "number"
    }, {
        start: 2,
        name: "step",
        type: "number",
        defaultValue: 0
    } ],
    attrs: [ {
        tfName: "Tidx",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "TruncatedNormal",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "means",
        name: "mean",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "stddev",
        name: "stdDev",
        type: "number",
        defaultValue: 1
    }, {
        tfName: "seed",
        name: "seed",
        type: "number"
    }, {
        tfName: "seed2",
        name: "seed2",
        type: "number",
        defaultValue: 0,
        notSupported: !0
    }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "T",
        name: "T",
        type: "number",
        notSupported: !0
    } ]
}, {
    tfOpName: "Zeros",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "shape",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "ZerosLike",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "Multinomial",
    category: "creation",
    inputs: [ {
        start: 0,
        name: "logits",
        type: "tensor"
    }, {
        start: 1,
        name: "numSamples",
        type: "number"
    } ],
    attrs: [ {
        tfName: "seed",
        name: "seed",
        type: "number"
    }, {
        tfName: "seed2",
        name: "seed2",
        type: "number"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    }, {
        tfName: "output_dtype",
        name: "output_dtype",
        type: "dtype"
    } ]
} ], ax = {};

Ze(ax, {
    json: () => rN
});

var rN = [ {
    tfOpName: "NonMaxSuppressionV2",
    category: "dynamic",
    inputs: [ {
        start: 0,
        name: "boxes",
        type: "tensor"
    }, {
        start: 1,
        name: "scores",
        type: "tensor"
    }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
    }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
    } ]
}, {
    tfOpName: "NonMaxSuppressionV3",
    category: "dynamic",
    inputs: [ {
        start: 0,
        name: "boxes",
        type: "tensor"
    }, {
        start: 1,
        name: "scores",
        type: "tensor"
    }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
    }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
    }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
    } ]
}, {
    tfOpName: "NonMaxSuppressionV4",
    category: "dynamic",
    inputs: [ {
        start: 0,
        name: "boxes",
        type: "tensor"
    }, {
        start: 1,
        name: "scores",
        type: "tensor"
    }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
    }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
    }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "T_threshold",
        name: "threshold",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "pad_to_max_output_size",
        name: "padToMaxOutputSize",
        type: "bool"
    } ]
}, {
    tfOpName: "NonMaxSuppressionV5",
    category: "dynamic",
    inputs: [ {
        start: 0,
        name: "boxes",
        type: "tensor"
    }, {
        start: 1,
        name: "scores",
        type: "tensor"
    }, {
        start: 2,
        name: "maxOutputSize",
        type: "number"
    }, {
        start: 3,
        name: "iouThreshold",
        type: "number"
    }, {
        start: 4,
        name: "scoreThreshold",
        type: "number"
    }, {
        start: 5,
        name: "softNmsSigma",
        type: "number"
    } ]
}, {
    tfOpName: "Where",
    category: "dynamic",
    inputs: [ {
        start: 0,
        name: "condition",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "ListDiff",
    category: "dynamic",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "y",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
} ], rx = {};

Ze(rx, {
    json: () => sN
});

var sN = [ {
    tfOpName: "LowerBound",
    category: "evaluation",
    inputs: [ {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
    }, {
        start: 1,
        name: "values",
        type: "tensor"
    } ]
}, {
    tfOpName: "TopKV2",
    category: "evaluation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "k",
        type: "number"
    } ],
    attrs: [ {
        tfName: "sorted",
        name: "sorted",
        type: "bool"
    } ]
}, {
    tfOpName: "UpperBound",
    category: "evaluation",
    inputs: [ {
        start: 0,
        name: "sortedSequence",
        type: "tensor"
    }, {
        start: 1,
        name: "values",
        type: "tensor"
    } ]
}, {
    tfOpName: "Unique",
    category: "evaluation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "UniqueV2",
    category: "evaluation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number"
    } ]
} ], sx = {};

Ze(sx, {
    json: () => iN
});

var iN = [ {
    tfOpName: "PlaceholderWithDefault",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "default",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "shape",
        name: "shape",
        type: "shape"
    }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "Placeholder",
    category: "graph",
    attrs: [ {
        tfName: "shape",
        name: "shape",
        type: "shape"
    }, {
        tfName: "dtype",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "Const",
    category: "graph"
}, {
    tfOpName: "Identity",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "IdentityN",
    category: "graph",
    inputs: [ {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
    } ]
}, {
    tfOpName: "Snapshot",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "Rank",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "Size",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "Shape",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "ShapeN",
    category: "graph",
    inputs: [ {
        start: 0,
        end: 0,
        name: "x",
        type: "tensors"
    } ]
}, {
    tfOpName: "Print",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "data",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "message",
        name: "message",
        type: "string"
    }, {
        tfName: "first_n",
        name: "firstN",
        type: "number",
        notSupported: !0
    }, {
        tfName: "summarize",
        name: "summarize",
        type: "number",
        defaultValue: 3
    } ]
}, {
    tfOpName: "NoOp",
    category: "graph",
    inputs: []
}, {
    tfOpName: "StopGradient",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "FakeQuantWithMinMaxVars",
    category: "graph",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "min",
        name: "min",
        type: "number"
    }, {
        tfName: "max",
        name: "max",
        type: "number"
    } ]
} ], ix = {};

Ze(ix, {
    json: () => oN
});

var oN = [ {
    tfOpName: "HashTable",
    category: "hash_table",
    inputs: [],
    attrs: [ {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
    }, {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
    }, {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
    }, {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "HashTableV2",
    category: "hash_table",
    inputs: [],
    attrs: [ {
        tfName: "shared_name",
        name: "sharedName",
        type: "string"
    }, {
        tfName: "use_node_name_sharing",
        name: "useNodeNameSharing",
        type: "bool"
    }, {
        tfName: "key_dtype",
        name: "keyDType",
        type: "dtype"
    }, {
        tfName: "value_dtype",
        name: "valueDType",
        type: "dtype"
    } ]
}, {
    tfOpName: "LookupTableImport",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    }, {
        start: 1,
        name: "keys",
        type: "tensor"
    }, {
        start: 2,
        name: "values",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LookupTableImportV2",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    }, {
        start: 1,
        name: "keys",
        type: "tensor"
    }, {
        start: 2,
        name: "values",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LookupTableFind",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    }, {
        start: 1,
        name: "keys",
        type: "tensor"
    }, {
        start: 2,
        name: "defaultValue",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LookupTableFindV2",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    }, {
        start: 1,
        name: "keys",
        type: "tensor"
    }, {
        start: 2,
        name: "defaultValue",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "Tin",
        name: "tIn",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "Tout",
        name: "tOut",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LookupTableSize",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    } ]
}, {
    tfOpName: "LookupTableSizeV2",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    } ]
}, {
    tfOpName: "InitializeTable",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    }, {
        start: 1,
        name: "keys",
        type: "tensor"
    }, {
        start: 2,
        name: "values",
        type: "tensor"
    } ]
}, {
    tfOpName: "InitializeTableV2",
    category: "hash_table",
    inputs: [ {
        start: 0,
        name: "tableHandle",
        type: "tensor"
    }, {
        start: 1,
        name: "keys",
        type: "tensor"
    }, {
        start: 2,
        name: "values",
        type: "tensor"
    } ]
} ], ox = {};

Ze(ox, {
    json: () => lN
});

var lN = [ {
    tfOpName: "ResizeBilinear",
    category: "image",
    inputs: [ {
        start: 0,
        name: "images",
        type: "tensor"
    }, {
        start: 1,
        name: "size",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
    }, {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "ResizeNearestNeighbor",
    category: "image",
    inputs: [ {
        start: 0,
        name: "images",
        type: "tensor"
    }, {
        start: 1,
        name: "size",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "align_corners",
        name: "alignCorners",
        type: "bool"
    }, {
        tfName: "half_pixel_centers",
        name: "halfPixelCenters",
        type: "bool"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "CropAndResize",
    category: "image",
    inputs: [ {
        start: 0,
        name: "image",
        type: "tensor"
    }, {
        start: 1,
        name: "boxes",
        type: "tensor"
    }, {
        start: 2,
        name: "boxInd",
        type: "tensor"
    }, {
        start: 3,
        name: "cropSize",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "method",
        name: "method",
        type: "string"
    }, {
        tfName: "extrapolation_value",
        name: "extrapolationValue",
        type: "number"
    } ]
}, {
    tfOpName: "ImageProjectiveTransformV3",
    category: "image",
    inputs: [ {
        start: 0,
        name: "images",
        type: "tensor"
    }, {
        start: 1,
        name: "transforms",
        type: "tensor"
    }, {
        start: 2,
        name: "outputShape",
        type: "number[]"
    }, {
        start: 3,
        name: "fillValue",
        type: "number"
    } ],
    attrs: [ {
        tfName: "interpolation",
        name: "interpolation",
        type: "string"
    }, {
        tfName: "fill_mode",
        name: "fillMode",
        type: "string"
    } ]
} ], lx = {};

Ze(lx, {
    json: () => uN
});

var uN = [ {
    tfOpName: "Equal",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "NotEqual",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Greater",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "GreaterEqual",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Less",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LessEqual",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LogicalAnd",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LogicalNot",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "LogicalOr",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Select",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "condition",
        type: "tensor"
    }, {
        start: 1,
        name: "a",
        type: "tensor"
    }, {
        start: 2,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "SelectV2",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "condition",
        type: "tensor"
    }, {
        start: 1,
        name: "a",
        type: "tensor"
    }, {
        start: 2,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "BitwiseAnd",
    category: "logical",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "y",
        type: "tensor"
    } ]
} ], ux = {};

Ze(ux, {
    json: () => dN
});

var dN = [ {
    tfOpName: "_FusedMatMul",
    category: "matrices",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    }, {
        start: 2,
        end: 0,
        name: "args",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "num_args",
        name: "numArgs",
        type: "number"
    }, {
        tfName: "fused_ops",
        name: "fusedOps",
        type: "string[]",
        defaultValue: []
    }, {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: 1e-4
    }, {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "leakyrelu_alpha",
        name: "leakyreluAlpha",
        type: "number",
        defaultValue: .2
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "MatMul",
    category: "matrices",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "transpose_a",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "transpose_b",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "BatchMatMul",
    category: "matrices",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "BatchMatMulV2",
    category: "matrices",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "b",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "adj_x",
        name: "transposeA",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "adj_y",
        name: "transposeB",
        type: "bool",
        defaultValue: !1
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Transpose",
    category: "matrices",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "perm",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Einsum",
    category: "matrices",
    inputs: [ {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "equation",
        name: "equation",
        type: "string"
    }, {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "MatrixBandPart",
    category: "matrices",
    inputs: [ {
        start: 0,
        name: "a",
        type: "tensor"
    }, {
        start: 1,
        name: "numLower",
        type: "tensor"
    }, {
        start: 1,
        name: "numUpper",
        type: "tensor"
    } ]
} ], dx = {};

Ze(dx, {
    json: () => pN
});

var pN = [ {
    tfOpName: "EuclideanNorm",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool",
        defaultValue: !1
    } ]
}, {
    tfOpName: "FusedBatchNorm",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "scale",
        type: "tensor"
    }, {
        start: 2,
        name: "offset",
        type: "tensor"
    }, {
        start: 3,
        name: "mean",
        type: "tensor"
    }, {
        start: 4,
        name: "variance",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: .001
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    } ]
}, {
    tfOpName: "FusedBatchNormV2",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "scale",
        type: "tensor"
    }, {
        start: 2,
        name: "offset",
        type: "tensor"
    }, {
        start: 3,
        name: "mean",
        type: "tensor"
    }, {
        start: 4,
        name: "variance",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: .001
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    } ]
}, {
    tfOpName: "FusedBatchNormV3",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "scale",
        type: "tensor"
    }, {
        start: 2,
        name: "offset",
        type: "tensor"
    }, {
        start: 3,
        name: "mean",
        type: "tensor"
    }, {
        start: 4,
        name: "variance",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "epsilon",
        name: "epsilon",
        type: "number",
        defaultValue: .001
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string",
        notSupported: !0
    } ]
}, {
    tfOpName: "LRN",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "depth_radius",
        name: "radius",
        type: "number",
        defaultValue: 5
    }, {
        tfName: "bias",
        name: "bias",
        type: "number",
        defaultValue: 1
    }, {
        tfName: "alpha",
        name: "alpha",
        type: "number",
        defaultValue: 1
    }, {
        tfName: "beta",
        name: "beta",
        type: "number",
        defaultValue: .5
    } ]
}, {
    tfOpName: "Softmax",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "LogSoftmax",
    category: "normalization",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
} ], px = {};

Ze(px, {
    json: () => cN
});

var cN = [ {
    tfOpName: "Bincount",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "size",
        type: "number"
    }, {
        start: 2,
        name: "weights",
        type: "tensor"
    } ]
}, {
    tfOpName: "DenseBincount",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "size",
        type: "number"
    }, {
        start: 2,
        name: "weights",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "binary_output",
        name: "binaryOutput",
        type: "bool"
    } ]
}, {
    tfOpName: "Max",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    } ]
}, {
    tfOpName: "Mean",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    } ]
}, {
    tfOpName: "Min",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    } ]
}, {
    tfOpName: "Sum",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    } ]
}, {
    tfOpName: "All",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    } ]
}, {
    tfOpName: "Any",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    } ]
}, {
    tfOpName: "ArgMax",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number"
    } ]
}, {
    tfOpName: "ArgMin",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number"
    } ]
}, {
    tfOpName: "Prod",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "keep_dims",
        name: "keepDims",
        type: "bool"
    }, {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "Cumprod",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number"
    } ],
    attrs: [ {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
    }, {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
    } ]
}, {
    tfOpName: "Cumsum",
    category: "reduction",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number"
    } ],
    attrs: [ {
        tfName: "exclusive",
        name: "exclusive",
        type: "bool"
    }, {
        tfName: "reverse",
        name: "reverse",
        type: "bool"
    } ]
} ], cx = {};

Ze(cx, {
    json: () => hN
});

var hN = [ {
    tfOpName: "ConcatV2",
    category: "slice_join",
    inputs: [ {
        start: 0,
        end: -1,
        name: "tensors",
        type: "tensors"
    }, {
        start: -1,
        name: "axis",
        type: "number"
    } ],
    attrs: [ {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
    } ]
}, {
    tfOpName: "Concat",
    category: "slice_join",
    inputs: [ {
        start: 1,
        end: 0,
        name: "tensors",
        type: "tensors"
    }, {
        start: 0,
        name: "axis",
        type: "number"
    } ],
    attrs: [ {
        tfName: "N",
        name: "n",
        type: "number",
        defaultValue: 2
    } ]
}, {
    tfOpName: "GatherV2",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "tensor"
    }, {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
    } ],
    attrs: [ {
        tfName: "batch_dims",
        name: "batchDims",
        type: "number",
        defaultValue: 0
    } ]
}, {
    tfOpName: "Gather",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        notSupported: !0
    } ]
}, {
    tfOpName: "Reverse",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "dims",
        type: "bool[]"
    } ]
}, {
    tfOpName: "ReverseV2",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number[]"
    } ]
}, {
    tfOpName: "Slice",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "begin",
        type: "number[]"
    }, {
        start: 2,
        name: "size",
        type: "number[]"
    } ]
}, {
    tfOpName: "StridedSlice",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "begin",
        type: "number[]"
    }, {
        start: 2,
        name: "end",
        type: "number[]"
    }, {
        start: 3,
        name: "strides",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "begin_mask",
        name: "beginMask",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "end_mask",
        name: "endMask",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "new_axis_mask",
        name: "newAxisMask",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "ellipsis_mask",
        name: "ellipsisMask",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "shrink_axis_mask",
        name: "shrinkAxisMask",
        type: "number",
        defaultValue: 0
    } ]
}, {
    tfOpName: "Pack",
    category: "slice_join",
    inputs: [ {
        start: 0,
        end: 0,
        name: "tensors",
        type: "tensors"
    } ],
    attrs: [ {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
    } ]
}, {
    tfOpName: "Unpack",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "axis",
        name: "axis",
        type: "number",
        defaultValue: 0
    }, {
        tfName: "num",
        name: "num",
        type: "number",
        defaultValue: 0,
        notSupported: !0
    } ]
}, {
    tfOpName: "Tile",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "reps",
        type: "number[]"
    } ]
}, {
    tfOpName: "Split",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "axis",
        type: "number",
        defaultValue: 0
    }, {
        start: 1,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "num_split",
        name: "numOrSizeSplits",
        type: "number",
        defaultValue: 1
    } ]
}, {
    tfOpName: "SplitV",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "numOrSizeSplits",
        type: "number[]"
    }, {
        start: 2,
        name: "axis",
        type: "number",
        defaultValue: 0
    } ]
}, {
    tfOpName: "ScatterNd",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "indices",
        type: "tensor"
    }, {
        start: 1,
        name: "values",
        type: "tensor"
    }, {
        start: 2,
        name: "shape",
        type: "number[]"
    } ]
}, {
    tfOpName: "GatherNd",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "tensor"
    } ]
}, {
    tfOpName: "SparseToDense",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "sparseIndices",
        type: "tensor"
    }, {
        start: 1,
        name: "outputShape",
        type: "number[]"
    }, {
        start: 2,
        name: "sparseValues",
        type: "tensor"
    }, {
        start: 3,
        name: "defaultValue",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "validate_indices",
        name: "validateIndices",
        type: "bool",
        defaultValue: !1,
        notSupported: !0
    } ]
}, {
    tfOpName: "TensorScatterUpdate",
    category: "slice_join",
    inputs: [ {
        start: 0,
        name: "tensor",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "tensor"
    }, {
        start: 2,
        name: "values",
        type: "tensor"
    } ]
} ], hx = {};

Ze(hx, {
    json: () => fN
});

var fN = [ {
    tfOpName: "SparseFillEmptyRows",
    category: "sparse",
    inputs: [ {
        start: 0,
        name: "indices",
        type: "tensor"
    }, {
        start: 1,
        name: "values",
        type: "tensor"
    }, {
        start: 2,
        name: "denseShape",
        type: "tensor"
    }, {
        start: 3,
        name: "defaultValue",
        type: "tensor"
    } ]
}, {
    tfOpName: "SparseReshape",
    category: "sparse",
    inputs: [ {
        start: 0,
        name: "inputIndices",
        type: "tensor"
    }, {
        start: 1,
        name: "inputShape",
        type: "tensor"
    }, {
        start: 2,
        name: "newShape",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "T",
        name: "dtype",
        type: "dtype",
        notSupported: !0
    } ]
}, {
    tfOpName: "SparseSegmentMean",
    category: "sparse",
    inputs: [ {
        start: 0,
        name: "data",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "tensor"
    }, {
        start: 2,
        name: "segmentIds",
        type: "tensor"
    } ]
}, {
    tfOpName: "SparseSegmentSum",
    category: "sparse",
    inputs: [ {
        start: 0,
        name: "data",
        type: "tensor"
    }, {
        start: 1,
        name: "indices",
        type: "tensor"
    }, {
        start: 2,
        name: "segmentIds",
        type: "tensor"
    } ]
} ], fx = {};

Ze(fx, {
    json: () => mN
});

var mN = [ {
    tfOpName: "FFT",
    category: "spectral",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "IFFT",
    category: "spectral",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ]
}, {
    tfOpName: "RFFT",
    category: "spectral",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
    } ]
}, {
    tfOpName: "IRFFT",
    category: "spectral",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "fft_length",
        type: "number",
        notSupported: !0
    } ]
} ], mx = {};

Ze(mx, {
    json: () => gN
});

var gN = [ {
    tfOpName: "StaticRegexReplace",
    category: "string",
    inputs: [ {
        start: 0,
        name: "input",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "pattern",
        name: "pattern",
        type: "string"
    }, {
        tfName: "rewrite",
        name: "rewrite",
        type: "string"
    }, {
        tfName: "replace_global",
        name: "replaceGlobal",
        type: "bool"
    } ]
}, {
    tfOpName: "StringNGrams",
    category: "string",
    inputs: [ {
        start: 0,
        name: "data",
        type: "tensor"
    }, {
        start: 1,
        name: "dataSplits",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "separator",
        name: "separator",
        type: "string"
    }, {
        tfName: "ngram_widths",
        name: "nGramWidths",
        type: "number[]"
    }, {
        tfName: "left_pad",
        name: "leftPad",
        type: "string"
    }, {
        tfName: "right_pad",
        name: "rightPad",
        type: "string"
    }, {
        tfName: "pad_width",
        name: "padWidth",
        type: "number"
    }, {
        tfName: "preserve_short_sequences",
        name: "preserveShortSequences",
        type: "bool"
    } ],
    outputs: [ "ngrams", "ngrams_splits" ]
}, {
    tfOpName: "StringSplit",
    category: "string",
    inputs: [ {
        start: 0,
        name: "input",
        type: "tensor"
    }, {
        start: 1,
        name: "delimiter",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "skip_empty",
        name: "skipEmpty",
        type: "bool"
    } ],
    outputs: [ "indices", "values", "shape" ]
}, {
    tfOpName: "StringToHashBucketFast",
    category: "string",
    inputs: [ {
        start: 0,
        name: "input",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "num_buckets",
        name: "numBuckets",
        type: "number"
    } ]
} ], gx = {};

Ze(gx, {
    json: () => yN
});

var yN = [ {
    tfOpName: "Cast",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "SrcT",
        name: "sdtype",
        type: "dtype",
        notSupported: !0
    }, {
        tfName: "DstT",
        name: "dtype",
        type: "dtype"
    } ]
}, {
    tfOpName: "ExpandDims",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "axis",
        type: "number"
    } ]
}, {
    tfOpName: "MirrorPad",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "padding",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "mode",
        name: "mode",
        type: "string"
    } ]
}, {
    tfOpName: "Pad",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "padding",
        type: "number[]"
    } ],
    attrs: [ {
        tfName: "constant_value",
        name: "constantValue",
        type: "number",
        defaultValue: 0
    } ]
}, {
    tfOpName: "PadV2",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "padding",
        type: "number[]"
    }, {
        start: 2,
        name: "constantValue",
        type: "number",
        defaultValue: 0
    } ]
}, {
    tfOpName: "Reshape",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "shape",
        type: "number[]"
    } ]
}, {
    tfOpName: "EnsureShape",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "shape",
        type: "number[]"
    } ]
}, {
    tfOpName: "Squeeze",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "axis",
        tfDeprecatedName: "squeeze_dims",
        name: "axis",
        type: "number[]"
    } ]
}, {
    tfOpName: "SpaceToBatchND",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "blockShape",
        type: "number[]"
    }, {
        start: 2,
        name: "paddings",
        type: "number[]"
    } ]
}, {
    tfOpName: "BatchToSpaceND",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "blockShape",
        type: "number[]"
    }, {
        start: 2,
        name: "crops",
        type: "number[]"
    } ]
}, {
    tfOpName: "DepthToSpace",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    } ],
    attrs: [ {
        tfName: "block_size",
        name: "blockSize",
        type: "number"
    }, {
        tfName: "data_format",
        name: "dataFormat",
        type: "string"
    } ]
}, {
    tfOpName: "BroadcastTo",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "x",
        type: "tensor"
    }, {
        start: 1,
        name: "shape",
        type: "number[]"
    } ],
    attrs: []
}, {
    tfOpName: "BroadcastArgs",
    category: "transformation",
    inputs: [ {
        start: 0,
        name: "s0",
        type: "tensor"
    }, {
        start: 1,
        name: "s1",
        type: "tensor"
    } ],
    attrs: []
} ], yx = class {
    static get Instance() {
        return this._instance || (this._instance = new this());
    }
    constructor() {
        let e = [].concat(...[ JA, QA, ex, tx, nx, ax, rx, sx, ix, ox, lx, ux, dx, px, cx, hx, fx, mx, gx ].map(t => t.json));
        this.opMappers = e.reduce((t, n) => (t[n.tfOpName] = n, t), {});
    }
    transformGraph(e, t = {}) {
        let n = e.node, a = [], r = [], s = [], i = n.reduce((f, m) => (f[m.name] = this.mapNode(m), 
        m.op.startsWith("Placeholder") ? a.push(f[m.name]) : m.op === "Const" ? r.push(f[m.name]) : (m.input == null || m.input.length === 0) && s.push(f[m.name]), 
        f), {}), l = [], o = [], p = {}, u = {};
        t != null && (p = this.mapSignatureEntries(t.inputs), u = this.mapSignatureEntries(t.outputs));
        let c = Object.keys(i);
        c.forEach(f => {
            let m = i[f];
            m.inputNames.forEach((g, y) => {
                let [ A, , x ] = ar(g), b = i[A];
                if (b.outputs != null) {
                    let v = b.outputs.indexOf(x);
                    if (v !== -1) {
                        let I = `${A}:${v}`;
                        m.inputNames[y] = I;
                    }
                }
                m.inputs.push(b), b.children.push(m);
            });
        }), Object.keys(u).length === 0 ? c.forEach(f => {
            let m = i[f];
            m.children.length === 0 && o.push(m);
        }) : Object.keys(u).forEach(f => {
            let [ m ] = ar(f), g = i[m];
            g != null && (g.signatureKey = u[f], o.push(g));
        }), Object.keys(p).length > 0 ? Object.keys(p).forEach(f => {
            let [ m ] = ar(f), g = i[m];
            g && (g.signatureKey = p[f], l.push(g));
        }) : l = a;
        let d = {};
        e.library != null && e.library.function != null && (d = e.library.function.reduce((f, m) => (f[m.signature.name] = this.mapFunction(m), 
        f), {}));
        let h = {
            nodes: i,
            inputs: l,
            outputs: o,
            weights: r,
            placeholders: a,
            signature: t,
            functions: d
        };
        return s.length > 0 && (h.initNodes = s), h;
    }
    mapSignatureEntries(e) {
        return Object.keys(e || {}).reduce((t, n) => (t[e[n].name] = n, t), {});
    }
    mapNode(e) {
        let t = ZA(e.op) || this.opMappers[e.op] || {};
        e.attr == null && (e.attr = {});
        let n = {
            name: e.name,
            op: e.op,
            category: t.category,
            inputNames: (e.input || []).map(a => a.startsWith("^") ? a.slice(1) : a),
            inputs: [],
            children: [],
            inputParams: {},
            attrParams: {},
            rawAttrs: e.attr,
            outputs: t.outputs
        };
        return t.inputs != null && (n.inputParams = t.inputs.reduce((a, r) => (a[r.name] = {
            type: r.type,
            inputIndexStart: r.start,
            inputIndexEnd: r.end
        }, a), {})), t.attrs != null && (n.attrParams = t.attrs.reduce((a, r) => {
            let s, i = r.type;
            switch (r.type) {
              case "string":
                s = xm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = xm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "string[]":
                s = Cm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = Cm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "number":
                s = vm(e.attr, r.tfName, r.defaultValue || 0), s === void 0 && r.tfDeprecatedName && (s = vm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "number[]":
                s = Nm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = Nm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "bool":
                s = bm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = bm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "bool[]":
                s = Rm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = Rm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "shape":
                s = Sm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = Sm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "shape[]":
                s = Tm(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = Tm(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "dtype":
                s = km(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = km(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "dtype[]":
                s = Im(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = Im(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "func":
                s = xx(e.attr, r.tfName, r.defaultValue), s === void 0 && r.tfDeprecatedName && (s = xx(e.attr, r.tfDeprecatedName, r.defaultValue));
                break;

              case "tensor":
              case "tensors":
                break;

              default:
                throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`);
            }
            return a[r.name] = {
                value: s,
                type: i
            }, a;
        }, {})), n;
    }
    mapFunction(e) {
        let t = e.nodeDef, n = [], a = {};
        t != null && (a = t.reduce((o, p) => (o[p.name] = this.mapNode(p), p.op === "Const" && n.push(o[p.name]), 
        o), {}));
        let r = [], s = [];
        e.signature.inputArg.forEach(o => {
            let [ p ] = ar(o.name), u = {
                name: p,
                op: "Placeholder",
                inputs: [],
                inputNames: [],
                category: "graph",
                inputParams: {},
                attrParams: {
                    dtype: {
                        value: wm(o.type),
                        type: "dtype"
                    }
                },
                children: []
            };
            u.signatureKey = o.name, r.push(u), a[p] = u;
        }), Object.keys(a).forEach(o => {
            let p = a[o];
            p.inputNames.forEach((u, c) => {
                let [ d, , h ] = ar(u), f = a[d];
                if (f.outputs != null) {
                    let m = f.outputs.indexOf(h);
                    if (m !== -1) {
                        let g = `${d}:${m}`;
                        p.inputNames[c] = g;
                    }
                }
                p.inputs.push(f), f.children.push(p);
            });
        });
        let i = e.ret;
        e.signature.outputArg.forEach(o => {
            let [ p, u ] = ar(i[o.name]), c = a[p];
            c != null && (c.defaultOutput = u, s.push(c));
        });
        let l = this.mapArgsToSignature(e);
        return {
            nodes: a,
            inputs: r,
            outputs: s,
            weights: n,
            placeholders: [],
            signature: l
        };
    }
    mapArgsToSignature(e) {
        return {
            methodName: e.signature.name,
            inputs: e.signature.inputArg.reduce((t, n) => (t[n.name] = this.mapArgToTensorInfo(n), 
            t), {}),
            outputs: e.signature.outputArg.reduce((t, n) => (t[n.name] = this.mapArgToTensorInfo(n, e.ret), 
            t), {})
        };
    }
    mapArgToTensorInfo(e, t) {
        let n = e.name;
        return t != null && (n = t[n]), {
            name: n,
            dtype: e.type
        };
    }
};

function Ax(e, t) {
    let n = Array.isArray(e) ? String.fromCharCode.apply(null, e) : function(a) {
        let r = H().global;
        if (r.atob !== void 0) return r.atob(a);
        if (typeof Buffer < "u") return new Buffer(a, "base64").toString();
        throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
    }(e);
    return t ? n : n.toLowerCase();
}

function xm(e, t, n, a = !1) {
    let r = e[t];
    return r != null ? Ax(r.s, a) : n;
}

function bm(e, t, n) {
    let a = e[t];
    return a ? a.b : n;
}

function vm(e, t, n) {
    let a = e[t] || {}, r = a.i != null ? a.i : a.f != null ? a.f : n;
    return typeof r == "number" ? r : parseInt(r, 10);
}

function wm(e) {
    switch (typeof e == "string" && (e = Vn[e]), e) {
      case Vn.DT_FLOAT:
      case Vn.DT_HALF:
        return "float32";

      case Vn.DT_INT32:
      case Vn.DT_INT64:
      case Vn.DT_INT8:
      case Vn.DT_UINT8:
        return "int32";

      case Vn.DT_BOOL:
        return "bool";

      case Vn.DT_DOUBLE:
        return "float32";

      case Vn.DT_STRING:
        return "string";

      case Vn.DT_COMPLEX64:
      case Vn.DT_COMPLEX128:
        return "complex64";

      default:
        return null;
    }
}

function xx(e, t, n) {
    let a = e[t];
    return a && a.func ? a.func.name : n;
}

function km(e, t, n) {
    let a = e[t];
    return a && a.type ? wm(a.type) : n;
}

function Im(e, t, n) {
    let a = e[t];
    return a && a.list && a.list.type ? a.list.type.map(r => wm(r)) : n;
}

function bx(e) {
    if (!e.unknownRank) return e.dim != null ? e.dim.map(t => typeof t.size == "number" ? t.size : parseInt(t.size, 10)) : [];
}

function Sm(e, t, n) {
    let a = e[t];
    return a && a.shape ? bx(a.shape) : n;
}

function Nm(e, t, n) {
    let a = e[t];
    return a ? ((a.list.f && a.list.f.length ? a.list.f : a.list.i) || []).map(r => typeof r == "number" ? r : parseInt(r, 10)) : n;
}

function Cm(e, t, n, a = !1) {
    let r = e[t];
    return r && r.list && r.list.s ? r.list.s.map(s => Ax(s, a)) : n;
}

function Tm(e, t, n) {
    let a = e[t];
    return a && a.list && a.list.shape ? a.list.shape.map(r => bx(r)) : n;
}

function Rm(e, t, n) {
    let a = e[t];
    return a && a.list && a.list.b ? a.list.b : n;
}

var AN = class {
    constructor(e, t, n) {
        this.node = e, this.tensorMap = t, this.context = n, this.inputs = [], this.attrs = {}, 
        this.inputs = e.inputNames.map(a => this.getInput(a)), e.rawAttrs != null && (this.attrs = Object.keys(e.rawAttrs).reduce((a, r) => (a[r] = this.getAttr(r), 
        a), {}));
    }
    getInput(e) {
        return Jt(e, this.tensorMap, this.context);
    }
    getAttr(e, t) {
        let n = this.node.rawAttrs[e];
        if (n.tensor != null) return Jt(e, this.tensorMap, this.context);
        if (n.i != null || n.f != null) return vm(this.node.rawAttrs, e, t);
        if (n.s != null) return xm(this.node.rawAttrs, e, t);
        if (n.b != null) return bm(this.node.rawAttrs, e, t);
        if (n.shape != null) return Sm(this.node.rawAttrs, e, t);
        if (n.type != null) return km(this.node.rawAttrs, e, t);
        if (n.list != null) {
            if (n.list.i != null || n.list.f != null) return Nm(this.node.rawAttrs, e, t);
            if (n.list.s != null) return Cm(this.node.rawAttrs, e, t);
            if (n.list.shape != null) return Tm(this.node.rawAttrs, e, t);
            if (n.list.b != null) return Rm(this.node.rawAttrs, e, t);
            if (n.list.type != null) return Im(this.node.rawAttrs, e, t);
        }
        return t;
    }
}, Ht = {};

Ze(Ht, {
    OP_SCOPE_SUFFIX: () => af,
    abs: () => Ln,
    acos: () => Y0,
    acosh: () => J0,
    add: () => _e,
    addN: () => hf,
    all: () => Q0,
    any: () => eg,
    argMax: () => Zl,
    argMin: () => tg,
    asin: () => ng,
    asinh: () => ag,
    atan: () => rg,
    atan2: () => sg,
    atanh: () => ig,
    avgPool: () => gf,
    avgPool3d: () => dg,
    basicLSTMCell: () => pg,
    batchNorm: () => $d,
    batchNorm2d: () => cg,
    batchNorm3d: () => hg,
    batchNorm4d: () => fg,
    batchToSpaceND: () => yf,
    bincount: () => Af,
    bitwiseAnd: () => mg,
    booleanMaskAsync: () => Qy,
    broadcastArgs: () => gg,
    broadcastTo: () => Jl,
    buffer: () => We,
    cast: () => Qe,
    ceil: () => yg,
    clipByValue: () => Ag,
    clone: () => wn,
    complex: () => Ka,
    concat: () => yt,
    concat1d: () => xg,
    concat2d: () => Jp,
    concat3d: () => bg,
    concat4d: () => vg,
    conv1d: () => wg,
    conv2d: () => Md,
    conv2dTranspose: () => Ig,
    conv3d: () => Sg,
    conv3dTranspose: () => Ng,
    cos: () => Cg,
    cosh: () => Tg,
    cosineWindow: () => hc,
    cumprod: () => Rg,
    cumsum: () => Eg,
    denseBincount: () => $g,
    depthToSpace: () => Mg,
    depthwiseConv2d: () => Qp,
    diag: () => Fg,
    dilation2d: () => _g,
    div: () => ze,
    divNoNan: () => Pg,
    dot: () => Dg,
    dropout: () => rA,
    einsum: () => go,
    elu: () => vf,
    enclosingPowerOfTwo: () => em,
    ensureShape: () => zg,
    equal: () => bf,
    erf: () => Lg,
    euclideanNorm: () => Vg,
    exp: () => Fr,
    expandDims: () => pn,
    expm1: () => Ug,
    eye: () => kf,
    fft: () => uc,
    fill: () => Qa,
    floor: () => If,
    floorDiv: () => Zp,
    fused: () => tm,
    gather: () => Sf,
    gatherND: () => aA,
    greater: () => Od,
    greaterEqual: () => Nf,
    ifft: () => Bd,
    imag: () => Pd,
    image: () => Ue,
    inTopKAsync: () => sA,
    irfft: () => Xf,
    isFinite: () => Gg,
    isInf: () => Hg,
    isNaN: () => jg,
    leakyRelu: () => Cf,
    less: () => ec,
    lessEqual: () => tc,
    linalg: () => mA,
    linspace: () => qg,
    localResponseNormalization: () => Xg,
    log: () => eu,
    log1p: () => Tf,
    logSigmoid: () => Zg,
    logSoftmax: () => Yg,
    logSumExp: () => Ef,
    logicalAnd: () => Dd,
    logicalNot: () => $f,
    logicalOr: () => Mf,
    logicalXor: () => Jg,
    losses: () => gA,
    lowerBound: () => Qg,
    matMul: () => ut,
    max: () => Jn,
    maxPool: () => Ff,
    maxPool3d: () => ey,
    maxPoolWithArgmax: () => ty,
    maximum: () => _f,
    mean: () => zd,
    meshgrid: () => ny,
    min: () => yo,
    minimum: () => Ld,
    mirrorPad: () => ay,
    mod: () => sc,
    moments: () => ry,
    movingAverage: () => eA,
    mul: () => ne,
    multiRNNCell: () => sy,
    multinomial: () => iy,
    neg: () => wa,
    norm: () => _d,
    notEqual: () => Of,
    oneHot: () => ic,
    ones: () => _r,
    onesLike: () => oy,
    op: () => V,
    outerProduct: () => ly,
    pad: () => Or,
    pad1d: () => uy,
    pad2d: () => dy,
    pad3d: () => py,
    pad4d: () => cy,
    pool: () => hy,
    pow: () => Ql,
    prelu: () => Df,
    print: () => cf,
    prod: () => fy,
    raggedGather: () => my,
    raggedRange: () => gy,
    raggedTensorToTensor: () => yy,
    rand: () => Ay,
    randomGamma: () => wy,
    randomNormal: () => Uf,
    randomStandardNormal: () => ky,
    randomUniform: () => oc,
    randomUniformInt: () => Iy,
    range: () => tu,
    real: () => nu,
    reciprocal: () => Sy,
    relu: () => Wd,
    relu6: () => Gf,
    reshape: () => Q,
    reverse: () => Pr,
    reverse1d: () => Ny,
    reverse2d: () => Cy,
    reverse3d: () => Ty,
    reverse4d: () => Ry,
    rfft: () => dc,
    round: () => Hf,
    rsqrt: () => Ey,
    scalar: () => je,
    scatterND: () => tA,
    searchSorted: () => rc,
    selu: () => $y,
    separableConv2d: () => My,
    setdiff1dAsync: () => Fy,
    sigmoid: () => va,
    sign: () => _y,
    signal: () => fA,
    sin: () => Oy,
    sinh: () => Py,
    slice: () => He,
    slice1d: () => Dy,
    slice2d: () => zy,
    slice3d: () => lc,
    slice4d: () => jf,
    softmax: () => qf,
    softplus: () => Rf,
    spaceToBatchND: () => Pf,
    sparse: () => yA,
    sparseToDense: () => nA,
    spectral: () => hA,
    split: () => Ia,
    sqrt: () => Pa,
    square: () => oa,
    squaredDifference: () => Kf,
    squeeze: () => at,
    stack: () => Bn,
    step: () => Zf,
    stridedSlice: () => Ly,
    string: () => AA,
    sub: () => $e,
    sum: () => dt,
    tan: () => Wy,
    tanh: () => Yp,
    tensor: () => Ye,
    tensor1d: () => Yt,
    tensor2d: () => Dr,
    tensor3d: () => Yf,
    tensor4d: () => By,
    tensor5d: () => Vy,
    tensor6d: () => Uy,
    tensorScatterUpdate: () => Hy,
    tile: () => Ao,
    topk: () => jy,
    transpose: () => au,
    truncatedNormal: () => qy,
    unique: () => Xy,
    unsortedSegmentSum: () => Ky,
    unstack: () => la,
    upperBound: () => Zy,
    variable: () => Yy,
    where: () => er,
    whereAsync: () => Qf,
    zeros: () => ka,
    zerosLike: () => Wn
});

function da(e, t, n = "") {
    if (typeof e != "number" && typeof t != "number") {
        k.assert(e.length === t.length, () => n + ` Shapes ${e} and ${t} must match`);
        for (let a = 0; a < e.length; a++) {
            let r = e[a], s = t[a];
            k.assert(r < 0 || s < 0 || r === s, () => n + ` Shapes ${e} and ${t} must match`);
        }
    }
}

function vx(e) {
    return !(typeof e == "number" || e.some(t => t < 0));
}

function Vd(e, t, n) {
    let a = Em(e, n), r = !vx(a);
    if (r && t.length === 0) throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);
    if (r && t.forEach(s => {
        a = Em(s.shape, a);
    }), !vx(a)) throw new Error(`Non-fully-defined elementShape: ${a}`);
    return a;
}

function Em(e, t) {
    if (typeof e == "number") return t;
    if (typeof t == "number") return e;
    if (e.length !== t.length) throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);
    let n = [];
    for (let a = 0; a < e.length; ++a) {
        let r = e[a], s = t[a];
        if (r >= 0 && s >= 0 && r !== s) throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);
        n[a] = r >= 0 ? r : s;
    }
    return n;
}

var xN = class {
    constructor(e, t, n, a, r, s, i) {
        this.name = e, this.dtype = t, this.maxSize = n, this.elementShape = a, 
        this.identicalElementShapes = r, this.dynamicSize = s, this.clearAfterRead = i, 
        this.tensors = [], this.closed_ = !1, this.idTensor = je(0), ba(this.idTensor);
    }
    get id() {
        return this.idTensor.id;
    }
    get closed() {
        return this.closed_;
    }
    clearAndClose(e) {
        this.tensors.forEach(t => {
            (e == null || !e.has(t.tensor.id)) && t.tensor.dispose();
        }), this.tensors = [], this.closed_ = !0, this.idTensor.dispose();
    }
    size() {
        return this.tensors.length;
    }
    read(e) {
        if (this.closed_) throw new Error(`TensorArray ${this.name} has already been closed.`);
        if (e < 0 || e >= this.size()) throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);
        let t = this.tensors[e];
        if (t.cleared) throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);
        return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor;
    }
    readMany(e) {
        return e.map(t => this.read(t));
    }
    write(e, t) {
        if (this.closed_) throw new Error(`TensorArray ${this.name} has already been closed.`);
        if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);
        let n = this.tensors[e] || {};
        if (t.dtype !== this.dtype) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);
        if (this.size() === 0 && (this.elementShape == null || this.elementShape.length === 0) && (this.elementShape = t.shape), 
        da(this.elementShape, t.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${e}.`), 
        n.read) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);
        if (n.written) throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);
        n.tensor = t, ba(t), n.written = !0, this.tensors[e] = n;
    }
    writeMany(e, t) {
        if (e.length !== t.length) throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);
        e.forEach((n, a) => this.write(n, t[a]));
    }
    gather(e, t) {
        if (t && t !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);
        if (e) e = e.slice(0, this.size()); else {
            e = [];
            for (let a = 0; a < this.size(); a++) e.push(a);
        }
        if (e.length === 0) return Ye([], [ 0 ].concat(this.elementShape));
        let n = this.readMany(e);
        return da(this.elementShape, n[0].shape, "TensorArray shape mismatch: "), 
        Bn(n, 0);
    }
    concat(e) {
        if (e && e !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);
        if (this.size() === 0) return Ye([], [ 0 ].concat(this.elementShape));
        let t = [];
        for (let a = 0; a < this.size(); a++) t.push(a);
        let n = this.readMany(t);
        return da(this.elementShape, n[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`), 
        yt(n, 0);
    }
    scatter(e, t) {
        if (t.dtype !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
        if (e.length !== t.shape[0]) throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);
        let n = Math.max(...e);
        if (!this.dynamicSize && n >= this.maxSize) throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);
        this.writeMany(e, la(t, 0));
    }
    split(e, t) {
        if (t.dtype !== this.dtype) throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);
        let n = 0, a = e.map(l => (n += l, n));
        if (n !== t.shape[0]) throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);
        if (!this.dynamicSize && e.length !== this.maxSize) throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);
        let r = n === 0 ? 0 : t.size / n, s = [];
        qe(() => {
            t = Q(t, [ 1, n, r ]);
            for (let l = 0; l < e.length; ++l) {
                let o = [ 0, l === 0 ? 0 : a[l - 1], 0 ], p = [ 1, e[l], r ];
                s[l] = Q(He(t, o, p), this.elementShape);
            }
            return s;
        });
        let i = [];
        for (let l = 0; l < e.length; l++) i[l] = l;
        this.writeMany(i, s);
    }
}, wc = class D2 {
    get id() {
        return this.idTensor.id;
    }
    constructor(t, n, a, r = -1) {
        this.tensors = t, this.elementShape = n, this.elementDtype = a, t != null && t.forEach(s => {
            if (a !== s.dtype) throw new Error(`Invalid data types; op elements ${a}, but list elements ${s.dtype}`);
            da(n, s.shape, "TensorList shape mismatch: "), ba(s);
        }), this.idTensor = je(0), this.maxNumElements = r, ba(this.idTensor);
    }
    copy() {
        return new D2([ ...this.tensors ], this.elementShape, this.elementDtype);
    }
    clearAndClose(t) {
        this.tensors.forEach(n => {
            (t == null || !t.has(n.id)) && n.dispose();
        }), this.tensors.length = 0, this.idTensor.dispose();
    }
    size() {
        return this.tensors.length;
    }
    stack(t, n, a = -1) {
        if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
        if (a !== -1 && this.tensors.length !== a) throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);
        da(t, this.elementShape, "TensorList shape mismatch: ");
        let r = Vd(this.elementShape, this.tensors, t);
        return qe(() => {
            let s = this.tensors.map(i => Q(i, r));
            return Bn(s, 0);
        });
    }
    popBack(t, n) {
        if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
        if (this.size() === 0) throw new Error("Trying to pop from an empty list.");
        let a = Vd(this.elementShape, this.tensors, t), r = this.tensors.pop();
        return r.kept = !1, da(r.shape, t, "TensorList shape mismatch: "), Q(r, a);
    }
    pushBack(t) {
        if (t.dtype !== this.elementDtype) throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);
        if (da(t.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw new Error("Trying to push element into a full list.");
        ba(t), this.tensors.push(t);
    }
    resize(t) {
        if (t < 0) throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);
        if (this.maxNumElements !== -1 && t > this.maxNumElements) throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);
        let n = new D2([], this.elementShape, this.elementDtype, this.maxNumElements);
        n.tensors.length = t;
        for (let a = 0; a < Math.min(this.tensors.length, t); ++a) n.tensors[a] = this.tensors[a];
        return n;
    }
    getItem(t, n, a) {
        if (a !== this.elementDtype) throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);
        if (t < 0 || t > this.tensors.length) throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);
        if (this.tensors[t] == null) throw new Error(`element at index ${t} is null.`);
        da(this.tensors[t].shape, n, "TensorList shape mismatch: ");
        let r = Vd(this.elementShape, this.tensors, n);
        return Q(this.tensors[t], r);
    }
    setItem(t, n) {
        if (n.dtype !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);
        if (t < 0 || this.maxNumElements !== -1 && t >= this.maxNumElements) throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);
        da(this.elementShape, n.shape, "TensorList shape mismatch: "), ba(n), this.tensors[t] != null && (this.tensors[t].kept = !1), 
        this.tensors[t] = n;
    }
    gather(t, n, a) {
        if (n !== this.elementDtype) throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);
        da(this.elementShape, a, "TensorList shape mismatch: "), t = t.slice(0, this.size());
        let r = Vd(this.elementShape, this.tensors, a);
        return t.length === 0 ? Ye([], [ 0 ].concat(r)) : qe(() => {
            let s = t.map(i => Q(this.tensors[i], r));
            return Bn(s, 0);
        });
    }
    concat(t, n) {
        if (t && t !== this.elementDtype) throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);
        da(this.elementShape, n, "TensorList shape mismatch: ");
        let a = Vd(this.elementShape, this.tensors, n);
        return this.size() === 0 ? Ye([], [ 0 ].concat(a)) : qe(() => {
            let r = this.tensors.map(s => Q(s, a));
            return yt(r, 0);
        });
    }
}, bN = async (e, t, n) => {
    switch (e.op) {
      case "If":
      case "StatelessIf":
        {
            let a = S("thenBranch", e, t, n), r = S("elseBranch", e, t, n), s = S("cond", e, t, n), i = S("args", e, t, n);
            return (await s.data())[0] ? n.functionMap[a].executeFunctionAsync(i, n.tensorArrayMap, n.tensorListMap) : n.functionMap[r].executeFunctionAsync(i, n.tensorArrayMap, n.tensorListMap);
        }

      case "While":
      case "StatelessWhile":
        {
            let a = S("body", e, t, n), r = S("cond", e, t, n), s = S("args", e, t, n), i = await n.functionMap[r].executeFunctionAsync(s, n.tensorArrayMap, n.tensorListMap), l = s.map(u => u.id), o = await i[0].data();
            i.forEach(u => {
                !u.kept && l.indexOf(u.id) === -1 && u.dispose();
            });
            let p = s;
            for (;o[0]; ) {
                let u = p;
                p = await n.functionMap[a].executeFunctionAsync(p, n.tensorArrayMap, n.tensorListMap);
                let c = p.map(h => h.id);
                u.forEach(h => {
                    !h.kept && l.indexOf(h.id) === -1 && c.indexOf(h.id) === -1 && h.dispose();
                });
                let d = await n.functionMap[r].executeFunctionAsync(p, n.tensorArrayMap, n.tensorListMap);
                o = await d[0].data(), d.forEach(h => {
                    !h.kept && l.indexOf(h.id) === -1 && c.indexOf(h.id) === -1 && h.dispose();
                });
            }
            return p;
        }

      case "LoopCond":
        return [ Wr(S("pred", e, t, n)) ];

      case "Switch":
        {
            let a = S("pred", e, t, n), r = S("data", e, t, n);
            return r.kept || (r = Wr(r)), (await a.data())[0] ? [ void 0, r ] : [ r, void 0 ];
        }

      case "Merge":
        {
            let a = e.inputNames.find(r => Jt(r, t, n) !== void 0);
            return a ? [ Wr(Jt(a, t, n)) ] : void 0;
        }

      case "Enter":
        {
            let a = S("frameName", e, t, n), r = S("tensor", e, t, n);
            return n.enterFrame(a), [ Wr(r) ];
        }

      case "Exit":
        {
            let a = S("tensor", e, t, n);
            return n.exitFrame(), [ Wr(a) ];
        }

      case "NextIteration":
        {
            let a = S("tensor", e, t, n);
            return n.nextIteration(), [ Wr(a) ];
        }

      case "TensorArrayV3":
        {
            let a = S("size", e, t, n), r = S("dtype", e, t, n), s = S("elementShape", e, t, n), i = S("dynamicSize", e, t, n), l = S("clearAfterRead", e, t, n), o = S("identicalElementShapes", e, t, n), p = S("name", e, t, n), u = new xN(p, r, a, s, o, i, l);
            return n.addTensorArray(u), [ u.idTensor, je(1) ];
        }

      case "TensorArrayWriteV3":
        {
            let a = S("tensorArrayId", e, t, n), r = S("index", e, t, n), s = S("tensor", e, t, n), i = n.getTensorArray(a.id);
            return i.write(r, s), [ i.idTensor ];
        }

      case "TensorArrayReadV3":
        {
            let a = S("tensorArrayId", e, t, n), r = S("index", e, t, n);
            return [ n.getTensorArray(a.id).read(r) ];
        }

      case "TensorArrayGatherV3":
        {
            let a = S("tensorArrayId", e, t, n), r = S("indices", e, t, n), s = S("dtype", e, t, n);
            return [ n.getTensorArray(a.id).gather(r, s) ];
        }

      case "TensorArrayScatterV3":
        {
            let a = S("tensorArrayId", e, t, n), r = S("indices", e, t, n), s = S("tensor", e, t, n), i = n.getTensorArray(a.id);
            return i.scatter(r, s), [ i.idTensor ];
        }

      case "TensorArrayConcatV3":
        {
            let a = S("tensorArrayId", e, t, n), r = n.getTensorArray(a.id), s = S("dtype", e, t, n);
            return [ r.concat(s) ];
        }

      case "TensorArraySplitV3":
        {
            let a = S("tensorArrayId", e, t, n), r = S("tensor", e, t, n), s = S("lengths", e, t, n), i = n.getTensorArray(a.id);
            return i.split(s, r), [ i.idTensor ];
        }

      case "TensorArraySizeV3":
        {
            let a = S("tensorArrayId", e, t, n);
            return [ je(n.getTensorArray(a.id).size(), "int32") ];
        }

      case "TensorArrayCloseV3":
        {
            let a = S("tensorArrayId", e, t, n), r = n.getTensorArray(a.id);
            return r.clearAndClose(), [ r.idTensor ];
        }

      case "TensorListSetItem":
        {
            let a = S("tensorListId", e, t, n), r = S("index", e, t, n), s = S("tensor", e, t, n), i = n.getTensorList(a.id);
            return i.setItem(r, s), [ i.idTensor ];
        }

      case "TensorListGetItem":
        {
            let a = S("tensorListId", e, t, n), r = S("index", e, t, n), s = S("elementShape", e, t, n), i = S("elementDType", e, t, n);
            return [ n.getTensorList(a.id).getItem(r, s, i) ];
        }

      case "TensorListScatterV2":
      case "TensorListScatter":
        {
            let a = S("indices", e, t, n), r = function(s, i, l, o) {
                if (i.length !== s.shape[0]) throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${i.length} vs. ${s.shape[0]}`);
                let p = Math.max(...i);
                if (o != null && o !== -1 && p >= o) throw new Error(`Max index must be < array size (${p}  vs. ${o})`);
                let u = new wc([], l, s.dtype, o), c = la(s, 0);
                return i.forEach((d, h) => {
                    u.setItem(d, c[h]);
                }), u;
            }(S("tensor", e, t, n), a, S("elementShape", e, t, n), S("numElements", e, t, n));
            return n.addTensorList(r), [ r.idTensor ];
        }

      case "TensorListReserve":
      case "EmptyTensorList":
        {
            let a, r = S("elementShape", e, t, n), s = S("elementDType", e, t, n);
            a = e.op === "TensorListReserve" ? "numElements" : "maxNumElements";
            let i = S(a, e, t, n), l = function(o, p, u, c) {
                return new wc([], o, p, c);
            }(r, s, 0, e.op === "TensorListReserve" ? -1 : i);
            return n.addTensorList(l), [ l.idTensor ];
        }

      case "TensorListGather":
        {
            let a = S("tensorListId", e, t, n), r = S("indices", e, t, n), s = S("elementShape", e, t, n), i = S("elementDType", e, t, n);
            return [ n.getTensorList(a.id).gather(r, i, s) ];
        }

      case "TensorListStack":
        {
            let a = S("tensorListId", e, t, n), r = S("elementShape", e, t, n), s = S("elementDType", e, t, n), i = S("numElements", e, t, n);
            return [ n.getTensorList(a.id).stack(r, s, i) ];
        }

      case "TensorListFromTensor":
        {
            let a = function(r, s, i) {
                let l = r.dtype;
                if (r.shape.length < 1) throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);
                if (r.dtype !== i) throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${i}`);
                da(r.shape.slice(1), s, "TensorList shape mismatch: ");
                let o = la(r);
                return new wc(o, s, l);
            }(S("tensor", e, t, n), S("elementShape", e, t, n), S("elementDType", e, t, n));
            return n.addTensorList(a), [ a.idTensor ];
        }

      case "TensorListConcat":
      case "TensorListConcatV2":
        {
            let a = S("tensorListId", e, t, n), r = n.getTensorList(a.id), s = S("dtype", e, t, n), i = S("elementShape", e, t, n);
            return [ r.concat(s, i) ];
        }

      case "TensorListPushBack":
        {
            let a = S("tensorListId", e, t, n), r = S("tensor", e, t, n), s = n.getTensorList(a.id);
            return s.pushBack(r), [ s.idTensor ];
        }

      case "TensorListPopBack":
        {
            let a = S("tensorListId", e, t, n), r = S("elementShape", e, t, n), s = S("elementDType", e, t, n);
            return [ n.getTensorList(a.id).popBack(r, s) ];
        }

      case "TensorListSplit":
        {
            let a = S("tensor", e, t, n), r = S("elementShape", e, t, n), s = function(i, l, o) {
                let p = 0, u = l.map(m => (p += m, p));
                if (p !== i.shape[0]) throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${p}, and tensor's shape is: ${i.shape}`);
                let c = Em(i.shape.slice(1), o), d = p === 0 ? 0 : i.size / p, h = qe(() => {
                    let m = [];
                    i = Q(i, [ 1, p, d ]);
                    for (let g = 0; g < l.length; ++g) {
                        let y = [ 0, g === 0 ? 0 : u[g - 1], 0 ], A = [ 1, l[g], d ];
                        m[g] = Q(He(i, y, A), c);
                    }
                    return i.dispose(), m;
                }), f = new wc([], o, i.dtype, l.length);
                for (let m = 0; m < h.length; m++) f.setItem(m, h[m]);
                return f;
            }(a, S("lengths", e, t, n), r);
            return n.addTensorList(s), [ s.idTensor ];
        }

      case "TensorListLength":
        {
            let a = S("tensorListId", e, t, n);
            return [ je(n.getTensorList(a.id).size(), "int32") ];
        }

      case "TensorListResize":
        {
            let a = S("tensorListId", e, t, n), r = S("size", e, t, n), s = n.getTensorList(a.id).resize(r);
            return n.addTensorList(s), [ s.idTensor ];
        }

      default:
        throw TypeError(`Node type ${e.op} is not implemented`);
    }
};

function wx(e, t, n) {
    let [ a, r ] = S("fusedOps", e, t, n), s = a === "biasadd", i = !s, l = r === "prelu", o = a === "fusedbatchnorm", p = S("numArgs", e, t, n);
    if (s) {
        if (l && p !== 2) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!l && s && p !== 1) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
    }
    if (o) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
    let u = S("strides", e, t, n), c = vc(e, t, n), d = S("dataFormat", e, t, n).toUpperCase(), h = S("dilations", e, t, n), [ f, m ] = S("args", e, t, n);
    return i && (m = f, f = void 0), {
        stride: u,
        pad: c,
        dataFormat: d,
        dilations: h,
        biasArg: f,
        preluArg: m,
        activationFunc: r,
        leakyreluAlpha: S("leakyreluAlpha", e, t, n)
    };
}

function $m(e, t, n) {
    return {
        boxes: S("boxes", e, t, n),
        scores: S("scores", e, t, n),
        maxOutputSize: S("maxOutputSize", e, t, n),
        iouThreshold: S("iouThreshold", e, t, n),
        scoreThreshold: S("scoreThreshold", e, t, n),
        softNmsSigma: S("softNmsSigma", e, t, n)
    };
}

var vN = class {
    get id() {
        return this.handle.id;
    }
    constructor(e, t) {
        this.keyDType = e, this.valueDType = t, this.handle = je(0), this.tensorMap = new Map(), 
        ba(this.handle);
    }
    clearAndClose() {
        this.tensorMap.forEach(e => e.dispose()), this.tensorMap.clear(), this.handle.dispose();
    }
    size() {
        return this.tensorMap.size;
    }
    tensorSize() {
        return je(this.size(), "int32");
    }
    async import(e, t) {
        this.checkKeyAndValueTensor(e, t);
        let n = await e.data();
        return this.tensorMap.forEach(a => a.dispose()), this.tensorMap.clear(), 
        qe(() => {
            let a = la(t), r = n.length, s = a.length;
            k.assert(r === s, () => `The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);
            for (let i = 0; i < r; i++) {
                let l = n[i], o = a[i];
                ba(o), this.tensorMap.set(l, o);
            }
            return this.handle;
        });
    }
    async find(e, t) {
        this.checkKeyAndValueTensor(e, t);
        let n = await e.data();
        return qe(() => {
            let a = [];
            for (let r = 0; r < n.length; r++) {
                let s = n[r], i = this.findWithDefault(s, t);
                a.push(i);
            }
            return Bn(a);
        });
    }
    findWithDefault(e, t) {
        let n = this.tensorMap.get(e);
        return n ?? t;
    }
    checkKeyAndValueTensor(e, t) {
        if (e.dtype !== this.keyDType) throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);
        if (t.dtype !== this.valueDType) throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`);
    }
};

function kx(e, t, n, a, r = qe) {
    let s = ((i, l, o) => {
        switch (i.category) {
          case "arithmetic":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "BiasAdd":
                  case "AddV2":
                  case "Add":
                    return [ h.add(S("a", u, c, d), S("b", u, c, d)) ];

                  case "AddN":
                    return [ h.addN(S("tensors", u, c, d)) ];

                  case "FloorMod":
                  case "Mod":
                    return [ h.mod(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Mul":
                    return [ h.mul(S("a", u, c, d), S("b", u, c, d)) ];

                  case "RealDiv":
                  case "Div":
                    return [ h.div(S("a", u, c, d), S("b", u, c, d)) ];

                  case "DivNoNan":
                    return [ h.divNoNan(S("a", u, c, d), S("b", u, c, d)) ];

                  case "FloorDiv":
                    return [ h.floorDiv(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Sub":
                    return [ h.sub(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Minimum":
                    return [ h.minimum(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Maximum":
                    return [ h.maximum(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Pow":
                    return [ h.pow(S("a", u, c, d), S("b", u, c, d)) ];

                  case "SquaredDifference":
                    return [ h.squaredDifference(S("a", u, c, d), S("b", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "basic_math":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Abs":
                  case "ComplexAbs":
                    return [ h.abs(S("x", u, c, d)) ];

                  case "Acos":
                    return [ h.acos(S("x", u, c, d)) ];

                  case "Acosh":
                    return [ h.acosh(S("x", u, c, d)) ];

                  case "Asin":
                    return [ h.asin(S("x", u, c, d)) ];

                  case "Asinh":
                    return [ h.asinh(S("x", u, c, d)) ];

                  case "Atan":
                    return [ h.atan(S("x", u, c, d)) ];

                  case "Atan2":
                    return [ h.atan2(S("x", u, c, d), S("y", u, c, d)) ];

                  case "Atanh":
                    return [ h.atanh(S("x", u, c, d)) ];

                  case "Ceil":
                    return [ h.ceil(S("x", u, c, d)) ];

                  case "Complex":
                    return [ h.complex(S("real", u, c, d), S("imag", u, c, d)) ];

                  case "Cos":
                    return [ h.cos(S("x", u, c, d)) ];

                  case "Cosh":
                    return [ h.cosh(S("x", u, c, d)) ];

                  case "Elu":
                    return [ h.elu(S("x", u, c, d)) ];

                  case "Erf":
                    return [ h.erf(S("x", u, c, d)) ];

                  case "Exp":
                    return [ h.exp(S("x", u, c, d)) ];

                  case "Expm1":
                    return [ h.expm1(S("x", u, c, d)) ];

                  case "Floor":
                    return [ h.floor(S("x", u, c, d)) ];

                  case "Log":
                    return [ h.log(S("x", u, c, d)) ];

                  case "Log1p":
                    return [ h.log1p(S("x", u, c, d)) ];

                  case "Imag":
                    return [ h.imag(S("x", u, c, d)) ];

                  case "Neg":
                    return [ h.neg(S("x", u, c, d)) ];

                  case "Reciprocal":
                    return [ h.reciprocal(S("x", u, c, d)) ];

                  case "Real":
                    return [ h.real(S("x", u, c, d)) ];

                  case "Relu":
                    return [ h.relu(S("x", u, c, d)) ];

                  case "Round":
                    return [ h.round(S("x", u, c, d)) ];

                  case "Selu":
                    return [ h.selu(S("x", u, c, d)) ];

                  case "Sigmoid":
                    return [ h.sigmoid(S("x", u, c, d)) ];

                  case "Sin":
                    return [ h.sin(S("x", u, c, d)) ];

                  case "Sign":
                    return [ h.sign(S("x", u, c, d)) ];

                  case "Sinh":
                    return [ h.sinh(S("x", u, c, d)) ];

                  case "Softplus":
                    return [ h.softplus(S("x", u, c, d)) ];

                  case "Sqrt":
                    return [ h.sqrt(S("x", u, c, d)) ];

                  case "Square":
                    return [ h.square(S("x", u, c, d)) ];

                  case "Tanh":
                    return [ h.tanh(S("x", u, c, d)) ];

                  case "Tan":
                    return [ h.tan(S("x", u, c, d)) ];

                  case "ClipByValue":
                    return [ h.clipByValue(S("x", u, c, d), S("clipValueMin", u, c, d), S("clipValueMax", u, c, d)) ];

                  case "Relu6":
                    return [ h.relu6(S("x", u, c, d)) ];

                  case "Rsqrt":
                    return [ h.rsqrt(Jt(u.inputNames[0], c, d)) ];

                  case "LeakyRelu":
                    return [ h.leakyRelu(S("x", u, c, d), S("alpha", u, c, d)) ];

                  case "Prelu":
                    return [ h.prelu(S("x", u, c, d), S("alpha", u, c, d)) ];

                  case "IsNan":
                    return [ h.isNaN(Jt(u.inputNames[0], c, d)) ];

                  case "IsInf":
                    return [ h.isInf(Jt(u.inputNames[0], c, d)) ];

                  case "IsFinite":
                    return [ h.isFinite(Jt(u.inputNames[0], c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "control":
            return bN(i, l, o);

          case "convolution":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Conv1D":
                    {
                        let f = S("stride", u, c, d), m = S("pad", u, c, d), g = S("dataFormat", u, c, d).toUpperCase(), y = S("dilation", u, c, d);
                        return [ h.conv1d(S("x", u, c, d), S("filter", u, c, d), f, m, g, y) ];
                    }

                  case "Conv2D":
                    {
                        let f = S("strides", u, c, d), m = vc(u, c, d), g = S("dataFormat", u, c, d).toUpperCase(), y = S("dilations", u, c, d);
                        return [ h.conv2d(S("x", u, c, d), S("filter", u, c, d), [ f[1], f[2] ], m, g, [ y[1], y[2] ]) ];
                    }

                  case "_FusedConv2D":
                    {
                        let {
                            stride: f,
                            pad: m,
                            dataFormat: g,
                            dilations: y,
                            biasArg: A,
                            preluArg: x,
                            activationFunc: b,
                            leakyreluAlpha: v
                        } = wx(u, c, d);
                        return [ h.fused.conv2d({
                            x: S("x", u, c, d),
                            filter: S("filter", u, c, d),
                            strides: [ f[1], f[2] ],
                            pad: m,
                            dataFormat: g,
                            dilations: [ y[1], y[2] ],
                            bias: A,
                            activation: b,
                            preluActivationWeights: x,
                            leakyreluAlpha: v
                        }) ];
                    }

                  case "FusedDepthwiseConv2dNative":
                    {
                        let {
                            stride: f,
                            pad: m,
                            dataFormat: g,
                            dilations: y,
                            biasArg: A,
                            preluArg: x,
                            activationFunc: b,
                            leakyreluAlpha: v
                        } = wx(u, c, d);
                        return [ h.fused.depthwiseConv2d({
                            x: S("x", u, c, d),
                            filter: S("filter", u, c, d),
                            strides: [ f[1], f[2] ],
                            pad: m,
                            dataFormat: g,
                            dilations: [ y[1], y[2] ],
                            bias: A,
                            activation: b,
                            preluActivationWeights: x,
                            leakyreluAlpha: v
                        }) ];
                    }

                  case "Conv2DBackpropInput":
                  case "Conv2dTranspose":
                    {
                        let f = S("outputShape", u, c, d), m = S("strides", u, c, d), g = vc(u, c, d);
                        return [ h.conv2dTranspose(S("x", u, c, d), S("filter", u, c, d), f, [ m[1], m[2] ], g) ];
                    }

                  case "DepthwiseConv2dNative":
                  case "DepthwiseConv2d":
                    {
                        let f = S("strides", u, c, d), m = vc(u, c, d), g = S("dilations", u, c, d), y = S("dataFormat", u, c, d).toUpperCase();
                        return [ h.depthwiseConv2d(S("input", u, c, d), S("filter", u, c, d), [ f[1], f[2] ], m, y, [ g[1], g[2] ]) ];
                    }

                  case "Conv3D":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("dataFormat", u, c, d).toUpperCase(), y = S("dilations", u, c, d);
                        return [ h.conv3d(S("x", u, c, d), S("filter", u, c, d), [ f[1], f[2], f[3] ], m, g, [ y[1], y[2], y[3] ]) ];
                    }

                  case "AvgPool":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("kernelSize", u, c, d);
                        return [ h.avgPool(S("x", u, c, d), [ g[1], g[2] ], [ f[1], f[2] ], m) ];
                    }

                  case "MaxPool":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("kernelSize", u, c, d);
                        return [ h.maxPool(S("x", u, c, d), [ g[1], g[2] ], [ f[1], f[2] ], m) ];
                    }

                  case "MaxPoolWithArgmax":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("kernelSize", u, c, d), y = S("includeBatchInIndex", u, c, d), {
                            result: A,
                            indexes: x
                        } = h.maxPoolWithArgmax(S("x", u, c, d), [ g[1], g[2] ], [ f[1], f[2] ], m, y);
                        return [ A, x ];
                    }

                  case "AvgPool3D":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("kernelSize", u, c, d);
                        return [ h.avgPool3d(S("x", u, c, d), [ g[1], g[2], g[3] ], [ f[1], f[2], f[3] ], m) ];
                    }

                  case "MaxPool3D":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("kernelSize", u, c, d);
                        return [ h.maxPool3d(S("x", u, c, d), [ g[1], g[2], g[3] ], [ f[1], f[2], f[3] ], m) ];
                    }

                  case "Dilation2D":
                    {
                        let f = S("strides", u, c, d), m = S("pad", u, c, d), g = S("dilations", u, c, d), y = f[1], A = f[2], x = g[1], b = g[2];
                        return [ h.dilation2d(S("x", u, c, d), S("filter", u, c, d), [ y, A ], m, [ x, b ], "NHWC") ];
                    }

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "creation":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Fill":
                    {
                        let f = S("shape", u, c, d), m = S("dtype", u, c, d), g = S("value", u, c, d);
                        return [ h.fill(f, g, m) ];
                    }

                  case "LinSpace":
                    {
                        let f = S("start", u, c, d), m = S("stop", u, c, d), g = S("num", u, c, d);
                        return [ h.linspace(f, m, g) ];
                    }

                  case "Multinomial":
                    {
                        let f = S("logits", u, c, d), m = S("numSamples", u, c, d), g = S("seed", u, c, d);
                        return [ h.multinomial(f, m, g) ];
                    }

                  case "OneHot":
                    {
                        let f = S("indices", u, c, d), m = S("depth", u, c, d), g = S("onValue", u, c, d), y = S("offValue", u, c, d), A = S("dtype", u, c, d);
                        return [ h.oneHot(f, m, g, y, A) ];
                    }

                  case "Ones":
                    return [ h.ones(S("shape", u, c, d), S("dtype", u, c, d)) ];

                  case "OnesLike":
                    return [ h.onesLike(S("x", u, c, d)) ];

                  case "RandomStandardNormal":
                    return [ h.randomStandardNormal(S("shape", u, c, d), S("dtype", u, c, d), S("seed", u, c, d)) ];

                  case "RandomUniform":
                    return [ h.randomUniform(S("shape", u, c, d), S("minval", u, c, d), S("maxval", u, c, d), S("dtype", u, c, d)) ];

                  case "RandomUniformInt":
                    return [ h.randomUniformInt(S("shape", u, c, d), S("minval", u, c, d), S("maxval", u, c, d), S("seed", u, c, d)) ];

                  case "Range":
                    {
                        let f = S("start", u, c, d), m = S("stop", u, c, d), g = S("step", u, c, d);
                        return [ h.range(f, m, g, S("dtype", u, c, d)) ];
                    }

                  case "TruncatedNormal":
                    {
                        let f = S("shape", u, c, d), m = S("mean", u, c, d), g = S("stdDev", u, c, d), y = S("seed", u, c, d);
                        return [ h.truncatedNormal(f, m, g, S("dtype", u, c, d), y) ];
                    }

                  case "Zeros":
                    return [ h.zeros(S("shape", u, c, d), S("dtype", u, c, d)) ];

                  case "ZerosLike":
                    return [ h.zerosLike(S("x", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "dynamic":
            return (async (u, c, d, h, f = Ht) => {
                switch (u.op) {
                  case "NonMaxSuppressionV5":
                    {
                        let {
                            boxes: m,
                            scores: g,
                            maxOutputSize: y,
                            iouThreshold: A,
                            scoreThreshold: x,
                            softNmsSigma: b
                        } = $m(u, c, d), v = await f.image.nonMaxSuppressionWithScoreAsync(m, g, y, A, x, b);
                        return [ v.selectedIndices, v.selectedScores ];
                    }

                  case "NonMaxSuppressionV4":
                    {
                        let {
                            boxes: m,
                            scores: g,
                            maxOutputSize: y,
                            iouThreshold: A,
                            scoreThreshold: x
                        } = $m(u, c, d), b = S("padToMaxOutputSize", u, c, d), v = await f.image.nonMaxSuppressionPaddedAsync(m, g, y, A, x, b);
                        return [ v.selectedIndices, v.validOutputs ];
                    }

                  case "NonMaxSuppressionV3":
                  case "NonMaxSuppressionV2":
                    {
                        let {
                            boxes: m,
                            scores: g,
                            maxOutputSize: y,
                            iouThreshold: A,
                            scoreThreshold: x
                        } = $m(u, c, d);
                        return [ await f.image.nonMaxSuppressionAsync(m, g, y, A, x) ];
                    }

                  case "Where":
                    {
                        let m = f.cast(S("condition", u, c, d), "bool"), g = [ await f.whereAsync(m) ];
                        return m.dispose(), g;
                    }

                  case "ListDiff":
                    return f.setdiff1dAsync(S("x", u, c, d), S("y", u, c, d));

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o);

          case "evaluation":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "LowerBound":
                    {
                        let f = S("sortedSequence", u, c, d), m = S("values", u, c, d);
                        return [ h.lowerBound(f, m) ];
                    }

                  case "TopKV2":
                    {
                        let f = S("x", u, c, d), m = S("k", u, c, d), g = S("sorted", u, c, d), y = h.topk(f, m, g);
                        return [ y.values, y.indices ];
                    }

                  case "UpperBound":
                    {
                        let f = S("sortedSequence", u, c, d), m = S("values", u, c, d);
                        return [ h.upperBound(f, m) ];
                    }

                  case "Unique":
                    {
                        let f = S("x", u, c, d), m = h.unique(f);
                        return [ m.values, m.indices ];
                    }

                  case "UniqueV2":
                    {
                        let f = S("x", u, c, d), m = S("axis", u, c, d), g = h.unique(f, m);
                        return [ g.values, g.indices ];
                    }

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "image":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "ResizeBilinear":
                    {
                        let f = S("images", u, c, d), m = S("size", u, c, d), g = S("alignCorners", u, c, d), y = S("halfPixelCenters", u, c, d);
                        return [ h.image.resizeBilinear(f, [ m[0], m[1] ], g, y) ];
                    }

                  case "ResizeNearestNeighbor":
                    {
                        let f = S("images", u, c, d), m = S("size", u, c, d), g = S("alignCorners", u, c, d), y = S("halfPixelCenters", u, c, d);
                        return [ h.image.resizeNearestNeighbor(f, [ m[0], m[1] ], g, y) ];
                    }

                  case "CropAndResize":
                    {
                        let f = S("image", u, c, d), m = S("boxes", u, c, d), g = S("boxInd", u, c, d), y = S("cropSize", u, c, d), A = S("method", u, c, d), x = S("extrapolationValue", u, c, d);
                        return [ h.image.cropAndResize(f, m, g, y, A, x) ];
                    }

                  case "ImageProjectiveTransformV3":
                    {
                        let f = S("images", u, c, d), m = S("transforms", u, c, d), g = S("outputShape", u, c, d), y = S("fillValue", u, c, d), A = S("interpolation", u, c, d), x = S("fillMode", u, c, d);
                        return [ h.image.transform(f, m, A.toLowerCase(), x.toLowerCase(), y, g) ];
                    }

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "graph":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Const":
                    return c[u.name];

                  case "PlaceholderWithDefault":
                    let f = S("default", u, c, d);
                    return [ Jt(u.name, c, d) || f ];

                  case "Placeholder":
                    return [ Jt(u.name, c, d) ];

                  case "Identity":
                  case "StopGradient":
                  case "FakeQuantWithMinMaxVars":
                  case "Snapshot":
                    return [ Wr(S("x", u, c, d)) ];

                  case "IdentityN":
                    return S("x", u, c, d).map(y => Wr(y));

                  case "Shape":
                    return [ h.tensor1d(S("x", u, c, d).shape, "int32") ];

                  case "ShapeN":
                    return S("x", u, c, d).map(y => h.tensor1d(y.shape));

                  case "Size":
                    return [ h.scalar(S("x", u, c, d).size, "int32") ];

                  case "Rank":
                    return [ h.scalar(S("x", u, c, d).rank, "int32") ];

                  case "NoOp":
                    return [ h.scalar(1) ];

                  case "Print":
                    let m = S("x", u, c, d), g = S("data", u, c, d);
                    S("message", u, c, d), S("summarize", u, c, d);
                    for (let y = 0; y < g.length; y++);
                    return [ m ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "logical":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Equal":
                    return [ h.equal(S("a", u, c, d), S("b", u, c, d)) ];

                  case "NotEqual":
                    return [ h.notEqual(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Greater":
                    return [ h.greater(S("a", u, c, d), S("b", u, c, d)) ];

                  case "GreaterEqual":
                    return [ h.greaterEqual(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Less":
                    return [ h.less(S("a", u, c, d), S("b", u, c, d)) ];

                  case "LessEqual":
                    return [ h.lessEqual(S("a", u, c, d), S("b", u, c, d)) ];

                  case "LogicalAnd":
                    return [ h.logicalAnd(S("a", u, c, d), S("b", u, c, d)) ];

                  case "LogicalNot":
                    return [ h.logicalNot(S("a", u, c, d)) ];

                  case "LogicalOr":
                    return [ h.logicalOr(S("a", u, c, d), S("b", u, c, d)) ];

                  case "Select":
                  case "SelectV2":
                    return [ h.where(S("condition", u, c, d), S("a", u, c, d), S("b", u, c, d)) ];

                  case "BitwiseAnd":
                    return [ h.bitwiseAnd(S("a", u, c, d), S("b", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "matrices":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "BatchMatMul":
                  case "BatchMatMulV2":
                  case "MatMul":
                    return [ h.matMul(S("a", u, c, d), S("b", u, c, d), S("transposeA", u, c, d), S("transposeB", u, c, d)) ];

                  case "Einsum":
                    return [ h.einsum(S("equation", u, c, d), ...S("tensors", u, c, d)) ];

                  case "Transpose":
                    return [ h.transpose(S("x", u, c, d), S("perm", u, c, d)) ];

                  case "_FusedMatMul":
                    let [ f, m ] = S("fusedOps", u, c, d), g = f === "biasadd", y = m === "prelu", A = S("numArgs", u, c, d), x = S("leakyreluAlpha", u, c, d);
                    if (g) {
                        if (y && A !== 2) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                        if (!y && A !== 1) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
                    }
                    let [ b, v ] = S("args", u, c, d);
                    return [ h.fused.matMul({
                        a: S("a", u, c, d),
                        b: S("b", u, c, d),
                        transposeA: S("transposeA", u, c, d),
                        transposeB: S("transposeB", u, c, d),
                        bias: b,
                        activation: m,
                        preluActivationWeights: v,
                        leakyreluAlpha: x
                    }) ];

                  case "MatrixBandPart":
                    return [ h.linalg.bandPart(S("a", u, c, d), S("numLower", u, c, d), S("numUpper", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "normalization":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "EuclideanNorm":
                    return [ h.euclideanNorm(S("x", u, c, d), S("axis", u, c, d), S("keepDims", u, c, d)) ];

                  case "FusedBatchNorm":
                  case "FusedBatchNormV2":
                  case "FusedBatchNormV3":
                    return [ h.batchNorm(S("x", u, c, d), S("mean", u, c, d), S("variance", u, c, d), S("offset", u, c, d), S("scale", u, c, d), S("epsilon", u, c, d)) ];

                  case "LRN":
                    return [ h.localResponseNormalization(S("x", u, c, d), S("radius", u, c, d), S("bias", u, c, d), S("alpha", u, c, d), S("beta", u, c, d)) ];

                  case "Softmax":
                    return [ h.softmax(S("x", u, c, d)) ];

                  case "LogSoftmax":
                    return [ h.logSoftmax(S("x", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "ragged":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "RaggedGather":
                    {
                        let {
                            outputNestedSplits: f,
                            outputDenseValues: m
                        } = h.raggedGather(S("paramsNestedSplits", u, c, d), S("paramsDenseValues", u, c, d), S("indices", u, c, d), S("outputRaggedRank", u, c, d));
                        return f.concat(m);
                    }

                  case "RaggedRange":
                    {
                        let {
                            rtNestedSplits: f,
                            rtDenseValues: m
                        } = h.raggedRange(S("starts", u, c, d), S("limits", u, c, d), S("splits", u, c, d));
                        return [ f, m ];
                    }

                  case "RaggedTensorToTensor":
                    return [ h.raggedTensorToTensor(S("shape", u, c, d), S("values", u, c, d), S("defaultValue", u, c, d), S("rowPartitionTensors", u, c, d), S("rowPartitionTypes", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "reduction":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Max":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.max(S("x", u, c, d), y, A) ];
                    }

                  case "Mean":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.mean(S("x", u, c, d), y, A) ];
                    }

                  case "Min":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.min(S("x", u, c, d), y, A) ];
                    }

                  case "Sum":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.sum(S("x", u, c, d), y, A) ];
                    }

                  case "All":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.all(S("x", u, c, d), y, A) ];
                    }

                  case "Any":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.any(S("x", u, c, d), y, A) ];
                    }

                  case "ArgMax":
                    {
                        let y = S("axis", u, c, d);
                        return [ h.argMax(S("x", u, c, d), y) ];
                    }

                  case "ArgMin":
                    {
                        let y = S("axis", u, c, d);
                        return [ h.argMin(S("x", u, c, d), y) ];
                    }

                  case "Prod":
                    {
                        let y = S("axis", u, c, d), A = S("keepDims", u, c, d);
                        return [ h.prod(S("x", u, c, d), y, A) ];
                    }

                  case "Cumprod":
                    {
                        let y = S("axis", u, c, d), A = S("exclusive", u, c, d), x = S("reverse", u, c, d);
                        return [ h.cumprod(S("x", u, c, d), y, A, x) ];
                    }

                  case "Cumsum":
                    {
                        let y = S("axis", u, c, d), A = S("exclusive", u, c, d), x = S("reverse", u, c, d);
                        return [ h.cumsum(S("x", u, c, d), y, A, x) ];
                    }

                  case "Bincount":
                    let f = S("x", u, c, d), m = S("weights", u, c, d), g = S("size", u, c, d);
                    return [ h.bincount(f, m, g) ];

                  case "DenseBincount":
                    {
                        let y = S("x", u, c, d), A = S("weights", u, c, d), x = S("size", u, c, d), b = S("binaryOutput", u, c, d);
                        return [ h.denseBincount(y, A, x, b) ];
                    }

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "slice_join":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "ConcatV2":
                  case "Concat":
                    {
                        let f = S("n", u, c, d), m = S("axis", u, c, d), g = S("tensors", u, c, d);
                        return g = g.slice(0, f), [ h.concat(g, m) ];
                    }

                  case "Gather":
                    {
                        let f = S("x", u, c, d), m = S("indices", u, c, d);
                        return [ h.gather(f, h.cast(m, "int32"), 0) ];
                    }

                  case "GatherV2":
                    {
                        let f = S("axis", u, c, d), m = S("batchDims", u, c, d), g = S("x", u, c, d), y = S("indices", u, c, d);
                        return [ h.gather(g, h.cast(y, "int32"), f, m) ];
                    }

                  case "Reverse":
                    {
                        let f = S("dims", u, c, d), m = [];
                        for (let y = 0; y < f.length; y++) f[y] && m.push(y);
                        let g = S("x", u, c, d);
                        return [ h.reverse(g, m) ];
                    }

                  case "ReverseV2":
                    {
                        let f = S("axis", u, c, d), m = S("x", u, c, d);
                        return [ h.reverse(m, f) ];
                    }

                  case "Slice":
                    {
                        let f = S("begin", u, c, d), m = S("size", u, c, d);
                        return [ h.slice(S("x", u, c, d), f, m) ];
                    }

                  case "StridedSlice":
                    {
                        let f = S("begin", u, c, d), m = S("end", u, c, d), g = S("strides", u, c, d), y = S("beginMask", u, c, d), A = S("endMask", u, c, d), x = S("ellipsisMask", u, c, d), b = S("newAxisMask", u, c, d), v = S("shrinkAxisMask", u, c, d), I = S("x", u, c, d);
                        return [ h.stridedSlice(I, f, m, g, y, A, x, b, v) ];
                    }

                  case "Pack":
                    return qe(() => {
                        let f = S("axis", u, c, d), m = S("tensors", u, c, d), g = m[0].shape, y = h.squeeze(m[0]).shape, A = m.map(x => {
                            let b = k.arraysEqual(x.shape, g);
                            if (!b && !k.arraysEqual(h.squeeze(x).shape, y)) throw new Error("the input tensors shape does not match");
                            return b ? x : h.reshape(x, g);
                        });
                        return [ h.stack(A, f) ];
                    });

                  case "Unpack":
                    {
                        let f = S("axis", u, c, d), m = S("tensor", u, c, d);
                        return h.unstack(m, f);
                    }

                  case "Tile":
                    {
                        let f = S("reps", u, c, d);
                        return [ h.tile(S("x", u, c, d), f) ];
                    }

                  case "Split":
                  case "SplitV":
                    {
                        let f = S("axis", u, c, d), m = S("numOrSizeSplits", u, c, d), g = S("x", u, c, d);
                        return h.split(g, m, f);
                    }

                  case "ScatterNd":
                    {
                        let f = S("indices", u, c, d), m = S("values", u, c, d), g = S("shape", u, c, d);
                        return [ h.scatterND(f, m, g) ];
                    }

                  case "GatherNd":
                    {
                        let f = S("x", u, c, d), m = S("indices", u, c, d);
                        return [ h.gatherND(f, m) ];
                    }

                  case "SparseToDense":
                    {
                        let f = S("sparseIndices", u, c, d), m = S("outputShape", u, c, d), g = S("sparseValues", u, c, d), y = S("defaultValue", u, c, d);
                        return [ h.sparseToDense(f, g, m, g.dtype === y.dtype ? y : h.cast(y, g.dtype)) ];
                    }

                  case "TensorScatterUpdate":
                    {
                        let f = S("indices", u, c, d), m = S("values", u, c, d), g = S("tensor", u, c, d);
                        return [ h.tensorScatterUpdate(g, f, m) ];
                    }

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "sparse":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "SparseFillEmptyRows":
                    {
                        let {
                            outputIndices: f,
                            outputValues: m,
                            emptyRowIndicator: g,
                            reverseIndexMap: y
                        } = h.sparse.sparseFillEmptyRows(S("indices", u, c, d), S("values", u, c, d), S("denseShape", u, c, d), S("defaultValue", u, c, d));
                        return [ f, m, g, y ];
                    }

                  case "SparseReshape":
                    {
                        let {
                            outputIndices: f,
                            outputShape: m
                        } = h.sparse.sparseReshape(S("inputIndices", u, c, d), S("inputShape", u, c, d), S("newShape", u, c, d));
                        return [ f, m ];
                    }

                  case "SparseSegmentMean":
                    return [ h.sparse.sparseSegmentMean(S("data", u, c, d), S("indices", u, c, d), S("segmentIds", u, c, d)) ];

                  case "SparseSegmentSum":
                    return [ h.sparse.sparseSegmentSum(S("data", u, c, d), S("indices", u, c, d), S("segmentIds", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "spectral":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "FFT":
                    return [ h.fft(S("x", u, c, d)) ];

                  case "IFFT":
                    return [ h.ifft(S("x", u, c, d)) ];

                  case "RFFT":
                    return [ h.rfft(S("x", u, c, d)) ];

                  case "IRFFT":
                    return [ h.irfft(S("x", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "string":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "StaticRegexReplace":
                    return [ h.string.staticRegexReplace(S("input", u, c, d), S("pattern", u, c, d), S("rewrite", u, c, d), S("replaceGlobal", u, c, d)) ];

                  case "StringNGrams":
                    {
                        let {
                            nGrams: f,
                            nGramsSplits: m
                        } = h.string.stringNGrams(S("data", u, c, d), S("dataSplits", u, c, d), S("separator", u, c, d), S("nGramWidths", u, c, d), S("leftPad", u, c, d), S("rightPad", u, c, d), S("padWidth", u, c, d), S("preserveShortSequences", u, c, d));
                        return [ f, m ];
                    }

                  case "StringSplit":
                    {
                        let {
                            indices: f,
                            values: m,
                            shape: g
                        } = h.string.stringSplit(S("input", u, c, d), S("delimiter", u, c, d), S("skipEmpty", u, c, d));
                        return [ f, m, g ];
                    }

                  case "StringToHashBucketFast":
                    return [ h.string.stringToHashBucketFast(S("input", u, c, d), S("numBuckets", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "transformation":
            return r(() => ((u, c, d, h = Ht) => {
                switch (u.op) {
                  case "Cast":
                    return [ h.cast(S("x", u, c, d), S("dtype", u, c, d)) ];

                  case "ExpandDims":
                    {
                        let f = S("axis", u, c, d);
                        return [ h.expandDims(S("x", u, c, d), f) ];
                    }

                  case "Squeeze":
                    {
                        let f = S("axis", u, c, d);
                        return [ h.squeeze(S("x", u, c, d), f) ];
                    }

                  case "Reshape":
                    return [ h.reshape(S("x", u, c, d), S("shape", u, c, d)) ];

                  case "EnsureShape":
                    return [ h.ensureShape(S("x", u, c, d), S("shape", u, c, d)) ];

                  case "MirrorPad":
                    return [ h.mirrorPad(S("x", u, c, d), S("padding", u, c, d), S("mode", u, c, d)) ];

                  case "PadV2":
                  case "Pad":
                    return [ h.pad(S("x", u, c, d), S("padding", u, c, d), S("constantValue", u, c, d)) ];

                  case "SpaceToBatchND":
                    {
                        let f = S("blockShape", u, c, d), m = S("paddings", u, c, d);
                        return [ h.spaceToBatchND(S("x", u, c, d), f, m) ];
                    }

                  case "BatchToSpaceND":
                    {
                        let f = S("blockShape", u, c, d), m = S("crops", u, c, d);
                        return [ h.batchToSpaceND(S("x", u, c, d), f, m) ];
                    }

                  case "DepthToSpace":
                    {
                        let f = S("blockSize", u, c, d), m = S("dataFormat", u, c, d).toUpperCase();
                        return [ h.depthToSpace(S("x", u, c, d), f, m) ];
                    }

                  case "BroadcastTo":
                    return [ h.broadcastTo(S("x", u, c, d), S("shape", u, c, d)) ];

                  case "BroadcastArgs":
                    return [ h.broadcastArgs(S("s0", u, c, d), S("s1", u, c, d)) ];

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o));

          case "hash_table":
            return (async (u, c, d, h) => {
                switch (u.op) {
                  case "HashTable":
                  case "HashTableV2":
                    {
                        let f = h.getHashTableHandleByName(u.name);
                        if (f != null) return [ f ];
                        {
                            let m = S("keyDType", u, c, d), g = S("valueDType", u, c, d), y = new vN(m, g);
                            return h.addHashTable(u.name, y), [ y.handle ];
                        }
                    }

                  case "InitializeTable":
                  case "InitializeTableV2":
                  case "LookupTableImport":
                  case "LookupTableImportV2":
                    {
                        let f = S("tableHandle", u, c, d, h), m = S("keys", u, c, d), g = S("values", u, c, d);
                        return [ await h.getHashTableById(f.id).import(m, g) ];
                    }

                  case "LookupTableFind":
                  case "LookupTableFindV2":
                    {
                        let f = S("tableHandle", u, c, d, h), m = S("keys", u, c, d), g = S("defaultValue", u, c, d);
                        return [ await h.getHashTableById(f.id).find(m, g) ];
                    }

                  case "LookupTableSize":
                  case "LookupTableSizeV2":
                    {
                        let f = S("tableHandle", u, c, d, h);
                        return [ h.getHashTableById(f.id).tensorSize() ];
                    }

                  default:
                    throw TypeError(`Node type ${u.op} is not implemented`);
                }
            })(i, l, o, a);

          case "custom":
            let p = ZA(i.op);
            if (p && p.customExecutor) return p.customExecutor(new AN(i, l, o));
            throw TypeError(`Custom op ${i.op} is not registered.`);

          default:
            throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`);
        }
    })(e, t, n);
    return k.isPromise(s) ? s.then(i => [].concat(i)) : [].concat(s);
}

var Ix = class {
    constructor(e = {}, t = {}, n = {}, a = {}, r) {
        this.weightMap = e, this.tensorArrayMap = t, this.tensorListMap = n, this.functionMap = a, 
        this.parseNodeNameCache = r, this.rootContext = {
            id: 0,
            frameName: "",
            iterationId: 0
        }, this.contexts = [ this.rootContext ], this.lastId = 0, this.generateCurrentContextIds();
    }
    newFrame(e, t) {
        return {
            id: e,
            frameName: t,
            iterationId: 0
        };
    }
    set currentContext(e) {
        this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds());
    }
    get currentContext() {
        return this.contexts;
    }
    get currentContextId() {
        return this._currentContextIds[0];
    }
    get currentContextIds() {
        return this._currentContextIds;
    }
    generateCurrentContextIds() {
        let e = [];
        for (let t = 0; t < this.contexts.length - 1; t++) {
            let n = this.contexts.slice(0, this.contexts.length - t);
            e.push(this.contextIdforContexts(n));
        }
        e.push(""), this._currentContextIds = e;
    }
    contextIdforContexts(e) {
        return e ? e.map(t => t.id === 0 && t.iterationId === 0 ? "" : `${t.frameName}-${t.iterationId}`).join("/") : "";
    }
    enterFrame(e) {
        this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), 
        this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)));
    }
    exitFrame() {
        if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
        this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift();
    }
    nextIteration() {
        if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
        {
            this.contexts = this.contexts.slice(), this.lastId++;
            let e = Object.assign({}, this.contexts[this.contexts.length - 1]);
            e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), 
            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));
        }
    }
    getWeight(e) {
        return this.weightMap[e];
    }
    addTensorArray(e) {
        this.tensorArrayMap[e.id] = e;
    }
    getTensorArray(e) {
        return this.tensorArrayMap[e];
    }
    addTensorList(e) {
        this.tensorListMap[e.id] = e;
    }
    getTensorList(e) {
        return this.tensorListMap[e];
    }
    dispose(e) {
        for (let t in this.tensorArrayMap) this.tensorArrayMap[t].clearAndClose(e);
        for (let t in this.tensorListMap) this.tensorListMap[t].clearAndClose(e);
    }
};

function Sx(e, t, n, a) {
    let r = new Set(), s = [], i = null, l = null, o = new Set(), p = new Set(Object.keys(e).map(d => Un(d)[0]));
    a = a || [];
    let u = new Set(a.map(d => Un(d.name)[0])), c = [ ...t ];
    for (;c.length > 0; ) {
        let d = c.pop();
        if ((bo(d) || NN(d) || CN(d)) && i == null && (i = d, l = i.children.map(h => h.name).filter(h => r.has(h))), 
        r.add(d.name), n[d.name] == null && !p.has(d.name) && !u.has(d.name)) {
            if (d.inputs.length === 0) {
                s.push(d.name);
                continue;
            }
            d.inputs.forEach(h => {
                o.has(h.name) || (o.add(h.name), c.push(h));
            });
        }
    }
    return {
        inputs: e,
        outputs: t,
        usedNodes: r,
        missingInputs: s,
        dynamicNode: i,
        syncInputs: l
    };
}

function wN(e, t) {
    let {
        usedNodes: n,
        inputs: a
    } = t, r = Object.keys(a).map(m => Un(m)[0]).map(m => e.nodes[m]), s = e.initNodes || [], i = m => n.has(typeof m == "string" ? m : m.name);
    function l(m) {
        return [ ...new Map(m.map(g => [ g.name, g ])).values() ];
    }
    let o = l([ ...r, ...e.weights, ...s ]).filter(i), p = l([ ...o, ...Object.values(e.nodes) ]).filter(i), u = new Map(p.map(m => [ m.name, m ])), c = {};
    for (let m of p) {
        c[m.name] = c[m.name] || 0;
        for (let g of m.children) i(g) || (c[g.name] = Number.POSITIVE_INFINITY), 
        c[g.name] = (c[g.name] || 0) + 1;
    }
    let d = Object.entries(c).filter(([ , m ]) => m === 0).map(([ m ]) => m), h = [ ...d ];
    for (;d.length > 0; ) {
        let m = d.pop(), g = u.get(m);
        for (let y of g.children.filter(i)) --c[y.name] == 0 && (h.push(y.name), 
        d.push(y.name));
    }
    let f = function(m, g) {
        let y = new Map(m.map(b => [ b.name, b ])), A = g.map(b => b.name), x = new Set(A);
        for (;A.length > 0; ) {
            let b = A.pop(), v = y.get(b);
            for (let I of v.children) !y.has(I.name) || x.has(I.name) || (x.add(I.name), 
            A.push(I.name));
        }
        return m.filter(b => x.has(b.name));
    }(h.map(m => u.get(m)), o);
    return function(m, g) {
        let y = new Map(m.map((I, N) => [ I.name, N ])), A = new Set(g.map(I => I.name)), x = I => A.has(typeof I == "string" ? I : I.name), b = new Set(m.map(I => I.name)), v = I => b.has(typeof I == "string" ? I : I.name);
        for (let I of m) {
            for (let N of I.children.filter(v)) {
                if (!y.has(N.name)) throw new kc(`Child ${N.name} of node ${I.name} is unreachable.`);
                if (y.get(I.name) > y.get(N.name)) throw new kc(`Node ${I.name} is scheduled to run after its child ${N.name}.`);
            }
            if (!x(I)) for (let N of I.inputs) {
                if (!y.has(N.name)) throw new kc(`Input ${N.name} of node ${I.name} is unreachable.`);
                if (y.get(N.name) > y.get(I.name)) throw new kc(`Node ${I.name} is scheduled to run before its input ${N.name}.`);
            }
        }
    }(f, o), f;
}

var kc = class extends Error {
    constructor(e) {
        super(`NodesExecutionOrderError: ${e}`);
    }
}, kN = new Set([ "Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While" ]), IN = new Set([ "NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where" ]), SN = new Set([ "HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2" ]);

function bo(e) {
    return kN.has(e.op);
}

function NN(e) {
    return IN.has(e.op);
}

function CN(e) {
    return SN.has(e.op);
}

var Nx = class m6 {
    get weightIds() {
        return this.parent ? this.parent.weightIds : this._weightIds;
    }
    get functionExecutorMap() {
        return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap;
    }
    get weightMap() {
        return this.parent ? this.parent.weightMap : this._weightMap;
    }
    set weightMap(t) {
        let n = Object.keys(t).map(a => t[a].map(r => r.id));
        this._weightIds = [].concat(...n), this._weightMap = t;
    }
    set resourceManager(t) {
        this._resourceManager = t;
    }
    get inputs() {
        return this._inputs.map(t => ({
            name: t.name,
            shape: t.attrParams.shape ? t.attrParams.shape.value : void 0,
            dtype: t.attrParams.dtype ? t.attrParams.dtype.value : void 0
        }));
    }
    get outputs() {
        return this._outputs.map(t => ({
            name: t.name,
            shape: t.attrParams.shape ? t.attrParams.shape.value : void 0,
            dtype: t.attrParams.dtype ? t.attrParams.dtype.value : void 0
        }));
    }
    get inputNodes() {
        return this._inputs.map(t => t.signatureKey || t.name);
    }
    get outputNodes() {
        return this._outputs.map(t => {
            let n = t.signatureKey || t.name;
            return t.defaultOutput ? `${n}:${t.defaultOutput}` : n;
        });
    }
    get functions() {
        return Object.keys(this._functions).reduce((t, n) => (t[n] = this._functions[n].signature, 
        t), {});
    }
    constructor(t, n) {
        this.graph = t, this.parent = n, this.compiledMap = new Map(), this.parseNodeNameCache = new Map(), 
        this._weightMap = {}, this.SEPARATOR = ",", this._functions = {}, this._functionExecutorMap = {}, 
        this.keepIntermediateTensors = !1, this._outputs = t.outputs, this._inputs = t.inputs, 
        this._initNodes = t.initNodes, this._signature = t.signature, this._functions = t.functions, 
        t.functions != null && Object.keys(t.functions).forEach(a => {
            this._functionExecutorMap[a] = new m6(t.functions[a], this);
        });
    }
    getCompilationKey(t, n) {
        let a = t.map(s => s.name).sort(), r = n.map(s => s.name).sort();
        return a.join(this.SEPARATOR) + "--" + r.join(this.SEPARATOR);
    }
    compile(t, n) {
        let a = Sx(t, n, this.weightMap, this._initNodes), {
            missingInputs: r,
            dynamicNode: s,
            syncInputs: i
        } = a;
        if (s != null) throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);
        if (r.length > 0) {
            let p = n.map(c => c.name), u = Object.keys(t);
            throw new Error(`Cannot compute the outputs [${p}] from the provided inputs [${u}]. Missing the following inputs: [${r}]`);
        }
        let l = wN(this.graph, a), o = function(p) {
            let u = new Map(p.map((g, y) => [ g.name, y ])), c = Number.MAX_SAFE_INTEGER, d = p.map((g, y) => bo(g) ? c : y), h = g => {
                let y = d[u.get(g.name)];
                return y ?? -1;
            }, f = p.map((g, y) => g.children.map(h).reduce((A, x) => Math.max(A, x), d[y])), m = new Map();
            for (let g = 0; g < p.length; ++g) {
                let y = f[g];
                if (y === c) continue;
                let A = p[g], x = p[y];
                m.has(x.name) || m.set(x.name, []), m.get(x.name).push(A);
            }
            return m;
        }(l);
        return {
            orderedNodes: l,
            nodeLiveUntilMap: o
        };
    }
    cloneAndKeepTensor(t) {
        if (t == null) return null;
        let n = t.clone();
        return ba(n), n;
    }
    cloneTensorList(t) {
        return t ? t.map(n => this.cloneAndKeepTensor(n)) : null;
    }
    cloneTensorMap(t) {
        return Object.fromEntries(Object.entries(t).map(([ n, a ]) => [ n, this.cloneTensorList(a) ]));
    }
    execute(t, n) {
        this.disposeIntermediateTensors(), t = this.mapInputs(t);
        let a = Object.keys(t).sort();
        this.checkInputs(t), this.checkInputShapeAndType(t), n = this.mapOutputs(n), 
        this.checkOutputs(n);
        let r = a.map(d => this.graph.nodes[Un(d)[0]]), s = n.map(d => Un(d)[0]), i = new Set(s), l = s.map(d => this.graph.nodes[d]);
        l.length === 0 && (l = this._outputs);
        let o = this.getCompilationKey(r, l), p = this.compiledMap.get(o);
        p == null && (p = this.compile(t, l), this.compiledMap.set(o, p));
        try {
            this.keepIntermediateTensors = H().getBool("KEEP_INTERMEDIATE_TENSORS");
        } catch {
            this.keepIntermediateTensors = !1;
        }
        let u = {}, c = {};
        return qe(() => {
            let d = new Ix(this.weightMap, u, c, this.functionExecutorMap, this.parseNodeNameCache), h = Object.assign({}, this.weightMap);
            this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), 
            Object.keys(t).forEach(y => {
                let [ A, x ] = Un(y, d), b = [];
                b[x] = t[y], h[A] = b, this.keepIntermediateTensors && (this.clonedTensorsMap[A] = this.cloneTensorList(b));
            });
            let f = this.getFrozenTensorIds(h), {
                orderedNodes: m,
                nodeLiveUntilMap: g
            } = p;
            for (let y of m) {
                if (h[y.name]) continue;
                let A = kx(y, h, d, this._resourceManager);
                if (k.isPromise(A)) throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);
                h[y.name] = A, this.keepIntermediateTensors && (this.clonedTensorsMap[y.name] = this.cloneTensorList(A)), 
                this.checkTensorForDisposalWithNodeLiveUntilInfo(y, h, d, f, i, g.get(y.name));
            }
            return this.parent == null && d.dispose(f), n.map(y => Jt(y, h, d));
        });
    }
    getFrozenTensorIds(t) {
        let n = [].concat.apply([], Object.keys(t).map(a => t[a]).map(a => a.map(r => r.id)));
        return new Set(n);
    }
    checkTensorForDisposal(t, n, a, r, s, i, l) {
        if (!bo(n) && !i.has(t)) {
            for (let o of a[t]) o != null && (l[o.id] = (l[o.id] || 0) + n.children.length);
            for (let o of n.inputs) {
                if (bo(o)) continue;
                let p = YA(o.name, a, r);
                if (p != null) for (let u of p) {
                    if (!u || u.kept || s.has(u.id)) continue;
                    let c = l[u.id];
                    c === 1 ? (u.dispose(), delete l[u.id]) : c != null && l[u.id]--;
                }
            }
        }
    }
    checkTensorForDisposalWithNodeLiveUntilInfo(t, n, a, r, s, i) {
        function l(o) {
            return bo(o) || s.has(o.name);
        }
        if (!bo(t) && i != null) for (let o of i) {
            if (l(o)) continue;
            let p = YA(o.name, n, a);
            for (let u of p) !u || u.kept || r.has(u.id) || u.dispose();
        }
    }
    async executeAsync(t, n) {
        return this._executeAsync(t, n);
    }
    disposeIntermediateTensors() {
        this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach(t => {
            for (let n of t) n && !n.isDisposed && n.dispose();
        }), this.clonedTensorsMap = null);
    }
    getIntermediateTensors() {
        return this.clonedTensorsMap;
    }
    async _executeAsync(t, n, a = !1, r = {}, s = {}) {
        this.disposeIntermediateTensors(), a || (t = this.mapInputs(t), this.checkInputs(t), 
        this.checkInputShapeAndType(t), n = this.mapOutputs(n), this.checkOutputs(n));
        try {
            this.keepIntermediateTensors = H().getBool("KEEP_INTERMEDIATE_TENSORS");
        } catch {
            this.keepIntermediateTensors = !1;
        }
        let i = new Ix(this.weightMap, r, s, this.functionExecutorMap, this.parseNodeNameCache);
        this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap));
        let l = await this.executeWithControlFlow(t, i, n, a), o = n.map(d => Jt(d, l, i)), p = o.map(d => d.id), u = Object.keys(t).map(d => t[d].id), c = new Set([ ...p, ...u, ...this.weightIds ]);
        return Object.values(l).forEach(d => {
            d.forEach(h => {
                h && !h.isDisposed && !c.has(h.id) && h.dispose();
            });
        }), this.parent == null && i.dispose(c), o;
    }
    async executeFunctionAsync(t, n, a) {
        let r = t.reduce((s, i, l) => (s[this.inputs[l].name] = i, s), {});
        return this._executeAsync(r, this.outputNodes, !0, n, a);
    }
    async executeWithControlFlow(t, n, a, r) {
        let s = Object.keys(t), i = s.map(b => this.graph.nodes[Un(b)[0]]), l = a.map(b => Un(b)[0]), o = new Set(l), p = l.map(b => this.graph.nodes[b]);
        p.length === 0 && (p = this._outputs);
        let {
            usedNodes: u,
            missingInputs: c,
            dynamicNode: d,
            syncInputs: h
        } = Sx(t, p, this.weightMap, this._initNodes), f = [ ...i, ...this.graph.weights, ...this._initNodes || [] ].map(b => ({
            node: b,
            contexts: n.currentContext
        })), m = Object.assign({}, this.weightMap);
        Object.keys(t).forEach(b => {
            let [ v, I ] = Un(b), N = [];
            N[I] = t[b], m[v] = N;
        });
        let g = {}, y = this.getFrozenTensorIds(m), A = {};
        for (;f.length > 0; ) {
            let b = this.processStack(i, f, n, m, A, y, o, g, u);
            await Promise.all(b);
        }
        let x = p.filter(b => !bo(b) && !Jt(b.name, m, n)).map(b => b.name);
        if (x.length > 0) {
            let b = "";
            throw d != null && (b = `Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`), 
            new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${b}`);
        }
        return m;
    }
    processStack(t, n, a, r, s, i, l, o, p) {
        let u = [];
        for (;n.length > 0; ) {
            let c = n.pop();
            a.currentContext = c.contexts;
            let d = "";
            if (c.node.op === "Enter" && S("isConstant", c.node, r, a) && ([ d ] = ar(c.node.name, a)), 
            r[c.node.name] == null) {
                let h = kx(c.node, r, a, this._resourceManager);
                d || ([ d ] = ar(c.node.name, a));
                let f = a.currentContext;
                k.isPromise(h) ? u.push(h.then(m => (r[d] = m, this.keepIntermediateTensors && (this.clonedTensorsMap[d] = this.cloneTensorList(m)), 
                a.currentContext = f, this.checkTensorForDisposal(d, c.node, r, a, i, l, o), 
                this.processChildNodes(c.node, n, a, r, s, p), m))) : (r[d] = h, 
                this.keepIntermediateTensors && (this.clonedTensorsMap[d] = this.cloneTensorList(h)), 
                this.checkTensorForDisposal(d, c.node, r, a, i, l, o), this.processChildNodes(c.node, n, a, r, s, p));
            } else this.processChildNodes(c.node, n, a, r, s, p);
        }
        return u;
    }
    processChildNodes(t, n, a, r, s, i) {
        t.children.forEach(l => {
            let [ o ] = ar(l.name, a);
            s[o] || !i.has(l.name) || (l.op === "Merge" ? l.inputNames.some(p => !!Jt(p, r, a)) && (s[o] = !0, 
            n.push({
                contexts: a.currentContext,
                node: l
            })) : l.inputNames.every(p => !!Jt(p, r, a)) && (s[o] = !0, n.push({
                contexts: a.currentContext,
                node: l
            })));
        });
    }
    dispose() {
        Object.keys(this.weightMap).forEach(t => this.weightMap[t].forEach(n => n.dispose()));
    }
    checkInputShapeAndType(t) {
        Object.keys(t).forEach(n => {
            let a = t[n], [ r ] = Un(n), s = this.graph.nodes[r];
            if (s.attrParams.shape && s.attrParams.shape.value) {
                let i = s.attrParams.shape.value, l = i.length === a.shape.length && a.shape.every((o, p) => i[p] === -1 || i[p] === o);
                k.assert(l, () => `The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${a.shape}]`);
            }
            s.attrParams.dtype && s.attrParams.dtype.value && k.assert(a.dtype === s.attrParams.dtype.value, () => `The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`);
        });
    }
    mapInputs(t) {
        var n, a;
        let r = {};
        for (let s in t) {
            let i = (a = (n = this._signature) === null || n === void 0 ? void 0 : n.inputs) === null || a === void 0 ? void 0 : a[s];
            i != null ? r[i.name] = t[s] : r[s] = t[s];
        }
        return r;
    }
    checkInputs(t) {
        let n = Object.keys(t).filter(a => {
            let [ r ] = Un(a);
            return this.graph.nodes[r] == null;
        });
        if (n.length > 0) throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`);
    }
    mapOutputs(t) {
        return t.map(n => {
            var a, r;
            let s = (r = (a = this._signature) === null || a === void 0 ? void 0 : a.outputs) === null || r === void 0 ? void 0 : r[n];
            return s != null ? s.name : n;
        }, {});
    }
    checkOutputs(t) {
        t.forEach(n => {
            let [ a ] = Un(n);
            if (!this.graph.nodes[a]) throw new Error(`The output '${n}' is not found in the graph`);
        });
    }
}, TN = class {
    constructor(e = {}, t = {}) {
        this.hashTableNameToHandle = e, this.hashTableMap = t;
    }
    addHashTable(e, t) {
        this.hashTableNameToHandle[e] = t.handle, this.hashTableMap[t.id] = t;
    }
    getHashTableHandleByName(e) {
        return this.hashTableNameToHandle[e];
    }
    getHashTableById(e) {
        return this.hashTableMap[e];
    }
    dispose() {
        for (let e in this.hashTableMap) this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
        for (let e in this.hashTableNameToHandle) this.hashTableNameToHandle[e].dispose(), 
        delete this.hashTableNameToHandle[e];
    }
}, RN = "?tfjs-format=file", EN = "model.json", Ic = class {
    get modelVersion() {
        return this.version;
    }
    get inputNodes() {
        return this.executor.inputNodes;
    }
    get outputNodes() {
        return this.executor.outputNodes;
    }
    get inputs() {
        return this.executor.inputs;
    }
    get outputs() {
        return this.executor.outputs;
    }
    get weights() {
        return this.executor.weightMap;
    }
    get metadata() {
        return this.artifacts.userDefinedMetadata;
    }
    get modelSignature() {
        return this.signature;
    }
    get modelStructuredOutputKeys() {
        return this.structuredOutputKeys;
    }
    constructor(e, t = {}, n = nr) {
        this.modelUrl = e, this.loadOptions = t, this.version = "n/a", this.io = n, 
        t == null && (this.loadOptions = {}), this.resourceManager = new TN();
    }
    findIOHandler() {
        let e = this.modelUrl;
        if (e.load != null) this.handler = e; else if (this.loadOptions.requestInit != null) this.handler = this.io.browserHTTPRequest(e, this.loadOptions); else {
            let t = this.io.getLoadHandlers(e, this.loadOptions);
            if (t.length === 0) t.push(this.io.browserHTTPRequest(e, this.loadOptions)); else if (t.length > 1) throw new Error(`Found more than one (${t.length}) load handlers for URL '${[ e ]}'`);
            this.handler = t[0];
        }
    }
    load() {
        if (this.findIOHandler(), this.handler.load == null) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
        let e = this.handler.load();
        return k.isPromise(e) ? e.then(t => t.getWeightStream == null ? this.loadSync(t) : this.loadStreaming(t)) : this.loadSync(e);
    }
    loadSync(e) {
        let t = this.io.decodeWeights(e.weightData, e.weightSpecs);
        return this.loadWithWeightMap(e, t);
    }
    async loadStreaming(e) {
        if (e.getWeightStream == null) throw new Error("Model artifacts missing streamWeights function");
        let t = await L0(e.getWeightStream(), e.weightSpecs);
        return this.loadWithWeightMap(e, t);
    }
    loadWithWeightMap(e, t) {
        this.artifacts = e;
        let n = this.artifacts.modelTopology, a = this.artifacts.signature;
        if (this.artifacts.userDefinedMetadata != null) {
            let r = this.artifacts.userDefinedMetadata;
            r.signature != null && (a = r.signature), r.structuredOutputKeys != null && (this.structuredOutputKeys = r.structuredOutputKeys);
        }
        if (this.signature = a, this.version = `${n.versions.producer}.${n.versions.minConsumer}`, 
        this.executor = new Nx(yx.Instance.transformGraph(n, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(t), 
        this.executor.resourceManager = this.resourceManager, e.modelInitializer != null && e.modelInitializer.node != null) {
            let r = yx.Instance.transformGraph(e.modelInitializer);
            this.initializer = new Nx(r), this.initializer.weightMap = this.executor.weightMap, 
            this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e.initializerSignature;
        }
        return !0;
    }
    async save(e, t) {
        if (typeof e == "string") {
            let n = this.io.getSaveHandlers(e);
            if (n.length === 0) throw new Error(`Cannot find any save handlers for URL '${e}'`);
            if (n.length > 1) throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);
            e = n[0];
        }
        if (e.save == null) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
        return e.save(this.artifacts);
    }
    addStructuredOutputNames(e) {
        if (this.structuredOutputKeys) {
            let t = {};
            return (e instanceof vt ? [ e ] : e).forEach((n, a) => t[this.structuredOutputKeys[a]] = n), 
            t;
        }
        return e;
    }
    predict(e, t) {
        let n = this.execute(e, this.outputNodes);
        return this.addStructuredOutputNames(n);
    }
    async predictAsync(e, t) {
        let n = await this.executeAsync(e, this.outputNodes);
        return this.addStructuredOutputNames(n);
    }
    normalizeInputs(e) {
        var t;
        if (!(e instanceof vt || Array.isArray(e))) {
            let r = (t = this.signature) === null || t === void 0 ? void 0 : t.inputs;
            if (r != null) for (let s in r) {
                let i = r[s];
                i.resourceId != null && (e[s] = this.resourceIdToCapturedInput[i.resourceId]);
            }
            return e;
        }
        e = Array.isArray(e) ? e : [ e ];
        let n = Object.keys(this.resourceIdToCapturedInput).length;
        if (e.length + n !== this.inputNodes.length) throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length - n} non-resource placeholders, while there are ${e.length} input tensors provided.`);
        let a = 0;
        return this.inputNodes.reduce((r, s) => {
            var i, l, o;
            let p = (o = (l = (i = this.signature) === null || i === void 0 ? void 0 : i.inputs) === null || l === void 0 ? void 0 : l[s]) === null || o === void 0 ? void 0 : o.resourceId;
            return r[s] = p != null ? this.resourceIdToCapturedInput[p] : e[a++], 
            r;
        }, {});
    }
    normalizeOutputs(e) {
        return e = e || this.outputNodes, Array.isArray(e) ? e : [ e ];
    }
    executeInitializerGraph() {
        return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
    }
    async executeInitializerGraphAsync() {
        return this.initializer == null ? [] : this.initializerSignature == null ? this.initializer.executeAsync({}, []) : this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
    }
    setResourceIdToCapturedInput(e) {
        if (this.resourceIdToCapturedInput = {}, this.initializerSignature) {
            let t = this.initializerSignature.outputs, n = Object.keys(t);
            for (let a = 0; a < n.length; a++) {
                let r = t[n[a]];
                this.resourceIdToCapturedInput[r.resourceId] = e[a];
            }
        }
    }
    execute(e, t) {
        this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), 
        e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
        let n = this.executor.execute(e, t);
        return n.length > 1 ? n : n[0];
    }
    async executeAsync(e, t) {
        this.resourceIdToCapturedInput == null && this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()), 
        e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
        let n = await this.executor.executeAsync(e, t);
        return n.length > 1 ? n : n[0];
    }
    getIntermediateTensors() {
        return this.executor.getIntermediateTensors();
    }
    disposeIntermediateTensors() {
        this.executor.disposeIntermediateTensors();
    }
    convertTensorMapToTensorsMap(e) {
        return Object.keys(e).reduce((t, n) => (t[n] = [ e[n] ], t), {});
    }
    dispose() {
        this.executor.dispose(), this.initializer && (this.initializer.dispose(), 
        this.resourceIdToCapturedInput && ae(this.resourceIdToCapturedInput)), this.resourceManager.dispose();
    }
};

async function Cx(e, t = {}, n = nr) {
    if (e == null) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
    t == null && (t = {}), t.fromTFHub && typeof e == "string" && (e = function(r) {
        return r.endsWith("/") || (r += "/"), `${r}${EN}${RN}`;
    }(e));
    let a = new Ic(e, t, n);
    return await a.load(), a;
}

function $N(e) {
    if (e == null) throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
    let t;
    if (e instanceof Array) {
        let [ a, r ] = e;
        if (!a) throw new Error("modelJSON must be the first element of the array");
        if (!(r && r instanceof ArrayBuffer)) throw new Error("An ArrayBuffer of weights must be the second element of the array");
        if (!("modelTopology" in a)) throw new Error("Model JSON is missing 'modelTopology'");
        if (!("weightsManifest" in a)) throw new Error("Model JSON is missing 'weightsManifest'");
        let s = nr.getWeightSpecs(a.weightsManifest), i = nr.getModelArtifactsForJSONSync(a, s, r);
        t = nr.fromMemorySync(i);
    } else if ("load" in e) t = e; else {
        if (!("modelTopology" in e && "weightSpecs" in e && "weightData" in e)) throw new Error("Unknown model format");
        t = nr.fromMemorySync(e);
    }
    let n = new Ic(t);
    return n.load(), n;
}

var MN = "4.17.0";

function Se(e, t) {
    Array.isArray(e) || (e = [ e ]), e.forEach(n => {
        n != null && k.assert(n.dtype !== "complex64", () => `${t} does not support complex64 tensors in the CPU backend.`);
    });
}

var FN = ua.whereImpl, Mm = class g6 extends al {
    nextDataId() {
        return g6.nextDataId++;
    }
    constructor() {
        super(), this.blockSize = 48, this.firstUse = !0, this.data = new Wu(this, Mt());
    }
    write(t, n, a) {
        this.firstUse && (this.firstUse = !1, H().get("IS_NODE") && C.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));
        let r = {
            id: this.nextDataId()
        };
        return this.data.set(r, {
            values: t,
            dtype: a,
            refCount: 1
        }), r;
    }
    makeTensorInfo(t, n, a) {
        let r;
        if (n === "string" && a != null && a.length > 0 && k.isString(a[0])) {
            let s = a.map(i => k.encodeString(i));
            r = this.write(s, t, n);
        } else r = this.write(a, t, n);
        return {
            dataId: r,
            shape: t,
            dtype: n
        };
    }
    refCount(t) {
        return this.data.has(t) ? this.data.get(t).refCount : 0;
    }
    incRef(t) {
        this.data.get(t).refCount++;
    }
    decRef(t) {
        this.data.has(t) && this.data.get(t).refCount--;
    }
    move(t, n, a, r, s) {
        this.data.set(t, {
            values: n,
            dtype: r,
            refCount: s
        });
    }
    numDataIds() {
        return this.data.numDataIds();
    }
    async read(t) {
        return this.readSync(t);
    }
    readSync(t) {
        let {
            dtype: n,
            complexTensorInfos: a
        } = this.data.get(t);
        if (n === "complex64") {
            let r = this.readSync(a.real.dataId), s = this.readSync(a.imag.dataId);
            return C.mergeRealAndImagArrays(r, s);
        }
        return k.convertBackendValuesAndArrayBuffer(this.data.get(t).values, n);
    }
    bufferSync(t) {
        let n = this.readSync(t.dataId);
        if (t.dtype === "string") try {
            let a = n.map(r => k.decodeString(r));
            return We(t.shape, t.dtype, a);
        } catch {
            throw new Error("Failed to decode encoded string bytes into utf-8");
        }
        return We(t.shape, t.dtype, n);
    }
    makeOutput(t, n, a) {
        return Mt().makeTensorFromTensorInfo(this.makeTensorInfo(n, a, t), this);
    }
    disposeData(t, n = !1) {
        if (this.data.has(t)) {
            if (this.data.get(t).refCount--, !n && this.data.get(t).refCount > 0) return !1;
            let {
                complexTensorInfos: a
            } = this.data.get(t);
            a != null && (this.disposeData(a.real.dataId, !0), this.disposeData(a.imag.dataId, !0)), 
            this.data.delete(t);
        }
        return !0;
    }
    disposeIntermediateTensorInfo(t) {
        this.disposeData(t.dataId);
    }
    async time(t) {
        let n = k.now();
        return t(), {
            kernelMs: k.now() - n
        };
    }
    memory() {
        return {
            unreliable: !0,
            reasons: [ "The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less." ]
        };
    }
    where(t) {
        Se([ t ], "where");
        let n = this.readSync(t.dataId);
        return FN(t.shape, n);
    }
    dispose() {}
    floatPrecision() {
        return 32;
    }
    epsilon() {
        return super.epsilon();
    }
};

Mm.nextDataId = 0;

var Sc = {};

function Tx(e) {
    let t = new Float32Array(e.length);
    for (let n = 0; n < e.length; ++n) t[n] = Math.abs(e[n]);
    return t;
}

Ze(Sc, {
    addImpl: () => Ex,
    bincountImpl: () => _m,
    bincountReduceImpl: () => $x,
    bitwiseAndImpl: () => Mx,
    castImpl: () => Rx,
    ceilImpl: () => Fx,
    concatImpl: () => Om,
    equalImpl: () => _x,
    expImpl: () => Px,
    expm1Impl: () => zx,
    floorDivImpl: () => Wx,
    floorImpl: () => Lx,
    gatherNdImpl: () => Bx,
    gatherV2Impl: () => Vx,
    greaterEqualImpl: () => Gx,
    greaterImpl: () => Ux,
    lessEqualImpl: () => jx,
    lessImpl: () => Hx,
    linSpaceImpl: () => qx,
    logImpl: () => Xx,
    maxImpl: () => Kx,
    maximumImpl: () => Zx,
    minimumImpl: () => Yx,
    multiplyImpl: () => Pm,
    negImpl: () => Jx,
    notEqualImpl: () => Qx,
    prodImpl: () => e5,
    raggedGatherImpl: () => n5,
    raggedRangeImpl: () => r5,
    raggedTensorToTensorImpl: () => o5,
    rangeImpl: () => zm,
    rsqrtImpl: () => l5,
    scatterImpl: () => iu,
    sigmoidImpl: () => SC,
    simpleAbsImpl: () => Tx,
    sliceImpl: () => Tc,
    sparseFillEmptyRowsImpl: () => d5,
    sparseReshapeImpl: () => p5,
    sparseSegmentReductionImpl: () => Lm,
    sqrtImpl: () => TC,
    squaredDifferenceImpl: () => c5,
    staticRegexReplaceImpl: () => h5,
    stridedSliceImpl: () => f5,
    stringNGramsImpl: () => Wm,
    stringSplitImpl: () => Bm,
    stringToHashBucketFastImpl: () => Vm,
    subImpl: () => m5,
    tileImpl: () => g5,
    topKImpl: () => A5,
    transposeImpl: () => Dm,
    uniqueImpl: () => Gm
});

var _N = {
    kernelName: ol,
    backendName: "cpu",
    kernelFunc: e => {
        let {
            x: t
        } = e.inputs, n = e.backend;
        Se(t, "abs");
        let a = new Float32Array(k.sizeFromShape(t.shape));
        return a = Tx(n.data.get(t.dataId).values), n.makeOutput(a, t.shape, t.dtype);
    }
};

function Ct(e) {
    return (t, n, a, r, s) => {
        let i = C.assertAndGetBroadcastShape(t, n), l = i.length, o = k.computeStrides(i), p = k.sizeFromShape(i), u = k.getTypedArrayFromDType(s, p), c = t.length, d = n.length, h = k.computeStrides(t), f = k.computeStrides(n), m = C.getBroadcastDims(t, i), g = C.getBroadcastDims(n, i);
        if (m.length + g.length === 0) for (let y = 0; y < u.length; ++y) u[y] = e(a[y % a.length], r[y % r.length]); else for (let y = 0; y < u.length; ++y) {
            let A = k.indexToLoc(y, l, o), x = A.slice(-c);
            m.forEach(N => x[N] = 0);
            let b = k.locToIndex(x, c, h), v = A.slice(-d);
            g.forEach(N => v[N] = 0);
            let I = k.locToIndex(v, d, f);
            u[y] = e(a[b], r[I]);
        }
        return [ u, i ];
    };
}

function Gn(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        real: a,
        imag: r
    } = t, s = n.data.get(a.dataId).values, i = n.data.get(r.dataId).values, l = n.makeTensorInfo(a.shape, "complex64");
    return n.data.get(l.dataId).complexTensorInfos = {
        real: n.makeTensorInfo(a.shape, "float32", s),
        imag: n.makeTensorInfo(r.shape, "float32", i)
    }, l;
}

var ON = {
    kernelName: qu,
    backendName: "cpu",
    kernelFunc: Gn
};

function Nc(e, t, n = "float32") {
    if (n === "complex64") return Gn({
        inputs: {
            real: Nc(e, t, "float32"),
            imag: Nc(e, t, "float32")
        },
        backend: e
    });
    let a = k.makeZerosTypedArray(k.sizeFromShape(t), n);
    return e.makeTensorInfo(t, n, a);
}

function La(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        x: a
    } = t;
    return n.incRef(a.dataId), {
        dataId: a.dataId,
        shape: a.shape,
        dtype: a.dtype
    };
}

var PN = {
    kernelName: Js,
    backendName: "cpu",
    kernelFunc: La
};

function vo(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        input: a
    } = t, r = n.data.get(a.dataId).complexTensorInfos.real, s = n.data.get(r.dataId).values;
    return n.makeTensorInfo(r.shape, r.dtype, s);
}

var DN = {
    kernelName: sd,
    backendName: "cpu",
    kernelFunc: vo
};

function Rx(e, t, n, a) {
    if (a === "int32") return [ t, "int32", Int32Array.from(e) ];
    if (a === "bool") {
        let r = k.toTypedArray([ 0 ], n), [ s, i ] = Ct((l, o) => l !== o ? 1 : 0)(t, [], e, r, "bool");
        return [ i, "bool", s ];
    }
    throw new Error(`Error in Cast: failed to cast ${n} to ${a}`);
}

function Br(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        dtype: s
    } = a;
    if (s === "complex64") {
        if (r.dtype === "complex64") return La({
            inputs: {
                x: r
            },
            backend: n
        });
        let u = Nc(n, r.shape, r.dtype), c = Br({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                dtype: "float32"
            }
        }), d = Gn({
            inputs: {
                real: c,
                imag: u
            },
            backend: n
        });
        return n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), 
        d;
    }
    if (r.dtype === "complex64") {
        let u = vo({
            inputs: {
                input: r
            },
            backend: n
        }), c = Br({
            inputs: {
                x: u
            },
            backend: n,
            attrs: {
                dtype: s
            }
        });
        return n.disposeIntermediateTensorInfo(u), c;
    }
    if (!k.hasEncodingLoss(r.dtype, s)) {
        let u = La({
            inputs: {
                x: r
            },
            backend: n
        });
        return {
            dataId: u.dataId,
            shape: u.shape,
            dtype: s
        };
    }
    let i = n.data.get(r.dataId).values, [ l, o, p ] = Rx(i, r.shape, r.dtype, s);
    return n.makeTensorInfo(l, o, p);
}

var zN = {
    kernelName: Ss,
    backendName: "cpu",
    kernelFunc: Br
};

function Lt(e, t, n, a) {
    return n == null ? ({
        inputs: r,
        backend: s
    }) => {
        let {
            a: i,
            b: l
        } = r, o = s;
        Se([ i, l ], e);
        let p = o.data.get(i.dataId).values, u = o.data.get(l.dataId).values, c = i.dtype === "string" ? C.fromUint8ToStringArray(p) : p, d = i.dtype === "string" ? C.fromUint8ToStringArray(u) : u, h = a || i.dtype, [ f, m ] = t(i.shape, l.shape, c, d, h);
        return o.makeTensorInfo(m, h, f);
    } : ({
        inputs: r,
        backend: s
    }) => {
        let {
            a: i,
            b: l
        } = r, o = s;
        if (i.dtype === "complex64" || l.dtype === "complex64") {
            let p = Br({
                inputs: {
                    x: i
                },
                backend: o,
                attrs: {
                    dtype: "complex64"
                }
            }), u = o.data.get(p.dataId), c = u.complexTensorInfos.real, d = u.complexTensorInfos.imag, h = o.data.get(c.dataId).values, f = o.data.get(d.dataId).values, m = Br({
                inputs: {
                    x: l
                },
                backend: o,
                attrs: {
                    dtype: "complex64"
                }
            }), g = o.data.get(m.dataId), y = g.complexTensorInfos.real, A = g.complexTensorInfos.imag, x = o.data.get(y.dataId).values, b = o.data.get(A.dataId).values, [ v, I, N ] = n(i.shape, l.shape, h, f, x, b), T = o.makeTensorInfo(N, "float32", v), R = o.makeTensorInfo(N, "float32", I), w = Gn({
                inputs: {
                    real: T,
                    imag: R
                },
                backend: o
            });
            return o.disposeIntermediateTensorInfo(p), o.disposeIntermediateTensorInfo(m), 
            o.disposeIntermediateTensorInfo(T), o.disposeIntermediateTensorInfo(R), 
            w;
        }
        {
            let p = o.data.get(i.dataId).values, u = o.data.get(l.dataId).values, c = a || i.dtype, [ d, h ] = t(i.shape, l.shape, p, u, c);
            return o.makeTensorInfo(h, c, d);
        }
    };
}

function Fm(e) {
    return (t, n, a, r, s, i) => {
        let l = C.assertAndGetBroadcastShape(t, n), o = k.sizeFromShape(l), p = l.length, u = k.computeStrides(l), c = k.getTypedArrayFromDType("float32", o), d = k.getTypedArrayFromDType("float32", o), h = C.getBroadcastDims(t, l), f = C.getBroadcastDims(n, l), m = C.mergeRealAndImagArrays(a, r), g = C.mergeRealAndImagArrays(s, i), y = t.length, A = k.computeStrides(t), x = n.length, b = k.computeStrides(n);
        if (h.length + f.length === 0) for (let v = 0; v < c.length; v++) {
            let I = v % m.length, N = v % g.length, T = e(m[2 * I], m[2 * I + 1], g[2 * N], g[2 * N + 1]);
            c[v] = T.real, d[v] = T.imag;
        } else for (let v = 0; v < c.length; v++) {
            let I = k.indexToLoc(v, p, u), N = I.slice(-y);
            h.forEach($ => N[$] = 0);
            let T = k.locToIndex(N, y, A), R = I.slice(-x);
            f.forEach($ => R[$] = 0);
            let w = k.locToIndex(R, x, b), E = e(m[2 * T], m[2 * T + 1], g[2 * w], g[2 * w + 1]);
            c[v] = E.real, d[v] = E.imag;
        }
        return [ c, d, l ];
    };
}

var Ex = Ct((e, t) => e + t), LN = Fm((e, t, n, a) => ({
    real: e + n,
    imag: t + a
})), su = Lt(Ar, Ex, LN), WN = {
    kernelName: Ar,
    backendName: "cpu",
    kernelFunc: su
};

function _m(e, t, n, a, r) {
    let s = k.sizeFromShape(a), i = k.makeZerosTypedArray(r, n);
    for (let l = 0; l < e.length; l++) {
        let o = e[l];
        if (o < 0) throw new Error("Input x must be non-negative!");
        o >= r || (i[o] += s > 0 ? t[l] : 1);
    }
    return i;
}

function $x(e, t, n, a = !1) {
    let r = e.shape[0], s = e.shape[1], i = We([ r, n ], t.dtype);
    for (let l = 0; l < r; l++) for (let o = 0; o < s; o++) {
        let p = e.get(l, o);
        if (p < 0) throw new Error("Input x must be non-negative!");
        p >= n || (a ? i.set(1, l, p) : t.size > 0 ? i.set(i.get(l, p) + t.get(l, o), l, p) : i.set(i.get(l, p) + 1, l, p));
    }
    return i;
}

var Mx = Ct((e, t) => e & t), BN = Lt(cl, Mx), VN = {
    kernelName: cl,
    backendName: "cpu",
    kernelFunc: BN
};

function Wa(e) {
    return (t, n, a) => {
        let r = k.getArrayFromDType(n, t.length);
        for (let s = 0; s < t.length; ++s) r[s] = e(t[s], a);
        return r;
    };
}

function pt(e, t, n) {
    return Vr(e, Wa(t), n);
}

function Vr(e, t, n) {
    return ({
        inputs: a,
        attrs: r,
        backend: s
    }) => {
        let {
            x: i
        } = a;
        Se(i, e);
        let l, o = s, p = o.data.get(i.dataId).values;
        if (i.dtype === "string") {
            if (!Array.isArray(p)) throw new Error("String tensor's value was not an instance of Array");
            l = C.fromUint8ToStringArray(p);
        } else l = p;
        let u = n || i.dtype, c = t(l, u, r);
        return o.makeTensorInfo(i.shape, u, c);
    };
}

var Fx = Wa(e => Math.ceil(e)), UN = Vr(Ns, Fx), GN = {
    kernelName: Ns,
    backendName: "cpu",
    kernelFunc: UN
};

function Om(e, t, n, a) {
    let r = k.getArrayFromDType(n, k.sizeFromShape(t));
    if (a && n !== "string") {
        let s = 0;
        e.forEach(i => {
            let l = k.sizeFromShape(i.shape);
            r.set(i.vals, s), s += l;
        });
    } else {
        let s = 0;
        e.forEach(i => {
            let l = n === "string" ? C.fromUint8ToStringArray(i.vals) : i.vals, o = 0;
            for (let p = 0; p < i.shape[0]; ++p) {
                let u = p * t[1] + s;
                for (let c = 0; c < i.shape[1]; ++c) r[u + c] = l[o++];
            }
            s += i.shape[1];
        });
    }
    return r;
}

var _x = Ct((e, t) => e === t ? 1 : 0), Ox = Lt(Vs, _x, null, "bool"), HN = {
    kernelName: Vs,
    backendName: "cpu",
    kernelFunc: Ox
}, Px = Wa(e => Math.exp(e)), Dx = Vr(Us, Px, "float32"), jN = {
    kernelName: Us,
    backendName: "cpu",
    kernelFunc: Dx
}, zx = Wa(e => Math.expm1(e)), qN = Vr(Gs, zx), XN = {
    kernelName: Gs,
    backendName: "cpu",
    kernelFunc: qN
}, Lx = Wa(e => Math.floor(e)), KN = Vr(js, Lx), ZN = {
    kernelName: js,
    backendName: "cpu",
    kernelFunc: KN
}, Wx = Ct((e, t) => Math.floor(e / t)), YN = Lt(qs, Wx, null, "int32"), JN = {
    kernelName: qs,
    backendName: "cpu",
    kernelFunc: YN
};

function Bx(e, t, n, a, r, s, i, l, o) {
    let p = We([ a, s ], n);
    for (let u = 0; u < a; u++) {
        let c = [], d = 0;
        for (let h = 0; h < r; h++) {
            let f = e[u * r + h];
            d += f * i[h], c.push(f);
        }
        if (d < 0 || d >= o / s) throw new Error(`Invalid indices: ${c} does not index into ${l}`);
        for (let h = 0; h < s; h++) p.values[u * s + h] = t.get(...t.indexToLoc(d * s + h));
    }
    return p;
}

function Vx(e, t, n) {
    let a = We(n, e.dtype);
    for (let r = 0; r < a.size; ++r) {
        let s = a.indexToLoc(r).slice(), i = s[0], l = s[2], o = t.locToIndex([ i, l ]);
        s[2] = t.values[o];
        let p = e.locToIndex(s);
        0 <= p && p < e.values.length && (a.values[r] = e.values[p]);
    }
    return a;
}

var Ux = Ct((e, t) => e > t ? 1 : 0), QN = Lt(Zs, Ux, null, "bool"), eC = {
    kernelName: Zs,
    backendName: "cpu",
    kernelFunc: QN
}, Gx = Ct((e, t) => e >= t ? 1 : 0), tC = Lt(Ys, Gx, null, "bool"), nC = {
    kernelName: Ys,
    backendName: "cpu",
    kernelFunc: tC
}, Hx = Ct((e, t) => e < t ? 1 : 0), aC = Lt(ai, Hx, null, "bool"), rC = {
    kernelName: ai,
    backendName: "cpu",
    kernelFunc: aC
}, jx = Ct((e, t) => e <= t ? 1 : 0), sC = Lt(ri, jx, null, "bool"), iC = {
    kernelName: ri,
    backendName: "cpu",
    kernelFunc: sC
};

function qx(e, t, n) {
    let a = (t - e) / (n - 1), r = k.makeZerosTypedArray(n, "float32");
    r[0] = e;
    for (let s = 1; s < r.length; s++) r[s] = r[s - 1] + a;
    return r;
}

var Xx = Wa(e => Math.log(e)), oC = Vr(ii, Xx), lC = {
    kernelName: ii,
    backendName: "cpu",
    kernelFunc: oC
};

function Kx(e, t, n, a) {
    let r = k.getTypedArrayFromDType(a, k.sizeFromShape(n));
    for (let s = 0; s < r.length; ++s) {
        let i = s * t, l = e[i];
        for (let o = 0; o < t; ++o) {
            let p = e[i + o];
            (Number.isNaN(p) || p > l) && (l = p);
        }
        r[s] = l;
    }
    return r;
}

var Zx = Ct((e, t) => Math.max(e, t)), uC = Lt(hi, Zx), dC = {
    kernelName: hi,
    backendName: "cpu",
    kernelFunc: uC
}, Yx = Ct((e, t) => Math.min(e, t)), pC = Lt(yi, Yx), cC = {
    kernelName: yi,
    backendName: "cpu",
    kernelFunc: pC
}, Pm = Ct((e, t) => e * t), hC = Fm((e, t, n, a) => ({
    real: e * n - t * a,
    imag: e * a + t * n
})), Cc = Lt(vi, Pm, hC), fC = {
    kernelName: vi,
    backendName: "cpu",
    kernelFunc: Cc
};

function Jx(e, t, n) {
    let a = k.createScalarValue(-1, n);
    return Pm([], t, a, e, n);
}

var mC = {
    kernelName: Cl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t;
        Se(a, "neg");
        let r = n.data.get(a.dataId).values, [ s, i ] = Jx(r, a.shape, a.dtype);
        return n.makeTensorInfo(i, a.dtype, s);
    }
}, Qx = Ct((e, t) => e !== t ? 1 : 0), gC = Lt(wi, Qx, null, "bool"), yC = {
    kernelName: wi,
    backendName: "cpu",
    kernelFunc: gC
};

function Dm(e, t, n, a, r) {
    let s = t.length, i = k.sizeFromShape(t), l = k.computeStrides(t), o = k.computeStrides(r), p = k.getTypedArrayFromDType(n, k.sizeFromShape(r));
    for (let u = 0; u < i; ++u) {
        let c = k.indexToLoc(u, s, l), d = new Array(c.length);
        for (let h = 0; h < d.length; h++) d[h] = c[a[h]];
        p[k.locToIndex(d, s, o)] = e[u];
    }
    return p;
}

function kn(e) {
    let {
        inputs: t,
        attrs: n,
        backend: a
    } = e, {
        x: r
    } = t, {
        perm: s
    } = n;
    Se(r, "transpose");
    let i = r.shape.length, l = new Array(i);
    for (let p = 0; p < l.length; p++) l[p] = r.shape[s[p]];
    let o = Dm(a.data.get(r.dataId).values, r.shape, r.dtype, s, l);
    return {
        dataId: a.write(o, l, r.dtype),
        shape: l,
        dtype: r.dtype
    };
}

var AC = {
    kernelName: Xa,
    backendName: "cpu",
    kernelFunc: kn
};

function e5(e, t, n, a) {
    let [ r, s ] = C.computeOutAndReduceShapes(e, a), i = Zt(t, "int32"), l = k.makeZerosTypedArray(k.sizeFromShape(r), i), o = k.sizeFromShape(s);
    for (let p = 0; p < l.length; ++p) {
        let u = p * o, c = 1;
        for (let d = 0; d < o; ++d) c *= n[u + d];
        l[p] = c;
    }
    return {
        outVals: l,
        outShape: r,
        outDtype: i
    };
}

var xC = {
    kernelName: Ri,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a;
        Se(r, "prod");
        let l = r.shape.length, o = k.parseAxisParam(s, r.shape), p = C.getAxesPermutation(o, l), u = o, c = r, d = [];
        p != null && (c = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), d.push(c), u = C.getInnerMostAxes(u.length, l));
        let h = n.data.get(c.dataId).values, {
            outVals: f,
            outShape: m,
            outDtype: g
        } = e5(c.shape, c.dtype, h, u), y = m;
        return i && (y = C.expandShapeToKeepDim(m, o)), d.forEach(A => n.disposeIntermediateTensorInfo(A)), 
        n.makeTensorInfo(y, g, f);
    }
};

function bC(e, t, n, a) {
    let r = [], s = 0, i = t.length - 1 + n.length, l = new Array(i).fill(null).map(() => [ 0 ]);
    (function(p, u) {
        for (let c = 0; c < p.length; ++c) {
            let d = p[c], h = c === p.length - 1 ? u : p[c + 1].length;
            if (d.length === 0) throw new Error("Ragged splits may not be empty");
            if (d[0] < 0) throw new Error("Ragged splits must be non-negative");
            if (d[d.length - 1] > h) throw new Error("Ragged splits must not point past values");
            for (let f = 1; f < d.length; ++f) if (d[f - 1] > d[f]) throw new Error("Ragged splits must be sorted in ascending order");
        }
    })(n, a);
    let o = 1;
    for (let p = 0; p < t.length - 1; ++p) {
        o *= t[p];
        let u = t[p + 1];
        for (let c = 1; c < o + 1; ++c) l[p].push(c * u);
    }
    for (let p = 0; p < e.length; ++p) {
        let u = e[p], c = e[p] + 1;
        for (let d = 0; d < n.length; ++d) {
            let h = n[d], f = d + t.length - 1;
            if (f >= 0) {
                let m = l[f], g = m[m.length - 1] - h[u];
                for (let y = u; y < c; ++y) l[f].push(h[y + 1] + g);
            }
            u = h[u], c = h[c];
        }
        c !== u && (r.push([ u, c ]), s += c - u);
    }
    return {
        outSplits: l,
        valueSlices: r,
        numValues: s
    };
}

function t5(e, t) {
    let n = e.slice(0, t);
    for (;n.length < t; ) n.push(1);
    for (let a = t; a < e.length; a++) n[t - 1] *= e[a];
    return n;
}

function vC(e, t, n, a, r) {
    let s = t.slice();
    s[0] = r;
    let i = k.getArrayFromDType(n, k.sizeFromShape(s)), l = e.length;
    return function(o, p, u, c, d, h) {
        let f = t5(p, 2)[1], m = t5(h, 2)[1], g = 0;
        for (let y of u) for (let A = y[0]; A < y[1]; ++A) {
            for (let x = 0; x < c; ++x) d[g * m + x] = o[A * f + x];
            ++g;
        }
    }(e, t, a, l === 0 ? 0 : l / t[0], i, s), [ i, s ];
}

function n5(e, t, n, a, r, s, i, l) {
    if (e.length === 0) throw new Error("paramsNestedSplits must be non empty");
    if (t[0].length === 0) throw new Error("Split tensors must not be scalars");
    if (function(f, m, g) {
        f.forEach((y, A) => {
            if (y < 0 || y >= g) {
                let x = k.indexToLoc(A, m.length, k.computeStrides(m)).join(",");
                throw new Error(`indices[${x}] = ${y} is not in [0, ${g})`);
            }
        });
    }(s, i, t[0][0] - 1), a.length === 0) throw new Error("params.rank must be nonzero");
    let o = a[0], {
        outSplits: p,
        valueSlices: u,
        numValues: c
    } = bC(s, i, e, o), d = function(f) {
        let m = [];
        for (let g = 0; g < f.length; ++g) {
            let y = f[g].length, A = k.getArrayFromDType("int32", y);
            m.push(A), f[g].forEach((x, b) => A[b] = x);
        }
        return m;
    }(p), h = vC(n, a, r, u, c);
    return [ d, h[0], h[1] ];
}

var a5 = 2147483647;

function r5(e, t, n, a, r, s, i) {
    if (t.length > 1) throw new Error("starts must be a scalar or vector");
    if (r.length > 1) throw new Error("limits must be a scalar or vector");
    if (i.length > 1) throw new Error("deltas must be a scalar or vector");
    let l = t.length === 0, o = r.length === 0, p = i.length === 0, u = [];
    l || u.push(t[0]), o || u.push(r[0]), p || u.push(i[0]);
    for (let g = 1; g < u.length; ++g) if (u[g] !== u[g - 1]) throw new Error("starts, limits, and deltas must have the same shape");
    let c = u.length === 0 ? 1 : u[0], d = k.getArrayFromDType("int32", c + 1);
    d[0] = 0;
    for (let g = 0; g < c; ++g) {
        let y, A = l ? e[0] : e[g], x = o ? a[0] : a[g], b = p ? s[0] : s[g];
        if (b === 0) throw new Error("Requires delta != 0");
        if (b > 0 && x < A || b < 0 && x > A) y = 0; else if (y = Math.ceil(Math.abs((x - A) / b)), 
        y > a5) throw new Error(`Requires ((limit - start) / delta) <= ${a5}`);
        d[g + 1] = d[g] + y;
    }
    let h = d[c], f = k.getArrayFromDType(n, h), m = 0;
    for (let g = 0; g < c; ++g) {
        let y = d[g + 1] - d[g], A = l ? e[0] : e[g], x = p ? s[0] : s[g];
        for (let b = 0; b < y; ++b) f[m++] = A, A += x;
    }
    return [ d, f ];
}

var pa = C.RowPartitionType, wC = class z2 {
    constructor(t, n, a, r, s, i, l, o, p, u) {
        this.shape = t, this.shapeShape = n, this.values = a, this.valuesShape = r, 
        this.valuesDType = s, this.defaultValue = i, this.defaultValueShape = l, 
        this.rowPartitionValues = o, this.rowPartitionValuesShapes = p, this.rowPartitionTypes = C.getRowPartitionTypesHelper(u), 
        this.raggedRank = C.getRaggedRank(this.rowPartitionTypes);
    }
    getRowPartitionTypeByDimension(t) {
        return this.rowPartitionTypes[0] === pa.FIRST_DIM_SIZE ? this.rowPartitionTypes[t + 1] : this.rowPartitionTypes[t];
    }
    getRowPartitionTensor(t) {
        return this.rowPartitionTypes[0] === pa.FIRST_DIM_SIZE ? this.rowPartitionValues[t + 1] : this.rowPartitionValues[t];
    }
    getMaxWidth(t) {
        let n = this.getRowPartitionTensor(t - 1);
        switch (this.getRowPartitionTypeByDimension(t - 1)) {
          case pa.VALUE_ROWIDS:
            return z2.getMaxWidthValueRowID(n);

          case pa.ROW_SPLITS:
            return z2.getMaxWidthRowSplit(n);

          default:
            throw new Error(`Cannot handle partition type ${pa[this.getRowPartitionTypeByDimension(t - 1)]}`);
        }
    }
    static getMaxWidthRowSplit(t) {
        let n = t.length;
        if (n === 0 || n === 1) return 0;
        let a = 0;
        for (let r = 0; r < n - 1; ++r) {
            let s = t[r + 1] - t[r];
            s > a && (a = s);
        }
        return a;
    }
    static getMaxWidthValueRowID(t) {
        let n = t.length;
        if (n === 0) return 0;
        let a = 0, r = t[0], s = 0;
        for (let i = 1; i < n; ++i) {
            let l = t[i];
            l !== r && (r = l, s = Math.max(i - a, s), a = i);
        }
        return Math.max(n - a, s);
    }
    tensorShapeFromTensor(t, n, a = !0) {
        if (n.length === 0) {
            if (t[0] === -1) return [];
            throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
        }
        return i5(t, a);
    }
    calculateOutputSize(t) {
        let n = this.valuesShape, a = this.defaultValueShape;
        C.validateDefaultValueShape(a, n);
        let r = this.tensorShapeFromTensor(this.shape, this.shapeShape), s = C.combineRaggedTensorToTensorShapes(this.raggedRank, r, n);
        s[0] < 0 && (s[0] = t);
        for (let i = 1; i <= this.raggedRank; ++i) s[i] < 0 && (s[i] = this.getMaxWidth(i));
        return s;
    }
    calculateFirstParentOutputIndex(t, n, a) {
        let r = Math.min(t, a), s = [], i = 0;
        for (let l = 0; l < r; ++l, i += n) s.push(i);
        for (let l = r; l < t; ++l) s.push(-1);
        return k.assert(s.length === t, () => "Final length of result must be equal to firstDimension."), 
        s;
    }
    calculateOutputIndexRowSplit(t, n, a, r) {
        let s = t.length, i = [];
        for (let l = 0; l < s - 1; ++l) {
            let o = t[l + 1] - t[l], p = Math.min(r, o), u = n[l];
            u === -1 && (p = 0);
            for (let c = 0; c < p; ++c) i.push(u), u += a;
            for (let c = 0; c < o - p; ++c) i.push(-1);
        }
        if (s > 0 && i.length !== t[s - 1]) throw new Error("Invalid row split size.");
        return i;
    }
    calculateOutputIndexValueRowID(t, n, a, r) {
        let s = t.length, i = [];
        if (s === 0) return [];
        let l = 0, o = t[0];
        if (o >= n.length) throw new Error(`Got currentValueRowId=${o}, which is not less than ${n.length}`);
        let p = n[o];
        i.push(p);
        for (let u = 1; u < s; ++u) {
            let c = t[u];
            if (c === o) p >= 0 && (++l, l < r ? p += a : p = -1); else {
                if (l = 0, o = c, c >= n.length) throw new Error(`Got nextValueRowId=${c} which is not less than ${n.length}`);
                p = n[c];
            }
            i.push(p);
        }
        if (i.length !== t.length) throw new Error("Invalid row ids.");
        return i;
    }
    calculateOutputIndex(t, n, a, r) {
        let s = this.getRowPartitionTensor(t), i = this.getRowPartitionTypeByDimension(t);
        switch (i) {
          case pa.VALUE_ROWIDS:
            return this.calculateOutputIndexValueRowID(s, n, a, r);

          case pa.ROW_SPLITS:
            if (s.length - 1 > n.length) throw new Error(`Row partition size is greater than output size: ${s.length - 1} > ${n.length}`);
            return this.calculateOutputIndexRowSplit(s, n, a, r);

          default:
            throw new Error(`Unsupported partition type: ${pa[i]}`);
        }
    }
    getFirstDimensionSize() {
        let t = this.rowPartitionValues[0];
        if (this.rowPartitionTypes.length === 0) throw new Error("No row_partition_types given.");
        let n = this.rowPartitionTypes[0];
        switch (n) {
          case pa.FIRST_DIM_SIZE:
            return t[0];

          case pa.VALUE_ROWIDS:
            throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");

          case pa.ROW_SPLITS:
            return this.rowPartitionValuesShapes[0][0] - 1;

          default:
            throw new Error(`Cannot handle type ${pa[n]}`);
        }
    }
    compute() {
        if (this.rowPartitionValues[0].length <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
        let t = this.getFirstDimensionSize(), n = this.calculateOutputSize(t), a = new Array(this.raggedRank + 1);
        a[a.length - 1] = 1;
        for (let i = a.length - 2; i >= 0; --i) a[i] = a[i + 1] * n[i + 1];
        let r = i5(n, !1), s = k.getArrayFromDType(this.valuesDType, k.sizeFromShape(r));
        if (a[0] * n[0] > 0) {
            let i = this.calculateFirstParentOutputIndex(t, a[0], n[0]);
            for (let l = 1; l <= this.raggedRank; ++l) i = this.calculateOutputIndex(l - 1, i, a[l], n[l]);
            this.setOutput(this.raggedRank, i, s, r);
        }
        return [ r, s ];
    }
    setOutput(t, n, a, r) {
        if (a.length === 0) return;
        let s = this.values, i = a, l = r.slice();
        l = l.slice(t + 1);
        let o = k.sizeFromShape(l), p = n.length, u = this.defaultValue;
        if (u.length !== o && u.length !== 1) {
            let f = this.defaultValueShape;
            qe(() => {
                let m = Q(u, f);
                u = Jl(m, l).dataSync();
            });
        }
        let c = 0, d = 0, h = 0;
        for (let f = 0; f <= p; ++f) {
            let m = f < p ? n[f] : -1;
            if (m !== h) {
                if (d < h) {
                    let g = s.subarray(c * o);
                    s5(i.subarray(d * o), g, (h - d) * o);
                }
                if (f >= p) {
                    let g = a.length;
                    m = Math.floor(g / o);
                }
                if (m > h) if (this.defaultValue.length === 1) i.subarray(h * o, m * o).fill(this.defaultValue[0]), 
                h = m; else for (;m > h; ) s5(i.slice(h * o), u, o), ++h;
                m < 0 ? (c = f + 1, d = h) : (c = f, d = h, h = d + 1);
            } else ++h;
        }
    }
};

function s5(e, t, n) {
    for (let a = 0; a < n; a++) e[a] = t[a];
}

function i5(e, t) {
    let n = [];
    for (let a of e) {
        if (a < 0) {
            if (!t) throw new Error(`Dimension ${a} must be >= 0`);
            if (a < -1) throw new Error(`Dimension ${a} must be >= -1`);
            a = -1;
        }
        n.push(a);
    }
    return n;
}

function o5(e, t, n, a, r, s, i, l, o, p) {
    return new wC(e, t, n, a, r, s, i, l, o, p).compute();
}

function zm(e, t, n, a) {
    if (e === t || e < t && n < 0 || t < e && n > 1) return k.makeZerosTypedArray(0, a);
    let r = Math.abs(Math.ceil((t - e) / n)), s = k.makeZerosTypedArray(r, a);
    t < e && n === 1 && (n = -1), s[0] = e;
    for (let i = 1; i < s.length; i++) s[i] = s[i - 1] + n;
    return s;
}

var l5 = Wa(e => 1 / Math.sqrt(e)), kC = Vr(Di, l5), IC = {
    kernelName: Di,
    backendName: "cpu",
    kernelFunc: kC
};

function iu(e, t, n, a, r, s, i, l, o, p) {
    let u = [ a / r, r ], c = e.values, d = t.values;
    if (a === 0) return We(n, t.dtype);
    let h = o instanceof $t ? o : We(u, t.dtype);
    typeof o == "string" || typeof o == "number" ? h.values.fill(o) : typeof o == "boolean" && h.values.fill(+o);
    for (let f = 0; f < s; f++) {
        let m = [], g = 0;
        for (let y = 0; y < i; y++) {
            let A = c[f * i + y];
            m.push(A), g += A * l[y];
        }
        if (g < 0 || g >= a / r) throw new Error(`Invalid indices: ${m} does not index into ${n}`);
        for (let y = 0; y < r; y++) p ? h.values[g * r + y] += d[f * r + y] : h.values[g * r + y] = t.rank === 0 ? d[0] : d[f * r + y];
    }
    return h;
}

var SC = Wa(e => 1 / (1 + Math.exp(-e))), u5 = pt(Hi, e => 1 / (1 + Math.exp(-e))), NC = {
    kernelName: Hi,
    backendName: "cpu",
    kernelFunc: u5
};

function Tc(e, t, n, a, r) {
    let s = St.isSliceContinous(a, t, n), i = k.sizeFromShape(n), l = k.computeStrides(a);
    if (s) {
        let u = St.computeFlatOffset(t, l);
        return r === "string" ? e.slice(u, u + i) : e.subarray(u, u + i);
    }
    let o = We(a, r, r === "string" ? C.fromUint8ToStringArray(e) : e), p = We(n, r);
    for (let u = 0; u < p.size; ++u) {
        let c = p.indexToLoc(u), d = c.map((h, f) => h + t[f]);
        p.set(o.get(...d), ...c);
    }
    return r === "string" ? C.fromStringArrayToUint8(p.values) : p.values;
}

function wo(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        begin: s,
        size: i
    } = a;
    Se(r, "slice");
    let [ l, o ] = St.parseSliceParams(r, s, i);
    St.assertParamsValid(r, l, o);
    let p = Tc(n.data.get(r.dataId).values, l, o, r.shape, r.dtype);
    return n.makeTensorInfo(o, r.dtype, p);
}

var CC = {
    kernelName: Pl,
    backendName: "cpu",
    kernelFunc: wo
};

function d5(e, t, n, a, r, s, i) {
    let l = t[0], o = s[0], p = new Array(o), u = new Array(l), c = t[1];
    if (o === 0) {
        if (l !== 0) throw new Error(C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(l));
        return [ k.getArrayFromDType(n, 0), [ 0, c ], k.getArrayFromDType(r, 0), p, u ];
    }
    let d = !0, h = 0, f = new Array(o).fill(0);
    for (let g = 0; g < l; ++g) {
        let y = e[g * c];
        if (y < 0) throw new Error(C.getSparseFillEmptyRowsNegativeIndexErrorMessage(g, y));
        if (y >= o) throw new Error(C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g, y, o));
        ++f[y], d = d && y >= h, h = y;
    }
    let m = !0;
    for (let g = 0; g < o; ++g) {
        let y = f[g] === 0;
        p[g] = y, m = m && !y, f[g] = Math.max(f[g], 1), g > 0 && (f[g] += f[g - 1]);
    }
    if (m && d) {
        let g = e, y = a;
        for (let A = 0; A < l; ++A) u[A] = A;
        return [ g, [ l, c ], y, p, u ];
    }
    {
        let g = f[o - 1], y = k.getArrayFromDType(n, g * c), A = k.getArrayFromDType(r, g), x = new Array(o).fill(0);
        for (let b = 0; b < l; ++b) {
            let v = e[b * c], I = x[v], N = (v === 0 ? 0 : f[v - 1]) + I;
            x[v]++;
            for (let T = 0; T < c; ++T) y[N * c + T] = e[b * c + T];
            A[N] = a[b], u[b] = N;
        }
        for (let b = 0; b < o; ++b) if (x[b] === 0) {
            let v = b === 0 ? 0 : f[b - 1];
            y[v * c + 0] = b;
            for (let I = 1; I < c; ++I) y[v * c + I] = 0;
            A[v] = i;
        }
        return [ y, [ g, c ], A, p, u ];
    }
}

function p5(e, t, n, a, r) {
    let s = k.sizeFromShape(a), i = t[0], l = r.length, o = [], p = 1, u = -1;
    for (let m = 0; m < l; ++m) {
        let g = r[m];
        if (g === -1) {
            if (u !== -1) throw new Error(C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u, m));
            u = m, o.push(1);
        } else {
            if (g < 0) throw new Error(C.getSparseReshapeNegativeOutputDimErrorMessage(m, g));
            p *= g, o.push(g);
        }
    }
    if (u !== -1) {
        if (p <= 0) throw new Error(C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());
        let m = Math.trunc(s / p);
        if (p * m !== s) throw new Error(C.getSparseReshapeInputOutputMultipleErrorMessage(a, o));
        o[u] = m;
    }
    if (k.sizeFromShape(o) !== s) throw new Error(C.getSparseReshapeInputOutputMismatchErrorMessage(a, o));
    let c = a.length, d = [];
    if (c > 0) {
        d[c - 1] = 1;
        for (let m = c - 2; m >= 0; --m) d[m] = d[m + 1] * a[m + 1];
    }
    let h = [];
    if (l > 0) {
        h[l - 1] = 1;
        for (let m = l - 2; m >= 0; --m) h[m] = h[m + 1] * o[m + 1];
    }
    let f = k.getArrayFromDType(n, i * l);
    for (let m = 0; m < i; ++m) {
        let g = 0;
        for (let y = 0; y < c; ++y) g += e[m * c + y] * d[y];
        for (let y = 0; y < l; ++y) f[m * l + y] = Math.trunc(g / h[y]), g %= h[y];
    }
    return [ f, [ i, l ], o ];
}

function Lm(e, t, n, a, r, s = !1, i = 0) {
    let l = a.length, o = [ t[0], e.length / t[0] ], p = o[1], u = l > 0 ? r[l - 1] + 1 : 0;
    if (u < 0) throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let c = t.slice();
    c[0] = u;
    let d = c.reduce((A, x) => A * x, 1), h = k.getArrayFromDType(n, d);
    if (l === 0) return u > 0 && h.fill(i), [ h, c ];
    if (u <= 0) throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let f = 0, m = 1, g = 0, y = r[f];
    for (;;) {
        let A = 0;
        if (m < l) {
            if (A = r[m], y === A) {
                ++m;
                continue;
            }
            if (y >= A) throw new Error(C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());
        }
        if (y < 0 || y >= u) throw new Error(C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y, u));
        y > g && h.fill(i, g * p, y * p);
        for (let x = f; x < m; ++x) {
            let b = a[x];
            if (b < 0 || b >= o[0]) throw new Error(C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x, a[x], o[0]));
            for (let v = 0; v < p; v++) h[y * p + v] += e[b * p + v];
        }
        if (s) for (let x = 0; x < p; x++) h[y * p + x] /= m - f;
        if (f = m, ++m, g = y + 1, y = A, m > l) break;
    }
    return g < u && h.fill(i, g * p, u * p), [ h, c ];
}

var TC = Wa(e => Math.sqrt(e)), RC = pt(qi, e => Math.sqrt(e)), EC = {
    kernelName: qi,
    backendName: "cpu",
    kernelFunc: RC
}, c5 = Ct((e, t) => {
    let n = e - t;
    return n * n;
}), $C = Lt(Yi, c5), MC = {
    kernelName: Yi,
    backendName: "cpu",
    kernelFunc: $C
}, h5 = Wa((e, t) => {
    let {
        pattern: n,
        replaceGlobal: a,
        rewrite: r
    } = t;
    return e.replace(new RegExp(n, a ? "g" : ""), r);
}), FC = Vr(ld, h5), _C = {
    kernelName: ld,
    backendName: "cpu",
    kernelFunc: FC
};

function f5(e, t, n, a) {
    let r = We(e, t.dtype);
    for (let s = 0; s < r.size; s++) {
        let i = r.indexToLoc(s), l = new Array(i.length);
        for (let o = 0; o < l.length; o++) l[o] = i[o] * n[o] + a[o];
        r.set(t.get(...l), ...i);
    }
    return r;
}

var OC = class {
    constructor(e, t, n, a, r, s) {
        this.separator = k.encodeString(e), this.nGramWidths = t, this.leftPad = k.encodeString(n), 
        this.rightPad = k.encodeString(a), this.padWidth = r, this.preserveShort = s;
    }
    getPadWidth(e) {
        return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1);
    }
    getNumNGrams(e, t) {
        let n = this.getPadWidth(t);
        return Math.max(0, e + 2 * n - t + 1);
    }
    createNGrams(e, t, n, a, r, s) {
        for (let i = 0; i < r; ++i) {
            let l = this.getPadWidth(s), o = Math.max(0, l - i), p = Math.max(0, l - (r - (i + 1))), u = s - (o + p), c = t + (o > 0 ? 0 : i - l), d = 0;
            d += o * this.leftPad.length;
            for (let g = 0; g < u; ++g) d += e[c + g].length;
            d += p * this.rightPad.length, d += (o + p + u - 1) * this.separator.length, 
            n[a + i] = new Uint8Array(d);
            let h = n[a + i], f = 0, m = g => g.forEach(y => h[f++] = y);
            for (let g = 0; g < o; ++g) m(this.leftPad), m(this.separator);
            for (let g = 0; g < u - 1; ++g) m(e[c + g]), m(this.separator);
            if (u > 0) {
                m(e[c + u - 1]);
                for (let g = 0; g < p; ++g) m(this.separator), m(this.rightPad);
            } else {
                for (let g = 0; g < p - 1; ++g) m(this.rightPad), m(this.separator);
                m(this.rightPad);
            }
        }
    }
    compute(e, t) {
        let n = e.length, a = t.length;
        if (a > 0) {
            let l = t[0];
            if (l !== 0) throw new Error(`First split value must be 0, got ${l}`);
            for (let o = 1; o < a; ++o) {
                let p = t[o] >= l;
                if (p = p && t[o] <= n, !p) throw new Error(`Invalid split value ${t[o]}, must be in [${l}, ${n}]`);
                l = t[o];
            }
            if (l !== n) throw new Error(`Last split value must be data size. Expected ${n}, got ${l}`);
        }
        let r = a - 1, s = k.getArrayFromDType("int32", a);
        if (n === 0 || a === 0) {
            let l = new Array(n);
            for (let o = 0; o <= r; ++o) s[o] = 0;
            return [ l, s ];
        }
        s[0] = 0;
        for (let l = 1; l <= r; ++l) {
            let o = t[l] - t[l - 1], p = 0;
            this.nGramWidths.forEach(u => {
                p += this.getNumNGrams(o, u);
            }), this.preserveShort && o > 0 && p === 0 && (p = 1), s[l] = s[l - 1] + p;
        }
        let i = new Array(s[r]);
        for (let l = 0; l < r; ++l) {
            let o = t[l], p = s[l];
            if (this.nGramWidths.forEach(u => {
                let c = t[l + 1] - t[l], d = this.getNumNGrams(c, u);
                this.createNGrams(e, o, i, p, d, u), p += d;
            }), this.preserveShort && p === s[l]) {
                let u = t[l + 1] - t[l];
                if (u === 0) continue;
                let c = u + 2 * this.padWidth;
                this.createNGrams(e, o, i, p, 1, c);
            }
        }
        return [ i, s ];
    }
};

function Wm(e, t, n, a, r, s, i, l) {
    return new OC(n, a, r, s, i, l).compute(e, t);
}

function PC(e, t, n, a) {
    if (!e.length) return;
    if (t.length === 0) {
        for (let s = 0; s < e.length; ++s) a.push(e.subarray(s, s + 1));
        return;
    }
    if (t.length === 1) {
        let s = t[0], i = e.indexOf(s);
        for (;i !== -1; ) {
            let l = e.subarray(0, i);
            (!n || l.length !== 0) && a.push(l), i = (e = e.subarray(i + 1)).indexOf(s);
        }
        return void ((!n || e.length !== 0) && a.push(e));
    }
    let r = 0;
    for (let s = 0; s < e.length + 1; s++) if (s === e.length || t.indexOf(e[s]) !== -1) {
        let i = e.subarray(r, s);
        (!n || i.length !== 0) && a.push(i), r = s + 1;
    }
}

function Bm(e, t, n) {
    let a = e.length, r = [], s = 0, i = 0, l = new Array(a);
    for (let d = 0; d < a; ++d) {
        let h = r.length;
        PC(e[d], t, n, r);
        let f = r.length - h;
        l[d] = f, s += f, i = Math.max(i, f);
    }
    let o = k.getArrayFromDType("int32", 2 * s), p = new Array(s), u = [ a, i ], c = 0;
    for (let d = 0; d < a; ++d) for (let h = 0; h < l[d]; ++h) o[2 * c] = d, o[2 * c + 1] = h, 
    p[c] = r[c], ++c;
    return [ o, p, u ];
}

function Vm(e, t) {
    let n = k.getArrayFromDType("int32", e.length);
    for (let a = 0; a < e.length; ++a) n[a] = k.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();
    return n;
}

var m5 = Ct((e, t) => e - t), DC = Fm((e, t, n, a) => ({
    real: e - n,
    imag: t - a
})), Um = Lt(Qi, m5, DC), zC = {
    kernelName: Qi,
    backendName: "cpu",
    kernelFunc: Um
};

function g5(e, t) {
    let n = new Array(e.rank);
    for (let r = 0; r < n.length; r++) n[r] = e.shape[r] * t[r];
    let a = We(n, e.dtype);
    for (let r = 0; r < a.values.length; ++r) {
        let s = a.indexToLoc(r), i = new Array(e.rank);
        for (let o = 0; o < i.length; o++) i[o] = s[o] % e.shape[o];
        let l = e.locToIndex(i);
        a.values[r] = e.values[l];
    }
    return a;
}

var Ud = (e, t) => {
    let n = t.value - e.value;
    return n === 0 ? e.index - t.index : n;
};

function y5(e, t, n = 0, a = e.length - 1) {
    for (;a > n; ) {
        if (a - n > 600) {
            let l = a - n + 1, o = t - n + 1, p = Math.log(l), u = .5 * Math.exp(2 * p / 3), c = .5 * Math.sqrt(p * u * (l - u) / l) * Math.sign(o - l / 2);
            y5(e, t, Math.max(n, Math.floor(t - o * u / l + c)), Math.min(a, Math.floor(t + (l - o) * u / l + c)));
        }
        let r = e[t], s = n, i = a;
        for (k.swap(e, n, t), Ud(e[a], r) > 0 && k.swap(e, n, a); s < i; ) {
            for (k.swap(e, s, i), s++, i--; Ud(e[s], r) < 0; ) s += 1;
            for (;Ud(e[i], r) > 0; ) i -= 1;
        }
        Ud(e[n], r) === 0 ? k.swap(e, n, i) : (i += 1, k.swap(e, i, a)), i <= t && (n = i + 1), 
        t <= i && (a = i - 1);
    }
}

function A5(e, t, n, a, r) {
    let s = t[t.length - 1], [ i, l ] = [ e.length / s, s ], o = k.getTypedArrayFromDType(n, i * a), p = k.getTypedArrayFromDType("int32", i * a);
    for (let c = 0; c < i; c++) {
        let d = c * l, h = e.subarray(d, d + l), f = new Array(h.length);
        h.forEach((A, x) => f[x] = {
            value: A,
            index: x
        }), a < f.length && (y5(f, a), f = f.slice(0, a)), r && f.sort(Ud);
        let m = c * a, g = o.subarray(m, m + a), y = p.subarray(m, m + a);
        for (let A = 0; A < a; A++) g[A] = f[A].value, y[A] = f[A].index;
    }
    let u = t.slice();
    return u[u.length - 1] = a, [ We(u, n, o), We(u, "int32", p) ];
}

function Gm(e, t, n, a) {
    let r = k.parseAxisParam(t, n)[0], s = [ 1, n[0], 1 ];
    for (let f = 0; f < r; f++) s[0] *= n[f];
    s[1] = n[r];
    for (let f = r + 1; f < n.length; f++) s[2] *= n[f];
    let i = new Map(), l = new Int32Array(n[r]), o = new $t(s, a, e), p = [], u = s[0] === 1 && s[2] === 1;
    for (let f = 0; f < n[r]; f++) {
        let m;
        if (u) m = e[f].toString(); else {
            let y = [];
            for (let A = 0; A < s[0]; A++) for (let x = 0; x < s[2]; x++) y.push(o.get(A, f, x));
            m = y.join(",");
        }
        let g = i.get(m);
        if (g != null) l[f] = g; else {
            let y = i.size;
            i.set(m, y), l[f] = y, p.push(f);
        }
    }
    let c = s.slice();
    c[1] = i.size;
    let d = new $t(c, a);
    p.forEach((f, m) => {
        for (let g = 0; g < s[0]; g++) for (let y = 0; y < s[2]; y++) d.set(o.get(g, f, y), g, m, y);
    });
    let h = n.slice();
    return h[r] = c[1], {
        outputValues: d.values,
        outputShape: h,
        indices: l
    };
}

var LC = "4.17.0";

ql("cpu", () => new Mm(), 1);

var x5 = pt(Ws, e => e >= 0 ? e : Math.exp(e) - 1), WC = {
    kernelName: Ws,
    backendName: "cpu",
    kernelFunc: x5
};

function b5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        alpha: s
    } = a;
    Se([ r ], "leakyRelu");
    let i = k.sizeFromShape(r.shape), l = n.data.get(r.dataId).values, o = k.getTypedArrayFromDType("float32", i);
    for (let p = 0; p < l.length; p++) o[p] = l[p] < 0 ? s * l[p] : l[p];
    return n.makeTensorInfo(r.shape, "float32", o);
}

var BC = {
    kernelName: ni,
    backendName: "cpu",
    kernelFunc: b5
}, VC = Ct((e, t) => e < 0 ? t * e : e);

function v5(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        x: a,
        alpha: r
    } = t;
    Se([ a, r ], "prelu");
    let s = n.data.get(a.dataId).values, i = n.data.get(r.dataId).values, [ l, o ] = VC(a.shape, r.shape, s, i, "float32");
    return n.makeTensorInfo(o, "float32", l);
}

var UC = {
    kernelName: Ti,
    backendName: "cpu",
    kernelFunc: v5
}, w5 = pt($i, e => Math.max(0, e)), GC = {
    kernelName: $i,
    backendName: "cpu",
    kernelFunc: w5
}, k5 = pt(_i, e => Math.min(Math.max(0, e), 6)), HC = {
    kernelName: _i,
    backendName: "cpu",
    kernelFunc: k5
};

function Rc(e, t, n, a, r) {
    if (n === "linear") return La({
        inputs: {
            x: t
        },
        backend: e
    });
    if (n === "relu") return w5({
        inputs: {
            x: t
        },
        backend: e
    });
    if (n === "elu") return x5({
        inputs: {
            x: t
        },
        backend: e
    });
    if (n === "relu6") return k5({
        inputs: {
            x: t
        },
        backend: e
    });
    if (n === "prelu") return v5({
        inputs: {
            x: t,
            alpha: a
        },
        backend: e
    });
    if (n === "leakyrelu") return b5({
        inputs: {
            x: t
        },
        backend: e,
        attrs: {
            alpha: r
        }
    });
    if (n === "sigmoid") return u5({
        inputs: {
            x: t
        },
        backend: e
    });
    throw new Error(`Activation ${n} has not been implemented for the CPU backend.`);
}

function At(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        shape: s
    } = a, i = k.sizeFromShape(r.shape), l = k.inferFromImplicitShape(s, i), o = k.sizeFromShape(l);
    k.assert(i === o, () => `The new shape (${l}) has ${o} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`), 
    n.incRef(r.dataId);
    let p = n.data.get(r.dataId);
    if (p.complexTensorInfos != null) {
        let u = p.complexTensorInfos.real, c = p.complexTensorInfos.imag;
        u.shape = l, c.shape = l;
    }
    return {
        dataId: r.dataId,
        shape: l,
        dtype: r.dtype
    };
}

var jC = {
    kernelName: Ml,
    backendName: "cpu",
    kernelFunc: At
};

function I5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        a: r,
        b: s
    } = t, {
        transposeA: i,
        transposeB: l
    } = a;
    Se([ r, s ], "matMul");
    let o = r.shape.length, p = s.shape.length, u = i ? r.shape[o - 2] : r.shape[o - 1], c = l ? s.shape[p - 1] : s.shape[p - 2], d = i ? r.shape[o - 1] : r.shape[o - 2], h = l ? s.shape[p - 2] : s.shape[p - 1], f = r.shape.slice(0, -2), m = s.shape.slice(0, -2), g = k.sizeFromShape(f), y = k.sizeFromShape(m), A = mo.assertAndGetBroadcastShape(r.shape.slice(0, -2), s.shape.slice(0, -2)).concat([ d, h ]);
    k.assert(u === c, () => `Error in matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${l} must match.`);
    let x = l ? [ y, h, c ] : [ y, c, h ], b = At({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            shape: i ? [ g, u, d ] : [ g, d, u ]
        }
    }), v = At({
        inputs: {
            x: s
        },
        backend: n,
        attrs: {
            shape: x
        }
    }), I = i ? b.shape[1] : b.shape[2], N = i ? b.shape[2] : b.shape[1], T = l ? v.shape[1] : v.shape[2], R = Math.max(g, y), w = n.data.get(b.dataId).values, E = n.data.get(v.dataId).values, $ = k.computeStrides(b.shape), M = k.computeStrides(v.shape), [ F, P, L ] = i ? [ $[0], 1, $[1] ] : [ $[0], $[1], 1 ], [ O, B, G ] = l ? [ 1, M[1], M[0] ] : [ M[1], 1, M[0] ], W = N * T, z = We([ R, N, T ], b.dtype), X = z.values, q = n.blockSize;
    for (let Z = 0; Z < R; Z++) {
        let Y = Z % g, te = Z % y;
        for (let re = 0; re < N; re += q) {
            let pe = Math.min(re + q, N);
            for (let ge = 0; ge < T; ge += q) {
                let Re = Math.min(ge + q, T);
                for (let ye = 0; ye < I; ye += q) {
                    let Me = Math.min(ye + q, I);
                    for (let Ee = re; Ee < pe; Ee++) for (let me = ge; me < Re; me++) {
                        let Oe = 0;
                        for (let we = ye; we < Me; we++) Oe += w[Y * F + Ee * P + we * L] * E[we * O + me * B + te * G];
                        X[Z * W + (Ee * T + me)] += Oe;
                    }
                }
            }
        }
    }
    return n.disposeIntermediateTensorInfo(b), n.disposeIntermediateTensorInfo(v), 
    n.makeTensorInfo(A, z.dtype, z.values);
}

var qC = {
    kernelName: ks,
    backendName: "cpu",
    kernelFunc: I5
}, XC = {
    kernelName: wr,
    backendName: "cpu",
    kernelFunc: function(e) {
        let t, n, a, {
            inputs: r,
            backend: s,
            attrs: i
        } = e, {
            a: l,
            b: o,
            bias: p,
            preluActivationWeights: u
        } = r, {
            transposeA: c,
            transposeB: d,
            activation: h,
            leakyreluAlpha: f
        } = i, m = [];
        t = I5({
            inputs: {
                a: l,
                b: o
            },
            attrs: {
                transposeA: c,
                transposeB: d
            },
            backend: s
        }), p && (n = su({
            inputs: {
                a: t,
                b: p
            },
            backend: s
        }), m.push(t), t = n), h && (a = Rc(s, t, h, u, f), m.push(t), t = a);
        for (let g of m) s.disposeIntermediateTensorInfo(g);
        return t;
    }
}, KC = pt(cs, e => Math.acos(e)), ZC = {
    kernelName: cs,
    backendName: "cpu",
    kernelFunc: KC
}, YC = pt(hs, e => Math.acosh(e)), JC = {
    kernelName: hs,
    backendName: "cpu",
    kernelFunc: YC
}, QC = {
    kernelName: fs,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, a = t;
        Se(t, "addN");
        let r = a.map(l => n.data.get(l.dataId).values), s = We(a[0].shape, a[0].dtype), i = s.values;
        for (let l = 0; l < a.length; l++) {
            let o = r[l];
            for (let p = 0; p < i.length; p++) i[p] += o[p];
        }
        return n.makeTensorInfo(s.shape, s.dtype, s.values);
    }
}, eT = {
    kernelName: ms,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a;
        Se(r, "all");
        let l = k.parseAxisParam(s, r.shape), o = l, p = C.getAxesPermutation(o, r.shape.length), u = r;
        p != null && (u = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), o = C.getInnerMostAxes(o.length, r.shape.length)), C.assertAxesAreInnerMostDims("all", o, u.shape.length);
        let [ c, d ] = C.computeOutAndReduceShapes(u.shape, o), h = k.sizeFromShape(d), f = k.makeZerosTypedArray(k.sizeFromShape(c), u.dtype), m = n.data.get(u.dataId).values;
        for (let y = 0; y < f.length; ++y) {
            let A = y * h, x = m[A];
            for (let b = 0; b < h; ++b) {
                let v = m[A + b];
                x = x && v;
            }
            f[y] = x;
        }
        p != null && n.disposeIntermediateTensorInfo(u);
        let g = n.makeTensorInfo(c, u.dtype, f);
        if (i) {
            let y = At({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    shape: C.expandShapeToKeepDim(c, l)
                }
            });
            return n.disposeIntermediateTensorInfo(g), y;
        }
        return g;
    }
}, tT = {
    kernelName: gs,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a;
        Se(r, "any");
        let l = k.parseAxisParam(s, r.shape), o = l, p = C.getAxesPermutation(o, r.shape.length), u = r;
        p != null && (u = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), o = C.getInnerMostAxes(o.length, r.shape.length)), C.assertAxesAreInnerMostDims("any", o, u.shape.length);
        let [ c, d ] = C.computeOutAndReduceShapes(u.shape, o), h = k.sizeFromShape(d), f = k.makeZerosTypedArray(k.sizeFromShape(c), u.dtype), m = n.data.get(u.dataId).values;
        for (let y = 0; y < f.length; ++y) {
            let A = y * h, x = m[A];
            for (let b = 0; b < h; ++b) {
                let v = m[A + b];
                x = x || v;
            }
            f[y] = x;
        }
        p != null && n.disposeIntermediateTensorInfo(u);
        let g = n.makeTensorInfo(c, u.dtype, f);
        if (i) {
            let y = At({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    shape: C.expandShapeToKeepDim(c, l)
                }
            });
            return n.disposeIntermediateTensorInfo(g), y;
        }
        return g;
    }
}, nT = {
    kernelName: ll,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s
        } = a;
        Se(r, "argMax");
        let i = k.parseAxisParam(s, r.shape), l = C.getAxesPermutation(i, r.shape.length), o = r, p = [];
        l != null && (o = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: l
            }
        }), p.push(o), i = C.getInnerMostAxes(i.length, o.shape.length)), i = [ i[0] ], 
        C.assertAxesAreInnerMostDims("argMax", i, o.shape.length);
        let [ u, c ] = C.computeOutAndReduceShapes(o.shape, i), d = k.sizeFromShape(u), h = k.makeZerosTypedArray(d, "int32"), f = k.sizeFromShape(c), m = n.data.get(o.dataId).values;
        for (let g = 0; g < h.length; ++g) {
            let y = g * f, A = m[y], x = 0;
            for (let b = 0; b < f; ++b) {
                let v = m[y + b];
                v > A && (A = v, x = b);
            }
            h[g] = x;
        }
        return p.forEach(g => n.disposeIntermediateTensorInfo(g)), n.makeTensorInfo(u, "int32", h);
    }
}, aT = {
    kernelName: ul,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s
        } = a;
        Se(r, "argMin");
        let i = k.parseAxisParam(s, r.shape), l = C.getAxesPermutation(i, r.shape.length), o = r, p = [];
        l != null && (o = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: l
            }
        }), p.push(o), i = C.getInnerMostAxes(i.length, o.shape.length)), i = [ i[0] ], 
        C.assertAxesAreInnerMostDims("argMin", i, o.shape.length);
        let [ u, c ] = C.computeOutAndReduceShapes(o.shape, i), d = k.sizeFromShape(u), h = k.makeZerosTypedArray(d, "int32"), f = k.sizeFromShape(c), m = n.data.get(o.dataId).values;
        for (let g = 0; g < h.length; ++g) {
            let y = g * f, A = m[y], x = 0;
            for (let b = 0; b < f; ++b) {
                let v = m[y + b];
                v < A && (A = v, x = b);
            }
            h[g] = x;
        }
        return p.forEach(g => n.disposeIntermediateTensorInfo(g)), n.makeTensorInfo(u, "int32", h);
    }
}, rT = pt(ys, e => Math.asin(e)), sT = {
    kernelName: ys,
    backendName: "cpu",
    kernelFunc: rT
}, iT = pt(As, e => Math.asinh(e)), oT = {
    kernelName: As,
    backendName: "cpu",
    kernelFunc: iT
}, lT = pt(xs, e => Math.atan(e)), uT = {
    kernelName: xs,
    backendName: "cpu",
    kernelFunc: lT
}, dT = Ct((e, t) => Math.atan2(e, t)), pT = Lt(vs, dT), cT = {
    kernelName: vs,
    backendName: "cpu",
    kernelFunc: pT
}, hT = pt(bs, e => Math.atanh(e)), fT = {
    kernelName: bs,
    backendName: "cpu",
    kernelFunc: hT
};

function Hm(e, t, n, a, r, s) {
    let i = r.strideHeight, l = r.strideWidth, o = r.dilationHeight, p = r.dilationWidth, u = r.effectiveFilterHeight, c = r.effectiveFilterWidth, d = r.padInfo.top, h = r.padInfo.left, f = s === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, m = We(r.outShape, n), g = m.values, y = r.outShape[1] * r.outShape[2] * r.outShape[3], A = r.outShape[2] * r.outShape[3], x = r.outShape[3];
    for (let b = 0; b < r.batchSize; ++b) {
        let v = b * y, I = b * a[0];
        for (let N = 0; N < r.inChannels; ++N) for (let T = 0; T < r.outHeight; ++T) {
            let R = T * i - d, w = Math.max(0, R), E = Math.min(r.inHeight, u + R), $ = v + T * A;
            for (let M = 0; M < r.outWidth; ++M) {
                let F = M * l - h, P = Math.max(0, F), L = Math.min(r.inWidth, c + F), O = f, B = 0, G = 0;
                for (let W = w; W < E; W += o) {
                    let z = I + W * a[1];
                    for (let X = P; X < L; X += p) {
                        let q = e[z + X * a[2] + N];
                        s === "max" && q > O ? O = q : s === "avg" && (B += q, G++);
                    }
                    if (isNaN(O)) break;
                }
                g[$ + M * x + N] = s === "avg" ? B / G : O;
            }
        }
    }
    return m;
}

function S5(e, t, n, a, r = !1, s = !1) {
    let i = We(a.outShape, "int32"), l = a.strideHeight, o = a.strideWidth, p = a.dilationHeight, u = a.dilationWidth, c = a.effectiveFilterHeight, d = a.effectiveFilterWidth, h = a.padInfo.top, f = a.padInfo.left, m = We(t, n, e);
    for (let g = 0; g < a.batchSize; ++g) for (let y = 0; y < a.inChannels; ++y) for (let A = 0; A < a.outHeight; ++A) {
        let x = A * l - h, b = x;
        for (;b < 0; ) b += p;
        let v = Math.min(a.inHeight, c + x);
        for (let I = 0; I < a.outWidth; ++I) {
            let N = I * o - f, T = N;
            for (;T < 0; ) T += u;
            let R = Math.min(a.inWidth, d + N), w = Number.NEGATIVE_INFINITY, E = -1;
            for (let $ = b; $ < v; $ += p) {
                let M = $ - x;
                for (let F = T; F < R; F += u) {
                    let P = F - N, L = m.get(g, $, F, y);
                    L > w && (w = L, E = r ? s ? ((g * a.inHeight + $) * a.inWidth + F) * a.inChannels + y : ($ * a.inWidth + F) * a.inChannels + y : M * d + P);
                }
            }
            i.set(E, g, A, I, y);
        }
    }
    return i;
}

function N5(e, t, n, a, r, s) {
    let i = r.strideDepth, l = r.strideHeight, o = r.strideWidth, p = r.dilationDepth, u = r.dilationHeight, c = r.dilationWidth, d = r.effectiveFilterDepth, h = r.effectiveFilterHeight, f = r.effectiveFilterWidth, m = r.padInfo.front, g = r.padInfo.top, y = r.padInfo.left, A = s === "max" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, x = We(r.outShape, n), b = x.values, v = r.outShape[1] * r.outShape[2] * r.outShape[3] * r.outShape[4], I = r.outShape[2] * r.outShape[3] * r.outShape[4], N = r.outShape[3] * r.outShape[4], T = r.outShape[4];
    for (let R = 0; R < r.batchSize; ++R) {
        let w = R * v, E = R * a[0];
        for (let $ = 0; $ < r.inChannels; ++$) for (let M = 0; M < r.outDepth; ++M) {
            let F = M * i - m, P = F;
            for (;P < 0; ) P += p;
            let L = Math.min(r.inDepth, d + F), O = w + M * I;
            for (let B = 0; B < r.outHeight; ++B) {
                let G = B * l - g, W = G;
                for (;W < 0; ) W += u;
                let z = Math.min(r.inHeight, h + G), X = O + B * N;
                for (let q = 0; q < r.outWidth; ++q) {
                    let Z = q * o - y, Y = Z;
                    for (;Y < 0; ) Y += c;
                    let te = Math.min(r.inWidth, f + Z), re = X + q * T, pe = A, ge = 0, Re = 0;
                    for (let ye = P; ye < L; ye += p) {
                        let Me = E + ye * a[1];
                        for (let Ee = W; Ee < z; Ee += u) {
                            let me = Me + Ee * a[2];
                            for (let Oe = Y; Oe < te; Oe += c) {
                                let we = e[me + Oe * a[3] + $];
                                if (s === "max" && we > pe ? pe = we : s === "avg" && (ge += we, 
                                Re++), isNaN(pe)) break;
                            }
                            if (isNaN(pe)) break;
                        }
                        if (isNaN(pe)) break;
                    }
                    b[re + $] = s === "avg" ? ge / Math.max(Re, 1) : pe;
                }
            }
        }
    }
    return x;
}

var mT = {
    kernelName: ws,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t;
        Se(r, "avgPool");
        let {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o
        } = a;
        k.assert(C.eitherStridesOrDilationsAreOne(i, 1), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);
        let p, u = C.computePool2DInfo(r.shape, s, i, 1, l, o);
        if (u.filterWidth === 1 && u.filterHeight === 1 && k.arraysEqual(u.inShape, u.outShape)) p = La({
            inputs: {
                x: r
            },
            backend: n
        }); else {
            let c = n.data.get(r.dataId).values, d = k.computeStrides(r.shape), h = Hm(c, r.shape, r.dtype, d, u, "avg");
            p = n.makeTensorInfo(u.outShape, r.dtype, h.values);
        }
        return p;
    }
}, gT = {
    kernelName: dl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o,
            dataFormat: p
        } = a;
        Se(r, "avgPool3d");
        let u = C.computePool3DInfo(r.shape, s, i, 1, l, o, p), c = N5(n.data.get(r.dataId).values, r.shape, r.dtype, k.computeStrides(r.shape), u, "avg");
        return n.makeTensorInfo(c.shape, "float32", c.values);
    }
}, yT = {
    kernelName: ju,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = a;
        Se([ r, s ], "avgPool3DGrad");
        let u = C.computePool3DInfo(s.shape, i, l, 1, o, p), c = u.strideDepth, d = u.strideHeight, h = u.strideWidth, f = u.filterDepth, m = u.filterHeight, g = u.filterWidth, y = u.dilationDepth, A = u.dilationHeight, x = u.dilationWidth, b = u.effectiveFilterDepth, v = u.effectiveFilterHeight, I = u.effectiveFilterWidth, N = b - 1 - u.padInfo.front, T = I - 1 - u.padInfo.left, R = v - 1 - u.padInfo.top, w = We(s.shape, "float32"), E = 1 / (f * m * g), $ = n.bufferSync(r);
        for (let M = 0; M < u.batchSize; ++M) for (let F = 0; F < u.inChannels; ++F) for (let P = 0; P < u.inDepth; ++P) for (let L = 0; L < u.inHeight; ++L) for (let O = 0; O < u.inWidth; ++O) {
            let B = P - N, G = L - R, W = O - T, z = 0;
            for (let X = 0; X < b; X += y) {
                let q = (B + X) / c;
                if (!(q < 0 || q >= u.outDepth || Math.floor(q) !== q)) for (let Z = 0; Z < v; Z += A) {
                    let Y = (G + Z) / d;
                    if (!(Y < 0 || Y >= u.outHeight || Math.floor(Y) !== Y)) for (let te = 0; te < I; te += x) {
                        let re = (W + te) / h;
                        re < 0 || re >= u.outWidth || Math.floor(re) !== re || (z += $.get(M, q, Y, re, F));
                    }
                }
            }
            w.set(z * E, M, P, L, O, F);
        }
        return n.makeTensorInfo(w.shape, w.dtype, w.values);
    }
}, AT = {
    kernelName: Hu,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s;
        Se([ r, s ], "avgPoolGrad");
        let {
            filterSize: l,
            strides: o,
            pad: p
        } = a, u = C.computePool2DInfo(i.shape, l, o, 1, p), c = u.strideHeight, d = u.strideWidth, h = u.filterHeight, f = u.filterWidth, m = u.dilationHeight, g = u.dilationWidth, y = u.effectiveFilterHeight, A = u.effectiveFilterWidth, x = A - 1 - u.padInfo.left, b = y - 1 - u.padInfo.top, v = We(i.shape, "float32"), I = 1 / (h * f), N = n.data.get(r.dataId).values, T = We(r.shape, "float32", N);
        for (let R = 0; R < u.batchSize; ++R) for (let w = 0; w < u.inChannels; ++w) for (let E = 0; E < u.inHeight; ++E) for (let $ = 0; $ < u.inWidth; ++$) {
            let M = E - b, F = $ - x, P = 0;
            for (let L = 0; L < y; L += m) {
                let O = (M + L) / c;
                if (!(O < 0 || O >= u.outHeight || Math.floor(O) !== O)) for (let B = 0; B < A; B += g) {
                    let G = (F + B) / d;
                    G < 0 || G >= u.outWidth || Math.floor(G) !== G || (P += T.get(R, O, G, w));
                }
            }
            v.set(P * I, R, E, $, w);
        }
        return n.makeTensorInfo(v.shape, v.dtype, v.values);
    }
}, xT = {
    kernelName: Xs,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            scale: s,
            offset: i,
            mean: l,
            variance: o
        } = t;
        k.assert(l.shape.length === o.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), 
        k.assert(i == null || l.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), 
        k.assert(s == null || l.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks."), 
        Se([ r, l, o, s, i ], "batchNorm");
        let {
            varianceEpsilon: p
        } = a;
        p == null && (p = .001);
        let u = n.data.get(r.dataId).values, c = n.data.get(l.dataId).values, d = n.data.get(o.dataId).values, h = s ? n.data.get(s.dataId).values : new Float32Array([ 1 ]), f = i ? n.data.get(i.dataId).values : new Float32Array([ 0 ]), m = new Float32Array(u.length), g = f.length, y = h.length, A = d.length, x = c.length, b = 0, v = 0, I = 0, N = 0;
        for (let T = 0; T < u.length; ++T) m[T] = f[b++] + (u[T] - c[v++]) * h[I++] / Math.sqrt(d[N++] + p), 
        b >= g && (b = 0), v >= x && (v = 0), I >= y && (I = 0), N >= A && (N = 0);
        return n.makeTensorInfo(r.shape, r.dtype, m);
    }
}, bT = {
    kernelName: pl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            crops: i
        } = a;
        Se([ r ], "batchToSpaceND");
        let l = s.reduce((y, A) => y * A), o = C.getReshaped(r.shape, s, l), p = C.getPermuted(o.length, s.length), u = C.getReshapedPermuted(r.shape, s, l), c = C.getSliceBeginCoords(i, s.length), d = C.getSliceSize(u, i, s.length), h = At({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: o
            }
        }), f = kn({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), m = At({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: u
            }
        }), g = wo({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                begin: c,
                size: d
            }
        });
        return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), 
        n.disposeIntermediateTensorInfo(m), g;
    }
}, vT = {
    kernelName: Is,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = t, {
            size: i
        } = a, l = _m(n.data.get(r.dataId).values, n.data.get(s.dataId).values, s.dtype, s.shape, i);
        return n.makeTensorInfo([ i ], s.dtype, l);
    }
}, wT = {
    kernelName: hl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            s0: a,
            s1: r
        } = t, s = n.data.get(a.dataId).values, i = n.data.get(r.dataId).values, l = C.assertAndGetBroadcastShape(Array.from(s), Array.from(i));
        return n.makeTensorInfo([ l.length ], "int32", Int32Array.from(l));
    }
}, kT = pt(xr, (e, t) => {
    let n = t;
    return e > n.clipValueMax ? n.clipValueMax : e < n.clipValueMin ? n.clipValueMin : e;
}), IT = {
    kernelName: xr,
    backendName: "cpu",
    kernelFunc: kT
}, ST = {
    kernelName: Xu,
    backendName: "cpu",
    kernelFunc: e => {
        let {
            x: t
        } = e.inputs, n = e.backend, a = new Float32Array(k.sizeFromShape(t.shape)), r = n.data.get(t.dataId), s = r.complexTensorInfos.real, i = r.complexTensorInfos.imag, l = n.data.get(s.dataId).values, o = n.data.get(i.dataId).values;
        for (let p = 0; p < l.length; p++) {
            let u = l[p], c = o[p];
            a[p] = Math.hypot(u, c);
        }
        return n.makeOutput(a, t.shape, "float32");
    }
};

function ou(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        input: a
    } = t, r = n.data.get(a.dataId).complexTensorInfos.imag, s = n.data.get(r.dataId).values;
    return n.makeTensorInfo(r.shape, r.dtype, s);
}

var NT = {
    kernelName: nd,
    backendName: "cpu",
    kernelFunc: ou
};

function lu(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        axis: r
    } = a, s = k.parseAxisParam(r, t[0].shape)[0], i = t.map(m => m.shape);
    C.assertParamsConsistent(i, s);
    let l = C.computeOutShape(t.map(m => m.shape), s);
    if (k.sizeFromShape(l) === 0) return n.makeTensorInfo(l, t[0].dtype, []);
    let o = t.filter(m => k.sizeFromShape(m.shape) > 0);
    if (o.length === 1) return La({
        inputs: {
            x: o[0]
        },
        backend: n
    });
    if (o[0].dtype === "complex64") {
        let m = o.map(b => vo({
            inputs: {
                input: b
            },
            backend: n
        })), g = o.map(b => ou({
            inputs: {
                input: b
            },
            backend: n
        })), y = lu({
            inputs: m,
            backend: n,
            attrs: {
                axis: s
            }
        }), A = lu({
            inputs: g,
            backend: n,
            attrs: {
                axis: s
            }
        }), x = Gn({
            inputs: {
                real: y,
                imag: A
            },
            backend: n
        });
        return m.forEach(b => n.disposeIntermediateTensorInfo(b)), g.forEach(b => n.disposeIntermediateTensorInfo(b)), 
        n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(A), 
        x;
    }
    let p = o.map(m => {
        let g = [ -1, k.sizeFromShape(m.shape.slice(s)) ];
        return At({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                shape: g
            }
        });
    }), u = p.map(m => ({
        vals: n.data.get(m.dataId).values,
        shape: m.shape
    }));
    l = C.computeOutShape(p.map(m => m.shape), 1);
    let c = p[0].shape[0] === 1, d = Om(u, l, t[0].dtype, c), h = C.computeOutShape(o.map(m => m.shape), s), f = n.makeTensorInfo(h, t[0].dtype, d);
    return p.forEach(m => n.disposeIntermediateTensorInfo(m)), f;
}

var CT = {
    kernelName: fl,
    backendName: "cpu",
    kernelFunc: lu
};

function C5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r,
        filter: s
    } = t, {
        strides: i,
        pad: l,
        dataFormat: o,
        dilations: p,
        dimRoundingMode: u
    } = a;
    Se([ r, s ], "conv2d");
    let c = C.convertConv2DDataFormat(o), d = C.computeConv2DInfo(r.shape, s.shape, i, p, l, u, !1, c), h = d.filterHeight, f = d.filterWidth, m = d.dilationHeight, g = d.dilationWidth, y = d.padInfo.left, A = d.padInfo.top, x = d.dataFormat === "channelsLast", b = new $t(d.outShape, r.dtype), v = k.computeStrides(r.shape), I = k.computeStrides(s.shape), N = v[0], T = x ? v[1] : v[2], R = x ? v[2] : 1, w = x ? 1 : v[1], E = b.strides[0], $ = x ? b.strides[1] : b.strides[2], M = x ? b.strides[2] : 1, F = x ? 1 : b.strides[1], P = n.data.get(r.dataId).values, L = n.data.get(s.dataId).values, O = b.values;
    for (let B = 0; B < d.batchSize; ++B) {
        let G = B * N, W = B * E;
        for (let z = 0; z < d.outHeight; ++z) {
            let X = W + z * $, q = z * d.strideHeight - A;
            for (let Z = 0; Z < h; ++Z) {
                let Y = q + Z * m;
                if (Y < 0 || Y >= d.inHeight) continue;
                let te = Z * I[0], re = G + Y * T;
                for (let pe = 0; pe < d.outWidth; ++pe) {
                    let ge = X + pe * M, Re = pe * d.strideWidth - y;
                    for (let ye = 0; ye < f; ++ye) {
                        let Me = Re + ye * g;
                        if (Me < 0 || Me >= d.inWidth) continue;
                        let Ee = re + Me * R, me = te + ye * I[1];
                        for (let Oe = 0; Oe < d.inChannels; ++Oe) {
                            let we = P[Ee + Oe * w];
                            for (let Be = 0; Be < d.outChannels; ++Be) O[ge + Be * F] += we * L[me + Be];
                            me += d.outChannels;
                        }
                    }
                }
            }
        }
    }
    return n.makeTensorInfo(b.shape, b.dtype, O);
}

var TT = {
    kernelName: Cs,
    backendName: "cpu",
    kernelFunc: C5
}, RT = {
    kernelName: Ku,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p,
            filterShape: u
        } = a;
        Se([ r, s ], "conv2dBackpropFilter");
        let c = C.convertConv2DDataFormat(o), d = C.computeConv2DInfo(r.shape, u, i, 1, l, p, !1, c), {
            strideHeight: h,
            strideWidth: f,
            filterHeight: m,
            filterWidth: g
        } = d, y = d.dataFormat === "channelsLast", A = new $t(d.filterShape, "float32"), x = d.padInfo.left, b = d.padInfo.top, v = n.data.get(r.dataId).values, I = n.data.get(s.dataId).values, N = new $t(r.shape, r.dtype, v), T = new $t(s.shape, s.dtype, I);
        for (let R = 0; R < m; ++R) {
            let w = Math.max(0, Math.ceil((b - R) / h)), E = Math.min(d.outHeight, (d.inHeight + b - R) / h);
            for (let $ = 0; $ < g; ++$) {
                let M = Math.max(0, Math.ceil((x - $) / f)), F = Math.min(d.outWidth, (d.inWidth + x - $) / f);
                for (let P = 0; P < d.inChannels; ++P) for (let L = 0; L < d.outChannels; ++L) {
                    let O = 0;
                    for (let B = 0; B < d.batchSize; ++B) for (let G = w; G < E; ++G) {
                        let W = R + G * h - b;
                        for (let z = M; z < F; ++z) {
                            let X = $ + z * f - x;
                            O += y ? N.get(B, W, X, P) * T.get(B, G, z, L) : N.get(B, P, W, X) * T.get(B, L, G, z);
                        }
                    }
                    A.set(O, R, $, P, L);
                }
            }
        }
        return n.makeTensorInfo(A.shape, A.dtype, A.values);
    }
}, ET = {
    kernelName: Ts,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            inputShape: i,
            strides: l,
            pad: o,
            dataFormat: p,
            dimRoundingMode: u
        } = a;
        Se([ r, s ], "conv2dBackpropInput");
        let c = k.computeStrides(s.shape), d = k.computeStrides(r.shape), h = C.convertConv2DDataFormat(p), f = C.computeConv2DInfo(i, s.shape, l, 1, o, u, !1, h), m = new $t(f.inShape, "float32"), g = m.values, y = n.data.get(r.dataId).values, A = n.data.get(s.dataId).values, [ x, b, v ] = c, {
            batchSize: I,
            filterHeight: N,
            filterWidth: T,
            inChannels: R,
            inHeight: w,
            inWidth: E,
            outChannels: $,
            outHeight: M,
            outWidth: F,
            strideHeight: P,
            strideWidth: L
        } = f;
        h = f.dataFormat;
        let O = N - 1 - f.padInfo.top, B = T - 1 - f.padInfo.left, G = h === "channelsLast", W = m.strides[0], z = G ? m.strides[1] : m.strides[2], X = G ? m.strides[2] : 1, q = G ? 1 : m.strides[1], Z = d[0], Y = G ? d[1] : d[2], te = G ? d[2] : 1, re = G ? 1 : d[1];
        for (let pe = 0; pe < I; ++pe) for (let ge = 0; ge < R; ++ge) for (let Re = 0; Re < w; ++Re) {
            let ye = Re - O, Me = Math.max(0, Math.ceil(ye / P)), Ee = Math.min(M, (N + ye) / P);
            for (let me = 0; me < E; ++me) {
                let Oe = me - B, we = Math.max(0, Math.ceil(Oe / L)), Be = Math.min(F, (T + Oe) / L), nt = 0;
                for (let Ve = Me; Ve < Ee; ++Ve) {
                    let ue = Ve * P - ye;
                    for (let ct = we; ct < Be; ++ct) {
                        let nn = Z * pe + Y * Ve + te * ct, K = x * (N - 1 - ue) + b * (T - 1 - (ct * L - Oe)) + v * ge;
                        for (let ie = 0; ie < $; ++ie) nt += y[nn + re * ie] * A[K + ie];
                    }
                }
                g[W * pe + z * Re + X * me + q * ge] = nt;
            }
        }
        return n.makeTensorInfo(m.shape, m.dtype, m.values);
    }
}, $T = {
    kernelName: Rs,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o
        } = a;
        Se([ r, s ], "conv3d");
        let p = C.computeConv3DInfo(r.shape, s.shape, i, o, l), {
            filterDepth: u,
            filterHeight: c,
            filterWidth: d,
            dilationDepth: h,
            dilationHeight: f,
            dilationWidth: m,
            padInfo: g
        } = p, y = g.front, A = g.left, x = g.top, b = new $t(p.outShape, r.dtype), v = n.data.get(r.dataId).values, I = n.data.get(s.dataId).values, N = b.values, T = k.computeStrides(r.shape), R = k.computeStrides(s.shape);
        for (let w = 0; w < p.batchSize; ++w) {
            let E = w * T[0], $ = w * b.strides[0];
            for (let M = 0; M < p.outDepth; ++M) {
                let F = $ + M * b.strides[1], P = M * p.strideDepth - y;
                for (let L = 0; L < u; ++L) {
                    let O = P + L * h;
                    if (O < 0 || O >= p.inDepth) continue;
                    let B = L * R[0], G = E + O * T[1];
                    for (let W = 0; W < p.outHeight; ++W) {
                        let z = F + W * b.strides[2], X = W * p.strideHeight - x;
                        for (let q = 0; q < c; ++q) {
                            let Z = X + q * f;
                            if (Z < 0 || Z >= p.inHeight) continue;
                            let Y = B + q * R[1], te = G + Z * T[2];
                            for (let re = 0; re < p.outWidth; ++re) {
                                let pe = z + re * p.outChannels, ge = re * p.strideWidth - A;
                                for (let Re = 0; Re < d; ++Re) {
                                    let ye = ge + Re * m;
                                    if (ye < 0 || ye >= p.inWidth) continue;
                                    let Me = Y + Re * R[2], Ee = te + ye * p.inChannels, me = Me;
                                    for (let Oe = 0; Oe < p.inChannels; ++Oe) {
                                        let we = v[Ee + Oe];
                                        for (let Be = 0; Be < p.outChannels; ++Be) N[pe + Be] += we * I[me + Be];
                                        me += p.outChannels;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return n.makeTensorInfo(b.shape, b.dtype, b.values);
    }
}, MT = {
    kernelName: ml,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            filterShape: o
        } = a;
        Se([ r, s ], "conv3dBackpropFilterV2");
        let p = k.computeStrides(r.shape), u = k.computeStrides(s.shape), c = C.computeConv3DInfo(r.shape, o, i, 1, l), d = c.strideDepth, h = c.strideHeight, f = c.strideWidth, m = c.filterDepth, g = c.filterHeight, y = c.filterWidth, A = new $t(c.filterShape, "float32"), x = A.values, [ b, v, I, N ] = A.strides, T = n.data.get(s.dataId).values, [ R, w, E, $ ] = u, M = n.data.get(r.dataId).values, [ F, P, L, O ] = p, B = c.padInfo.front, G = c.padInfo.left, W = c.padInfo.top;
        for (let z = 0; z < m; ++z) {
            let X = Math.max(0, Math.ceil((B - z) / d)), q = Math.min(c.outDepth, (c.inDepth + B - z) / d), Z = z * b;
            for (let Y = 0; Y < g; ++Y) {
                let te = Math.max(0, Math.ceil((W - Y) / h)), re = Math.min(c.outHeight, (c.inHeight + W - Y) / h), pe = Y * v + Z;
                for (let ge = 0; ge < y; ++ge) {
                    let Re = Math.max(0, Math.ceil((G - ge) / f)), ye = Math.min(c.outWidth, (c.inWidth + G - ge) / f), Me = ge * I + pe;
                    for (let Ee = 0; Ee < c.inChannels; ++Ee) {
                        let me = Ee * N + Me;
                        for (let Oe = 0; Oe < c.outChannels; ++Oe) {
                            let we = 0;
                            for (let Be = 0; Be < c.batchSize; ++Be) {
                                let nt = Be * F, Ve = Be * R;
                                for (let ue = X; ue < q; ++ue) {
                                    let ct = (z + ue * d - B) * P + nt, nn = ue * w + Ve;
                                    for (let K = te; K < re; ++K) {
                                        let ie = (Y + K * h - W) * L + ct, Pe = K * E + nn;
                                        for (let Ge = Re; Ge < ye; ++Ge) {
                                            let De = Ge * $ + Pe;
                                            we += M[(ge + Ge * f - G) * O + ie + Ee] * T[De + Oe];
                                        }
                                    }
                                }
                            }
                            x[me + Oe] = we;
                        }
                    }
                }
            }
        }
        return n.makeTensorInfo(A.shape, A.dtype, A.values);
    }
}, FT = {
    kernelName: Es,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            pad: i,
            strides: l,
            inputShape: o
        } = a;
        Se([ r ], "conv3dBackpropInputV2");
        let p = k.computeStrides(r.shape), u = k.computeStrides(s.shape), c = C.computeConv3DInfo(o, s.shape, l, 1, i), d = new $t(c.inShape, "float32"), h = d.values, [ f, m, g, y ] = d.strides, A = n.data.get(r.dataId).values, [ x, b, v, I ] = p, N = n.data.get(s.dataId).values, [ T, R, w, E ] = u, {
            batchSize: $,
            filterDepth: M,
            filterHeight: F,
            filterWidth: P,
            inChannels: L,
            inDepth: O,
            inHeight: B,
            inWidth: G,
            outChannels: W,
            outDepth: z,
            outHeight: X,
            outWidth: q,
            strideDepth: Z,
            strideHeight: Y,
            strideWidth: te
        } = c, re = M - 1 - c.padInfo.front, pe = F - 1 - c.padInfo.top, ge = P - 1 - c.padInfo.left;
        for (let Re = 0; Re < $; ++Re) for (let ye = 0; ye < L; ++ye) for (let Me = 0; Me < O; ++Me) {
            let Ee = Me - re, me = Math.max(0, Math.ceil(Ee / Z)), Oe = Math.min(z, (M + Ee) / Z);
            for (let we = 0; we < B; ++we) {
                let Be = we - pe, nt = Math.max(0, Math.ceil(Be / Y)), Ve = Math.min(X, (F + Be) / Y);
                for (let ue = 0; ue < G; ++ue) {
                    let ct = ue - ge, nn = Math.max(0, Math.ceil(ct / te)), K = Math.min(q, (P + ct) / te), ie = 0;
                    for (let Pe = me; Pe < Oe; ++Pe) {
                        let Ge = Pe * Z - Ee;
                        for (let De = nt; De < Ve; ++De) {
                            let Xe = De * Y - Be;
                            for (let et = nn; et < K; ++et) {
                                let Ce = x * Re + b * Pe + v * De + I * et, mt = T * (M - 1 - Ge) + R * (F - 1 - Xe) + w * (P - 1 - (et * te - ct)) + E * ye;
                                for (let an = 0; an < W; ++an) ie += A[Ce + an] * N[mt + an];
                            }
                        }
                    }
                    h[f * Re + m * Me + g * we + y * ue + ye] = ie;
                }
            }
        }
        return n.makeTensorInfo(d.shape, d.dtype, d.values);
    }
}, _T = pt($s, e => Math.cos(e)), OT = {
    kernelName: $s,
    backendName: "cpu",
    kernelFunc: _T
}, PT = pt(Ms, e => Math.cosh(e)), DT = {
    kernelName: Ms,
    backendName: "cpu",
    kernelFunc: PT
}, zT = {
    kernelName: Os,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r,
            boxes: s,
            boxInd: i
        } = t, {
            cropSize: l,
            method: o,
            extrapolationValue: p
        } = a, [ u, c, d, h ] = r.shape, f = s.shape[0], [ m, g ] = l, y = We([ f, m, g, h ], "float32"), A = n.data.get(s.dataId).values, x = n.data.get(i.dataId).values, b = n.data.get(r.dataId).values, v = k.computeStrides(r.shape), I = k.computeStrides(y.shape);
        for (let N = 0; N < f; N++) {
            let T = 4 * N, R = A[T], w = A[T + 1], E = A[T + 2], $ = A[T + 3], M = x[N];
            if (M >= u) continue;
            let F = m > 1 ? (E - R) * (c - 1) / (m - 1) : 0, P = g > 1 ? ($ - w) * (d - 1) / (g - 1) : 0;
            for (let L = 0; L < m; L++) {
                let O = m > 1 ? R * (c - 1) + L * F : .5 * (R + E) * (c - 1);
                if (O < 0 || O > c - 1) for (let B = 0; B < g; B++) for (let G = 0; G < h; G++) {
                    let W = G + B * I[2] + L * I[1] + N * I[0];
                    y.values[W] = p;
                } else if (o === "bilinear") {
                    let B = Math.floor(O), G = Math.ceil(O), W = O - B;
                    for (let z = 0; z < g; z++) {
                        let X = g > 1 ? w * (d - 1) + z * P : .5 * (w + $) * (d - 1);
                        if (X < 0 || X > d - 1) {
                            for (let te = 0; te < h; te++) {
                                let re = te + z * I[2] + L * I[1] + N * I[0];
                                y.values[re] = p;
                            }
                            continue;
                        }
                        let q = Math.floor(X), Z = Math.ceil(X), Y = X - q;
                        for (let te = 0; te < h; te++) {
                            let re = te + q * v[2] + B * v[1] + M * v[0], pe = b[re];
                            re = te + Z * v[2] + B * v[1] + M * v[0];
                            let ge = b[re];
                            re = te + q * v[2] + G * v[1] + M * v[0];
                            let Re = b[re];
                            re = te + Z * v[2] + G * v[1] + M * v[0];
                            let ye = pe + (ge - pe) * Y, Me = Re + (b[re] - Re) * Y;
                            re = te + z * I[2] + L * I[1] + N * I[0], y.values[re] = ye + (Me - ye) * W;
                        }
                    }
                } else for (let B = 0; B < g; ++B) {
                    let G = g > 1 ? w * (d - 1) + B * P : .5 * (w + $) * (d - 1);
                    if (G < 0 || G > d - 1) {
                        for (let X = 0; X < h; X++) {
                            let q = X + B * I[2] + L * I[1] + N * I[0];
                            y.values[q] = p;
                        }
                        continue;
                    }
                    let W = Math.round(G), z = Math.round(O);
                    for (let X = 0; X < h; X++) {
                        let q = X + W * v[2] + z * v[1] + M * v[0], Z = X + B * I[2] + L * I[1] + N * I[0];
                        y.values[Z] = b[q];
                    }
                }
            }
        }
        return n.makeTensorInfo(y.shape, y.dtype, y.values);
    }
}, LT = {
    kernelName: Fs,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a;
        Se(r, "cumprod");
        let o = C.getAxesPermutation([ s ], r.shape.length), p = r;
        o != null && (p = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: o
            }
        }));
        let u = C.getInnerMostAxes(1, r.shape.length)[0];
        if (u !== p.shape.length - 1) throw new Error(`backend.cumprod in CPU expects an inner-most axis=${p.shape.length - 1} but got axis=${u}`);
        let c = Zt(p.dtype, "int32"), d = k.makeOnesTypedArray(k.sizeFromShape(p.shape), c), h = n.data.get(p.dataId).values, f = p.shape[p.shape.length - 1], m = l ? (y, A) => y + f - A - 1 : (y, A) => y + A;
        for (let y = 0; y < h.length; y += f) for (let A = 0; A < f; A++) {
            let x = m(y, A);
            if (A === 0) d[x] = i ? 1 : h[x]; else {
                let b = m(y, A - 1);
                d[x] = i ? h[b] * d[b] : h[x] * d[b];
            }
        }
        let g = n.makeTensorInfo(p.shape, c, d);
        if (o != null) {
            let y = kn({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    perm: C.getUndoAxesPermutation(o)
                }
            });
            return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(p), 
            y;
        }
        return g;
    }
}, WT = {
    kernelName: _s,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a;
        Se(r, "cumsum");
        let o = C.getAxesPermutation([ s ], r.shape.length), p = r;
        o != null && (p = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: o
            }
        }));
        let u = C.getInnerMostAxes(1, r.shape.length)[0];
        if (u !== p.shape.length - 1) throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length - 1} but got axis=${u}`);
        let c = Zt(p.dtype, "int32"), d = k.makeZerosTypedArray(k.sizeFromShape(p.shape), c), h = n.data.get(p.dataId).values, f = p.shape[p.shape.length - 1], m = l ? (y, A) => y + f - A - 1 : (y, A) => y + A;
        for (let y = 0; y < h.length; y += f) for (let A = 0; A < f; A++) {
            let x = m(y, A);
            if (A === 0) d[x] = i ? 0 : h[x]; else {
                let b = m(y, A - 1);
                d[x] = i ? h[b] + d[b] : h[x] + d[b];
            }
        }
        let g = n.makeTensorInfo(p.shape, c, d);
        if (o != null) {
            let y = kn({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    perm: C.getUndoAxesPermutation(o)
                }
            });
            return n.disposeIntermediateTensorInfo(g), n.disposeIntermediateTensorInfo(p), 
            y;
        }
        return g;
    }
}, BT = {
    kernelName: gl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = t, {
            size: i,
            binaryOutput: l
        } = a;
        if (r.shape.length === 1) {
            let o = _m(n.data.get(r.dataId).values, n.data.get(s.dataId).values, s.dtype, s.shape, i);
            return n.makeTensorInfo([ i ], s.dtype, o);
        }
        if (r.shape.length === 2) {
            let o = $x(n.bufferSync(r), n.bufferSync(s), i, l);
            return n.makeTensorInfo(o.shape, s.dtype, o.values);
        }
        throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`);
    }
}, VT = {
    kernelName: Ps,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockSize: s,
            dataFormat: i
        } = a;
        k.assert(i === "NHWC", () => `Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);
        let l = r.shape[0], o = r.shape[1], p = r.shape[2], u = r.shape[3], c = o * s, d = p * s, h = u / (s * s), f = n.data.get(r.dataId).values, m = new Float32Array(l * c * d * h), g = 0;
        for (let y = 0; y < l; ++y) for (let A = 0; A < c; ++A) {
            let x = Math.floor(A / s), b = A % s;
            for (let v = 0; v < d; ++v) {
                let I = Math.floor(v / s), N = (b * s + v % s) * h;
                for (let T = 0; T < h; ++T) {
                    let R = T + N + u * (I + p * (x + o * y));
                    m[g++] = f[R];
                }
            }
        }
        return n.makeTensorInfo([ l, c, d, h ], r.dtype, m);
    }
};

function T5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r,
        filter: s
    } = t, {
        strides: i,
        pad: l,
        dilations: o,
        dimRoundingMode: p
    } = a;
    Se([ r, s ], "depthwiseConv2DNative");
    let u = k.computeStrides(r.shape), c = k.computeStrides(s.shape), d = o;
    d == null && (d = [ 1, 1 ]), k.assert(C.eitherStridesOrDilationsAreOne(i, d), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);
    let h = C.computeConv2DInfo(r.shape, s.shape, i, d, l, p, !0), {
        filterHeight: f,
        filterWidth: m,
        dilationHeight: g,
        dilationWidth: y,
        padInfo: A
    } = h, x = A.left, b = A.top, v = h.outChannels / h.inChannels, I = new $t(h.outShape, r.dtype), N = n.data.get(r.dataId).values, T = n.data.get(s.dataId).values, R = I.values;
    for (let w = 0; w < h.batchSize; ++w) {
        let E = w * u[0], $ = w * I.strides[0];
        for (let M = 0; M < h.outHeight; ++M) {
            let F = $ + M * I.strides[1], P = M * h.strideHeight - b;
            for (let L = 0; L < f; ++L) {
                let O = P + L * g;
                if (O < 0 || O >= h.inHeight) continue;
                let B = L * c[0], G = E + O * u[1];
                for (let W = 0; W < h.outWidth; ++W) {
                    let z = F + W * I.strides[2], X = W * h.strideWidth - x;
                    for (let q = 0; q < m; ++q) {
                        let Z = X + q * y;
                        if (Z < 0 || Z >= h.inWidth) continue;
                        let Y = B + q * c[1], te = G + Z * h.inChannels, re = z, pe = Y;
                        for (let ge = 0; ge < h.inChannels; ++ge) {
                            let Re = N[te + ge];
                            for (let ye = 0; ye < v; ++ye) R[re + ye] += Re * T[pe + ye];
                            re += v, pe += v;
                        }
                    }
                }
            }
        }
    }
    return n.makeTensorInfo(I.shape, I.dtype, I.values);
}

var UT = {
    kernelName: Ds,
    backendName: "cpu",
    kernelFunc: T5
}, GT = {
    kernelName: Zu,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            dilations: l,
            pad: o,
            dimRoundingMode: p,
            filterShape: u
        } = a;
        Se([ r, s ], "depthwiseConv2dNativeBackpropFilter");
        let c = C.computeConv2DInfo(r.shape, u, i, l, o, p, !0), {
            strideHeight: d,
            strideWidth: h,
            filterHeight: f,
            filterWidth: m
        } = c, g = new $t(c.filterShape, "float32"), y = c.padInfo.left, A = c.padInfo.top, x = c.outChannels / c.inChannels, b = n.data.get(r.dataId).values, v = new $t(r.shape, r.dtype, b), I = n.data.get(s.dataId).values, N = new $t(s.shape, s.dtype, I);
        for (let T = 0; T < f; ++T) {
            let R = Math.max(0, Math.ceil((A - T) / d)), w = Math.min(c.outHeight, (c.inHeight + A - T) / d);
            for (let E = 0; E < m; ++E) {
                let $ = Math.max(0, Math.ceil((y - E) / h)), M = Math.min(c.outWidth, (c.inWidth + y - E) / h);
                for (let F = 0; F < c.outChannels; ++F) {
                    let P = Math.trunc(F / x), L = F % x, O = 0;
                    for (let B = 0; B < c.batchSize; ++B) for (let G = R; G < w; ++G) {
                        let W = T + G * d - A;
                        for (let z = $; z < M; ++z) {
                            let X = E + z * h - y;
                            O += v.get(B, W, X, P) * N.get(B, G, z, F);
                        }
                    }
                    g.set(O, T, E, P, L);
                }
            }
        }
        return n.makeTensorInfo(g.shape, g.dtype, g.values);
    }
}, HT = {
    kernelName: Yu,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            strides: i,
            dilations: l,
            pad: o,
            dimRoundingMode: p,
            inputShape: u
        } = a;
        Se([ r, s ], "depthwiseConv2DNativeBackpropInput");
        let c = k.computeStrides(r.shape), d = k.computeStrides(s.shape), h = C.computeConv2DInfo(u, s.shape, i, l, o, p, !0), f = new $t(h.inShape, "float32"), m = f.values, [ g, y, A ] = f.strides, x = n.data.get(r.dataId).values, [ b, v, I ] = c, N = n.data.get(s.dataId).values, [ T, R, w ] = d, {
            batchSize: E,
            filterHeight: $,
            filterWidth: M,
            inChannels: F,
            inHeight: P,
            inWidth: L,
            outChannels: O,
            outHeight: B,
            outWidth: G,
            strideHeight: W,
            strideWidth: z
        } = h, X = $ - 1 - h.padInfo.top, q = M - 1 - h.padInfo.left, Z = O / F;
        for (let Y = 0; Y < E; ++Y) for (let te = 0; te < F; ++te) for (let re = 0; re < P; ++re) {
            let pe = re - X, ge = Math.max(0, Math.ceil(pe / W)), Re = Math.min(B, ($ + pe) / W);
            for (let ye = 0; ye < L; ++ye) {
                let Me = ye - q, Ee = Math.max(0, Math.ceil(Me / z)), me = Math.min(G, (M + Me) / z), Oe = 0;
                for (let we = ge; we < Re; ++we) {
                    let Be = we * W - pe;
                    for (let nt = Ee; nt < me; ++nt) {
                        let Ve = b * Y + v * we + I * nt, ue = T * ($ - 1 - Be) + R * (M - 1 - (nt * z - Me)) + w * te;
                        for (let ct = 0; ct < Z; ++ct) Oe += x[Ve + (te * Z + ct)] * N[ue + ct];
                    }
                }
                m[g * Y + y * re + A * ye + te] = Oe;
            }
        }
        return n.makeTensorInfo(f.shape, f.dtype, f.values);
    }
}, jT = {
    kernelName: yl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t, r = k.sizeFromShape(a.shape), s = n.data.get(a.dataId).values, i = We([ r, r ], a.dtype), l = i.values;
        for (let p = 0; p < s.length; p++) l[p * r + p] = s[p];
        let o = [ ...a.shape, ...a.shape ];
        return n.makeTensorInfo(o, i.dtype, i.values);
    }
}, qT = {
    kernelName: zs,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        backend: t,
        attrs: n
    }) => {
        let {
            x: a,
            filter: r
        } = e, {
            strides: s,
            pad: i,
            dilations: l
        } = n, o = t, p = o.data.get(a.dataId).values, u = a.shape.length, c = o.data.get(r.dataId).values, d = r.shape.length, {
            batchSize: h,
            inHeight: f,
            inWidth: m,
            inChannels: g,
            outHeight: y,
            outWidth: A,
            padInfo: x,
            strideHeight: b,
            strideWidth: v,
            filterHeight: I,
            filterWidth: N,
            dilationHeight: T,
            dilationWidth: R,
            outShape: w
        } = C.computeDilation2DInfo(a.shape, r.shape, s, i, "NHWC", l), E = k.sizeFromShape(w), $ = w.length, M = k.getArrayFromDType(a.dtype, E);
        for (let F = 0; F < h; ++F) for (let P = 0; P < y; ++P) {
            let L = P * b - x.top;
            for (let O = 0; O < A; ++O) {
                let B = O * v - x.left;
                for (let G = 0; G < g; ++G) {
                    let W = Number.MIN_SAFE_INTEGER;
                    for (let z = 0; z < I; ++z) {
                        let X = L + z * T;
                        if (X >= 0 && X < f) for (let q = 0; q < N; ++q) {
                            let Z = B + q * R;
                            if (Z >= 0 && Z < m) {
                                let Y = k.locToIndex([ F, X, Z, G ], u, k.computeStrides(a.shape)), te = k.locToIndex([ z, q, G ], d, k.computeStrides(r.shape)), re = p[Y] + c[te];
                                re > W && (W = re);
                            }
                        }
                    }
                    M[k.locToIndex([ F, P, O, G ], $, k.computeStrides(w))] = W;
                }
            }
        }
        return {
            dataId: o.write(k.toTypedArray(M, a.dtype), w, a.dtype),
            shape: w,
            dtype: a.dtype
        };
    }
}, XT = {
    kernelName: xl,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        backend: t,
        attrs: n
    }) => {
        let {
            x: a,
            filter: r,
            dy: s
        } = e, {
            strides: i,
            pad: l,
            dilations: o
        } = n, p = t, u = k.toNestedArray(a.shape, p.data.get(a.dataId).values), c = k.toNestedArray(r.shape, p.data.get(r.dataId).values), {
            batchSize: d,
            inHeight: h,
            inWidth: f,
            inChannels: m,
            outHeight: g,
            outWidth: y,
            padInfo: A,
            strideHeight: x,
            strideWidth: b,
            filterHeight: v,
            filterWidth: I,
            dilationHeight: N,
            dilationWidth: T,
            outShape: R
        } = C.computeDilation2DInfo(a.shape, r.shape, i, l, "NHWC", o);
        k.assert(s.rank === R.length, () => `Error in ${xl}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);
        let w = k.toNestedArray(R, p.data.get(s.dataId).values), E = k.makeZerosNestedTypedArray(r.shape, r.dtype);
        for (let $ = 0; $ < d; ++$) for (let M = 0; M < g; ++M) {
            let F = M * x - A.top;
            for (let P = 0; P < y; ++P) {
                let L = P * b - A.left;
                for (let O = 0; O < m; ++O) {
                    let B = Number.MIN_SAFE_INTEGER, G = 0, W = 0;
                    for (let z = 0; z < v; ++z) {
                        let X = F + z * N;
                        if (X >= 0 && X < h) for (let q = 0; q < I; ++q) {
                            let Z = L + q * T;
                            if (Z >= 0 && Z < f) {
                                let Y = u[$][X][Z][O] + c[z][q][O];
                                Y > B && (B = Y, G = z, W = q);
                            }
                        }
                    }
                    E[G][W][O] += w[$][M][P][O];
                }
            }
        }
        return {
            dataId: p.write(k.toTypedArray(E, a.dtype), r.shape, r.dtype),
            shape: r.shape,
            dtype: r.dtype
        };
    }
}, KT = {
    kernelName: Al,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        backend: t,
        attrs: n
    }) => {
        let {
            x: a,
            filter: r,
            dy: s
        } = e, {
            strides: i,
            pad: l,
            dilations: o
        } = n, p = t, u = k.toNestedArray(a.shape, p.data.get(a.dataId).values), c = k.toNestedArray(r.shape, p.data.get(r.dataId).values), {
            batchSize: d,
            inHeight: h,
            inWidth: f,
            inChannels: m,
            outHeight: g,
            outWidth: y,
            padInfo: A,
            strideHeight: x,
            strideWidth: b,
            filterHeight: v,
            filterWidth: I,
            dilationHeight: N,
            dilationWidth: T,
            outShape: R
        } = C.computeDilation2DInfo(a.shape, r.shape, i, l, "NHWC", o);
        k.assert(s.rank === R.length, () => `Error in ${Al}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);
        let w = k.toNestedArray(R, p.data.get(s.dataId).values), E = k.makeZerosNestedTypedArray(a.shape, a.dtype);
        for (let $ = 0; $ < d; ++$) for (let M = 0; M < g; ++M) {
            let F = M * x - A.top;
            for (let P = 0; P < y; ++P) {
                let L = P * b - A.left;
                for (let O = 0; O < m; ++O) {
                    let B = Number.MIN_SAFE_INTEGER, G = F < 0 ? 0 : F, W = L < 0 ? 0 : L;
                    for (let z = 0; z < v; ++z) {
                        let X = F + z * N;
                        if (X >= 0 && X < h) for (let q = 0; q < I; ++q) {
                            let Z = L + q * T;
                            if (Z >= 0 && Z < f) {
                                let Y = u[$][X][Z][O] + c[z][q][O];
                                Y > B && (B = Y, G = X, W = Z);
                            }
                        }
                    }
                    E[$][G][W][O] += w[$][M][P][O];
                }
            }
        }
        return {
            dataId: p.write(k.toTypedArray(E, a.dtype), a.shape, a.dtype),
            shape: a.shape,
            dtype: a.dtype
        };
    }
}, ZT = {
    kernelName: Ju,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r
        } = t, {
            canvas: s,
            options: i
        } = a, {
            contextOptions: l,
            imageOptions: o
        } = i || {}, p = (o == null ? void 0 : o.alpha) || 1, u = (l == null ? void 0 : l.contextType) || "2d";
        if (u !== "2d") throw new Error(`Context type ${l.contextType} is not supported by the CPU backend.`);
        let c = s.getContext(u, (l == null ? void 0 : l.contextAttributes) || {});
        if (c == null) throw new Error(`Could not get the context with ${u} type.`);
        let [ d, h ] = r.shape.slice(0, 2), f = r.shape.length === 2 ? 1 : r.shape[2], m = n.data.get(r.dataId).values, g = r.dtype === "float32" ? 255 : 1, y = new Uint8ClampedArray(h * d * 4);
        for (let x = 0; x < d * h; ++x) {
            let b = [ 0, 0, 0, 255 * p ];
            for (let I = 0; I < f; I++) {
                let N = m[x * f + I];
                if (r.dtype === "float32") {
                    if (N < 0 || N > 1) throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${N}.`);
                } else if (r.dtype === "int32" && (N < 0 || N > 255)) throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${N}.`);
                f === 1 ? (b[0] = N * g, b[1] = N * g, b[2] = N * g) : b[I] = N * g;
            }
            let v = 4 * x;
            y[v + 0] = Math.round(b[0]), y[v + 1] = Math.round(b[1]), y[v + 2] = Math.round(b[2]), 
            y[v + 3] = Math.round(b[3]);
        }
        s.width = h, s.height = d;
        let A = new ImageData(y, h, d);
        return c.putImageData(A, 0, 0), r;
    }
};

function Gd(e) {
    let t, {
        inputs: n,
        backend: a,
        attrs: r
    } = e, {
        x: s
    } = n, {
        axis: i,
        keepDims: l
    } = r;
    Se(s, "sum"), t = s.dtype === "bool" ? Br({
        inputs: {
            x: s
        },
        backend: a,
        attrs: {
            dtype: "int32"
        }
    }) : La({
        inputs: {
            x: s
        },
        backend: a
    });
    let o = t.shape.length, p = k.parseAxisParam(i, t.shape), u = C.getAxesPermutation(p, o), c = p, d = t;
    u != null && (d = kn({
        inputs: {
            x: t
        },
        backend: a,
        attrs: {
            perm: u
        }
    }), c = C.getInnerMostAxes(c.length, o)), C.assertAxesAreInnerMostDims("sum", c, d.shape.length);
    let [ h, f ] = C.computeOutAndReduceShapes(d.shape, c), m = Nc(a, h, C.upcastType(d.dtype, "int32")), g = k.sizeFromShape(f), y = a.data.get(m.dataId).values, A = a.data.get(d.dataId).values;
    for (let x = 0; x < y.length; ++x) {
        let b = x * g, v = 0;
        for (let I = 0; I < g; ++I) v += A[b + I];
        y[x] = v;
    }
    if (l) {
        let x = m;
        m = At({
            inputs: {
                x: m
            },
            backend: a,
            attrs: {
                shape: C.expandShapeToKeepDim(m.shape, p)
            }
        }), a.disposeIntermediateTensorInfo(x);
    }
    return a.disposeIntermediateTensorInfo(t), u != null && a.disposeIntermediateTensorInfo(d), 
    m;
}

var YT = {
    kernelName: Xi,
    backendName: "cpu",
    kernelFunc: Gd
}, JT = {
    kernelName: Qu,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            equation: r
        } = a, s = t, {
            allDims: i,
            summedDims: l,
            idDims: o
        } = C.decodeEinsumEquation(r, s.length);
        C.checkEinsumDimSizes(i.length, o, s);
        let {
            path: p,
            steps: u
        } = C.getEinsumComputePath(l, o), c = u.length, d = null, h = i.length, f = [];
        for (let m = 0; m < c; ++m) {
            for (let g of u[m]) {
                let y, {
                    permutationIndices: A,
                    expandDims: x
                } = C.getEinsumPermutation(h, o[g]);
                C.isIdentityPermutation(A) ? y = s[g] : (y = kn({
                    inputs: {
                        x: s[g]
                    },
                    backend: n,
                    attrs: {
                        perm: A
                    }
                }), f.push(y));
                let b = y.shape.slice();
                for (let v = 0; v < x.length; ++v) b.splice(x[v], 0, 1);
                k.arraysEqual(y.shape, b) || (y = At({
                    inputs: {
                        x: y
                    },
                    backend: n,
                    attrs: {
                        shape: b
                    }
                }), f.push(y)), d === null ? d = y : (d = Cc({
                    inputs: {
                        a: y,
                        b: d
                    },
                    backend: n
                }), f.push(d));
            }
            m < c - 1 && (p[m] >= 0 && (d = Gd({
                inputs: {
                    x: d
                },
                backend: n,
                attrs: {
                    axis: p[m] - (i.length - h),
                    keepDims: !1
                }
            }), f.push(d)), h--);
        }
        for (let m of f) m !== d && n.disposeIntermediateTensorInfo(m);
        return d;
    }
}, QT = {
    kernelName: bl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            dy: a,
            y: r
        } = t;
        Se([ a, r ], "eluGrad");
        let s = new Float32Array(k.sizeFromShape(r.shape)), i = n.data.get(r.dataId).values, l = n.data.get(a.dataId).values;
        for (let o = 0; o < i.length; ++o) {
            let p = i[o];
            s[o] = p >= 0 ? l[o] : l[o] * (p + 1);
        }
        return n.makeTensorInfo(r.shape, "float32", s);
    }
}, eR = C.ERF_P, tR = C.ERF_A1, nR = C.ERF_A2, aR = C.ERF_A3, rR = C.ERF_A4, sR = C.ERF_A5, iR = pt(Bs, e => {
    let t = Math.sign(e), n = Math.abs(e), a = 1 / (1 + eR * n);
    return t * (1 - ((((sR * a + rR) * a + aR) * a + nR) * a + tR) * a * Math.exp(-n * n));
}), oR = {
    kernelName: Bs,
    backendName: "cpu",
    kernelFunc: iR
};

function Ec(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        input: r
    } = t, {
        dim: s
    } = a, i = r.shape.length, l = r.shape.slice(), o = s;
    return s < 0 && (k.assert(-(i + 1) <= s, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), 
    o = i + s + 1), l.splice(o, 0, 1), At({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            shape: l
        }
    });
}

var lR = {
    kernelName: vl,
    backendName: "cpu",
    kernelFunc: Ec
}, uR = Ct((e, t) => e / t), jm = Lt(Ls, uR), qm = {
    kernelName: Ls,
    backendName: "cpu",
    kernelFunc: jm
};

function R5(e, t, n) {
    let a = e.shape, r = a[0], s = a[1], i = n.data.get(e.dataId), l = i.complexTensorInfos.real, o = i.complexTensorInfos.imag, p = [ r, s ], u = k.sizeFromShape(p), c = k.getTypedArrayFromDType("float32", u), d = k.getTypedArrayFromDType("float32", u);
    for (let g = 0; g < r; g++) {
        let y = wo({
            inputs: {
                x: l
            },
            backend: n,
            attrs: {
                begin: [ g, 0 ],
                size: [ 1, s ]
            }
        }), A = wo({
            inputs: {
                x: o
            },
            backend: n,
            attrs: {
                begin: [ g, 0 ],
                size: [ 1, s ]
            }
        }), x = Gn({
            inputs: {
                real: y,
                imag: A
            },
            backend: n
        }), {
            real: b,
            imag: v
        } = dR(x, t, n), I = C.mergeRealAndImagArrays(b, v);
        for (let N = 0; N < s; N++) {
            let T = C.getComplexWithIndex(I, N);
            c[g * s + N] = T.real, d[g * s + N] = T.imag;
        }
        n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(A), 
        n.disposeIntermediateTensorInfo(x);
    }
    let h = n.makeTensorInfo(p, "float32", c), f = n.makeTensorInfo(p, "float32", d), m = Gn({
        inputs: {
            real: h,
            imag: f
        },
        backend: n
    });
    return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), 
    m;
}

function dR(e, t, n) {
    let a = k.sizeFromShape(e.shape), r = n.data.get(e.dataId), s = n.data.get(r.complexTensorInfos.real.dataId).values, i = n.data.get(r.complexTensorInfos.imag.dataId).values;
    if (function(l) {
        return !(l & l - 1);
    }(a)) {
        let l = Xm(s, i, a, t, n), o = [ e.shape[0], e.shape[1] ];
        if (t) {
            let p = n.makeTensorInfo(o, "float32", l.real), u = n.makeTensorInfo(o, "float32", l.imag), c = n.makeTensorInfo([], "float32", k.createScalarValue(a, "float32")), d = La({
                inputs: {
                    x: c
                },
                backend: n
            }), h = qm.kernelFunc({
                inputs: {
                    a: p,
                    b: c
                },
                backend: n
            }), f = qm.kernelFunc({
                inputs: {
                    a: u,
                    b: d
                },
                backend: n
            }), m = n.data.get(h.dataId).values, g = n.data.get(f.dataId).values;
            return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(u), 
            n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(d), 
            n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), 
            {
                real: m,
                imag: g
            };
        }
        return l;
    }
    {
        let l = function(o, p, u) {
            let c = new Float32Array(2 * p);
            for (let d = 0; d < p; d++) {
                let h = 0, f = 0;
                for (let m = 0; m < p; m++) {
                    let g = C.exponent(d * m, p, u), y = C.getComplexWithIndex(o, m);
                    h += y.real * g.real - y.imag * g.imag, f += y.real * g.imag + y.imag * g.real;
                }
                u && (h /= p, f /= p), C.assignToTypedArray(c, h, f, d);
            }
            return c;
        }(C.mergeRealAndImagArrays(s, i), a, t);
        return C.splitRealAndImagArrays(l);
    }
}

function Xm(e, t, n, a, r) {
    if (n === 1) return {
        real: e,
        imag: t
    };
    let s = C.mergeRealAndImagArrays(e, t), i = n / 2, l = C.complexWithEvenIndex(s), o = l.real, p = l.imag, u = [ o.length ], c = r.makeTensorInfo(u, "float32", o), d = r.makeTensorInfo(u, "float32", p), h = Gn({
        inputs: {
            real: c,
            imag: d
        },
        backend: r
    }), f = C.complexWithOddIndex(s), m = f.real, g = f.imag, y = [ m.length ], A = r.makeTensorInfo(y, "float32", m), x = r.makeTensorInfo(y, "float32", g), b = Gn({
        inputs: {
            real: A,
            imag: x
        },
        backend: r
    }), v = Xm(o, p, i, a, r), I = v.real, N = v.imag, T = [ I.length ], R = r.makeTensorInfo(T, "float32", I), w = r.makeTensorInfo(T, "float32", N), E = Gn({
        inputs: {
            real: R,
            imag: w
        },
        backend: r
    }), $ = Xm(m, g, i, a, r), M = $.real, F = $.imag, P = [ M.length ], L = r.makeTensorInfo(P, "float32", M), O = r.makeTensorInfo(P, "float32", F), B = Gn({
        inputs: {
            real: L,
            imag: O
        },
        backend: r
    }), G = C.exponents(n, a), W = [ G.real.length ], z = r.makeTensorInfo(W, "float32", G.real), X = r.makeTensorInfo(W, "float32", G.imag), q = Gn({
        inputs: {
            real: z,
            imag: X
        },
        backend: r
    }), Z = Cc({
        inputs: {
            a: q,
            b: B
        },
        backend: r
    }), Y = su({
        inputs: {
            a: E,
            b: Z
        },
        backend: r
    }), te = Um({
        inputs: {
            a: E,
            b: Z
        },
        backend: r
    }), re = vo({
        inputs: {
            input: Y
        },
        backend: r
    }), pe = vo({
        inputs: {
            input: te
        },
        backend: r
    }), ge = ou({
        inputs: {
            input: Y
        },
        backend: r
    }), Re = ou({
        inputs: {
            input: te
        },
        backend: r
    }), ye = lu({
        inputs: [ re, pe ],
        backend: r,
        attrs: {
            axis: 0
        }
    }), Me = lu({
        inputs: [ ge, Re ],
        backend: r,
        attrs: {
            axis: 0
        }
    }), Ee = r.data.get(ye.dataId).values, me = r.data.get(Me.dataId).values;
    return r.disposeIntermediateTensorInfo(c), r.disposeIntermediateTensorInfo(d), 
    r.disposeIntermediateTensorInfo(h), r.disposeIntermediateTensorInfo(A), r.disposeIntermediateTensorInfo(x), 
    r.disposeIntermediateTensorInfo(b), r.disposeIntermediateTensorInfo(R), r.disposeIntermediateTensorInfo(w), 
    r.disposeIntermediateTensorInfo(E), r.disposeIntermediateTensorInfo(L), r.disposeIntermediateTensorInfo(O), 
    r.disposeIntermediateTensorInfo(B), r.disposeIntermediateTensorInfo(z), r.disposeIntermediateTensorInfo(X), 
    r.disposeIntermediateTensorInfo(q), r.disposeIntermediateTensorInfo(Z), r.disposeIntermediateTensorInfo(Y), 
    r.disposeIntermediateTensorInfo(te), r.disposeIntermediateTensorInfo(re), r.disposeIntermediateTensorInfo(ge), 
    r.disposeIntermediateTensorInfo(pe), r.disposeIntermediateTensorInfo(Re), r.disposeIntermediateTensorInfo(ye), 
    r.disposeIntermediateTensorInfo(Me), {
        real: Ee,
        imag: me
    };
}

var pR = {
    kernelName: ed,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            input: a
        } = t, r = k.sizeFromShape(a.shape), s = a.shape[a.shape.length - 1], i = At({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: [ r / s, s ]
            }
        }), l = R5(i, !1, n), o = At({
            inputs: {
                x: l
            },
            backend: n,
            attrs: {
                shape: a.shape
            }
        });
        return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), 
        o;
    }
};

function Km(e) {
    let {
        backend: t,
        attrs: n
    } = e, {
        shape: a,
        value: r,
        dtype: s
    } = n, i = s || k.inferDtype(r), l = k.getArrayFromDType(i, k.sizeFromShape(a));
    return function(o, p, u) {
        o.fill(p);
    }(l, r), t.makeTensorInfo(a, i, l);
}

var cR = {
    kernelName: wl,
    backendName: "cpu",
    kernelFunc: Km
}, hR = {
    kernelName: Hs,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            image: a
        } = e, r = n, s = k.getTypedArrayFromDType(a.dtype, k.sizeFromShape(a.shape)), [ i, l, o, p ] = a.shape, u = r.data.get(a.dataId).values;
        for (let c = 0; c < i; c++) {
            let d = c * o * l * p;
            for (let h = 0; h < l; h++) {
                let f = h * (o * p);
                for (let m = 0; m < o; m++) {
                    let g = m * p;
                    for (let y = 0; y < p; y++) {
                        let A = Math.round(o - m - 1), x = d + f + g + y, b = u[x];
                        A >= 0 && A < o && (b = u[d + f + A * p + y]), s[x] = b;
                    }
                }
            }
        }
        return {
            dataId: r.write(s, a.shape, a.dtype),
            shape: a.shape,
            dtype: a.dtype
        };
    }
}, fR = {
    kernelName: kr,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dataFormat: u,
            dilations: c,
            dimRoundingMode: d,
            activation: h,
            leakyreluAlpha: f
        } = a, m = C5({
            inputs: {
                x: r,
                filter: s
            },
            backend: n,
            attrs: {
                strides: o,
                pad: p,
                dataFormat: u,
                dilations: c,
                dimRoundingMode: d
            }
        });
        if (i) {
            let g = m;
            if (u === "NCHW" && i.shape.length === 1 && i.shape[0] !== 1) {
                let y = At({
                    inputs: {
                        x: i
                    },
                    backend: n,
                    attrs: {
                        shape: [ i.shape[0], 1, 1 ]
                    }
                });
                m = su({
                    inputs: {
                        a: m,
                        b: y
                    },
                    backend: n
                }), n.disposeIntermediateTensorInfo(y);
            } else m = su({
                inputs: {
                    a: m,
                    b: i
                },
                backend: n
            });
            n.disposeIntermediateTensorInfo(g);
        }
        if (h) {
            let g = m;
            if (u === "NCHW" && h === "prelu" && l.shape.length === 1 && l.shape[0] !== 1) {
                let y = At({
                    inputs: {
                        x: l
                    },
                    backend: n,
                    attrs: {
                        shape: [ l.shape[0], 1, 1 ]
                    }
                });
                m = Rc(n, m, h, y, f), n.disposeIntermediateTensorInfo(y);
            } else m = Rc(n, m, h, l, f);
            n.disposeIntermediateTensorInfo(g);
        }
        return m;
    }
}, mR = {
    kernelName: Ir,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dataFormat: u,
            dilations: c,
            dimRoundingMode: d,
            activation: h,
            leakyreluAlpha: f
        } = a, m = T5({
            inputs: {
                x: r,
                filter: s
            },
            backend: n,
            attrs: {
                strides: o,
                pad: p,
                dataFormat: u,
                dilations: c,
                dimRoundingMode: d
            }
        });
        if (i) {
            let g = m;
            m = su({
                inputs: {
                    a: m,
                    b: i
                },
                backend: n
            }), n.disposeIntermediateTensorInfo(g);
        }
        if (h) {
            let g = m;
            m = Rc(n, m, h, l, f), n.disposeIntermediateTensorInfo(g);
        }
        return m;
    }
}, gR = {
    kernelName: Ks,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            params: a,
            indices: r
        } = t, s = k.sizeFromShape(a.shape), i = r.shape, l = i[i.length - 1], [ o, p, u, c ] = C.prepareAndValidate(a, r);
        if (p === 0) return n.makeTensorInfo(o, a.dtype, []);
        let d = Bx(n.data.get(r.dataId).values, n.bufferSync(a), a.dtype, p, l, u, c, a.shape, s);
        return n.makeTensorInfo(o, a.dtype, d.values);
    }
}, yR = {
    kernelName: kl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            indices: s
        } = t, {
            axis: i,
            batchDims: l
        } = a;
        Se([ r, s ], "gatherV2");
        let o = k.parseAxisParam(i, r.shape)[0], p = n.data.get(s.dataId).values, u = r.shape[o];
        for (let x = 0; x < p.length; ++x) {
            let b = p[x];
            k.assert(b <= u - 1 && b >= 0, () => `GatherV2: the index value ${b} is not in [0, ${u - 1}]`);
        }
        let c = l;
        l == null && (c = 0);
        let d = k.sizeFromShape(s.shape), h = C.segment_util.collectGatherOpShapeInfo(r, s, o, c), f = At({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ h.batchSize, h.outerSize, h.dimSize, h.sliceSize ]
            }
        }), m = At({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: [ h.batchSize, d / h.batchSize ]
            }
        }), g = [ h.batchSize, h.outerSize, d / h.batchSize, h.sliceSize ], y = n.bufferSync(m), A = Vx(n.bufferSync(f), y, g);
        return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), 
        n.makeTensorInfo(h.outputShape, A.dtype, A.values);
    }
}, AR = {
    kernelName: td,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            input: a
        } = t, r = k.sizeFromShape(a.shape), s = a.shape[a.shape.length - 1], i = At({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: [ r / s, s ]
            }
        }), l = R5(i, !0, n), o = At({
            inputs: {
                x: l
            },
            backend: n,
            attrs: {
                shape: a.shape
            }
        });
        return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), 
        o;
    }
}, xR = pt(Qs, e => Number.isFinite(e) ? 1 : 0, "bool"), bR = {
    kernelName: Qs,
    backendName: "cpu",
    kernelFunc: xR
}, vR = pt(ei, e => Math.abs(e) === 1 / 0 ? 1 : 0, "bool"), wR = {
    kernelName: ei,
    backendName: "cpu",
    kernelFunc: vR
}, kR = pt(ti, e => Number.isNaN(e) ? 1 : 0, "bool"), IR = {
    kernelName: ti,
    backendName: "cpu",
    kernelFunc: kR
}, SR = {
    kernelName: si,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            backend: t,
            attrs: n
        } = e, {
            start: a,
            stop: r,
            num: s
        } = n, i = qx(a, r, s);
        return t.makeTensorInfo([ i.length ], "float32", i);
    }
}, NR = pt(oi, e => Math.log1p(e)), CR = {
    kernelName: oi,
    backendName: "cpu",
    kernelFunc: NR
}, TR = Ct((e, t) => e && t), RR = Lt(li, TR, null, "bool"), ER = {
    kernelName: li,
    backendName: "cpu",
    kernelFunc: RR
}, $R = pt(ui, e => e ? 0 : 1, "bool"), MR = {
    kernelName: ui,
    backendName: "cpu",
    kernelFunc: $R
}, FR = Ct((e, t) => e || t), _R = Lt(di, FR, null, "bool"), OR = {
    kernelName: di,
    backendName: "cpu",
    kernelFunc: _R
}, PR = {
    kernelName: pi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            depthRadius: s,
            bias: i,
            alpha: l,
            beta: o
        } = a;
        Se(r, "LRN");
        let p = r.shape[3], u = p - 1, c = n.data.get(r.dataId).values, d = k.sizeFromShape(r.shape), h = new Float32Array(d);
        function f(m) {
            let g = m % p, y = m - g + Math.max(0, g - s), A = m - g + Math.min(g + s, u), x = 0;
            for (;y <= A; y++) {
                let b = c[y];
                x += b * b;
            }
            return x;
        }
        for (let m = 0; m < d; m++) {
            let g = f(m), y = c[m] * Math.pow(i + l * g, -o);
            h[m] = y;
        }
        return n.makeTensorInfo(r.shape, r.dtype, h);
    }
}, DR = {
    kernelName: Il,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            y: s,
            dy: i
        } = t, {
            depthRadius: l,
            bias: o,
            alpha: p,
            beta: u
        } = a;
        Se(i, "LRNGrad");
        let c = k.sizeFromShape(i.shape), d = i.shape[3], h = n.data.get(i.dataId).values, f = n.data.get(r.dataId).values, m = n.data.get(s.dataId).values, g = new Float32Array(c), y = c;
        for (let A = 0; A < y; A++) {
            let x = A % d, b = A - x + Math.max(0, x - l), v = A - x + Math.min(d, x + l + 1), I = 0;
            for (let N = b; N < v; N++) I += Math.pow(f[N], 2);
            I = p * I + o;
            for (let N = b; N < v; N++) {
                let T = -2 * p * u * f[N] * m[A] / I;
                A === N && (T += Math.pow(I, -u)), T *= h[A], g[N] += T;
            }
        }
        return n.makeTensorInfo(i.shape, r.dtype, g);
    }
};

function E5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        reductionIndices: s,
        keepDims: i
    } = a, l = n, o = r.shape, p = o.length, u = k.parseAxisParam(s, o), c = u, d = C.getAxesPermutation(c, p), h = l.data.get(r.dataId).values;
    if (d != null) {
        let x = new Array(p);
        for (let b = 0; b < x.length; b++) x[b] = o[d[b]];
        h = Dm(h, o, r.dtype, d, x), c = C.getInnerMostAxes(c.length, p), o = x;
    }
    Se(r, "max"), C.assertAxesAreInnerMostDims("max", c, p);
    let [ f, m ] = C.computeOutAndReduceShapes(o, c), g = Kx(h, k.sizeFromShape(m), f, r.dtype), y = l.write(g, f, r.dtype), A = f;
    return i && (A = C.expandShapeToKeepDim(f, u)), {
        dataId: y,
        shape: A,
        dtype: r.dtype
    };
}

var zR = {
    kernelName: ci,
    backendName: "cpu",
    kernelFunc: E5
}, LR = {
    kernelName: fi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t;
        Se(r, "maxPool");
        let {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o
        } = a;
        k.assert(C.eitherStridesOrDilationsAreOne(i, 1), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);
        let p, u = C.computePool2DInfo(r.shape, s, i, 1, l, o);
        if (u.filterWidth === 1 && u.filterHeight === 1 && k.arraysEqual(u.inShape, u.outShape)) p = La({
            inputs: {
                x: r
            },
            backend: n
        }); else {
            let c = n.data.get(r.dataId).values, d = k.computeStrides(r.shape), h = Hm(c, r.shape, r.dtype, d, u, "max");
            p = n.makeTensorInfo(u.outShape, r.dtype, h.values);
        }
        return p;
    }
}, WR = {
    kernelName: Sl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o,
            dataFormat: p
        } = a;
        Se(r, "maxPool3d");
        let u = C.computePool3DInfo(r.shape, s, i, 1, l, o, p), c = N5(n.data.get(r.dataId).values, r.shape, r.dtype, k.computeStrides(r.shape), u, "max");
        return n.makeTensorInfo(c.shape, "float32", c.values);
    }
}, BR = {
    kernelName: rd,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = a;
        Se([ r, s ], "maxPool3DGrad");
        let u = C.computePool3DInfo(s.shape, i, l, 1, o, p), c = function(w, E) {
            let $ = We(E.outShape, "int32"), M = E.strideDepth, F = E.strideHeight, P = E.strideWidth, L = E.dilationDepth, O = E.dilationHeight, B = E.dilationWidth, G = E.effectiveFilterDepth, W = E.effectiveFilterHeight, z = E.effectiveFilterWidth, X = E.padInfo.front, q = E.padInfo.top, Z = E.padInfo.left;
            for (let Y = 0; Y < E.batchSize; ++Y) for (let te = 0; te < E.inChannels; ++te) for (let re = 0; re < E.outDepth; ++re) {
                let pe = re * M - X, ge = pe;
                for (;ge < 0; ) ge += L;
                let Re = Math.min(E.inDepth, G + pe);
                for (let ye = 0; ye < E.outHeight; ++ye) {
                    let Me = ye * F - q, Ee = Me;
                    for (;Ee < 0; ) Ee += O;
                    let me = Math.min(E.inHeight, W + Me);
                    for (let Oe = 0; Oe < E.outWidth; ++Oe) {
                        let we = Oe * P - Z, Be = we;
                        for (;Be < 0; ) Be += B;
                        let nt = Math.min(E.inWidth, z + we), Ve = Number.NEGATIVE_INFINITY, ue = -1;
                        for (let ct = ge; ct < Re; ct += L) {
                            let nn = ct - pe;
                            for (let K = Ee; K < me; K += O) {
                                let ie = K - Me;
                                for (let Pe = Be; Pe < nt; Pe += B) {
                                    let Ge = Pe - we, De = w.get(Y, ct, K, Pe, te);
                                    De >= Ve && (Ve = De, ue = nn * W * z + ie * W + Ge);
                                }
                            }
                        }
                        $.set(ue, Y, re, ye, Oe, te);
                    }
                }
            }
            return $;
        }(n.bufferSync(s), u), d = u.strideDepth, h = u.strideHeight, f = u.strideWidth, m = u.dilationDepth, g = u.dilationHeight, y = u.dilationWidth, A = u.effectiveFilterDepth, x = u.effectiveFilterHeight, b = u.effectiveFilterWidth, v = A - 1 - u.padInfo.front, I = b - 1 - u.padInfo.left, N = x - 1 - u.padInfo.top, T = We(s.shape, "float32"), R = n.bufferSync(r);
        for (let w = 0; w < u.batchSize; ++w) for (let E = 0; E < u.inChannels; ++E) for (let $ = 0; $ < u.inDepth; ++$) for (let M = 0; M < u.inHeight; ++M) for (let F = 0; F < u.inWidth; ++F) {
            let P = $ - v, L = M - N, O = F - I, B = 0;
            for (let G = 0; G < A; G += m) {
                let W = (P + G) / d;
                if (!(W < 0 || W >= u.outDepth || Math.floor(W) !== W)) for (let z = 0; z < x; z += g) {
                    let X = (L + z) / h;
                    if (!(X < 0 || X >= u.outHeight || Math.floor(X) !== X)) for (let q = 0; q < b; q += y) {
                        let Z = (O + q) / f;
                        if (Z < 0 || Z >= u.outWidth || Math.floor(Z) !== Z) continue;
                        let Y = A * x * b - 1 - c.get(w, W, X, Z, E) === G * x * b + z * b + q ? 1 : 0;
                        Y !== 0 && (B += R.get(w, W, X, Z, E) * Y);
                    }
                }
            }
            T.set(B, w, $, M, F, E);
        }
        return n.makeTensorInfo(T.shape, T.dtype, T.values);
    }
}, VR = {
    kernelName: ad,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s,
            output: i
        } = t, l = s;
        Se([ s, i ], "maxPoolGrad");
        let {
            filterSize: o,
            strides: p,
            pad: u,
            dimRoundingMode: c
        } = a, d = C.computePool2DInfo(l.shape, o, p, 1, u, c), h = n.data.get(l.dataId).values, f = We(d.outShape, l.dtype, S5(h, l.shape, l.dtype, d).values), m = d.strideHeight, g = d.strideWidth, y = d.dilationHeight, A = d.dilationWidth, x = d.effectiveFilterHeight, b = d.effectiveFilterWidth, v = b - 1 - d.padInfo.left, I = x - 1 - d.padInfo.top, N = We(l.shape, "float32"), T = n.data.get(r.dataId).values, R = We(r.shape, "float32", T);
        for (let w = 0; w < d.batchSize; ++w) for (let E = 0; E < d.inChannels; ++E) for (let $ = 0; $ < d.inHeight; ++$) for (let M = 0; M < d.inWidth; ++M) {
            let F = $ - I, P = M - v, L = 0;
            for (let O = 0; O < x; O += y) {
                let B = (F + O) / m;
                if (!(B < 0 || B >= d.outHeight || Math.floor(B) !== B)) for (let G = 0; G < b; G += A) {
                    let W = (P + G) / g;
                    if (W < 0 || W >= d.outWidth || Math.floor(W) !== W) continue;
                    let z = x * b - 1 - f.get(w, B, W, E) === O * b + G ? 1 : 0;
                    z !== 0 && (L += R.get(w, B, W, E) * z);
                }
            }
            N.set(L, w, $, M, E);
        }
        return n.makeTensorInfo(N.shape, N.dtype, N.values);
    }
}, UR = {
    kernelName: Nl,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            x: a
        } = e, {
            filterSize: r,
            strides: s,
            pad: i,
            includeBatchInIndex: l
        } = t, o = n;
        Se(a, "MaxPoolWithArgmax");
        let p = o.data.get(a.dataId).values, u = C.computePool2DInfo(a.shape, r, s, [ 1, 1 ], i), [ c, d ] = function(m, g, y, A, x) {
            let b = Hm(m, 0, y, k.computeStrides(g), x, "max"), v = S5(m, g, y, x, !0, A);
            return [ b.values, v.values ];
        }(p, a.shape, a.dtype, l, u), h = o.write(c, u.outShape, a.dtype), f = o.write(d, u.outShape, a.dtype);
        return [ {
            dataId: h,
            shape: u.outShape,
            dtype: a.dtype
        }, {
            dataId: f,
            shape: u.outShape,
            dtype: "int32"
        } ];
    }
}, GR = {
    kernelName: mi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a, l = k.parseAxisParam(s, r.shape), o = C.computeOutAndReduceShapes(r.shape, l)[1], p = k.sizeFromShape(o), u = [], c = n.makeTensorInfo([], "float32", new Float32Array([ p ]));
        u.push(c);
        let d = Br({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                dtype: "float32"
            }
        });
        u.push(d);
        let h = jm({
            inputs: {
                a: d,
                b: c
            },
            backend: n
        });
        u.push(h);
        let f = Gd({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                axis: s,
                keepDims: i
            }
        });
        return u.forEach(m => n.disposeIntermediateTensorInfo(m)), f;
    }
}, HR = {
    kernelName: gi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a;
        Se(r, "min");
        let l = k.parseAxisParam(s, r.shape), o = l, p = C.getAxesPermutation(o, r.shape.length), u = r;
        p != null && (u = kn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), o = C.getInnerMostAxes(o.length, r.shape.length)), C.assertAxesAreInnerMostDims("min", o, u.shape.length);
        let [ c, d ] = C.computeOutAndReduceShapes(u.shape, o), h = k.sizeFromShape(d), f = k.makeZerosTypedArray(k.sizeFromShape(c), u.dtype), m = n.data.get(u.dataId).values;
        for (let y = 0; y < f.length; ++y) {
            let A = y * h, x = m[A];
            for (let b = 0; b < h; ++b) {
                let v = m[A + b];
                (Number.isNaN(v) || v < x) && (x = v);
            }
            f[y] = x;
        }
        p != null && n.disposeIntermediateTensorInfo(u);
        let g = n.makeTensorInfo(c, u.dtype, f);
        if (i) {
            let y = At({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    shape: C.expandShapeToKeepDim(c, l)
                }
            });
            return n.disposeIntermediateTensorInfo(g), y;
        }
        return g;
    }
}, jR = {
    kernelName: Ai,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            paddings: s,
            mode: i
        } = a;
        Se(r, "mirrorPad");
        let l = s.map((A, x) => A[0] + r.shape[x] + A[1]), o = s.map(A => A[0]), p = s.map((A, x) => A[0] + r.shape[x]), u = i === "reflect" ? 0 : 1, c = n.data.get(r.dataId).values, d = r.shape.length, h = k.computeStrides(r.shape), f = k.sizeFromShape(l), m = l.length, g = k.computeStrides(l), y = k.getTypedArrayFromDType(r.dtype, f);
        for (let A = 0; A < f; A++) {
            let x = k.indexToLoc(A, m, g);
            for (let v = 0; v < m; v++) x[v] < o[v] ? x[v] = 2 * o[v] - x[v] - u : x[v] >= p[v] && (x[v] = 2 * (p[v] - 1) - x[v] + u);
            x = x.map((v, I) => v - o[I]);
            let b = k.locToIndex(x, d, h);
            y[A] = c[b];
        }
        return {
            dataId: n.write(y, l, r.dtype),
            shape: l,
            dtype: r.dtype
        };
    }
}, qR = Ct((e, t) => {
    let n = e % t;
    return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t;
}), XR = Lt(xi, qR), KR = {
    kernelName: xi,
    backendName: "cpu",
    kernelFunc: XR
}, ZR = nl(J2());

function $5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        logits: r
    } = t, {
        dim: s
    } = a, i = r.shape.length, l = s;
    if (l === -1 && (l = i - 1), l !== i - 1) throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${l}`);
    let o = k.parseAxisParam([ l ], r.shape), p = E5({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            reductionIndices: o,
            keepDims: !1
        }
    }), u = C.expandShapeToKeepDim(p.shape, o), c = At({
        inputs: {
            x: p
        },
        backend: n,
        attrs: {
            shape: u
        }
    }), d = Um({
        inputs: {
            a: r,
            b: c
        },
        backend: n
    }), h = Dx({
        inputs: {
            x: d
        },
        backend: n
    }), f = Gd({
        inputs: {
            x: h
        },
        backend: n,
        attrs: {
            axis: o,
            keepDims: !1
        }
    }), m = At({
        inputs: {
            x: f
        },
        backend: n,
        attrs: {
            shape: u
        }
    }), g = jm({
        inputs: {
            a: h,
            b: m
        },
        backend: n
    });
    return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(c), 
    n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), 
    n.disposeIntermediateTensorInfo(m), g;
}

var YR = {
    kernelName: Ki,
    backendName: "cpu",
    kernelFunc: $5
}, JR = {
    kernelName: bi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            logits: r
        } = t, {
            numSamples: s,
            seed: i,
            normalized: l
        } = a;
        Se(r, "multinomial");
        let o = l ? r : $5({
            inputs: {
                logits: r
            },
            backend: n,
            attrs: {
                dim: -1
            }
        }), p = o.shape[0], u = o.shape[1], c = n.data.get(o.dataId).values, d = [ p, s ], h = k.makeZerosTypedArray(k.sizeFromShape(d), "int32");
        for (let f = 0; f < p; ++f) {
            let m = f * u, g = new Float32Array(u - 1);
            g[0] = c[m];
            for (let x = 1; x < g.length; ++x) g[x] = g[x - 1] + c[m + x];
            let y = ZR.alea(i.toString()), A = f * s;
            for (let x = 0; x < s; ++x) {
                let b = y();
                h[A + x] = g.length;
                for (let v = 0; v < g.length; v++) if (b < g[v]) {
                    h[A + x] = v;
                    break;
                }
            }
        }
        return l || n.disposeIntermediateTensorInfo(o), n.makeTensorInfo(d, "int32", h);
    }
}, QR = ua.nonMaxSuppressionV3Impl, eE = {
    kernelName: ki,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o
        } = a;
        Se(r, "NonMaxSuppression");
        let p = n.data.get(r.dataId).values, u = n.data.get(s.dataId).values, {
            selectedIndices: c
        } = QR(p, u, i, l, o);
        return n.makeTensorInfo([ c.length ], "int32", new Int32Array(c));
    }
}, tE = ua.nonMaxSuppressionV4Impl, nE = {
    kernelName: Tl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o,
            padToMaxOutputSize: p
        } = a;
        Se(r, "NonMaxSuppressionPadded");
        let u = n.data.get(r.dataId).values, c = n.data.get(s.dataId).values, {
            selectedIndices: d,
            validOutputs: h
        } = tE(u, c, i, l, o, p);
        return [ n.makeTensorInfo([ d.length ], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([ h ])) ];
    }
}, aE = ua.nonMaxSuppressionV5Impl, rE = {
    kernelName: Ii,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o,
            softNmsSigma: p
        } = a;
        Se(r, "NonMaxSuppressionWithScore");
        let u = n.data.get(r.dataId).values, c = n.data.get(s.dataId).values, d = i, h = l, f = o, m = p, {
            selectedIndices: g,
            selectedScores: y
        } = aE(u, c, d, h, f, m);
        return [ n.makeTensorInfo([ g.length ], "int32", new Int32Array(g)), n.makeTensorInfo([ y.length ], "float32", new Float32Array(y)) ];
    }
}, sE = {
    kernelName: Si,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r
        } = t, {
            dtype: s,
            depth: i,
            onValue: l,
            offValue: o
        } = a;
        Se(r, "oneHot");
        let p = k.sizeFromShape(r.shape), u = new Float32Array(p * i);
        u.fill(o);
        let c = n.data.get(r.dataId).values;
        for (let d = 0; d < p; ++d) c[d] >= 0 && c[d] < i && (u[d * i + c[d]] = l);
        return n.makeTensorInfo([ ...r.shape, i ], s, u);
    }
};

function $c(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        x: a
    } = t;
    if (a.dtype === "string") throw new Error("zerosLike is not supported for string tensors");
    if (a.dtype === "complex64") {
        let r = vo({
            inputs: {
                input: a
            },
            backend: n
        }), s = $c({
            inputs: {
                x: r
            },
            backend: n
        }), i = ou({
            inputs: {
                input: a
            },
            backend: n
        }), l = $c({
            inputs: {
                x: i
            },
            backend: n
        }), o = Gn({
            inputs: {
                real: s,
                imag: l
            },
            backend: n
        });
        return n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(s), 
        n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), 
        o;
    }
    return Km({
        backend: n,
        attrs: {
            shape: a.shape,
            value: 0,
            dtype: a.dtype
        }
    });
}

var iE = {
    kernelName: Gl,
    backendName: "cpu",
    kernelFunc: $c
}, oE = {
    kernelName: Rl,
    backendName: "cpu",
    kernelFunc: function e(t) {
        let {
            inputs: n,
            backend: a
        } = t, {
            x: r
        } = n;
        if (r.dtype === "string") throw new Error("onesLike is not supported for string tensors");
        if (r.dtype === "complex64") {
            let s = vo({
                inputs: {
                    input: r
                },
                backend: a
            }), i = e({
                inputs: {
                    x: s
                },
                backend: a
            }), l = ou({
                inputs: {
                    input: r
                },
                backend: a
            }), o = $c({
                inputs: {
                    x: l
                },
                backend: a
            }), p = Gn({
                inputs: {
                    real: i,
                    imag: o
                },
                backend: a
            });
            return a.disposeIntermediateTensorInfo(s), a.disposeIntermediateTensorInfo(i), 
            a.disposeIntermediateTensorInfo(l), a.disposeIntermediateTensorInfo(o), 
            p;
        }
        return Km({
            backend: a,
            attrs: {
                shape: r.shape,
                value: 1,
                dtype: r.dtype
            }
        });
    }
};

function M5(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        axis: r
    } = a;
    if (t.length === 1) return Ec({
        inputs: {
            input: t[0]
        },
        backend: n,
        attrs: {
            dim: r
        }
    });
    let s = t[0].shape, i = t[0].dtype;
    t.forEach(p => {
        k.assertShapesMatch(s, p.shape, "All tensors passed to stack must have matching shapes"), 
        k.assert(i === p.dtype, () => "All tensors passed to stack must have matching dtypes");
    });
    let l = [], o = lu({
        inputs: t.map(p => {
            let u = Ec({
                inputs: {
                    input: p
                },
                backend: n,
                attrs: {
                    dim: r
                }
            });
            return l.push(u), u;
        }),
        backend: n,
        attrs: {
            axis: r
        }
    });
    return l.forEach(p => n.disposeIntermediateTensorInfo(p)), o;
}

var lE = {
    kernelName: El,
    backendName: "cpu",
    kernelFunc: M5
}, F5 = {
    kernelName: Ni,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            paddings: s,
            constantValue: i
        } = a;
        Se(r, "pad");
        let l = s.map((y, A) => y[0] + r.shape[A] + y[1]), o = s.map(y => y[0]), p = n.data.get(r.dataId).values, u = k.sizeFromShape(r.shape), c = r.shape.length, d = k.computeStrides(r.shape), h = k.sizeFromShape(l), f = l.length, m = k.computeStrides(l), g = k.getTypedArrayFromDType(r.dtype, h);
        i !== 0 && g.fill(i);
        for (let y = 0; y < u; y++) {
            let A = k.indexToLoc(y, c, d).map((x, b) => x + o[b]);
            g[k.locToIndex(A, f, m)] = p[y];
        }
        return {
            dataId: n.write(g, l, r.dtype),
            shape: l,
            dtype: r.dtype
        };
    }
}, uE = Ct((e, t) => Math.pow(e, t)), dE = Lt(Ci, uE), pE = {
    kernelName: Ci,
    backendName: "cpu",
    kernelFunc: dE
}, cE = {
    kernelName: Bp,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            paramsNestedSplits: r,
            paramsDenseValues: s,
            indices: i
        } = t, l = r.map(g => n.data.get(g.dataId).values), o = r.map(g => g.shape), p = n.data.get(s.dataId).values, u = n.data.get(i.dataId).values, [ c, d, h ] = n5(l, o, p, s.shape, s.dtype, u, i.shape), f = c.map(g => n.makeTensorInfo([ g.length ], "int32", g)), m = n.makeTensorInfo(h, s.dtype, d);
        return f.concat([ m ]);
    }
}, hE = {
    kernelName: Vp,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            starts: a,
            limits: r,
            deltas: s
        } = t, i = n.data.get(a.dataId).values, l = n.data.get(r.dataId).values, o = n.data.get(s.dataId).values, [ p, u ] = r5(i, a.shape, a.dtype, l, r.shape, o, s.shape);
        return [ n.makeTensorInfo([ p.length ], "int32", p), n.makeTensorInfo([ u.length ], a.dtype, u) ];
    }
}, fE = {
    kernelName: Up,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            shape: r,
            values: s,
            defaultValue: i,
            rowPartitionTensors: l
        } = t, {
            rowPartitionTypes: o
        } = a, p = n.data.get(r.dataId).values, u = n.data.get(s.dataId).values, c = n.data.get(i.dataId).values, d = l.map(g => n.data.get(g.dataId).values), h = l.map(g => g.shape), [ f, m ] = o5(p, r.shape, u, s.shape, s.dtype, c, i.shape, d, h, o);
        return n.makeTensorInfo(f, s.dtype, m);
    }
}, mE = {
    kernelName: $l,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            backend: t,
            attrs: n
        } = e, {
            start: a,
            stop: r,
            dtype: s,
            step: i
        } = n, l = zm(a, r, i, s);
        return t.makeTensorInfo([ l.length ], s, l);
    }
}, gE = pt(Ei, e => 1 / e), yE = {
    kernelName: Ei,
    backendName: "cpu",
    kernelFunc: gE
}, AE = {
    kernelName: Fi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r
        } = t, {
            alignCorners: s,
            halfPixelCenters: i,
            size: l
        } = a;
        Se(r, "resizeBilinear");
        let o = k.computeStrides(r.shape), [ p, u ] = l, [ c, d, h, f ] = r.shape, m = n.data.get(r.dataId).values, g = new Float32Array(k.sizeFromShape([ c, p, u, f ])), y = [ s && p > 1 ? d - 1 : d, s && u > 1 ? h - 1 : h ], A = [ s && p > 1 ? p - 1 : p, s && u > 1 ? u - 1 : u ], x = 0, b = y[0] / A[0], v = y[1] / A[1];
        for (let I = 0; I < c; I++) for (let N = 0; N < p; N++) {
            let T;
            T = i ? b * (N + .5) - .5 : b * N;
            let R = Math.max(0, Math.floor(T)), w = T - R, E = Math.min(d - 1, Math.ceil(T)), $ = I * o[0] + R * o[1], M = I * o[0] + E * o[1];
            for (let F = 0; F < u; F++) {
                let P;
                P = i ? v * (F + .5) - .5 : v * F;
                let L = Math.max(0, Math.floor(P)), O = P - L, B = Math.min(h - 1, Math.ceil(P)), G = $ + L * o[2], W = M + L * o[2], z = $ + B * o[2], X = M + B * o[2];
                for (let q = 0; q < f; q++) {
                    let Z = m[G + q], Y = m[W + q], te = Z + (m[z + q] - Z) * O, re = te + (Y + (m[X + q] - Y) * O - te) * w;
                    g[x++] = re;
                }
            }
        }
        return n.makeTensorInfo([ c, p, u, f ], "float32", g);
    }
}, xE = {
    kernelName: _l,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r,
            dy: s
        } = t, {
            alignCorners: i
        } = a;
        Se([ s, r ], "resizeBilinearGrad");
        let l = k.computeStrides(r.shape), [ o, p, u, c ] = r.shape, [ , d, h ] = s.shape, f = new Float32Array(o * p * u * c), m = [ i && d > 1 ? p - 1 : p, i && h > 1 ? u - 1 : u ], g = [ i && d > 1 ? d - 1 : d, i && h > 1 ? h - 1 : h ], y = m[0] / g[0], A = m[1] / g[1], x = n.data.get(s.dataId).values, b = 0;
        for (let v = 0; v < o; v++) {
            let I = v * l[0];
            for (let N = 0; N < d; N++) {
                let T = N * y, R = Math.floor(T), w = Math.min(Math.ceil(T), p - 1), E = I + R * l[1], $ = I + w * l[1], M = T - R, F = 1 - M;
                for (let P = 0; P < h; P++) {
                    let L = P * A, O = Math.floor(L), B = Math.min(Math.ceil(L), u - 1), G = L - O, W = 1 - G, z = E + O * l[2], X = E + B * l[2], q = $ + O * l[2], Z = $ + B * l[2], Y = F * W, te = F * G, re = M * W, pe = M * G;
                    for (let ge = 0; ge < c; ge++) {
                        let Re = x[b++];
                        f[z + ge] += Re * Y, f[X + ge] += Re * te, f[q + ge] += Re * re, 
                        f[Z + ge] += Re * pe;
                    }
                }
            }
        }
        return n.makeTensorInfo([ o, u, p, c ], "float32", f);
    }
}, bE = {
    kernelName: Mi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r
        } = t, {
            alignCorners: s,
            halfPixelCenters: i,
            size: l
        } = a;
        Se(r, "resizeNearestNeighbor");
        let o = k.computeStrides(r.shape), [ p, u ] = l, [ c, d, h, f ] = r.shape, m = n.data.get(r.dataId).values, g = new Float32Array(c * p * u * f), y = [ s && p > 1 ? d - 1 : d, s && u > 1 ? h - 1 : h ], A = [ s && p > 1 ? p - 1 : p, s && u > 1 ? u - 1 : u ], x = y[0] / A[0], b = y[1] / A[1], v = 0;
        for (let I = 0; I < c; I++) {
            let N = I * o[0];
            for (let T = 0; T < p; T++) {
                let R = i ? x * (T + .5) : x * T, w = Math.min(d - 1, s ? Math.round(R) : Math.floor(R));
                i && (w = Math.max(0, w));
                let E = N + w * o[1];
                for (let $ = 0; $ < u; $++) {
                    let M = i ? b * ($ + .5) : b * $, F = Math.min(h - 1, s ? Math.round(M) : Math.floor(M));
                    i && (F = Math.max(0, F));
                    let P = E + F * o[2];
                    for (let L = 0; L < f; L++) {
                        let O = m[P + L];
                        g[v++] = O;
                    }
                }
            }
        }
        return n.makeTensorInfo([ c, p, u, f ], r.dtype, g);
    }
}, vE = {
    kernelName: Fl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r,
            dy: s
        } = t, {
            alignCorners: i
        } = a;
        Se([ s, r ], "resizeNearestNeighborGrad");
        let l = k.computeStrides(r.shape), o = k.computeStrides(s.shape), [ p, u, c, d ] = r.shape, [ , h, f ] = s.shape, m = new Float32Array(p * u * c * d), g = n.data.get(s.dataId).values, y = [ i && h > 1 ? u - 1 : u, i && f > 1 ? c - 1 : c ], A = [ i && h > 1 ? h - 1 : h, i && f > 1 ? f - 1 : f ], x = y[0] / A[0], b = y[1] / A[1], v = 1 / x, I = 1 / b, N = 2 * Math.ceil(v) + 2, T = 2 * Math.ceil(I) + 2;
        for (let R = 0; R < p; R++) {
            let w = R * l[0];
            for (let E = 0; E < u; E++) {
                let $ = w + E * l[1], M = Math.floor(E * v), F = Math.floor(M - N / 2);
                for (let P = 0; P < c; P++) {
                    let L = $ + P * l[2], O = Math.floor(P * I), B = Math.floor(O - T / 2);
                    for (let G = 0; G < d; G++) {
                        let W = 0;
                        for (let z = 0; z < N; z++) {
                            let X = z + F;
                            if (X < 0 || X >= h) continue;
                            let q = w + X * o[1], Z = X * x;
                            if (E === Math.min(u - 1, i ? Math.round(Z) : Math.floor(Z))) for (let Y = 0; Y < T; Y++) {
                                let te = Y + B;
                                if (te < 0 || te >= f) continue;
                                let re = q + te * o[2], pe = te * b;
                                P === Math.min(c - 1, i ? Math.round(pe) : Math.floor(pe)) && (W += g[re + G]);
                            }
                        }
                        m[L + G] = W;
                    }
                }
            }
        }
        return n.makeTensorInfo(r.shape, r.dtype, m);
    }
}, wE = {
    kernelName: Oi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            dims: s
        } = a;
        Se(r, "reverse");
        let i = r.shape.length, l = k.parseAxisParam(s, r.shape);
        if (i === 0) return La({
            inputs: {
                x: r
            },
            backend: n
        });
        let o = new $t(r.shape, r.dtype), p = n.bufferSync(r);
        for (let u = 0; u < o.size; u++) {
            let c = o.indexToLoc(u), d = c.slice();
            l.forEach(h => d[h] = r.shape[h] - 1 - d[h]), o.set(p.get(...d), ...c);
        }
        return n.makeTensorInfo(o.shape, o.dtype, o.values);
    }
}, kE = {
    kernelName: ro,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            image: a
        } = e, {
            radians: r,
            fillValue: s,
            center: i
        } = t, l = n, o = k.getTypedArrayFromDType(a.dtype, k.sizeFromShape(a.shape)), [ p, u, c, d ] = a.shape, [ h, f ] = C.getImageCenter(i, u, c), m = Math.sin(r), g = Math.cos(r), y = l.data.get(a.dataId).values;
        for (let A = 0; A < p; A++) {
            let x = A * c * u * d;
            for (let b = 0; b < u; b++) {
                let v = b * (c * d);
                for (let I = 0; I < c; I++) {
                    let N = I * d;
                    for (let T = 0; T < d; T++) {
                        let R = [ p, b, I, T ], w = R[2], E = R[1], $ = (w - h) * g - (E - f) * m, M = (w - h) * m + (E - f) * g;
                        $ = Math.round($ + h), M = Math.round(M + f);
                        let F = s;
                        typeof s != "number" && (F = T === 3 ? 255 : s[T]), $ >= 0 && $ < c && M >= 0 && M < u && (F = y[x + M * (c * d) + $ * d + T]), 
                        o[x + v + N + T] = F;
                    }
                }
            }
        }
        return {
            dataId: l.write(o, a.shape, a.dtype),
            shape: a.shape,
            dtype: a.dtype
        };
    }
}, IE = pt(Pi, e => {
    let t = Math.floor(e);
    return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1;
}), SE = {
    kernelName: Pi,
    backendName: "cpu",
    kernelFunc: IE
}, NE = {
    kernelName: zi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r,
            updates: s
        } = t, {
            shape: i
        } = a, {
            sliceRank: l,
            numUpdates: o,
            sliceSize: p,
            strides: u,
            outputSize: c
        } = C.calculateShapes(s, r, i), d = iu(n.bufferSync(r), n.bufferSync(s), i, c, p, o, l, u, 0, !0);
        return n.makeTensorInfo(i, d.dtype, d.values);
    }
};

function CE(e, t) {
    let n = 0, a = e.length, r = 0;
    for (;n < a; ) r = Math.floor((n + a) / 2), e[r] < t ? n = r + 1 : a = r;
    return a;
}

function TE(e, t) {
    let n = 0, a = e.length, r = 0;
    for (;n < a; ) r = Math.floor((n + a) / 2), e[r] <= t ? n = r + 1 : a = r;
    return a;
}

var RE = {
    kernelName: Wi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            sortedSequence: r,
            values: s
        } = t, {
            side: i
        } = a, l = function(o, p, u, c, d, h) {
            let f = k.getArrayFromDType("int32", u * d);
            for (let m = 0; m < u; ++m) {
                let g = o.slice(m * c, (m + 1) * c), y = m * d;
                for (let A = 0; A < d; ++A) f[y + A] = h === "left" ? CE(g, p[A + y]) : TE(g, p[A + y]);
            }
            return f;
        }(n.data.get(r.dataId).values, n.data.get(s.dataId).values, r.shape[0], r.shape[1], s.shape[1], i);
        return n.makeTensorInfo(s.shape, "int32", l);
    }
}, EE = {
    kernelName: Ol,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            condition: a,
            t: r,
            e: s
        } = t;
        Se([ a, r, s ], "select");
        let i = a.shape.length, l = n.data.get(a.dataId).values, o = n.data.get(r.dataId).values, p = n.data.get(s.dataId).values, u = Zt(r.dtype, s.dtype), c = k.makeZerosTypedArray(k.sizeFromShape(r.shape), u), d = 0, h = i === 0 || i > 1 || r.shape.length === 1 ? 1 : k.sizeFromShape(r.shape.slice(1));
        for (let f = 0; f < l.length; f++) for (let m = 0; m < h; m++) l[f] === 1 ? c[d++] = o[f] : c[d++] = p[f];
        return n.makeTensorInfo(r.shape, u, c);
    }
}, $E = C.SELU_SCALEALPHA, ME = C.SELU_SCALE, FE = pt(Bi, e => e >= 0 ? ME * e : $E * (Math.exp(e) - 1)), _E = {
    kernelName: Bi,
    backendName: "cpu",
    kernelFunc: FE
}, OE = pt(Gi, e => e < 0 ? -1 : e > 0 ? 1 : 0), PE = {
    kernelName: Gi,
    backendName: "cpu",
    kernelFunc: OE
}, DE = pt(Vi, e => Math.sin(e)), zE = {
    kernelName: Vi,
    backendName: "cpu",
    kernelFunc: DE
}, LE = pt(Ui, e => Math.sinh(e)), WE = {
    kernelName: Ui,
    backendName: "cpu",
    kernelFunc: LE
}, _5 = Math.log(1.1920928955078125e-7) + 2, BE = pt(ji, e => {
    let t, n = e > -_5, a = e < _5, r = Math.exp(e);
    return t = a ? r : n ? e : Math.log(1 + r), t;
}), VE = {
    kernelName: ji,
    backendName: "cpu",
    kernelFunc: BE
}, UE = {
    kernelName: Dl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            paddings: i
        } = a;
        Se([ r ], "spaceToBatchND");
        let l = k.sizeFromShape(s), o = [ [ 0, 0 ] ];
        o.push(...i);
        for (let g = 1 + s.length; g < r.shape.length; ++g) o.push([ 0, 0 ]);
        let p = F5.kernelFunc({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                paddings: o,
                constantValue: 0
            }
        }), u = C.getReshaped(p.shape, s, l, !1), c = C.getPermuted(u.length, s.length, !1), d = C.getReshapedPermuted(p.shape, s, l, !1), h = At({
            inputs: {
                x: p
            },
            backend: n,
            attrs: {
                shape: u
            }
        }), f = kn({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                perm: c
            }
        }), m = At({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: d
            }
        });
        return n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(h), 
        n.disposeIntermediateTensorInfo(f), m;
    }
}, GE = {
    kernelName: id,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            indices: a,
            values: r,
            denseShape: s,
            defaultValue: i
        } = t;
        if (s.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);
        if (a.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
        ${a.shape}`);
        if (r.shape.length !== 1) throw new Error(`Values must be a vector, saw:
        ${r.shape}`);
        if (i.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);
        let l = n.data.get(a.dataId).values, o = n.data.get(r.dataId).values, p = n.data.get(s.dataId).values, u = n.data.get(i.dataId).values[0], [ c, d, h, f, m ] = d5(l, a.shape, a.dtype, o, r.dtype, p, u);
        return [ n.makeTensorInfo(d, a.dtype, c), n.makeTensorInfo([ d[0] ], r.dtype, h), n.makeTensorInfo([ f.length ], "bool", new Uint8Array(f.map(g => Number(g)))), n.makeTensorInfo([ m.length ], a.dtype, new Int32Array(m)) ];
    }
}, HE = {
    kernelName: Ll,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            inputIndices: a,
            inputShape: r,
            newShape: s
        } = t;
        if (a.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);
        if (r.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
        let i = Array.from(n.data.get(r.dataId).values), l = n.data.get(a.dataId).values, o = Array.from(n.data.get(s.dataId).values), [ p, u, c ] = p5(l, a.shape, a.dtype, i, o);
        return [ n.makeTensorInfo(u, a.dtype, p), n.makeTensorInfo([ c.length ], s.dtype, new Int32Array(c)) ];
    }
}, jE = {
    kernelName: Wl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            data: a,
            indices: r,
            segmentIds: s
        } = t;
        if (a.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (r.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);
        if (r.shape[0] !== s.shape[0]) throw new Error("segmentIds and indices should have same size.");
        let i = n.data.get(a.dataId).values, l = n.data.get(r.dataId).values, o = n.data.get(s.dataId).values, [ p, u ] = Lm(i, a.shape, a.dtype, l, o, !0);
        return n.makeTensorInfo(u, a.dtype, p);
    }
}, qE = {
    kernelName: Bl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            data: a,
            indices: r,
            segmentIds: s
        } = t;
        if (a.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (r.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);
        if (r.shape[0] !== s.shape[0]) throw new Error("segmentIds and indices should have same size.");
        let i = n.data.get(a.dataId).values, l = n.data.get(r.dataId).values, o = n.data.get(s.dataId).values, [ p, u ] = Lm(i, a.shape, a.dtype, l, o);
        return n.makeTensorInfo(u, a.dtype, p);
    }
}, XE = {
    kernelName: Zi,
    backendName: "cpu",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            sparseIndices: s,
            sparseValues: i,
            defaultValue: l
        } = n, {
            outputShape: o
        } = r, {
            sliceRank: p,
            numUpdates: u,
            sliceSize: c,
            strides: d,
            outputSize: h
        } = C.calculateShapes(i, s, o), f = !1, m = a.bufferSync(s);
        switch (i.dtype) {
          case "bool":
            t = iu(m, a.bufferSync(i), o, h, c, u, p, d, !!a.data.get(l.dataId).values[0], f);
            break;

          case "float32":
          case "int32":
            t = iu(m, a.bufferSync(i), o, h, c, u, p, d, a.data.get(l.dataId).values[0], f);
            break;

          case "string":
            t = iu(m, a.bufferSync(i), o, h, c, u, p, d, k.decodeString(a.data.get(l.dataId).values[0]), f);
            break;

          default:
            throw new Error(`Unsupported type ${i.dtype}`);
        }
        return a.makeTensorInfo(o, t.dtype, t.values);
    }
}, KE = {
    kernelName: zl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            numOrSizeSplits: s,
            axis: i
        } = a, l = k.parseAxisParam(i, r.shape)[0], o = C.prepareSplitSize(r, s, l), p = new Array(r.shape.length).fill(0), u = r.shape.slice();
        return o.map(c => {
            let d = [ ...u ];
            d[l] = c;
            let h = wo({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    begin: p,
                    size: d
                }
            });
            return p[l] += c, h;
        });
    }
}, ZE = {
    kernelName: od,
    backendName: "cpu",
    kernelFunc: ({
        inputs: e,
        backend: t
    }) => {
        let {
            x: n
        } = e, a = t;
        Se(n, "square");
        let r = a.data.get(n.dataId).values, s = new Float32Array(r.length);
        for (let i = 0; i < r.length; ++i) {
            let l = r[i];
            s[i] = l * l;
        }
        return {
            dataId: a.write(s, n.shape, n.dtype),
            shape: n.shape,
            dtype: n.dtype
        };
    }
}, YE = pt(vr, (e, t) => {
    let n = t;
    return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha;
}), JE = {
    kernelName: vr,
    backendName: "cpu",
    kernelFunc: YE
}, QE = {
    kernelName: Ji,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            begin: s,
            end: i,
            strides: l,
            beginMask: o,
            endMask: p,
            ellipsisMask: u,
            newAxisMask: c,
            shrinkAxisMask: d
        } = a;
        Se(r, "stridedSlice");
        let h, {
            finalShapeSparse: f,
            finalShape: m,
            isIdentity: g,
            sliceDim0: y,
            isSimpleSlice: A,
            begin: x,
            end: b,
            strides: v
        } = St.sliceInfo(r.shape, s, i, l, o, p, u, c, d);
        if (g) h = At({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: m
            }
        }); else if (y || A) {
            k.assert(r.shape.length >= 1, () => `Input must have rank at least 1, got: ${r.shape.length}`);
            let I = St.computeOutShape(x, b, v), N = wo({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    begin: x,
                    size: I
                }
            });
            h = At({
                inputs: {
                    x: N
                },
                backend: n,
                attrs: {
                    shape: m
                }
            }), n.disposeIntermediateTensorInfo(N);
        } else {
            let I = f5(f, n.bufferSync(r), v, x);
            h = n.makeTensorInfo(m, I.dtype, I.values);
        }
        return h;
    }
}, e$ = {
    kernelName: Vl,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            separator: r,
            nGramWidths: s,
            leftPad: i,
            rightPad: l,
            padWidth: o,
            preserveShortSequences: p
        } = a, {
            data: u,
            dataSplits: c
        } = t, d = n.data.get(u.dataId).values, h = n.data.get(c.dataId).values, [ f, m ] = Wm(d, h, r, s, i, l, o, p);
        return [ n.makeTensorInfo([ f.length ], "string", f), n.makeTensorInfo(c.shape, "int32", m) ];
    }
}, t$ = {
    kernelName: ud,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            skipEmpty: r
        } = a, {
            input: s,
            delimiter: i
        } = t;
        if (s.dtype !== "string") throw new Error("Input must be of datatype string");
        if (s.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${s.shape}`);
        if (i.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
        let l = n.data.get(s.dataId).values, o = n.data.get(i.dataId).values[0], [ p, u, c ] = Bm(l, o, r), d = u.length;
        return [ n.makeTensorInfo([ d, 2 ], "int32", p), n.makeTensorInfo([ d ], "string", u), n.makeTensorInfo([ 2 ], "int32", new Int32Array(c)) ];
    }
}, n$ = {
    kernelName: dd,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            numBuckets: r
        } = a, {
            input: s
        } = t;
        if (s.dtype !== "string") throw new Error("Input must be of datatype string");
        if (r <= 0) throw new Error("Number of buckets must be at least 1");
        let i = Vm(n.data.get(s.dataId).values, r);
        return n.makeTensorInfo(s.shape, "int32", i);
    }
}, a$ = pt(eo, e => Math.tan(e)), r$ = {
    kernelName: eo,
    backendName: "cpu",
    kernelFunc: a$
}, s$ = pt(to, e => Math.tanh(e)), i$ = {
    kernelName: Li,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            tensor: a,
            indices: r,
            updates: s
        } = t, {
            sliceRank: i,
            numUpdates: l,
            sliceSize: o,
            strides: p,
            outputSize: u
        } = C.calculateShapes(s, r, a.shape), c = n.bufferSync(r), d = n.bufferSync(s), h = n.bufferSync(a), f = iu(c, d, a.shape, u, o, l, i, p, h, !1);
        return n.makeTensorInfo(a.shape, f.dtype, f.values);
    }
}, o$ = {
    kernelName: br,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            reps: s
        } = a;
        Se(r, "tile");
        let i = g5(n.bufferSync(r), s);
        return n.makeTensorInfo(i.shape, i.dtype, i.values);
    }
}, l$ = {
    kernelName: no,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            k: s,
            sorted: i
        } = a;
        Se(r, "topk");
        let l = n.data.get(r.dataId).values, [ o, p ] = A5(l, r.shape, r.dtype, s, i);
        return [ n.makeTensorInfo(o.shape, o.dtype, o.values), n.makeTensorInfo(p.shape, p.dtype, p.values) ];
    }
}, u$ = {
    kernelName: ao,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            image: r,
            transforms: s
        } = t, {
            interpolation: i,
            fillMode: l,
            fillValue: o,
            outputShape: p
        } = n, [ u, c, d, h ] = r.shape, [ f, m ] = p ?? [ c, d ], g = [ u, f, m, h ], y = k.computeStrides(r.shape), A = y[0], x = y[1], b = y[2], v = k.computeStrides(g), I = v[0], N = v[1], T = v[2], R = k.getTypedArrayFromDType(r.dtype, k.sizeFromShape(g));
        R.fill(o);
        let w = a.data.get(r.dataId).values, E = a.data.get(s.dataId).values;
        for (let $ = 0; $ < u; ++$) {
            let M = s.shape[0] === 1 ? E : E.subarray(8 * $, 8 * $ + 8);
            for (let F = 0; F < f; ++F) for (let P = 0; P < m; ++P) for (let L = 0; L < h; ++L) {
                let O, B = M[6] * P + M[7] * F + 1;
                if (B === 0) continue;
                let G = (M[0] * P + M[1] * F + M[2]) / B, W = (M[3] * P + M[4] * F + M[5]) / B, z = O5(G, d, l), X = O5(W, c, l);
                switch (i) {
                  case "nearest":
                    O = d$(w, c, d, A, x, b, $, X, z, L, o);
                    break;

                  case "bilinear":
                    O = p$(w, c, d, A, x, b, $, X, z, L, o);
                    break;

                  default:
                    throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`);
                }
                R[$ * I + F * N + P * T + L] = O;
            }
            return a.makeTensorInfo(g, r.dtype, R);
        }
        return {
            dataId: a.write(R, g, r.dtype),
            shape: r.shape,
            dtype: r.dtype
        };
    }
};

function O5(e, t, n) {
    switch (n) {
      case "reflect":
        return function(a, r) {
            let s = a;
            if (s < 0) if (r <= 1) s = 0; else {
                let i = 2 * r;
                s < i && (s = i * Math.trunc(-s / i) + s), s = s < -r ? s + i : -s - 1;
            } else if (s > r - 1) if (r <= 1) s = 0; else {
                let i = 2 * r;
                s -= i * Math.trunc(s / i), s >= r && (s = i - s - 1);
            }
            return k.clamp(0, s, r - 1);
        }(e, t);

      case "wrap":
        return function(a, r) {
            let s = a;
            if (s < 0) if (r <= 1) s = 0; else {
                let i = r - 1;
                s += r * (Math.trunc(-s / i) + 1);
            } else if (s > r - 1) if (r <= 1) s = 0; else {
                let i = r - 1;
                s -= r * Math.trunc(s / i);
            }
            return k.clamp(0, s, r - 1);
        }(e, t);

      case "nearest":
        return function(a, r) {
            return k.clamp(0, a, r - 1);
        }(e, t);

      default:
        return function(a, r) {
            return a;
        }(e);
    }
}

function Hd(e, t, n, a, r, s, i, l, o, p, u) {
    return 0 <= l && l < t && 0 <= o && o < n ? e[i * a + l * r + o * s + p] : u;
}

function d$(e, t, n, a, r, s, i, l, o, p, u) {
    return Hd(e, t, n, a, r, s, i, Math.round(l), Math.round(o), p, u);
}

function p$(e, t, n, a, r, s, i, l, o, p, u) {
    let c = Math.floor(l), d = Math.floor(o), h = c + 1, f = d + 1;
    return (h - l) * ((f - o) * Hd(e, t, n, a, r, s, i, c, d, p, u) + (o - d) * Hd(e, t, n, a, r, s, i, c, f, p, u)) + (l - c) * ((f - o) * Hd(e, t, n, a, r, s, i, h, d, p, u) + (o - d) * Hd(e, t, n, a, r, s, i, h, f, p, u));
}

var c$ = {
    kernelName: pd,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            axis: r
        } = n, {
            x: s
        } = t;
        Se(s, "unique");
        let i = a.data.get(s.dataId).values, {
            outputValues: l,
            outputShape: o,
            indices: p
        } = Gm(i, r, s.shape, s.dtype);
        return [ a.makeTensorInfo(o, s.dtype, l), a.makeTensorInfo([ p.length ], "int32", p) ];
    }
}, h$ = {
    kernelName: Ul,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            value: r
        } = t, {
            axis: s
        } = a;
        s < 0 && (s += r.shape.length);
        let i = r.shape.length, l = r.shape[s], o = new Array(i - 1), p = 0;
        for (let h = 0; h < i; h++) h !== s && (o[p++] = r.shape[h]);
        let u = new Array(i).fill(0), c = r.shape.slice();
        c[s] = 1;
        let d = new Array(l);
        for (let h = 0; h < d.length; h++) {
            u[s] = h;
            let f = wo({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    begin: u,
                    size: c
                }
            });
            d[h] = At({
                inputs: {
                    x: f
                },
                backend: n,
                attrs: {
                    shape: o
                }
            }), n.disposeIntermediateTensorInfo(f);
        }
        return d;
    }
}, f$ = {
    kernelName: cd,
    backendName: "cpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            segmentIds: s
        } = t, {
            numSegments: i
        } = a;
        Se(r, "unsortedSegmentSum");
        let l = [], o = [], p = r.shape.length - s.shape.length, u = s;
        for (let d = 0; d < p; ++d) {
            let h = Ec({
                inputs: {
                    input: u
                },
                backend: n,
                attrs: {
                    dim: d + 1
                }
            });
            u = h, o.push(h);
        }
        for (let d = 0; d < i; ++d) {
            let h = k.createScalarValue(d, "int32"), f = n.makeTensorInfo([], "int32", h), m = Ox({
                inputs: {
                    a: f,
                    b: u
                },
                backend: n
            }), g = Br({
                inputs: {
                    x: m
                },
                backend: n,
                attrs: {
                    dtype: "float32"
                }
            }), y = Cc({
                inputs: {
                    a: g,
                    b: r
                },
                backend: n
            }), A = Gd({
                inputs: {
                    x: y
                },
                backend: n,
                attrs: {
                    axis: 0,
                    keepDims: !1
                }
            });
            l.push(A), o.push(f), o.push(m), o.push(g), o.push(y), o.push(A);
        }
        let c = M5({
            inputs: l,
            backend: n,
            attrs: {
                axis: 0
            }
        });
        return o.forEach(d => n.disposeIntermediateTensorInfo(d)), c;
    }
}, m$ = [ XC, _N, ZC, JC, WN, QC, eT, tT, nT, aT, sT, oT, uT, cT, fT, mT, gT, yT, AT, qC, xT, bT, vT, VN, wT, zN, GN, IT, ON, ST, CT, TT, RT, ET, $T, MT, FT, OT, DT, zT, LT, WT, BT, VT, UT, GT, HT, jT, qT, XT, KT, ZT, JT, WC, QT, HN, oR, jN, lR, XN, pR, cR, hR, ZN, JN, fR, mR, gR, yR, eC, nC, PN, AR, NT, bR, wR, IR, BC, rC, iC, SR, lC, CR, ER, MR, OR, PR, DR, zR, dC, LR, WR, BR, VR, UR, GR, HR, cC, jR, KR, JR, fC, mC, eE, nE, rE, yC, sE, oE, lE, F5, pE, UC, xC, cE, hE, fE, mE, DN, qm, yE, GC, HC, jC, AE, xE, bE, vE, wE, kE, SE, IC, NE, RE, EE, _E, NC, PE, zE, WE, CC, YR, VE, UE, GE, HE, jE, qE, XE, KE, EC, ZE, MC, _C, JE, QE, e$, t$, n$, zC, YT, r$, {
    kernelName: to,
    backendName: "cpu",
    kernelFunc: s$
}, i$, o$, l$, u$, AC, c$, h$, f$, iE ];

for (let e of m$) Aa(e);

var P5 = {};

Ze(P5, {
    assertNotComplex: () => du,
    bindCanvasToFramebuffer: () => v$,
    bindColorTextureToFramebuffer: () => Dc,
    bindTextureToProgramUniformSampler: () => Y5,
    bindTextureUnit: () => X5,
    bindVertexBufferToProgramAttribute: () => Qm,
    callAndCheck: () => fe,
    canBeRepresented: () => D5,
    createFragmentShader: () => W5,
    createFramebuffer: () => q5,
    createProgram: () => B5,
    createStaticIndexBuffer: () => G5,
    createStaticVertexBuffer: () => U5,
    createTexture: () => H5,
    createVertexShader: () => L5,
    getBatchDim: () => Io,
    getExtensionOrThrow: () => Xd,
    getFramebufferErrorMessage: () => J5,
    getMaxTexturesInShader: () => nb,
    getNumChannels: () => x$,
    getProgramUniformLocation: () => Z5,
    getProgramUniformLocationOrThrow: () => K5,
    getRowsCols: () => So,
    getShapeAs3D: () => Zd,
    getTextureShapeFromLogicalShape: () => eb,
    getWebGLDisjointQueryTimerVersion: () => ab,
    getWebGLErrorMessage: () => z5,
    getWebGLMaxTextureSize: () => tb,
    hasExtension: () => ea,
    isCapableOfRenderingToFloatTexture: () => rb,
    isDownloadFloatTextureEnabled: () => sb,
    isReshapeFree: () => Yd,
    isWebGLFenceEnabled: () => ib,
    isWebGLVersionEnabled: () => t1,
    linkProgram: () => V5,
    logShaderSourceAndInfoLog: () => Jm,
    resetMaxTextureSize: () => w$,
    resetMaxTexturesInShader: () => k$,
    unbindColorTextureFromFramebuffer: () => e1,
    unbindTextureUnit: () => b$,
    validateFramebuffer: () => Kd,
    validateProgram: () => Pc,
    validateTextureSize: () => j5
});

var jd, Qn, Qt, ko = {}, Mc = {
    alpha: !1,
    antialias: !1,
    premultipliedAlpha: !1,
    preserveDrawingBuffer: !1,
    depth: !1,
    stencil: !1,
    failIfMajorPerformanceCaveat: !0
};

function Zm(e, t) {
    ko[e] = t;
}

function Sa(e, t) {
    if (!(e in ko) || t != null) {
        let a = function(r, s) {
            if (r !== 1 && r !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
            let i = s ?? function(l) {
                if (!H().getBool("IS_SAFARI") && typeof OffscreenCanvas < "u" && l === 2) return new OffscreenCanvas(300, 150);
                if (typeof document < "u") return document.createElement("canvas");
                throw new Error("Cannot create a canvas in this context");
            }(r);
            return i.addEventListener("webglcontextlost", l => {
                l.preventDefault(), delete ko[r];
            }, !1), H().getBool("SOFTWARE_WEBGL_ENABLED") && (Mc.failIfMajorPerformanceCaveat = !1), 
            r === 1 ? i.getContext("webgl", Mc) || i.getContext("experimental-webgl", Mc) : i.getContext("webgl2", Mc);
        }(e, t);
        if (a === null) return null;
        ko[e] = a;
    }
    let n = ko[e];
    return n == null || n.isContextLost() ? (delete ko[e], Sa(e)) : (n.disable(n.DEPTH_TEST), 
    n.disable(n.STENCIL_TEST), n.disable(n.BLEND), n.disable(n.DITHER), n.disable(n.POLYGON_OFFSET_FILL), 
    n.disable(n.SAMPLE_COVERAGE), n.enable(n.SCISSOR_TEST), n.enable(n.CULL_FACE), 
    n.cullFace(n.BACK), ko[e]);
}

function qd(e, t) {
    return [ t, e ];
}

function Fc(e) {
    let t = k.sizeFromShape(e), n = Math.ceil(t / 4);
    return k.sizeToSquarishShape(n);
}

function uu(e, t) {
    return [ Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2)) ];
}

function Ym(e, t) {
    let n, a, r, s, i, l, o, p, u, c, d = e;
    return H().getNumber("WEBGL_VERSION") === 2 ? (n = d.R32F, a = d.R16F, r = d.RGBA16F, 
    s = d.RGBA32F, i = d.RED, o = 4, p = 1, u = d.HALF_FLOAT, c = d.FLOAT, l = d.RGBA8) : (n = e.RGBA, 
    a = e.RGBA, r = e.RGBA, s = d.RGBA, i = e.RGBA, o = 4, p = 4, u = t != null ? t.HALF_FLOAT_OES : null, 
    c = e.FLOAT, l = e.RGBA), {
        internalFormatFloat: n,
        internalFormatHalfFloat: a,
        internalFormatPackedHalfFloat: r,
        internalFormatPackedFloat: s,
        textureFormatFloat: i,
        downloadTextureFormat: l,
        downloadUnpackNumChannels: o,
        defaultNumChannels: p,
        textureTypeHalfFloat: u,
        textureTypeFloat: c
    };
}

function fe(e, t) {
    let n = t();
    return H().getBool("DEBUG") && function(a) {
        let r = a.getError();
        if (r !== a.NO_ERROR) throw new Error("WebGL Error: " + z5(a, r));
    }(e), n;
}

(function(e) {
    e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH";
})(jd || (jd = {})), function(e) {
    e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", 
    e[e.DOWNLOAD = 3] = "DOWNLOAD";
}(Qn || (Qn = {})), function(e) {
    e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", 
    e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", 
    e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16";
}(Qt || (Qt = {}));

var g$ = 5.96e-8, y$ = 65504;

function D5(e) {
    return !!(H().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || e === 0 || g$ < Math.abs(e) && Math.abs(e) < y$);
}

function z5(e, t) {
    switch (t) {
      case e.NO_ERROR:
        return "NO_ERROR";

      case e.INVALID_ENUM:
        return "INVALID_ENUM";

      case e.INVALID_VALUE:
        return "INVALID_VALUE";

      case e.INVALID_OPERATION:
        return "INVALID_OPERATION";

      case e.INVALID_FRAMEBUFFER_OPERATION:
        return "INVALID_FRAMEBUFFER_OPERATION";

      case e.OUT_OF_MEMORY:
        return "OUT_OF_MEMORY";

      case e.CONTEXT_LOST_WEBGL:
        return "CONTEXT_LOST_WEBGL";

      default:
        return `Unknown error code ${t}`;
    }
}

function Xd(e, t) {
    return rr(e, () => e.getExtension(t), 'Extension "' + t + '" not supported on this browser.');
}

function L5(e, t) {
    let n = rr(e, () => e.createShader(e.VERTEX_SHADER), "Unable to create vertex WebGLShader.");
    if (fe(e, () => e.shaderSource(n, t)), fe(e, () => e.compileShader(n)), e.getShaderParameter(n, e.COMPILE_STATUS) === !1) throw new Error("Failed to compile vertex shader.");
    return n;
}

function W5(e, t) {
    let n = rr(e, () => e.createShader(e.FRAGMENT_SHADER), "Unable to create fragment WebGLShader.");
    if (fe(e, () => e.shaderSource(n, t)), fe(e, () => e.compileShader(n)), H().get("ENGINE_COMPILE_ONLY")) return n;
    if (e.getShaderParameter(n, e.COMPILE_STATUS) === !1) throw Jm(t, e.getShaderInfoLog(n)), 
    new Error("Failed to compile fragment shader.");
    return n;
}

var _c, Oc, A$ = /ERROR: [0-9]+:([0-9]+):/g;

function Jm(e, t) {
    let n = A$.exec(t);
    if (n == null) return;
    let a = +n[1], r = e.split(`
`), s = r.length.toString().length + 2, i = r.map((o, p) => k.rightPad((p + 1).toString(), s) + o), l = 0;
    for (let o = 0; o < i.length; o++) l = Math.max(i[o].length, l);
    i.slice(0, a - 1), i.slice(a - 1, a), i.slice(a);
}

function B5(e) {
    return rr(e, () => e.createProgram(), "Unable to create WebGLProgram.");
}

function V5(e, t) {
    if (fe(e, () => e.linkProgram(t)), !H().get("ENGINE_COMPILE_ONLY") && e.getProgramParameter(t, e.LINK_STATUS) === !1) throw new Error("Failed to link vertex and fragment shaders.");
}

function Pc(e, t) {
    if (fe(e, () => e.validateProgram(t)), e.getProgramParameter(t, e.VALIDATE_STATUS) === !1) throw new Error("Shader program validation failed.");
}

function U5(e, t) {
    let n = rr(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
    return fe(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), fe(e, () => e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW)), 
    n;
}

function G5(e, t) {
    let n = rr(e, () => e.createBuffer(), "Unable to create WebGLBuffer");
    return fe(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n)), fe(e, () => e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW)), 
    n;
}

function x$() {
    return H().getNumber("WEBGL_VERSION") === 2 ? 1 : 4;
}

function H5(e) {
    return rr(e, () => e.createTexture(), "Unable to create WebGLTexture.");
}

function j5(e, t) {
    let n = H().getNumber("WEBGL_MAX_TEXTURE_SIZE");
    if (e <= 0 || t <= 0) throw new Error(`Requested texture size [${e}x${t}] is invalid.`);
    if (e > n || t > n) throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`);
}

function q5(e) {
    return rr(e, () => e.createFramebuffer(), "Unable to create WebGLFramebuffer.");
}

function Qm(e, t, n, a, r, s, i) {
    let l = e.getAttribLocation(t, n);
    return l !== -1 && (fe(e, () => e.bindBuffer(e.ARRAY_BUFFER, a)), fe(e, () => e.vertexAttribPointer(l, r, e.FLOAT, !1, s, i)), 
    fe(e, () => e.enableVertexAttribArray(l)), !0);
}

function X5(e, t, n) {
    Q5(e, n), fe(e, () => e.activeTexture(e.TEXTURE0 + n)), fe(e, () => e.bindTexture(e.TEXTURE_2D, t));
}

function b$(e, t) {
    Q5(e, t), fe(e, () => e.activeTexture(e.TEXTURE0 + t)), fe(e, () => e.bindTexture(e.TEXTURE_2D, null));
}

function K5(e, t, n) {
    return rr(e, () => e.getUniformLocation(t, n), 'uniform "' + n + '" not present in program.');
}

function Z5(e, t, n) {
    return e.getUniformLocation(t, n);
}

function Y5(e, t, n, a) {
    fe(e, () => X5(e, t, a)), fe(e, () => e.uniform1i(n, a));
}

function v$(e) {
    fe(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), fe(e, () => e.viewport(0, 0, e.canvas.width, e.canvas.height)), 
    fe(e, () => e.scissor(0, 0, e.canvas.width, e.canvas.height));
}

function Dc(e, t, n) {
    fe(e, () => e.bindFramebuffer(e.FRAMEBUFFER, n)), fe(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0));
}

function e1(e, t) {
    fe(e, () => e.bindFramebuffer(e.FRAMEBUFFER, t)), fe(e, () => e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0));
}

function Kd(e) {
    let t = e.checkFramebufferStatus(e.FRAMEBUFFER);
    if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + J5(e, t));
}

function J5(e, t) {
    switch (t) {
      case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

      case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

      case e.FRAMEBUFFER_UNSUPPORTED:
        return "FRAMEBUFFER_UNSUPPORTED";

      default:
        return `unknown error ${t}`;
    }
}

function rr(e, t, n) {
    let a = fe(e, () => t());
    if (a == null) throw new Error(n);
    return a;
}

function Q5(e, t) {
    let n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1, a = t + e.TEXTURE0;
    if (a < e.TEXTURE0 || a > n) throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`);
}

function Io(e, t = 2) {
    return k.sizeFromShape(e.slice(0, e.length - t));
}

function So(e) {
    if (e.length === 0) throw Error("Cannot get rows and columns of an empty shape array.");
    return [ e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1] ];
}

function Zd(e) {
    let t = [ 1, 1, 1 ];
    return e.length === 0 || e.length === 1 && e[0] === 1 || (t = [ Io(e), ...So(e) ]), 
    t;
}

function eb(e, t = !1) {
    let n = H().getNumber("WEBGL_MAX_TEXTURE_SIZE"), a = H().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
    a === 1 / 0 && H().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (a = n / 2), 
    t && (n *= 2, a *= 2, (e = e.map((l, o) => o >= e.length - 2 ? k.nearestLargerEven(e[o]) : e[o])).length === 1 && (e = [ 2, e[0] ])), 
    e.length !== 2 && (e = k.squeezeShape(e).newShape);
    let r = k.sizeFromShape(e), s = null;
    e.length <= 1 && r <= n ? s = [ 1, r ] : e.length === 2 && e[0] <= n && e[1] <= n ? s = e : e.length === 3 && e[0] * e[1] <= n && e[2] <= n ? s = [ e[0] * e[1], e[2] ] : e.length === 3 && e[0] <= n && e[1] * e[2] <= n ? s = [ e[0], e[1] * e[2] ] : e.length === 4 && e[0] * e[1] * e[2] <= n && e[3] <= n ? s = [ e[0] * e[1] * e[2], e[3] ] : e.length === 4 && e[0] <= n && e[1] * e[2] * e[3] <= n && (s = [ e[0], e[1] * e[2] * e[3] ]);
    let i = s != null && Math.max(...s) > a && Math.min(...s) <= (t ? 2 : 1) && Math.min(...s) > 0;
    if (s == null || i) if (t) {
        let l = Io(e), o = 2, p = 2;
        e.length && ([ o, p ] = So(e)), r = l * (o / 2) * (p / 2), s = k.sizeToSquarishShape(r).map(u => 2 * u);
    } else s = k.sizeToSquarishShape(r);
    return s;
}

function zc(e) {
    return e % 2 == 0;
}

function Yd(e, t) {
    if (e = e.slice(-2), t = t.slice(-2), k.arraysEqual(e, t) || !e.length || !t.length || e[0] === 0 || e[1] === 0 || t[0] === 0 || t[1] === 0) return !0;
    if (e.length !== t.length) {
        let n = e[e.length - 1], a = t[t.length - 1];
        if (n === a || zc(n) && zc(a) && (e[0] === 1 || t[0] === 1)) return !0;
    }
    return e[1] === t[1] && zc(e[0]) && zc(t[0]);
}

function tb(e) {
    if (_c == null) {
        let t = Sa(e);
        _c = t.getParameter(t.MAX_TEXTURE_SIZE);
    }
    return _c;
}

function w$() {
    _c = null;
}

function k$() {
    Oc = null;
}

function nb(e) {
    if (Oc == null) {
        let t = Sa(e);
        Oc = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
    }
    return Math.min(16, Oc);
}

function ab(e) {
    if (e === 0) return 0;
    let t, n = Sa(e);
    return t = ea(n, "EXT_disjoint_timer_query_webgl2") && e === 2 ? 2 : ea(n, "EXT_disjoint_timer_query") ? 1 : 0, 
    t;
}

function ea(e, t) {
    return e.getExtension(t) != null;
}

function t1(e) {
    try {
        if (Sa(e) != null) return !0;
    } catch {
        return !1;
    }
    return !1;
}

function rb(e) {
    if (e === 0) return !1;
    let t = Sa(e);
    if (e === 1) {
        if (!ea(t, "OES_texture_float")) return !1;
    } else if (!ea(t, "EXT_color_buffer_float")) return !1;
    return n1(t);
}

function sb(e) {
    if (e === 0) return !1;
    let t = Sa(e);
    if (e !== 1) {
        if (ea(t, "EXT_color_buffer_float")) return n1(t);
        let n = "EXT_color_buffer_half_float";
        if (ea(t, n)) {
            let a = t.getExtension(n);
            return function(r, s) {
                let i = Ym(r, s), l = r.createTexture();
                r.bindTexture(r.TEXTURE_2D, l), r.texImage2D(r.TEXTURE_2D, 0, i.internalFormatHalfFloat, 1, 1, 0, i.textureFormatFloat, i.textureTypeHalfFloat, null);
                let o = r.createFramebuffer();
                r.bindFramebuffer(r.FRAMEBUFFER, o), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, l, 0);
                let p = r.checkFramebufferStatus(r.FRAMEBUFFER) === r.FRAMEBUFFER_COMPLETE;
                return r.bindTexture(r.TEXTURE_2D, null), r.bindFramebuffer(r.FRAMEBUFFER, null), 
                r.deleteTexture(l), r.deleteFramebuffer(o), p;
            }(t, a);
        }
        return !1;
    }
    return !(!ea(t, "OES_texture_float") || !ea(t, "WEBGL_color_buffer_float")) && n1(t);
}

function n1(e) {
    let t = Ym(e), n = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, n), e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
    let a = e.createFramebuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, a), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
    let r = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
    return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), 
    e.deleteTexture(n), e.deleteFramebuffer(a), r;
}

function ib(e) {
    return e === 2 && Sa(e).fenceSync != null;
}

function du(e, t) {
    Array.isArray(e) || (e = [ e ]), e.forEach(n => {
        n != null && k.assert(n.dtype !== "complex64", () => `${t} does not support complex64 tensors in the WebGL backend.`);
    });
}

var Te = H();

function hn() {
    let e, t, n, a, r, s, i, l, o, p;
    return H().getNumber("WEBGL_VERSION") === 2 ? (e = "#version 300 es", t = "in", 
    n = "out", a = "in", r = "texture", s = "outputColor", i = "out vec4 outputColor;", 
    l = H().getBool("WEBGL2_ISNAN_CUSTOM") ? `
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    ` : "", o = "", p = `
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `) : (e = "", t = "attribute", n = "varying", a = "varying", r = "texture2D", 
    s = "gl_FragColor", i = "", l = `
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `, o = `
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `, p = `
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `), {
        version: e,
        attribute: t,
        varyingVs: n,
        varyingFs: a,
        texture2D: r,
        output: s,
        defineOutput: i,
        defineSpecialNaN: l,
        defineSpecialInf: o,
        defineRound: p
    };
}

function No(e, t, n = "index") {
    let a = k.computeStrides(t);
    return a.map((r, s) => `${`int ${e[s]} = ${n} / ${r}`}; ${s === a.length - 1 ? `int ${e[s + 1]} = ${n} - ${e[s]} * ${r}` : `index -= ${e[s]} * ${r}`};`).join("");
}

function Lc(e, t, n = "index") {
    let a = k.computeStrides(t);
    return a.map((r, s) => `${`int ${e[s]} = ${n} / outShapeStrides[${s}]`}; ${s === a.length - 1 ? `int ${e[s + 1]} = ${n} - ${e[s]} * outShapeStrides[${s}]` : `index -= ${e[s]} * outShapeStrides[${s}]`};`).join("");
}

function I$(e, t, n = "index") {
    let a = function(r, s) {
        let i = r.length, l = r.map(p => `${s}[${p}]`), o = new Array(i - 1);
        o[i - 2] = l[i - 1];
        for (let p = i - 3; p >= 0; --p) o[p] = `(${o[p + 1]} * ${l[p + 1]})`;
        return o;
    }(e.map((r, s) => s), t);
    return a.map((r, s) => `${`int ${e[s]} = ${n} / ${a[s]}`}; ${s === a.length - 1 ? `int ${e[s + 1]} = ${n} - ${e[s]} * ${a[s]}` : `index -= ${e[s]} * ${a[s]}`};`).join("");
}

function a1(e) {
    let t = k.computeStrides(e).map(n => n.toString());
    return `
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`;
}

Te.registerFlag("HAS_WEBGL", () => Te.getNumber("WEBGL_VERSION") > 0), Te.registerFlag("WEBGL_VERSION", () => t1(2) ? 2 : t1(1) ? 1 : 0), 
Te.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => !1), Te.registerFlag("WEBGL_BUFFER_SUPPORTED", () => Te.get("WEBGL_VERSION") === 2), 
Te.registerFlag("WEBGL_CPU_FORWARD", () => !0), Te.registerFlag("WEBGL_FORCE_F16_TEXTURES", () => !1), 
Te.registerFlag("WEBGL_PACK", () => Te.getBool("HAS_WEBGL")), Te.registerFlag("WEBGL_PACK_NORMALIZATION", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_PACK_CLIP", () => Te.getBool("WEBGL_PACK")), Te.registerFlag("WEBGL_PACK_DEPTHWISECONV", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_PACK_REDUCE", () => Te.getBool("WEBGL_PACK")), Te.registerFlag("WEBGL_LAZILY_UNPACK", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_CONV_IM2COL", () => Te.getBool("WEBGL_PACK")), Te.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", () => Te.getBool("WEBGL_PACK")), 
Te.registerFlag("WEBGL_MAX_TEXTURE_SIZE", () => tb(Te.getNumber("WEBGL_VERSION"))), 
Te.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", () => nb(Te.getNumber("WEBGL_VERSION"))), 
Te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
    let e = Te.getNumber("WEBGL_VERSION");
    return e === 0 ? 0 : ab(e);
}), Te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => Te.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !Id.isMobile()), 
Te.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", () => rb(Te.getNumber("WEBGL_VERSION"))), 
Te.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", () => !Te.getBool("WEBGL_FORCE_F16_TEXTURES") && Te.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")), 
Te.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => sb(Te.getNumber("WEBGL_VERSION"))), 
Te.registerFlag("WEBGL_FENCE_API_ENABLED", () => ib(Te.getNumber("WEBGL_VERSION"))), 
Te.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", () => Te.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0), 
Te.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, e => {
    if (typeof e != "number") throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);
    if (e < 0 && e !== -1) throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`);
}), Te.registerFlag("WEBGL_FLUSH_THRESHOLD", () => Id.isMobile() ? 1 : -1, e => {
    if (typeof e != "number") throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);
    if (e < 0 && e !== -1) throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`);
}), Te.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", () => 128), Te.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", () => !1), 
Te.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5), Te.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128), 
Te.registerFlag("WEBGL_EXP_CONV", () => !1), Te.registerFlag("SOFTWARE_WEBGL_ENABLED", () => Te.getBool("IS_TEST")), 
Te.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0), Te.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => !1), 
Te.registerFlag("WEBGL2_ISNAN_CUSTOM", () => !1), Te.registerFlag("ENGINE_COMPILE_ONLY", () => !1);

var ob = `
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`, {
    getBroadcastDims: lb
} = C;

function S$(e, t, n) {
    let a = [];
    if (e.forEach(d => {
        let h = k.sizeFromShape(d.shapeInfo.logicalShape);
        if (d.shapeInfo.isUniform ? a.push(`uniform float ${d.name}${h > 1 ? `[${h}]` : ""};`) : (a.push(`uniform sampler2D ${d.name};`), 
        a.push(`uniform int offset${d.name};`)), n.enableShapeUniforms) {
            let {
                uniformShape: f
            } = r1(n.packedInputs, d.shapeInfo.logicalShape, d.shapeInfo.texShape);
            switch (f.length) {
              case 1:
                a.push(`uniform int ${d.name}Shape;`);
                break;

              case 2:
                a.push(`uniform ivec2 ${d.name}Shape;`);
                break;

              case 3:
                a.push(`uniform ivec3 ${d.name}Shape;`);
                break;

              case 4:
                a.push(`uniform ivec4 ${d.name}Shape;`);
            }
            a.push(`uniform ivec2 ${d.name}TexShape;`);
        }
    }), n.enableShapeUniforms) {
        switch (t.logicalShape.length) {
          case 1:
            a.push("uniform int outShape;");
            break;

          case 2:
            a.push("uniform ivec2 outShape;"), a.push("uniform int outShapeStrides;");
            break;

          case 3:
            a.push("uniform ivec3 outShape;"), a.push("uniform ivec2 outShapeStrides;");
            break;

          case 4:
            a.push("uniform ivec4 outShape;"), a.push("uniform ivec3 outShapeStrides;");
        }
        a.push("uniform ivec2 outTexShape;");
    }
    n.customUniforms && n.customUniforms.forEach(d => {
        a.push(`uniform ${d.type} ${d.name}${d.arrayIndex ? `[${d.arrayIndex}]` : ""};`);
    });
    let r, s, i = a.join(`
`), l = e.map(d => function(h, f, m = !1, g) {
        let y = "";
        y += m ? ub(h, g) : pu(h, g);
        let A = h.shapeInfo.logicalShape, x = f.logicalShape;
        return A.length <= x.length && (y += m ? function(b, v) {
            let I, N = b.name, T = N.charAt(0).toUpperCase() + N.slice(1), R = "get" + T + "AtOutCoords", w = b.shapeInfo.logicalShape.length, E = v.logicalShape.length, $ = lb(b.shapeInfo.logicalShape, v.logicalShape), M = ft(E), F = E - w, P = [ "x", "y", "z", "w", "u", "v" ];
            I = w === 0 ? "" : E < 2 && $.length >= 1 ? "coords = 0;" : $.map(W => `coords.${P[W + F]} = 0;`).join(`
`);
            let L = "";
            L = E < 2 && w > 0 ? "coords" : b.shapeInfo.logicalShape.map((W, z) => `coords.${P[z + F]}`).join(", ");
            let O = "return outputValue;", B = k.sizeFromShape(b.shapeInfo.logicalShape) === 1, G = k.sizeFromShape(v.logicalShape) === 1;
            if (w !== 1 || B || G) {
                if (B && !G) O = E === 1 ? `
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      ` : `
        return vec4(outputValue.x);
      `; else if ($.length) {
                    let W = w - 2, z = w - 1;
                    $.indexOf(W) > -1 && $.indexOf(z) > -1 ? O = "return vec4(outputValue.x);" : $.indexOf(W) > -1 ? O = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : $.indexOf(z) > -1 && (O = "return vec4(outputValue.xx, outputValue.zz);");
                }
            } else O = `
      return vec4(outputValue.xy, outputValue.xy);
    `;
            return `
    vec4 ${R}() {
      ${M} coords = getOutputCoords();
      ${I}
      vec4 outputValue = get${T}(${L});
      ${O}
    }
  `;
        }(h, f) : function(b, v) {
            let I = b.name, N = I.charAt(0).toUpperCase() + I.slice(1), T = "get" + N + "AtOutCoords", R = v.texShape, w = b.shapeInfo.texShape, E = b.shapeInfo.logicalShape.length, $ = v.logicalShape.length;
            if (!b.shapeInfo.isUniform && E === $ && b.shapeInfo.flatOffset == null && k.arraysEqual(w, R)) return `
      float ${T}() {
        return sampleTexture(${I}, resultUV);
      }
    `;
            let M, F = ft($), P = lb(b.shapeInfo.logicalShape, v.logicalShape), L = $ - E, O = [ "x", "y", "z", "w", "u", "v" ];
            M = E === 0 ? "" : $ < 2 && P.length >= 1 ? "coords = 0;" : P.map(G => `coords.${O[G + L]} = 0;`).join(`
`);
            let B = "";
            return B = $ < 2 && E > 0 ? "coords" : b.shapeInfo.logicalShape.map((G, W) => `coords.${O[W + L]}`).join(", "), 
            `
    float ${T}() {
      ${F} coords = getOutputCoords();
      ${M}
      return get${N}(${B});
    }
  `;
        }(h, f)), y;
    }(d, t, n.packedInputs, n.enableShapeUniforms)).join(`
`), o = t.texShape, p = hn(), u = function(d) {
        return `
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${d.texture2D}(textureSampler, uv).r;
    }
  `;
    }(p), c = function(d) {
        return `${d.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${d.varyingFs} vec2 resultUV;
    ${d.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${d.defineSpecialNaN}
    ${d.defineSpecialInf}
    ${d.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${N$}
    ${C$}
    ${T$}
  `;
    }(p);
    return t.isPacked ? (r = function(d, h, f) {
        switch (d.length) {
          case 0:
            return db();

          case 1:
            return function(m, g, y) {
                let A = [ Math.ceil(g[0] / 2), Math.ceil(g[1] / 2) ];
                return A[0] === 1 ? y ? `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${A[1]}.0);
      }
    ` : A[1] === 1 ? y ? `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    ` : `
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${A[0]}.0);
      }
    ` : y ? `
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${A[0]}, ${A[1]}));
      return 2 * (resTexRC.x * ${A[1]} + resTexRC.y);
    }
  `;
            }(0, h, f);

          case 2:
            return function(m, g, y) {
                let A = [ Math.ceil(g[0] / 2), Math.ceil(g[1] / 2) ];
                if (k.arraysEqual(m, g)) return y ? `
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${A[0]}, ${A[1]}));
      }
    `;
                let x = Math.ceil(m[1] / 2);
                return y ? `
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${A[0]}, ${A[1]}));

      int index = resTexRC.x * ${A[1]} + resTexRC.y;
      int r = 2 * (index / ${x});
      int c = imod(index, ${x}) * 2;

      return ivec2(r, c);
    }
  `;
            }(d, h, f);

          case 3:
            return function(m, g, y) {
                if (y) return `
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;
                let A = [ Math.ceil(g[0] / 2), Math.ceil(g[1] / 2) ], x = Math.ceil(m[2] / 2), b = x * Math.ceil(m[1] / 2);
                return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${A[0]}, ${A[1]}));
      int index = resTexRC.x * ${A[1]} + resTexRC.y;

      int b = index / ${b};
      index -= b * ${b};

      int r = 2 * (index / ${x});
      int c = imod(index, ${x}) * 2;

      return ivec3(b, r, c);
    }
  `;
            }(d, h, f);

          default:
            return function(m, g, y) {
                if (y) return `
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;
                let A = [ Math.ceil(g[0] / 2), Math.ceil(g[1] / 2) ], x = Math.ceil(m[m.length - 1] / 2), b = x * Math.ceil(m[m.length - 2] / 2), v = b, I = "", N = "b, r, c";
                for (let T = 2; T < m.length - 1; T++) v *= m[m.length - T - 1], 
                I = `
      int b${T} = index / ${v};
      index -= b${T} * ${v};
    ` + I, N = `b${T}, ` + N;
                return `
    ivec${m.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${A[0]}, ${A[1]}));
      int index = resTexRC.x * ${A[1]} + resTexRC.y;

      ${I}

      int b = index / ${b};
      index -= b * ${b};

      int r = 2 * (index / ${x});
      int c = imod(index, ${x}) * 2;

      return ivec${m.length}(${N});
    }
  `;
            }(d, h, f);
        }
    }(t.logicalShape, o, n.enableShapeUniforms), s = function(d) {
        return `
    void setOutput(vec4 val) {
      ${d.output} = val;
    }
  `;
    }(p)) : (r = function(d, h, f) {
        switch (d.length) {
          case 0:
            return db();

          case 1:
            return function(m, g, y) {
                return g[0] === 1 ? y ? `
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.x * ${g[1]}.0);
      }
    ` : g[1] === 1 ? y ? `
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    ` : `
      int getOutputCoords() {
        return int(resultUV.y * ${g[0]}.0);
      }
    ` : y ? `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  ` : `
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${g[0]}, ${g[1]}));
      return resTexRC.x * ${g[1]} + resTexRC.y;
    }
  `;
            }(0, h, f);

          case 2:
            return function(m, g, y) {
                return k.arraysEqual(m, g) ? y ? `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    ` : `
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${g[0]}, ${g[1]}));
      }
    ` : m[1] === 1 ? y ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${g[0]}, ${g[1]}));
        int index = resTexRC.x * ${g[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    ` : m[0] === 1 ? y ? `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    ` : `
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${g[0]}, ${g[1]}));
        int index = resTexRC.x * ${g[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    ` : y ? `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  ` : `
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${g[0]}, ${g[1]}));
      int index = resTexRC.x * ${g[1]} + resTexRC.y;
      int r = index / ${m[1]};
      int c = index - r * ${m[1]};
      return ivec2(r, c);
    }
  `;
            }(d, h, f);

          case 3:
            return function(m, g, y) {
                if (y) return `
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Lc([ "r", "c", "d" ], m)}
    return ivec3(r, c, d);
  }
`;
                let A = No([ "r", "c", "d" ], m);
                return `
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${g[0]}, ${g[1]}));
      int index = resTexRC.x * ${g[1]} + resTexRC.y;
      ${A}
      return ivec3(r, c, d);
    }
  `;
            }(d, h, f);

          case 4:
            return function(m, g, y) {
                if (y) return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Lc([ "r", "c", "d", "d2" ], m)}
      return ivec4(r, c, d, d2);
    }
  `;
                let A = No([ "r", "c", "d", "d2" ], m);
                return `
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${g[0]}, ${g[1]}));
      int index = resTexRC.x * ${g[1]} + resTexRC.y;
      ${A}
      return ivec4(r, c, d, d2);
    }
  `;
            }(d, h, f);

          case 5:
            return function(m, g) {
                let y = No([ "r", "c", "d", "d2", "d3" ], m);
                return `
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${g[0]},
                             ${g[1]}));

      int index = resTexRC.x * ${g[1]} + resTexRC.y;

      ${y}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `;
            }(d, h);

          case 6:
            return function(m, g) {
                let y = No([ "r", "c", "d", "d2", "d3", "d4" ], m);
                return `
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${g[0]}, ${g[1]}));
      int index = resTexRC.x * ${g[1]} + resTexRC.y;

      ${y}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `;
            }(d, h);

          default:
            throw new Error(`${d.length}-D output sampling is not yet supported`);
        }
    }(t.logicalShape, o, n.enableShapeUniforms), s = function(d) {
        return `
    void setOutput(float val) {
      ${d.output} = vec4(val, 0, 0, 0);
    }
  `;
    }(p)), n.packedInputs && (c += R$), [ c, u, s, i, r, l, n.userCode ].join(`
`);
}

function pu(e, t = !1) {
    let n = e.shapeInfo.logicalShape;
    switch (n.length) {
      case 0:
        return function(a, r) {
            let s = a.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1);
            if (a.shapeInfo.isUniform) return `float ${i}() {return ${s};}`;
            let [ l, o ] = a.shapeInfo.texShape;
            if (l === 1 && o === 1) return `
      float ${i}() {
        return sampleTexture(${s}, halfCR);
      }
    `;
            let p = Co(s);
            if (r) return `
    float ${i}() {
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], ${p});
      return sampleTexture(${s}, uv);
    }
  `;
            let [ u, c ] = a.shapeInfo.texShape;
            return `
    float ${i}() {
      vec2 uv = uvFromFlat(${u}, ${c}, ${p});
      return sampleTexture(${s}, uv);
    }
  `;
        }(e, t);

      case 1:
        return function(a, r) {
            let s = a.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1);
            if (a.shapeInfo.isUniform) return `
      float ${i}(int index) {
        ${cu(a)}
      }
    `;
            let l = a.shapeInfo.texShape, o = l[0], p = l[1];
            if (p === 1 && o === 1) return `
      float ${i}(int index) {
        return sampleTexture(${s}, halfCR);
      }
    `;
            let u = Co(s);
            return p === 1 ? r ? `
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    ` : `
      float ${i}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${u}) + 0.5) / ${o}.0);
        return sampleTexture(${s}, uv);
      }
    ` : o === 1 ? r ? `
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    ` : `
      float ${i}(int index) {
        vec2 uv = vec2((float(index + ${u}) + 0.5) / ${p}.0, 0.5);
        return sampleTexture(${s}, uv);
      }
    ` : r ? `
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${u});
      return sampleTexture(${s}, uv);
    }
  ` : `
    float ${i}(int index) {
      vec2 uv = uvFromFlat(${o}, ${p}, index + ${u});
      return sampleTexture(${s}, uv);
    }
  `;
        }(e, t);

      case 2:
        return function(a, r) {
            let s = a.shapeInfo.logicalShape, i = a.name, l = "get" + i.charAt(0).toUpperCase() + i.slice(1), o = a.shapeInfo.texShape;
            if (o != null && k.arraysEqual(s, o)) {
                if (r) return `
      float ${l}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    `;
                let m = o[0];
                return `
    float ${l}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${o[1]}.0, ${m}.0);
      return sampleTexture(${i}, uv);
    }
  `;
            }
            let {
                newShape: p,
                keptDims: u
            } = k.squeezeShape(s), c = p;
            if (c.length < s.length) {
                let m = [ "row", "col" ];
                return `
      ${pu(hu(a, c), r)}
      float ${l}(int row, int col) {
        return ${l}(${fu(m, u)});
      }
    `;
            }
            if (a.shapeInfo.isUniform) return `
      float ${l}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${s[1]}, 1)));
        ${cu(a)}
      }
    `;
            let d = o[0], h = o[1], f = Co(i);
            return h === 1 ? r ? `
      float ${l}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${i}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));
        return sampleTexture(${i}, uv);
      }
    ` : `
    float ${l}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${s[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${i}, uv);
    }
  ` : d === 1 ? r ? `
      float ${l}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${i}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);
        return sampleTexture(${i}, uv);
      }
    ` : `
    float ${l}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${s[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${i}, uv);
    }
  ` : r ? `
      float ${l}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);
        return sampleTexture(${i}, uv);
      }
    ` : `
  float ${l}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${s[1]} + col + ${f};
    vec2 uv = uvFromFlat(${d}, ${h}, index);
    return sampleTexture(${i}, uv);
  }
`;
        }(e, t);

      case 3:
        return function(a, r) {
            let s = a.shapeInfo.logicalShape, i = a.name, l = "get" + i.charAt(0).toUpperCase() + i.slice(1), o = s[1] * s[2], p = s[2], {
                newShape: u,
                keptDims: c
            } = k.squeezeShape(s), d = u;
            if (d.length < s.length) {
                let A = [ "row", "col", "depth" ];
                return `
        ${pu(hu(a, d), r)}
        float ${l}(int row, int col, int depth) {
          return ${l}(${fu(A, c)});
        }
      `;
            }
            if (a.shapeInfo.isUniform) return `
      float ${l}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${p}, 1)));
        ${cu(a)}
      }
    `;
            let h = a.shapeInfo.texShape, f = h[0], m = h[1], g = a.shapeInfo.flatOffset;
            if (m === o && g == null) return r ? `
      float ${l}(int row, int col, int depth) {
        int stride1 = ${i}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    ` : `
        float ${l}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${p}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${i}, uv);
        }
      `;
            if (m === p && g == null) return r ? `
      float ${l}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    ` : `
    float ${l}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${s[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${i}, uv);
    }
  `;
            let y = Co(i);
            return r ? `
    float ${l}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${i}Shape[1] * ${i}Shape[2];
      int stride1 = ${i}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${y};
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);
      return sampleTexture(${i}, uv);
    }
    ` : `
      float ${l}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${p} + depth + ${y};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${i}, uv);
      }
  `;
        }(e, t);

      case 4:
        return function(a, r) {
            let s = a.shapeInfo.logicalShape, i = a.name, l = "get" + i.charAt(0).toUpperCase() + i.slice(1), o = s[3], p = s[2] * o, u = s[1] * p, {
                newShape: c,
                keptDims: d
            } = k.squeezeShape(s);
            if (c.length < s.length) {
                let v = [ "row", "col", "depth", "depth2" ];
                return `
      ${pu(hu(a, c), r)}
      float ${l}(int row, int col, int depth, int depth2) {
        return ${l}(${fu(v, d)});
      }
    `;
            }
            if (a.shapeInfo.isUniform) return `
      float ${l}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${u}, ${p}, ${o}, 1)));
        ${cu(a)}
      }
    `;
            let h = a.shapeInfo.flatOffset, f = a.shapeInfo.texShape, m = f[0], g = f[1], y = `int stride2 = ${i}Shape[3];`, A = `int stride1 = ${i}Shape[2] * stride2;`, x = `int stride0 = ${i}Shape[1] * stride1;`;
            if (g === u && h == null) return r ? `
      float ${l}(int row, int col, int depth, int depth2) {
        ${y}
        ${A}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    ` : `
      float ${l}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${p}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${i}, uv);
      }
    `;
            if (g === o && h == null) return r ? `
      float ${l}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${i}TexShape[1], ${i}TexShape[0]);
        return sampleTexture(${i}, uv);
      }
    ` : `
      float ${l}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s[1] * s[2]}, ${s[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${i}, uv);
      }
    `;
            let b = Co(i);
            return r ? `
    float ${l}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${y}
      ${A}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${b});
      return sampleTexture(${i}, uv);
    }
  ` : `
    float ${l}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${p} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${m}, ${g}, index + ${b});
      return sampleTexture(${i}, uv);
    }
  `;
        }(e, t);

      case 5:
        return function(a) {
            let r = a.shapeInfo.logicalShape, s = a.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), l = r[4], o = r[3] * l, p = r[2] * o, u = r[1] * p, {
                newShape: c,
                keptDims: d
            } = k.squeezeShape(r);
            if (c.length < r.length) {
                let A = [ "row", "col", "depth", "depth2", "depth3" ];
                return `
      ${pu(hu(a, c))}
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        return ${i}(${fu(A, d)});
      }
    `;
            }
            if (a.shapeInfo.isUniform) return `
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${p}, ${o}, ${l})) +
          depth3;
        ${cu(a)}
      }
    `;
            let h = a.shapeInfo.flatOffset, f = a.shapeInfo.texShape, m = f[0], g = f[1];
            if (g === u && h == null) return `
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${p}, ${o}, ${l}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;
            if (g === l && h == null) return `
      float ${i}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${r[1] * r[2] * r[3]},
               ${r[2] * r[3]}, ${r[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${s}, uv);
      }
    `;
            let y = Co(s);
            return `
    float ${i}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${p} + depth * ${o} +
          depth2 * ${l} + depth3 + ${y};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${s}, uv);
    }
  `;
        }(e);

      case 6:
        return function(a) {
            let r = a.shapeInfo.logicalShape, s = a.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), {
                newShape: l,
                keptDims: o
            } = k.squeezeShape(r);
            if (l.length < r.length) {
                let x = [ "row", "col", "depth", "depth2", "depth3", "depth4" ];
                return `
      ${pu(hu(a, l))}
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${i}(${fu(x, o)});
      }
    `;
            }
            let p = r[5], u = r[4] * p, c = r[3] * u, d = r[2] * c, h = r[1] * d;
            if (a.shapeInfo.isUniform) return `
      float ${i}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${d}, ${c}, ${u})) +
          dot(
            vec2(depth3, depth4),
            vec2(${p}, 1)));
        ${cu(a)}
      }
    `;
            let f = a.shapeInfo.flatOffset, m = a.shapeInfo.texShape, g = m[0], y = m[1];
            if (y === h && f == null) return `
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${c}, ${u}, ${p})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${g}.0);
        return sampleTexture(${s}, uv);
      }
    `;
            if (y === p && f == null) return `
      float ${i}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${r[1] * r[2] * r[3] * r[4]},
               ${r[2] * r[3] * r[4]},
               ${r[3] * r[4]},
               ${r[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${g}.0);
        return sampleTexture(${s}, uv);
      }
    `;
            let A = Co(s);
            return `
    float ${i}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${d} + depth * ${c} +
          depth2 * ${u} + depth3 * ${p} + depth4 + ${A};
      vec2 uv = uvFromFlat(${g}, ${y}, index);
      return sampleTexture(${s}, uv);
    }
  `;
        }(e);

      default:
        throw new Error(`${n.length}-D input sampling is not yet supported`);
    }
}

function ub(e, t) {
    switch (e.shapeInfo.logicalShape.length) {
      case 0:
        return function(n) {
            let a = n.name, r = "get" + a.charAt(0).toUpperCase() + a.slice(1), s = hn();
            return `
    vec4 ${r}() {
      return ${s.texture2D}(${a}, halfCR);
    }
  `;
        }(e);

      case 1:
        return function(n, a) {
            let r = n.name, s = "get" + r.charAt(0).toUpperCase() + r.slice(1), i = n.shapeInfo.texShape, l = hn();
            if (a) return `
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${l.texture2D}(${r}, uv);
    }
  `;
            let o = [ Math.ceil(i[0] / 2), Math.ceil(i[1] / 2) ];
            return `
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${l.texture2D}(${r}, uv);
    }
  `;
        }(e, t);

      case 2:
        return function(n, a) {
            let r = n.shapeInfo.logicalShape, s = n.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), l = n.shapeInfo.texShape, o = l[0], p = l[1], u = hn();
            if (l != null && k.arraysEqual(r, l)) return a ? `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    ` : `
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${o}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;
            if (a) return `
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;
            let c = [ Math.ceil(l[0] / 2), Math.ceil(l[1] / 2) ], d = Math.ceil(r[1] / 2);
            return `
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d}, ${c[0]}, ${c[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;
        }(e, t);

      case 3:
        return function(n, a) {
            let r = n.shapeInfo.logicalShape, s = n.name, i = "get" + s.charAt(0).toUpperCase() + s.slice(1), l = n.shapeInfo.texShape, o = [ Math.ceil(l[0] / 2), Math.ceil(l[1] / 2) ];
            if (r[0] === 1) {
                let f = [ 1, 2 ], m = [ "b", "row", "col" ];
                return `
        ${ub(hu(n, r.slice(1)), a)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${fu(m, f)});
        }
      `;
            }
            let p = hn();
            if (a) return `
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${p.texture2D}(${s}, uv);
    }
  `;
            let u = o[0], c = o[1], d = Math.ceil(r[2] / 2), h = d * Math.ceil(r[1] / 2);
            return `
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${c}, ${h}, ${d}, b, row, col);
      return ${p.texture2D}(${s}, uv);
    }
  `;
        }(e, t);

      default:
        return function(n, a) {
            let r = n.name, s = "get" + r.charAt(0).toUpperCase() + r.slice(1), i = hn();
            if (a) return `
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${r}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${r}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${r}, uv);
    }
  `;
            let l = n.shapeInfo.logicalShape, o = l.length, p = n.shapeInfo.texShape, u = [ Math.ceil(p[0] / 2), Math.ceil(p[1] / 2) ], c = u[0], d = u[1], h = Math.ceil(l[o - 1] / 2), f = h * Math.ceil(l[o - 2] / 2), m = "int b, int row, int col", g = `b * ${f} + (row / 2) * ${h} + (col / 2)`;
            for (let y = 2; y < o - 1; y++) m = `int b${y}, ` + m, f *= l[o - y - 1], 
            g = `b${y} * ${f} + ` + g;
            return `
    vec4 ${s}(${m}) {
      int index = ${g};
      int texR = index / ${d};
      int texC = index - texR * ${d};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});
      return ${i.texture2D}(${r}, uv);
    }
  `;
        }(e, t);
    }
}

var N$ = `
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, C$ = `
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, T$ = `
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`, R$ = `
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;

function db() {
    return `
    int getOutputCoords() {
      return 0;
    }
  `;
}

function Co(e) {
    return `offset${e}`;
}

function cu(e) {
    let t = e.name, n = k.sizeFromShape(e.shapeInfo.logicalShape);
    return n < 2 ? `return ${t};` : `
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `;
}

function ft(e) {
    if (e <= 1) return "int";
    if (e === 2) return "ivec2";
    if (e === 3) return "ivec3";
    if (e === 4) return "ivec4";
    if (e === 5) return "ivec5";
    if (e === 6) return "ivec6";
    throw Error(`GPU for rank ${e} is not yet supported`);
}

function r1(e, t, n) {
    let {
        newShape: a,
        keptDims: r
    } = k.squeezeShape(t), s = t.length, i = e && s === 3 && t[0] === 1, l = i ? t.slice(1) : a, o = !e && s > 1 && !k.arraysEqual(t, n) && a.length < s || i;
    return {
        useSqueezeShape: o,
        uniformShape: o ? l : t,
        keptDims: r
    };
}

function hu(e, t) {
    let n = JSON.parse(JSON.stringify(e));
    return n.shapeInfo.logicalShape = t, n;
}

function fu(e, t) {
    return t.map(n => e[n]).join(", ");
}

function pb(e, t, n) {
    let a, r, s, i = [], l = [], o = null, p = null;
    p = e.getUniformLocation(n, "NAN", !1), H().getNumber("WEBGL_VERSION") === 1 && (o = e.getUniformLocation(n, "INFINITY", !1));
    let u = !1;
    for (let c of t.variableNames) {
        let d = {
            name: c,
            uniform: e.getUniformLocation(n, c, u),
            offset: e.getUniformLocation(n, `offset${c}`, u)
        };
        t.enableShapeUniforms && (d.shape = e.getUniformLocation(n, `${c}Shape`, u), 
        d.texShape = e.getUniformLocation(n, `${c}TexShape`, u)), i.push(d);
    }
    if (t.enableShapeUniforms && (a = e.getUniformLocation(n, "outShape", u), s = e.getUniformLocation(n, "outShapeStrides", u), 
    r = e.getUniformLocation(n, "outTexShape", u)), t.customUniforms) for (let c of t.customUniforms) l.push(e.getUniformLocation(n, c.name, u));
    return {
        variablesLocations: i,
        customUniformLocations: l,
        infLoc: o,
        nanLoc: p,
        outShapeLocation: a,
        outShapeStridesLocation: s,
        outTexShapeLocation: r
    };
}

function cb(e, t) {
    if (e.length !== t.length) throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);
    e.forEach((n, a) => {
        let r = n.logicalShape, s = t[a], i = s.shape;
        if (!k.arraysEqual(r, i)) throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);
        if (n.isUniform && s.isUniform) return;
        let l = n.texShape, o = s.isUniform ? null : s.texData.texShape;
        if (!k.arraysEqual(l, o)) throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${o} must match`);
    });
}

function on(e) {
    return H().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4;
}

var E$ = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.packedInputs = !1, this.packedOutput = !0, 
        this.outPackingScheme = jd.DENSE, this.customUniforms = [ {
            name: "texShape",
            type: "ivec2"
        } ];
        let t = hn();
        this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length), 
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? Lc([ "r", "c", "d" ], e) : No([ "r", "c", "d" ], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `;
    }
}, $$ = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outPackingScheme = jd.DENSE, this.customUniforms = [ {
            name: "texShape",
            type: "ivec2"
        } ];
        let t = hn();
        this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length), 
        this.userCode = `
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms ? Lc([ "r", "c", "d" ], e) : No([ "r", "c", "d" ], e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `;
    }
}, M$ = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.outTexUsage = Qn.DOWNLOAD;
        let t = hn();
        this.outputShape = e, this.userCode = `
      ${ob}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `;
    }
}, F$ = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !1, 
        this.outTexUsage = Qn.DOWNLOAD;
        let t = hn();
        this.outputShape = e, this.userCode = `
      ${ob}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `;
    }
}, _$ = {
    R: 0,
    G: 1,
    B: 2,
    A: 3
}, hb = class {
    constructor(e, t = !1, n = "RGBA") {
        this.variableNames = [ "A" ], this.customUniforms = [ {
            name: "texShape",
            type: "ivec2"
        } ];
        let a = hn();
        this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length);
        let r = "result";
        t && (r = "floor(result * 255. + 0.5)");
        let s = "";
        for (let i = 0; i < n.length; i++) {
            let l = n[i];
            s += `
          if(offset == ${i}) {
            result = values[${_$[l]}];
          }`;
        }
        this.userCode = `
      ${this.enableShapeUniforms ? `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
` : a1(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${s}
        }
        ${a.output} = vec4(${r}, 0., 0., 0.);
      }
    `;
    }
}, O$ = class {
    constructor(e, t = !1) {
        this.variableNames = [ "A" ], this.packedInputs = !1, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "texShape",
            type: "ivec2"
        } ];
        let n = hn();
        this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length);
        let a = "", r = "result";
        t && (r = "floor(result * 255. + 0.5)");
        for (let s = 0; s <= 1; s++) for (let i = 0; i <= 1; i++) {
            let l = 2 * s + i;
            a += `
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms ? "outShape[2]" : `${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms ? "outShape[1]" : `${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `;
        }
        this.userCode = `
        ${this.enableShapeUniforms ? `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
` : a1(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${n.output} = ${r};
        }
    `;
    }
}, fb = {};

function mb(e) {
    let t = hn();
    return L5(e, `${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`);
}

function gb(e) {
    return U5(e, new Float32Array([ -1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0 ]));
}

function yb(e) {
    return G5(e, new Uint16Array([ 0, 1, 2, 2, 1, 3 ]));
}

function Jd(e, t, n, a, r, s) {
    j5(t, n);
    let i = H5(e), l = e.TEXTURE_2D;
    return fe(e, () => e.bindTexture(l, i)), fe(e, () => e.texParameteri(l, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)), 
    fe(e, () => e.texParameteri(l, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), fe(e, () => e.texParameteri(l, e.TEXTURE_MIN_FILTER, e.NEAREST)), 
    fe(e, () => e.texParameteri(l, e.TEXTURE_MAG_FILTER, e.NEAREST)), H().getNumber("WEBGL_VERSION") === 1 ? fe(e, () => e.texImage2D(l, 0, a, t, n, 0, r, s, null)) : fe(e, () => e.texStorage2D(l, 1, a, t, n)), 
    fe(e, () => e.bindTexture(e.TEXTURE_2D, null)), {
        texture: i,
        texShape: [ n, t ]
    };
}

function s1(e) {
    return e.internalFormatFloat;
}

function Ab(e, t, n, a) {
    let [ r, s ] = qd(t, n);
    return Jd(e, r, s, s1(a), a.textureFormatFloat, e.FLOAT);
}

function i1(e) {
    return e.internalFormatHalfFloat;
}

function xb(e, t, n, a) {
    let [ r, s ] = qd(t, n);
    return Jd(e, r, s, i1(a), a.textureFormatFloat, a.textureTypeHalfFloat);
}

function o1(e) {
    return e.downloadTextureFormat;
}

function bb(e, t, n, a) {
    let [ r, s ] = qd(t, n);
    return Jd(e, r, s, o1(a), e.RGBA, e.UNSIGNED_BYTE);
}

function l1(e) {
    return e.internalFormatPackedFloat;
}

function vb(e, t, n, a) {
    let [ r, s ] = uu(t, n);
    return Jd(e, r, s, l1(a), e.RGBA, e.FLOAT);
}

function u1(e) {
    return e.internalFormatPackedHalfFloat;
}

function wb(e, t, n, a) {
    let [ r, s ] = uu(t, n);
    return Jd(e, r, s, u1(a), e.RGBA, a.textureTypeHalfFloat);
}

function kb(e, t, n) {
    return fe(e, () => e.bindBuffer(e.ARRAY_BUFFER, n)), Qm(e, t, "clipSpacePos", n, 3, 20, 0) && Qm(e, t, "uv", n, 2, 20, 12);
}

function Ib(e, t, n, a, r, s) {
    let i, l, o;
    fe(e, () => e.bindTexture(e.TEXTURE_2D, t)), r instanceof Uint8Array ? (i = new Uint8Array(n * a * 4), 
    l = e.UNSIGNED_BYTE, o = e.RGBA) : (i = new Float32Array(n * a * 4), l = e.FLOAT, 
    o = s.internalFormatPackedFloat), i.set(r), H().getNumber("WEBGL_VERSION") === 2 ? fe(e, () => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n, a, e.RGBA, l, i)) : fe(e, () => e.texImage2D(e.TEXTURE_2D, 0, o, n, a, 0, e.RGBA, l, i)), 
    fe(e, () => e.bindTexture(e.TEXTURE_2D, null));
}

function Sb(e, t, n) {
    fe(e, () => e.bindTexture(e.TEXTURE_2D, t)), n.data instanceof Uint8Array ? H().getNumber("WEBGL_VERSION") === 2 ? fe(e, () => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n.width, n.height, e.RGBA, e.UNSIGNED_BYTE, n.data)) : fe(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data)) : H().getNumber("WEBGL_VERSION") === 2 ? fe(e, () => e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, e.RGBA, e.UNSIGNED_BYTE, n)) : fe(e, () => e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n)), 
    fe(e, () => e.bindTexture(e.TEXTURE_2D, null));
}

function Nb(e, t, n, a) {
    let r = e.createBuffer();
    fe(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, r));
    let s = 16 * t * n;
    return fe(e, () => e.bufferData(e.PIXEL_PACK_BUFFER, s, e.STREAM_READ)), fe(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0)), 
    fe(e, () => e.bindBuffer(e.PIXEL_PACK_BUFFER, null)), r;
}

function Cb(e, t, n) {
    let a = e, r = new Float32Array(n);
    return a.bindBuffer(a.PIXEL_PACK_BUFFER, t), a.getBufferSubData(a.PIXEL_PACK_BUFFER, 0, r), 
    a.bindBuffer(a.PIXEL_PACK_BUFFER, null), r;
}

function Tb(e, t, n, a) {
    let [ r, s ] = qd(t, n), i = new Uint8Array(function(l, o) {
        return l * o;
    }(t * n, 4));
    return fe(e, () => e.readPixels(0, 0, r, s, a.downloadTextureFormat, e.UNSIGNED_BYTE, i)), 
    new Float32Array(i.buffer);
}

function Rb(e, t, n, a, r, s, i, l) {
    let o = e, p = new Float32Array(function(u, c) {
        let [ d, h ] = uu(u, c);
        return d * h * 4;
    }(s, i));
    return o.bindBuffer(o.PIXEL_PACK_BUFFER, t), o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, p), 
    o.bindBuffer(o.PIXEL_PACK_BUFFER, null), p;
}

function Eb(e, t, n) {
    let a = new Float32Array(t * n * 4);
    return fe(e, () => e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, a)), a;
}

Ze(fb, {
    bindVertexProgramAttributeStreams: () => kb,
    createBufferFromOutputTexture: () => Nb,
    createFloat16MatrixTexture: () => xb,
    createFloat16PackedMatrixTexture: () => wb,
    createFloat32MatrixTexture: () => Ab,
    createIndexBuffer: () => yb,
    createPackedMatrixTexture: () => vb,
    createUnsignedBytesMatrixTexture: () => bb,
    createVertexBuffer: () => gb,
    createVertexShader: () => mb,
    downloadByteEncodedFloatMatrixFromOutputTexture: () => Tb,
    downloadFloat32MatrixFromBuffer: () => Cb,
    downloadMatrixFromPackedOutputTexture: () => Eb,
    downloadPackedMatrixFromBuffer: () => Rb,
    getInternalFormatForFloat16MatrixTexture: () => i1,
    getInternalFormatForFloat16PackedMatrixTexture: () => u1,
    getInternalFormatForFloat32MatrixTexture: () => s1,
    getInternalFormatForPackedMatrixTexture: () => l1,
    getInternalFormatForUnsignedBytesMatrixTexture: () => o1,
    uploadDenseMatrixToTexture: () => Ib,
    uploadPixelDataToTexture: () => Sb
});

var Qd = class {
    constructor(e) {
        this.outputTexture = null, this.program = null, this.disposed = !1, this.itemsToPoll = [];
        let t = H().getNumber("WEBGL_VERSION");
        if (e != null ? (this.gl = e, Zm(t, e)) : this.gl = Sa(t), e = this.gl, 
        H().getNumber("WEBGL_VERSION") === 2) {
            let r = e;
            this.createVertexArray = () => fe(r, () => r.createVertexArray()), this.bindVertexArray = s => fe(r, () => r.bindVertexArray(s)), 
            this.deleteVertexArray = s => fe(r, () => r.deleteVertexArray(s)), this.getVertexArray = () => fe(r, () => r.getParameter(r.VERTEX_ARRAY_BINDING));
        } else if (e != null) {
            let r = e.getExtension("OES_vertex_array_object");
            if (r == null) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
            this.createVertexArray = () => fe(e, () => r.createVertexArrayOES()), 
            this.bindVertexArray = s => fe(e, () => r.bindVertexArrayOES(s)), this.deleteVertexArray = s => fe(e, () => r.deleteVertexArrayOES(s)), 
            this.getVertexArray = () => fe(e, () => e.getParameter(r.VERTEX_ARRAY_BINDING_OES));
        }
        let n = "WEBGL_color_buffer_float", a = "EXT_color_buffer_half_float";
        if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), 
        H().getNumber("WEBGL_VERSION") === 1) {
            let r = "OES_texture_float", s = "OES_texture_half_float";
            if (this.textureFloatExtension = Xd(this.gl, r), ea(this.gl, s)) this.textureHalfFloatExtension = Xd(this.gl, s); else if (H().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
            if (this.colorBufferFloatExtension = this.gl.getExtension(n), ea(this.gl, a)) this.colorBufferHalfFloatExtension = Xd(this.gl, a); else if (H().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
        } else if (n = "EXT_color_buffer_float", ea(this.gl, n)) this.colorBufferFloatExtension = this.gl.getExtension(n); else {
            if (!ea(this.gl, a)) throw new Error("GL context does not support color renderable floats");
            this.colorBufferHalfFloatExtension = this.gl.getExtension(a);
        }
        this.vertexBuffer = gb(this.gl), this.indexBuffer = yb(this.gl), this.framebuffer = q5(this.gl), 
        this.textureConfig = Ym(this.gl, this.textureHalfFloatExtension);
    }
    get debug() {
        return H().getBool("DEBUG");
    }
    dispose() {
        if (this.disposed) return;
        this.program, this.outputTexture;
        let e = this.gl;
        fe(e, () => e.finish()), fe(e, () => e.bindFramebuffer(e.FRAMEBUFFER, null)), 
        fe(e, () => e.deleteFramebuffer(this.framebuffer)), fe(e, () => e.bindBuffer(e.ARRAY_BUFFER, null)), 
        fe(e, () => e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null)), fe(e, () => e.deleteBuffer(this.indexBuffer)), 
        this.disposed = !0;
    }
    createFloat32MatrixTexture(e, t) {
        return this.throwIfDisposed(), Ab(this.gl, e, t, this.textureConfig);
    }
    createFloat16MatrixTexture(e, t) {
        return this.throwIfDisposed(), xb(this.gl, e, t, this.textureConfig);
    }
    createUnsignedBytesMatrixTexture(e, t) {
        return this.throwIfDisposed(), bb(this.gl, e, t, this.textureConfig);
    }
    uploadPixelDataToTexture(e, t) {
        this.throwIfDisposed(), Sb(this.gl, e, t);
    }
    uploadDenseMatrixToTexture(e, t, n, a) {
        this.throwIfDisposed(), Ib(this.gl, e, t, n, a, this.textureConfig);
    }
    createFloat16PackedMatrixTexture(e, t) {
        return this.throwIfDisposed(), wb(this.gl, e, t, this.textureConfig);
    }
    createPackedMatrixTexture(e, t) {
        return this.throwIfDisposed(), vb(this.gl, e, t, this.textureConfig);
    }
    deleteMatrixTexture(e) {
        this.throwIfDisposed(), this.outputTexture === e && (e1(this.gl, this.framebuffer), 
        this.outputTexture = null), fe(this.gl, () => this.gl.deleteTexture(e));
    }
    downloadByteEncodedFloatMatrixFromOutputTexture(e, t, n) {
        return this.downloadMatrixDriver(e, () => Tb(this.gl, t, n, this.textureConfig));
    }
    downloadPackedMatrixFromBuffer(e, t, n, a, r, s) {
        return Rb(this.gl, e, 0, 0, 0, r, s, this.textureConfig);
    }
    downloadFloat32MatrixFromBuffer(e, t) {
        return Cb(this.gl, e, t);
    }
    createBufferFromTexture(e, t, n) {
        this.bindTextureToFrameBuffer(e);
        let a = Nb(this.gl, t, n, this.textureConfig);
        return this.unbindTextureToFrameBuffer(), a;
    }
    createAndWaitForFence() {
        let e = this.createFence(this.gl);
        return this.pollFence(e);
    }
    createFence(e) {
        let t, n;
        if (H().getBool("WEBGL_FENCE_API_ENABLED")) {
            let a = e, r = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
            e.flush(), n = () => {
                let s = a.clientWaitSync(r, 0, 0);
                return s === a.ALREADY_SIGNALED || s === a.CONDITION_SATISFIED;
            }, t = r;
        } else H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), 
        this.endQuery(), n = () => this.isQueryAvailable(t, H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : n = () => !0;
        return {
            query: t,
            isFencePassed: n
        };
    }
    downloadMatrixFromPackedTexture(e, t, n) {
        return this.downloadMatrixDriver(e, () => Eb(this.gl, t, n));
    }
    createProgram(e) {
        this.throwIfDisposed();
        let t = this.gl;
        this.vertexShader == null && (this.vertexShader = mb(t));
        let n = B5(t);
        fe(t, () => t.attachShader(n, this.vertexShader)), fe(t, () => t.attachShader(n, e)), 
        V5(t, n);
        let a = Object.assign(n, {
            vao: this.createVertexArray()
        });
        return this.debug && Pc(t, a), a;
    }
    buildVao(e) {
        this.setProgram(e), this.bindVertexArray(e.vao);
        let t = this.gl;
        fe(t, () => t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer)), kb(t, e, this.vertexBuffer);
    }
    deleteProgram(e) {
        this.throwIfDisposed(), e === this.program && (this.program = null), e != null && (fe(this.gl, () => this.gl.deleteProgram(e)), 
        this.deleteVertexArray(e.vao));
    }
    setProgram(e) {
        this.throwIfDisposed(), this.program = e, this.program != null && this.debug && Pc(this.gl, this.program), 
        fe(this.gl, () => this.gl.useProgram(e));
    }
    getUniformLocation(e, t, n = !0) {
        return this.throwIfDisposed(), n ? K5(this.gl, e, t) : Z5(this.gl, e, t);
    }
    getAttributeLocation(e, t) {
        return this.throwIfDisposed(), fe(this.gl, () => this.gl.getAttribLocation(e, t));
    }
    getUniformLocationNoThrow(e, t) {
        return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);
    }
    setInputMatrixTexture(e, t, n) {
        this.throwIfDisposed(), this.throwIfNoProgram(), Y5(this.gl, e, t, n);
    }
    setOutputMatrixTexture(e, t, n) {
        this.setOutputMatrixTextureDriver(e, n, t);
    }
    setOutputPackedMatrixTexture(e, t, n) {
        this.throwIfDisposed();
        let [ a, r ] = uu(t, n);
        this.setOutputMatrixTextureDriver(e, a, r);
    }
    setOutputMatrixWriteRegion(e, t, n, a) {
        this.setOutputMatrixWriteRegionDriver(n, e, a, t);
    }
    setOutputPackedMatrixWriteRegion(e, t, n, a) {
        throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
    }
    debugValidate() {
        this.program != null && Pc(this.gl, this.program), Kd(this.gl);
    }
    executeProgram() {
        this.throwIfDisposed(), this.throwIfNoProgram();
        let e = this.gl;
        this.debug && (this.getVertexArray(), this.debugValidate()), fe(e, () => e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0));
    }
    blockUntilAllProgramsCompleted() {
        this.throwIfDisposed(), fe(this.gl, () => this.gl.finish());
    }
    getQueryTimerExtension() {
        return this.disjointQueryTimerExtension == null && (this.disjointQueryTimerExtension = Xd(this.gl, H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), 
        this.disjointQueryTimerExtension;
    }
    getQueryTimerExtensionWebGL2() {
        return this.getQueryTimerExtension();
    }
    getQueryTimerExtensionWebGL1() {
        return this.getQueryTimerExtension();
    }
    beginQuery() {
        if (H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
            let n = this.gl, a = this.getQueryTimerExtensionWebGL2(), r = n.createQuery();
            return n.beginQuery(a.TIME_ELAPSED_EXT, r), r;
        }
        let e = this.getQueryTimerExtensionWebGL1(), t = e.createQueryEXT();
        return e.beginQueryEXT(e.TIME_ELAPSED_EXT, t), t;
    }
    endQuery() {
        if (H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
            let t = this.gl, n = this.getQueryTimerExtensionWebGL2();
            return void t.endQuery(n.TIME_ELAPSED_EXT);
        }
        let e = this.getQueryTimerExtensionWebGL1();
        e.endQueryEXT(e.TIME_ELAPSED_EXT);
    }
    async waitForQueryAndGetTime(e) {
        return await k.repeatedTry(() => this.disposed || this.isQueryAvailable(e, H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), 
        this.getQueryTime(e, H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
    }
    getQueryTime(e, t) {
        if (t === 0) return null;
        if (t === 2) {
            let n = this.gl;
            return n.getQueryParameter(e, n.QUERY_RESULT) / 1e6;
        }
        {
            let n = this.getQueryTimerExtensionWebGL1();
            return n.getQueryObjectEXT(e, n.QUERY_RESULT_EXT) / 1e6;
        }
    }
    isQueryAvailable(e, t) {
        if (t === 0) return !0;
        if (t === 2) {
            let n = this.gl, a = this.getQueryTimerExtensionWebGL2(), r = n.getQueryParameter(e, n.QUERY_RESULT_AVAILABLE);
            return this.disjoint == null && (this.disjoint = this.gl.getParameter(a.GPU_DISJOINT_EXT)), 
            r && !this.disjoint;
        }
        {
            let n = this.getQueryTimerExtensionWebGL1(), a = n.getQueryObjectEXT(e, n.QUERY_RESULT_AVAILABLE_EXT);
            return this.disjoint == null && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)), 
            a && !this.disjoint;
        }
    }
    pollFence(e) {
        return new Promise(t => {
            this.addItemToPoll(() => e.isFencePassed(), () => t());
        });
    }
    pollItems() {
        let e = function(t) {
            let n = 0;
            for (;n < t.length && t[n](); ++n);
            return n - 1;
        }(this.itemsToPoll.map(t => t.isDoneFn));
        for (let t = 0; t <= e; ++t) {
            let {
                resolveFn: n
            } = this.itemsToPoll[t];
            n();
        }
        this.itemsToPoll = this.itemsToPoll.slice(e + 1);
    }
    addItemToPoll(e, t) {
        if (this.itemsToPoll.push({
            isDoneFn: e,
            resolveFn: t
        }), this.itemsToPoll.length > 1) return;
        let n;
        "setTimeoutCustom" in H().platform && (n = H().platform.setTimeoutCustom.bind(H().platform)), 
        k.repeatedTry(() => (this.pollItems(), this.itemsToPoll.length === 0), () => 0, null, n);
    }
    bindTextureToFrameBuffer(e) {
        this.throwIfDisposed(), Dc(this.gl, e, this.framebuffer), this.debug && Kd(this.gl);
    }
    unbindTextureToFrameBuffer() {
        this.outputTexture != null ? (Dc(this.gl, this.outputTexture, this.framebuffer), 
        this.debug && Kd(this.gl)) : e1(this.gl, this.framebuffer);
    }
    downloadMatrixDriver(e, t) {
        this.bindTextureToFrameBuffer(e);
        let n = t();
        return this.unbindTextureToFrameBuffer(), n;
    }
    setOutputMatrixTextureDriver(e, t, n) {
        this.throwIfDisposed();
        let a = this.gl;
        Dc(a, e, this.framebuffer), this.debug && Kd(a), this.outputTexture = e, 
        fe(a, () => a.viewport(0, 0, t, n)), fe(a, () => a.scissor(0, 0, t, n));
    }
    setOutputMatrixWriteRegionDriver(e, t, n, a) {
        this.throwIfDisposed(), fe(this.gl, () => this.gl.scissor(e, t, n, a));
    }
    throwIfDisposed() {
        if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.");
    }
    throwIfNoProgram() {
        if (this.program == null) throw new Error("No GPU program is currently set.");
    }
}, {
    addImpl: P$,
    bincountImpl: $b,
    bincountReduceImpl: D$,
    bitwiseAndImpl: z$,
    castImpl: L$,
    ceilImpl: W$,
    concatImpl: B$,
    equalImpl: V$,
    expImpl: U$,
    expm1Impl: G$,
    floorImpl: H$,
    gatherNdImpl: j$,
    gatherV2Impl: q$,
    greaterImpl: X$,
    greaterEqualImpl: K$,
    lessImpl: Z$,
    lessEqualImpl: Y$,
    linSpaceImpl: J$,
    logImpl: Q$,
    maxImpl: eM,
    maximumImpl: tM,
    minimumImpl: nM,
    multiplyImpl: aM,
    negImpl: rM,
    notEqualImpl: sM,
    prodImpl: iM,
    raggedGatherImpl: oM,
    raggedRangeImpl: lM,
    raggedTensorToTensorImpl: uM,
    rangeImpl: dM,
    rsqrtImpl: pM,
    scatterImpl: cM,
    sigmoidImpl: hM,
    simpleAbsImpl: Mb,
    sliceImpl: fM,
    sparseFillEmptyRowsImpl: mM,
    sparseReshapeImpl: gM,
    sparseSegmentReductionImpl: Fb,
    sqrtImpl: yM,
    staticRegexReplaceImpl: AM,
    stridedSliceImpl: xM,
    stringNGramsImpl: bM,
    stringSplitImpl: vM,
    stringToHashBucketFastImpl: wM,
    subImpl: kM,
    tileImpl: IM,
    topKImpl: SM,
    transposeImpl: d1,
    uniqueImpl: NM
} = Sc;

function _b(e, t) {
    return [ "x", "y", "z", "w", "u", "v" ].slice(0, t).map(n => `${e}.${n}`);
}

function fn(e, t) {
    return t === 1 ? [ e ] : _b(e, t);
}

var CM = class {
    constructor(e) {
        if (this.variableNames = [ "A" ], this.packedInputs = !1, this.packedOutput = !0, 
        this.outputShape = e, this.rank = e.length, this.enableShapeUniforms = on(this.outputShape.length), 
        this.rank === 0) this.userCode = `
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `; else {
            let t = fn("rc", this.rank), n = ft(this.rank), a = this.getOutOfBoundsCondition(t), r = this.getSetup(t), s = this.getOutput(t);
            this.userCode = `
        void main() {
          ${n} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${s}));
          }
        }
      `;
        }
    }
    getSourceCoordsArr(e) {
        let t = [];
        for (let n = 0; n <= 1; n++) for (let a = 0; a <= 1; a++) {
            let r = `${n === 0 ? "r" : "rp1"}, ${a === 0 ? "c" : "cp1"}`;
            for (let s = 2; s < this.rank; s++) r = `${e[e.length - 1 - s]},` + r;
            t.push(r);
        }
        return t;
    }
    getOutOfBoundsCondition(e) {
        if (this.rank === 1) return `rc > ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]}`;
        let t = "";
        for (let n = this.rank - 2; n < this.rank; n++) t += `${e[n]} >= ${this.enableShapeUniforms ? `outShape[${n}]` : this.outputShape[n]}`, 
        n < this.rank - 1 && (t += "||");
        return t;
    }
    getSetup(e) {
        if (this.rank === 1) return "";
        let t = e.slice(-2), n = this.enableShapeUniforms ? `outShape[${this.rank} - 1]` : this.outputShape[this.rank - 1], a = this.enableShapeUniforms ? `outShape[${this.rank} - 2]` : this.outputShape[this.rank - 2];
        return `
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${a};
    `;
    }
    getOutput(e) {
        let t = this.getSourceCoordsArr(e);
        return this.rank === 1 ? `getA(rc), (rc + 1 >= ${this.enableShapeUniforms ? "outShape" : this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0` : `getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`;
    }
}, Ob = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "inputShape",
            type: "ivec3"
        } ], this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length);
        let n = "";
        for (let a = 0; a < 4; a++) {
            let r = "thisRC = rc;";
            a % 2 == 1 && (r += "thisRC.z += 1;"), a > 1 && (r += "thisRC.y += 1;"), 
            n += `
        ${r}
        ${a > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : ""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a > 0 ? "}" : ""}
      `;
        }
        this.userCode = `
      ${function(a, r) {
            return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r ? I$([ "r", "c", "d" ], "inputShape") : No([ "r", "c", "d" ], a)}
      return ivec3(r, c, d);
    }
  `;
        }(t, this.enableShapeUniforms)}
      ${this.enableShapeUniforms ? `
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
` : a1(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms ? "outShape[1]" : e[1]};
        int cols = ${this.enableShapeUniforms ? "outShape[2]" : e[2]};

        ${n}

        setOutput(result);
      }
    `;
    }
}, TM = class {
    constructor(e) {
        this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, 
        this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, 
        this.logEnabled = !1;
    }
    acquireTexture(e, t, n) {
        let a = Db(t, n), r = zb(e, a, n);
        r in this.freeTextures || (this.freeTextures[r] = []), r in this.usedTextures || (this.usedTextures[r] = []);
        let s, i = Pb(e, a, this.gpgpu.gl, this.gpgpu.textureConfig, n);
        if (this.freeTextures[r].length > 0) {
            this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= i, 
            this.log();
            let l = this.freeTextures[r].pop();
            return this.usedTextures[r].push(l), l;
        }
        return a === Qt.PACKED_2X2_FLOAT32 ? s = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : a === Qt.PACKED_2X2_FLOAT16 ? s = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : a === Qt.UNPACKED_FLOAT32 ? s = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : a === Qt.UNPACKED_FLOAT16 ? s = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : a === Qt.PACKED_4X1_UNSIGNED_BYTE && (s = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), 
        this.usedTextures[r].push(s), this.numUsedTextures++, this._numBytesAllocated += i, 
        this.log(), s;
    }
    releaseTexture(e, t, n, a) {
        if (this.freeTextures == null) return;
        let r = Db(n, a), s = zb(t, r, a);
        s in this.freeTextures || (this.freeTextures[s] = []);
        let i = Pb(t, r, this.gpgpu.gl, this.gpgpu.textureConfig, a), l = H().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");
        l !== -1 && this._numBytesAllocated > l ? (this.gpgpu.deleteMatrixTexture(e.texture), 
        this._numBytesAllocated -= i) : (this.freeTextures[s].push(e), this.numFreeTextures++, 
        this._numBytesFree += i), this.numUsedTextures--;
        let o = this.usedTextures[s], p = o && o.indexOf(e);
        if (p == null || p < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
        o[p] = o[o.length - 1], o.pop(), this.log();
    }
    log() {
        this.logEnabled && (this.numFreeTextures, this.numUsedTextures, this._numBytesFree, 
        this._numBytesAllocated);
    }
    get numBytesAllocated() {
        return this._numBytesAllocated;
    }
    get numBytesFree() {
        return this._numBytesFree;
    }
    getNumUsedTextures() {
        return this.numUsedTextures;
    }
    getNumFreeTextures() {
        return this.numFreeTextures;
    }
    dispose() {
        if (this.freeTextures != null) {
            for (let e in this.freeTextures) this.freeTextures[e].forEach(t => {
                this.gpgpu.deleteMatrixTexture(t.texture);
            });
            for (let e in this.usedTextures) this.usedTextures[e].forEach(t => {
                this.gpgpu.deleteMatrixTexture(t.texture);
            });
            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, 
            this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0;
        }
    }
};

function Pb(e, t, n, a, r) {
    let s, i = function(o, p) {
        switch (o) {
          case Qt.PACKED_2X2_FLOAT32:
            return l1(p);

          case Qt.PACKED_2X2_FLOAT16:
            return u1(p);

          case Qt.UNPACKED_FLOAT32:
            return s1(p);

          case Qt.UNPACKED_FLOAT16:
            return i1(p);

          case Qt.PACKED_4X1_UNSIGNED_BYTE:
            return o1(p);

          default:
            throw new Error(`Unknown physical texture type ${o}`);
        }
    }(t, a);
    if (r) {
        let [ o, p ] = uu(e[0], e[1]);
        s = o * p;
    } else {
        let [ o, p ] = qd(e[0], e[1]);
        s = o * p;
    }
    let l = function(o, p) {
        let u = o;
        if (p === u.R32F) return 4;
        if (p === u.R16F) return 2;
        if (p === u.RGBA32F || p === o.RGBA) return 16;
        if (p === u.RGBA16F) return 8;
        if (p === u.RGBA8) return 4;
        throw new Error(`Unknown internal format ${p}`);
    }(n, i);
    return s * l;
}

function Db(e, t) {
    if (e === Qn.UPLOAD) return Qt.PACKED_2X2_FLOAT32;
    if (e === Qn.RENDER || e == null) return function(n) {
        return H().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? n ? Qt.PACKED_2X2_FLOAT32 : Qt.UNPACKED_FLOAT32 : n ? Qt.PACKED_2X2_FLOAT16 : Qt.UNPACKED_FLOAT16;
    }(t);
    if (e === Qn.DOWNLOAD || e === Qn.PIXELS) return Qt.PACKED_4X1_UNSIGNED_BYTE;
    throw new Error(`Unknown logical texture type ${e}`);
}

function zb(e, t, n) {
    return `${e[0]}_${e[1]}_${t}_${n}`;
}

var Ba = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length), 
        this.userCode = `
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
}, ca = "if (isnan(x)) return x;", RM = "return x;", Lb = "return abs(x);", EM = "return (x >= 0.0) ? x : (exp(x) - 1.0);", $M = ca + `
  return (x < 0.0) ? 0.0 : x;
`, MM = ca + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`, Ur = "return x;", FM = "return 1.0 / (1.0 + exp(-1.0 * x));", _M = "return x;", OM = `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`, PM = `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, DM = `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`, zM = "return 1.0 / (1.0 + exp(-1.0 * x));", Gr = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length), 
        this.userCode = `
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `;
    }
}, LM = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !1, 
        this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length);
        let t = e.length, n = fn("rc", t), a = ft(t), r = function(l, o) {
            if (l === 1) return "rc";
            let p = "";
            for (let u = 0; u < l; u++) p += o[u], u < l - 1 && (p += ",");
            return p;
        }(t, n), s = n.slice(-2), i = t <= 1 ? "rc" : `vec2(${s.join(",")})`;
        this.userCode = `
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${i}));
      }
    `;
    }
}, WM = ua.whereImpl, p1 = {}, BM = H().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"), Wc = class y6 extends al {
    nextDataId() {
        return y6.nextDataId++;
    }
    constructor(t) {
        if (super(), this.pendingRead = new WeakMap(), this.pendingDisposal = new WeakSet(), 
        this.dataRefCount = new WeakMap(), this.numBytesInGPU = 0, this.uploadWaitMs = 0, 
        this.downloadWaitMs = 0, this.lastGlFlushTime = 0, this.warnedAboutMemory = !1, 
        this.pendingDeletes = 0, this.disposed = !1, !H().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
        let n;
        if (t != null) {
            if (t instanceof Qd) n = t; else {
                let a = Sa(H().getNumber("WEBGL_VERSION"), t);
                n = new Qd(a);
            }
            this.binaryCache = {}, this.gpgpuCreatedLocally = !1;
        } else {
            let a = Sa(H().getNumber("WEBGL_VERSION"));
            n = new Qd(a), this.binaryCache = function(r) {
                return r in p1 || (p1[r] = {}), p1[r];
            }(H().getNumber("WEBGL_VERSION")), this.gpgpuCreatedLocally = !0;
        }
        this.gpgpu = n, this.canvas = this.gpgpu.gl.canvas, this.textureManager = new TM(this.gpgpu), 
        this.numMBBeforeWarning = H().global.screen == null ? 1024 : H().global.screen.height * H().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, 
        this.texData = new Wu(this, Mt());
    }
    numDataIds() {
        return this.texData.numDataIds() - this.pendingDeletes;
    }
    writeTexture(t, n, a, r, s, i) {
        let l = this.makeTensorInfo(n, a), o = this.texData.get(l.dataId);
        o.isPacked = !1, o.texture = {
            texture: t,
            texShape: [ r, s ]
        }, o.texShape = [ r, s ];
        let p = Zd(n), u = new hb(p, !1, i), c = this.runWebGLProgram(u, [ l ], a, [ [ r, s ] ]);
        return c.shape = n, o.texture = null, this.disposeIntermediateTensorInfo(l), 
        c.dataId;
    }
    write(t, n, a) {
        if ((H().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || H().getBool("DEBUG")) && this.checkNumericalProblems(t), 
        a === "complex64" && t != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        let r = {
            id: this.nextDataId()
        };
        return this.texData.set(r, {
            shape: n,
            dtype: a,
            values: t,
            usage: Qn.UPLOAD,
            refCount: 1
        }), r;
    }
    refCount(t) {
        return this.texData.has(t) ? this.texData.get(t).refCount : 0;
    }
    incRef(t) {
        this.texData.get(t).refCount++;
    }
    decRef(t) {
        this.texData.has(t) && this.texData.get(t).refCount--;
    }
    move(t, n, a, r, s) {
        if (H().getBool("DEBUG") && this.checkNumericalProblems(n), r === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.texData.set(t, {
            shape: a,
            dtype: r,
            values: n,
            usage: Qn.UPLOAD,
            refCount: s
        });
    }
    disposeIntermediateTensorInfo(t) {
        this.disposeData(t.dataId);
    }
    readSync(t) {
        let n = this.texData.get(t), {
            values: a,
            dtype: r,
            complexTensorInfos: s,
            slice: i,
            shape: l,
            isPacked: o
        } = n;
        if (i != null) {
            let d;
            d = o ? new Gr(l, Ur) : new Ba(l, Ur);
            let h = this.runWebGLProgram(d, [ {
                dataId: t,
                shape: l,
                dtype: r
            } ], r), f = this.readSync(h.dataId);
            return this.disposeIntermediateTensorInfo(h), f;
        }
        if (a != null) return this.convertAndCacheOnCPU(t);
        if (r === "string") return a;
        let p, u, c = this.activeTimers != null;
        if (c && (p = k.now()), r === "complex64") {
            let d = this.readSync(s.real.dataId), h = this.readSync(s.imag.dataId);
            u = C.mergeRealAndImagArrays(d, h);
        } else u = this.getValuesFromTexture(t);
        return c && (this.downloadWaitMs += k.now() - p), this.convertAndCacheOnCPU(t, u);
    }
    async read(t) {
        if (this.pendingRead.has(t)) {
            let f = this.pendingRead.get(t);
            return new Promise(m => f.push(m));
        }
        let n = this.texData.get(t), {
            values: a,
            shape: r,
            slice: s,
            dtype: i,
            complexTensorInfos: l,
            isPacked: o
        } = n;
        if (s != null) {
            let f;
            f = o ? new Gr(r, Ur) : new Ba(r, Ur);
            let m = this.runWebGLProgram(f, [ {
                dataId: t,
                shape: r,
                dtype: i
            } ], i), g = this.read(m.dataId);
            return this.disposeIntermediateTensorInfo(m), g;
        }
        if (a != null) return this.convertAndCacheOnCPU(t);
        if (H().getBool("DEBUG") && !H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") && H().getNumber("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
        let p, u, c = null;
        if (i !== "complex64" && H().get("WEBGL_BUFFER_SUPPORTED")) {
            p = this.decode(t);
            let f = this.texData.get(p.dataId);
            c = this.gpgpu.createBufferFromTexture(f.texture.texture, ...Fc(r));
        }
        if (this.pendingRead.set(t, []), i !== "complex64" && await this.gpgpu.createAndWaitForFence(), 
        i === "complex64") {
            let f = await Promise.all([ this.read(l.real.dataId), this.read(l.imag.dataId) ]), m = f[0], g = f[1];
            u = C.mergeRealAndImagArrays(m, g);
        } else if (c == null) u = this.getValuesFromTexture(t); else {
            let f = k.sizeFromShape(r);
            u = this.gpgpu.downloadFloat32MatrixFromBuffer(c, f);
        }
        if (p != null && this.disposeIntermediateTensorInfo(p), c != null) {
            let f = this.gpgpu.gl;
            fe(f, () => f.deleteBuffer(c));
        }
        let d = this.convertAndCacheOnCPU(t, u), h = this.pendingRead.get(t);
        return this.pendingRead.delete(t), h.forEach(f => f(d)), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), 
        this.disposeData(t) && Mt().removeDataId(t, this), this.pendingDeletes--), 
        d;
    }
    readToGPU(t, n = {}) {
        let a = this.texData.get(t), {
            values: r,
            shape: s,
            slice: i,
            dtype: l,
            isPacked: o,
            texture: p
        } = a;
        if (l === "complex64") throw new Error("Does not support reading texture for complex64 dtype.");
        if (i != null) {
            let h;
            h = o ? new Gr(s, Ur) : new Ba(s, Ur);
            let f = this.runWebGLProgram(h, [ {
                dataId: t,
                shape: s,
                dtype: l
            } ], l), m = this.readToGPU(f, n);
            return this.disposeIntermediateTensorInfo(f), m;
        }
        if (p == null) throw r != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
        let u = this.decode(t, n.customTexShape), c = Mt().makeTensorFromTensorInfo(u), d = this.texData.get(u.dataId);
        return Object.assign({
            tensorRef: c
        }, d.texture);
    }
    bufferSync(t) {
        let n = this.readSync(t.dataId);
        if (t.dtype === "string") try {
            let a = n.map(r => k.decodeString(r));
            return We(t.shape, t.dtype, a);
        } catch {
            throw new Error("Failed to decode encoded string bytes into utf-8");
        }
        return We(t.shape, t.dtype, n);
    }
    checkNumericalProblems(t) {
        if (t != null) for (let n = 0; n < t.length; n++) {
            let a = t[n];
            if (!D5(a)) throw H().getBool("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error(`The value ${a} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`) : Error(`The value ${a} cannot be represented on this device.`);
        }
    }
    getValuesFromTexture(t) {
        let {
            shape: n,
            dtype: a,
            isPacked: r
        } = this.texData.get(t), s = k.sizeFromShape(n);
        if (H().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
            let d = this.decode(t), h = this.texData.get(d.dataId), f = this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture, ...Fc(n)).subarray(0, s);
            return this.disposeIntermediateTensorInfo(d), f;
        }
        let i = H().getBool("WEBGL_PACK") && r === !0, l = i ? Zd(n) : n, o = i ? new F$(l) : new M$(l), p = this.runWebGLProgram(o, [ {
            shape: l,
            dtype: a,
            dataId: t
        } ], "float32"), u = this.texData.get(p.dataId), c = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture, u.texShape[0], u.texShape[1]).subarray(0, s);
        return this.disposeIntermediateTensorInfo(p), c;
    }
    timerAvailable() {
        return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
    }
    time(t) {
        let n = this.activeTimers, a = [], r = !1;
        this.programTimersStack == null ? (this.programTimersStack = a, r = !0) : this.activeTimers.push(a), 
        this.activeTimers = a, t();
        let s = k.flatten(this.activeTimers.map(o => o.query)).filter(o => o != null), i = k.flatten(this.activeTimers.map(o => o.name)).filter(o => o != null);
        this.activeTimers = n, r && (this.programTimersStack = null);
        let l = {
            uploadWaitMs: this.uploadWaitMs,
            downloadWaitMs: this.downloadWaitMs,
            kernelMs: null,
            wallMs: null
        };
        return (async () => {
            if (H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
                let o = await Promise.all(s);
                l.kernelMs = k.sum(o), l.getExtraProfileInfo = () => o.map((p, u) => ({
                    name: i[u],
                    ms: p
                })).map(p => `${p.name}: ${p.ms}`).join(", ");
            } else l.kernelMs = {
                error: "WebGL query timers are not supported in this environment."
            };
            return this.uploadWaitMs = 0, this.downloadWaitMs = 0, l;
        })();
    }
    memory() {
        return {
            unreliable: !1,
            numBytesInGPU: this.numBytesInGPU,
            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
            numBytesInGPUFree: this.textureManager.numBytesFree
        };
    }
    startTimer() {
        return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
            startMs: k.now(),
            endMs: null
        };
    }
    endTimer(t) {
        return H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), 
        t) : (t.endMs = k.now(), t);
    }
    async getQueryTime(t) {
        if (H().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this.gpgpu.waitForQueryAndGetTime(t);
        let n = t;
        return n.endMs - n.startMs;
    }
    disposeData(t, n = !1) {
        if (this.pendingDisposal.has(t)) return !1;
        if (!this.texData.has(t)) return !0;
        if (n ? this.texData.get(t).refCount = 0 : this.texData.get(t).refCount--, 
        !n && this.texData.get(t).refCount > 0) return !1;
        if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), this.pendingDeletes++, 
        !1;
        this.releaseGPUData(t);
        let {
            complexTensorInfos: a
        } = this.texData.get(t);
        return a != null && (this.disposeData(a.real.dataId, n), this.disposeData(a.imag.dataId, n)), 
        this.texData.delete(t), !0;
    }
    releaseGPUData(t) {
        let {
            texture: n,
            dtype: a,
            texShape: r,
            usage: s,
            isPacked: i,
            slice: l
        } = this.texData.get(t), o = l && l.origDataId || t, p = this.dataRefCount.get(o);
        p > 1 ? this.dataRefCount.set(o, p - 1) : (this.dataRefCount.delete(o), 
        n != null && (this.numBytesInGPU -= this.computeBytes(r, a), this.textureManager.releaseTexture(n, r, s, i)));
        let u = this.texData.get(t);
        u.texture = null, u.texShape = null, u.isPacked = !1, u.slice = null;
    }
    getTexture(t) {
        return this.uploadToGPU(t), this.texData.get(t).texture.texture;
    }
    getDataInfo(t) {
        return this.texData.get(t);
    }
    shouldExecuteOnCPU(t, n = BM) {
        return H().getBool("WEBGL_CPU_FORWARD") && t.every(a => this.texData.get(a.dataId).texture == null && k.sizeFromShape(a.shape) < n);
    }
    getGPGPUContext() {
        return this.gpgpu;
    }
    where(t) {
        C.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
        let n = t.dataSync();
        return WM(t.shape, n);
    }
    packedUnaryOp(t, n, a) {
        let r = new Gr(t.shape, n), s = this.compileAndRun(r, [ t ], a);
        return Mt().makeTensorFromTensorInfo(s);
    }
    abs(t) {
        if (this.shouldExecuteOnCPU([ t ]) && t.dtype !== "complex64") {
            let r = Mb(this.texData.get(t.dataId).values);
            return this.makeOutput(t.shape, t.dtype, r);
        }
        if (H().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(t, Lb, t.dtype);
        let n = new Ba(t.shape, Lb), a = this.compileAndRun(n, [ t ]);
        return Mt().makeTensorFromTensorInfo(a);
    }
    makeTensorInfo(t, n, a) {
        let r;
        if (n === "string" && a != null && a.length > 0 && k.isString(a[0])) {
            let s = a.map(i => k.encodeString(i));
            r = this.write(s, t, n);
        } else r = this.write(a, t, n);
        return this.texData.get(r).usage = null, {
            dataId: r,
            shape: t,
            dtype: n
        };
    }
    makeOutput(t, n, a) {
        return Mt().makeTensorFromTensorInfo(this.makeTensorInfo(t, n, a), this);
    }
    unpackTensor(t) {
        let n = new LM(t.shape);
        return this.runWebGLProgram(n, [ t ], t.dtype);
    }
    packTensor(t) {
        let n = new CM(t.shape);
        return this.runWebGLProgram(n, [ t ], t.dtype, null, !0);
    }
    packedReshape(t, n) {
        let a = [ Io(t.shape), ...So(t.shape) ], r = {
            dtype: t.dtype,
            shape: a,
            dataId: t.dataId
        }, s = [ Io(n), ...So(n) ], i = new Ob(s, a), l = [ a ], o = this.runWebGLProgram(i, [ r ], t.dtype, l, !0);
        return {
            dataId: o.dataId,
            shape: n,
            dtype: o.dtype
        };
    }
    decode(t, n) {
        let a = this.texData.get(t), {
            isPacked: r,
            shape: s,
            dtype: i
        } = a;
        if (n != null) {
            let u = k.sizeFromShape(s), c = n[0] * n[1] * 4;
            k.assert(u <= c, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
        }
        let l, o = Zd(s);
        l = r ? new $$(o) : new E$(o);
        let p = [ n ?? Fc(o) ];
        return {
            dtype: i,
            shape: s,
            dataId: this.runWebGLProgram(l, [ {
                shape: o,
                dtype: i,
                dataId: t
            } ], i, p, !0, n).dataId
        };
    }
    runWebGLProgram(t, n, a, r, s = !1, i) {
        let l = this.makeTensorInfo(t.outputShape, a), o = this.texData.get(l.dataId);
        if (t.packedOutput && (o.isPacked = !0), t.outPackingScheme === jd.DENSE) {
            let y = i ?? Fc(t.outputShape);
            o.texShape = y.map(A => 2 * A);
        }
        if (t.outTexUsage != null && (o.usage = t.outTexUsage), k.sizeFromShape(l.shape) === 0) return o.values = k.getTypedArrayFromDType(l.dtype, 0), 
        l;
        let p = [], u = n.map(y => {
            if (y.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
            let A = this.texData.get(y.dataId);
            if (A.texture == null) {
                if (!t.packedInputs && k.sizeFromShape(y.shape) <= H().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                    shape: y.shape,
                    texData: null,
                    isUniform: !0,
                    uniformValues: A.values
                };
                t.packedInputs && (A.isPacked = !0, A.shape = y.shape);
            }
            if (this.uploadToGPU(y.dataId), !!A.isPacked != !!t.packedInputs) y = A.isPacked ? this.unpackTensor(y) : this.packTensor(y), 
            p.push(y), A = this.texData.get(y.dataId); else if (A.isPacked && !Yd(A.shape, y.shape)) {
                let x = y, b = y.shape;
                y.shape = A.shape, y = this.packedReshape(y, b), p.push(y), A = this.texData.get(y.dataId), 
                x.shape = b;
            }
            return {
                shape: y.shape,
                texData: A,
                isUniform: !1
            };
        });
        this.uploadToGPU(l.dataId);
        let c, d = {
            shape: l.shape,
            texData: o,
            isUniform: !1
        }, h = function(y, A, x) {
            let b = "";
            A.concat(x).forEach(N => {
                let T = N.texData != null && N.texData.slice != null && N.texData.slice.flatOffset > 0;
                if (y.enableShapeUniforms && !N.isUniform) {
                    let R = N.texData.texShape, {
                        useSqueezeShape: w,
                        uniformShape: E,
                        keptDims: $
                    } = r1(y.packedInputs, N.shape, R), M = "", F = "", P = "";
                    if (E.length === 1 && y.packedInputs) {
                        let X = [ Math.ceil(R[0] / 2), Math.ceil(R[1] / 2) ];
                        M = `${X[0] > 1}_${X[1] > 1}`;
                    } else if (E.length !== 2 || y.packedInputs) {
                        if (E.length > 2 && !y.packedInputs) {
                            let X = k.computeStrides(E);
                            P = `${X[0] === R[1]}_${X[X.length - 1] === R[1]}`;
                        }
                    } else F = `${E[0] > 1}_${E[1] > 1}`;
                    let L = N.shape.length, O = E.length === 2 && k.arraysEqual(N.shape, R), B = k.sizeFromShape(N.shape) === 1, G = C.getBroadcastDims(N.shape, x.shape), W = !y.packedInputs && L === x.shape.length && k.arraysEqual(R, x.texData.texShape), z = y.packedInputs || E.length > 2 ? "" : `${R[0] > 1}_${R[1] > 1}`;
                    b += `${L}_${W}_${w ? $ : ""}_${E.length}_${B}_${G}_${O}_${M}_${F}_${P}_${z}_${T}`;
                } else {
                    let R = N.isUniform ? "uniform" : N.texData.texShape;
                    b += `${N.shape}_${R}_${T}`;
                }
            });
            let v = y.userCode, I = y.constructor.name;
            return I += "_" + b + "_" + v + `${H().getNumber("WEBGL_VERSION")}`, 
            I;
        }(t, u, d), f = this.getAndSaveBinary(h, () => function(y, A, x, b) {
            let v = x.map((E, $) => {
                let M = {
                    logicalShape: E.shape,
                    texShape: E.isUniform ? null : E.texData.texShape,
                    isUniform: E.isUniform,
                    isPacked: !E.isUniform && E.texData.isPacked,
                    flatOffset: null
                };
                return E.texData != null && E.texData.slice != null && E.texData.slice.flatOffset > 0 && (M.flatOffset = E.texData.slice.flatOffset), 
                {
                    name: A.variableNames[$],
                    shapeInfo: M
                };
            }), I = v.map(E => E.shapeInfo), N = {
                logicalShape: b.shape,
                texShape: b.texData.texShape,
                isUniform: !1,
                isPacked: b.texData.isPacked,
                flatOffset: null
            }, T = S$(v, N, A), R = W5(y.gl, T), w = y.createProgram(R);
            return H().get("ENGINE_COMPILE_ONLY") ? {
                program: A,
                fragmentShader: R,
                source: T,
                webGLProgram: w,
                inShapeInfos: I,
                outShapeInfo: N,
                variablesLocations: null,
                customUniformLocations: null,
                infLoc: null,
                nanLoc: null,
                outShapeLocation: null,
                outShapeStridesLocation: null,
                outTexShapeLocation: null
            } : (y.buildVao(w), Object.assign({
                program: A,
                fragmentShader: R,
                source: T,
                webGLProgram: w,
                inShapeInfos: I,
                outShapeInfo: N
            }, pb(y, A, w)));
        }(this.gpgpu, t, u, d)), m = this.activeTimers != null;
        m && (c = this.startTimer()), H().get("ENGINE_COMPILE_ONLY") || function(y, A, x, b, v) {
            A.program.enableShapeUniforms || (cb(A.inShapeInfos, x), cb([ A.outShapeInfo ], [ b ]));
            let I = b.texData.texture, N = b.texData.texShape;
            b.texData.isPacked ? y.setOutputPackedMatrixTexture(I.texture, N[0], N[1]) : y.setOutputMatrixTexture(I.texture, N[0], N[1]), 
            y.setProgram(A.webGLProgram), y.bindVertexArray(A.webGLProgram.vao), 
            H().getNumber("WEBGL_VERSION") === 1 && A.infLoc !== null && y.gl.uniform1f(A.infLoc, 1 / 0), 
            A.nanLoc !== null && y.gl.uniform1f(A.nanLoc, NaN);
            for (let R = 0; R < x.length; ++R) {
                let w = x[R], {
                    uniform: E,
                    offset: $,
                    shape: M,
                    texShape: F
                } = A.variablesLocations[R];
                if (M) {
                    let {
                        uniformShape: P
                    } = r1(A.program.packedInputs, w.shape, w.texData.texShape);
                    switch (P.length) {
                      case 1:
                        y.gl.uniform1iv(M, new Int32Array(P));
                        break;

                      case 2:
                        y.gl.uniform2iv(M, new Int32Array(P));
                        break;

                      case 3:
                        y.gl.uniform3iv(M, new Int32Array(P));
                        break;

                      case 4:
                        y.gl.uniform4iv(M, new Int32Array(P));
                    }
                }
                if (F && y.gl.uniform2i(F, w.texData.texShape[0], w.texData.texShape[1]), 
                E != null) {
                    if (w.isUniform) {
                        if (k.sizeFromShape(w.shape) < 2) y.gl.uniform1f(E, w.uniformValues[0]); else {
                            let P = w.uniformValues;
                            P instanceof Float32Array || (P = new Float32Array(P)), 
                            y.gl.uniform1fv(E, P);
                        }
                        continue;
                    }
                    w.texData.slice != null && $ != null && y.gl.uniform1i($, w.texData.slice.flatOffset), 
                    y.setInputMatrixTexture(w.texData.texture.texture, E, R);
                }
            }
            let T = A.outShapeLocation;
            if (T) switch (b.shape.length) {
              case 1:
                y.gl.uniform1iv(T, new Int32Array(b.shape));
                break;

              case 2:
                y.gl.uniform2iv(T, new Int32Array(b.shape));
                break;

              case 3:
                y.gl.uniform3iv(T, new Int32Array(b.shape));
                break;

              case 4:
                y.gl.uniform4iv(T, new Int32Array(b.shape));
            }
            if (A.outShapeStridesLocation) {
                let R = k.computeStrides(b.shape);
                switch (b.shape.length) {
                  case 2:
                    y.gl.uniform1iv(A.outShapeStridesLocation, new Int32Array(R));
                    break;

                  case 3:
                    y.gl.uniform2iv(A.outShapeStridesLocation, new Int32Array(R));
                    break;

                  case 4:
                    y.gl.uniform3iv(A.outShapeStridesLocation, new Int32Array(R));
                }
            }
            if (A.outTexShapeLocation && y.gl.uniform2i(A.outTexShapeLocation, b.texData.texShape[0], b.texData.texShape[1]), 
            A.program.customUniforms && v) for (let R = 0; R < A.program.customUniforms.length; ++R) {
                let w = A.program.customUniforms[R], E = A.customUniformLocations[R], $ = v[R];
                if (w.type === "float") y.gl.uniform1fv(E, $); else if (w.type === "vec2") y.gl.uniform2fv(E, $); else if (w.type === "vec3") y.gl.uniform3fv(E, $); else if (w.type === "vec4") y.gl.uniform4fv(E, $); else if (w.type === "int") y.gl.uniform1iv(E, $); else if (w.type === "ivec2") y.gl.uniform2iv(E, $); else if (w.type === "ivec3") y.gl.uniform3iv(E, $); else {
                    if (w.type !== "ivec4") throw Error(`uniform type ${w.type} is not supported yet.`);
                    y.gl.uniform4iv(E, $);
                }
            }
            y.executeProgram();
        }(this.gpgpu, f, u, d, r), p.forEach(y => this.disposeIntermediateTensorInfo(y)), 
        m && (c = this.endTimer(c), this.activeTimers.push({
            name: t.constructor.name,
            query: this.getQueryTime(c)
        }));
        let g = H().getNumber("WEBGL_FLUSH_THRESHOLD");
        if (g > 0) {
            let y = k.now();
            y - this.lastGlFlushTime > g && (this.gpgpu.gl.flush(), this.lastGlFlushTime = y);
        }
        if (!H().getBool("WEBGL_LAZILY_UNPACK") && o.isPacked && s === !1) {
            let y = this.unpackTensor(l);
            return this.disposeIntermediateTensorInfo(l), y;
        }
        return l;
    }
    compileAndRun(t, n, a, r, s = !1) {
        return a = a || n[0].dtype, this.runWebGLProgram(t, n, a, r, s);
    }
    getAndSaveBinary(t, n) {
        return t in this.binaryCache || (this.binaryCache[t] = n()), this.binaryCache[t];
    }
    getTextureManager() {
        return this.textureManager;
    }
    dispose() {
        this.disposed || (H().getBool("IS_TEST") || Object.keys(this.binaryCache).forEach(t => {
            this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram), delete this.binaryCache[t];
        }), this.textureManager.dispose(), this.canvas != null && typeof HTMLCanvasElement < "u" && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, 
        this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), 
        this.disposed = !0);
    }
    floatPrecision() {
        return this.floatPrecisionValue == null && (this.floatPrecisionValue = qe(() => {
            if (!H().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                let t = H().getBool("DEBUG");
                H().set("DEBUG", !1);
                let n = this.abs(je(1e-8)).dataSync()[0];
                if (H().set("DEBUG", t), n > 0) return 32;
            }
            return 16;
        })), this.floatPrecisionValue;
    }
    epsilon() {
        return this.floatPrecision() === 32 ? 1e-7 : 1e-4;
    }
    uploadToGPU(t) {
        let n = this.texData.get(t), {
            shape: a,
            dtype: r,
            values: s,
            texture: i,
            usage: l,
            isPacked: o
        } = n;
        if (i != null) return;
        let p, u = this.activeTimers != null;
        u && (p = k.now());
        let c = n.texShape;
        if (c == null && (c = eb(a, o), n.texShape = c), s != null) {
            let d, h = Zd(a), f = c[1], m = c[0], g = s instanceof Uint8Array || s instanceof Uint8ClampedArray;
            (o || !g) && ([ f, m ] = uu(c[0], c[1])), d = o ? new O$(h, g) : new hb(h, g);
            let y = g ? [ m, f ] : c, A = this.makeTensorInfo(y, r), x = this.texData.get(A.dataId);
            x.usage = g ? Qn.PIXELS : Qn.UPLOAD, x.texShape = y, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(A.dataId), f, m, s);
            let b = [ [ m, f ] ], v = this.runWebGLProgram(d, [ A ], r, b, !0), I = this.texData.get(v.dataId);
            n.texShape = I.texShape, n.isPacked = I.isPacked, n.usage = I.usage, 
            H().get("ENGINE_COMPILE_ONLY") ? this.disposeData(v.dataId) : (n.texture = I.texture, 
            n.values = null, this.texData.delete(v.dataId)), this.disposeIntermediateTensorInfo(A), 
            u && (this.uploadWaitMs += k.now() - p);
        } else {
            let d = this.acquireTexture(c, l, r, o);
            n.texture = d;
        }
    }
    convertAndCacheOnCPU(t, n) {
        let a = this.texData.get(t), {
            dtype: r
        } = a;
        return n != null && (a.values = function(s, i) {
            if (i === "float32" || i === "complex64") return s;
            if (i === "int32" || i === "bool") {
                let l = i === "int32" ? new Int32Array(s.length) : new Uint8Array(s.length);
                for (let o = 0; o < l.length; ++o) l[o] = Math.round(s[o]);
                return l;
            }
            throw new Error(`Unknown dtype ${i}`);
        }(n, r)), a.values;
    }
    acquireTexture(t, n, a, r) {
        return this.numBytesInGPU += this.computeBytes(t, a), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024 && ((this.numBytesInGPU / 1024 / 1024).toFixed(2), 
        this.warnedAboutMemory = !0), this.textureManager.acquireTexture(t, n, r);
    }
    computeBytes(t, n) {
        return t[0] * t[1] * k.bytesPerElement(n);
    }
    checkCompileCompletion() {
        for (let [ , t ] of Object.entries(this.binaryCache)) this.checkCompletion_(t);
    }
    async checkCompileCompletionAsync() {
        let t = [];
        if (this.gpgpu.parallelCompilationExtension) {
            for (let [ , n ] of Object.entries(this.binaryCache)) t.push(this.checkCompletionAsync_(n));
            return Promise.all(t);
        }
        for (let [ , n ] of Object.entries(this.binaryCache)) {
            let a = new Promise(r => {
                try {
                    this.checkCompletion_(n), r(!0);
                } catch (s) {
                    throw s;
                }
            });
            t.push(a);
        }
        return Promise.all(t);
    }
    async checkCompletionAsync_(t) {
        return this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR) ? this.checkCompletion_(t) : (await HA(), 
        this.checkCompletionAsync_(t));
    }
    checkCompletion_(t) {
        if (this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.gl.LINK_STATUS) === !1) throw this.gpgpu.gl.getShaderParameter(t.fragmentShader, this.gpgpu.gl.COMPILE_STATUS) === !1 ? (Jm(t.source, this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)), 
        new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
        return !0;
    }
    getUniformLocations() {
        for (let t of Object.values(this.binaryCache)) {
            this.gpgpu.buildVao(t.webGLProgram);
            let {
                variablesLocations: n,
                customUniformLocations: a,
                infLoc: r,
                nanLoc: s,
                outShapeLocation: i,
                outShapeStridesLocation: l,
                outTexShapeLocation: o
            } = pb(this.gpgpu, t.program, t.webGLProgram);
            t.variablesLocations = n, t.customUniformLocations = a, t.infLoc = r, 
            t.nanLoc = s, t.outShapeLocation = i, t.outShapeStridesLocation = l, 
            t.outTexShapeLocation = o;
        }
    }
    createTensorFromGPUData(t, n, a) {
        t.channels = t.channels || "RGBA";
        let {
            texture: r,
            height: s,
            width: i,
            channels: l
        } = t, o = Mt().backend;
        if (!o.gpgpu.gl.isTexture(r)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
        let p = o.writeTexture(r, n, a, s, i, l);
        return Mt().makeTensorFromDataId(p, n, a, o);
    }
};

Wc.nextDataId = 0;

var VM = "4.17.0";

function Wb() {
    H().set("WEBGL_FORCE_F16_TEXTURES", !0);
}

Id.isBrowser() && ql("webgl", () => new Wc(), 2);

var UM = {
    forceHalfFloat: Wb
}, c1 = `
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`, To = class {
    constructor(e, t, n) {
        this.variableNames = [ "A", "B" ], this.outputShape = C.assertAndGetBroadcastShape(t, n), 
        this.enableShapeUniforms = on(this.outputShape.length), this.userCode = `
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `;
    }
}, Ro = `
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`, mu = class {
    constructor(e, t, n, a = !1) {
        this.variableNames = [ "A", "B" ], this.supportsBroadcasting = !0, this.packedInputs = !0, 
        this.packedOutput = !0, this.outputShape = C.assertAndGetBroadcastShape(t, n);
        let r = this.outputShape.length;
        this.enableShapeUniforms = on(r);
        let s = "";
        if (a) if (r === 0 || k.sizeFromShape(this.outputShape) === 1) s = `
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `; else if (s = `
          ${ft(r)} coords = getOutputCoords();
        `, r === 1) this.enableShapeUniforms ? s += `
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          ` : s += `
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `; else {
            let i = fn("coords", r);
            this.enableShapeUniforms ? s += `
            bool nextRowOutOfBounds =
              (${i[r - 2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${i[r - 1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          ` : s += `
            bool nextRowOutOfBounds =
              (${i[r - 2]} + 1) >= ${this.outputShape[r - 2]};
            bool nextColOutOfBounds =
              (${i[r - 1]} + 1) >= ${this.outputShape[r - 1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `;
        }
        this.userCode = `
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `;
    }
};

function Hn(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        x: a
    } = t;
    return n.incRef(a.dataId), {
        dataId: a.dataId,
        shape: a.shape,
        dtype: a.dtype
    };
}

var GM = {
    kernelName: Js,
    backendName: "webgl",
    kernelFunc: Hn
};

function Hr(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        real: a,
        imag: r
    } = t, s = n.makeTensorInfo(a.shape, "complex64"), i = n.texData.get(s.dataId), l = Hn({
        inputs: {
            x: a
        },
        backend: n
    }), o = Hn({
        inputs: {
            x: r
        },
        backend: n
    });
    return i.complexTensorInfos = {
        real: l,
        imag: o
    }, s;
}

var HM = {
    kernelName: qu,
    backendName: "webgl",
    kernelFunc: Hr
}, Bb = "return (a < 0.) ? b * a : a;", Vb = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`, jM = {
    kernelName: ni,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            alpha: s
        } = a, i = n.makeTensorInfo([], "float32", k.createScalarValue(s, "float32")), l = H().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new mu(Vb, r.shape, i.shape) : new To(Bb, r.shape, i.shape), o = n.runWebGLProgram(l, [ r, i ], "float32");
        return n.disposeIntermediateTensorInfo(i), o;
    }
}, Ub = "return (a < 0.) ? b * a : a;", Gb = `
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`, qM = {
    kernelName: Ti,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a,
            alpha: r
        } = t, s = H().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new mu(Gb, a.shape, r.shape) : new To(Ub, a.shape, r.shape);
        return n.runWebGLProgram(s, [ a, r ], "float32");
    }
}, gu = "if (isnan(x)) return x;";

function rt({
    opSnippet: e,
    packedOpSnippet: t,
    cpuKernelImpl: n,
    dtype: a
}) {
    return ({
        inputs: r,
        backend: s
    }) => {
        let i, {
            x: l
        } = r, o = s, p = a || l.dtype;
        if (o.shouldExecuteOnCPU([ l ]) && n != null) {
            let u = o.texData.get(l.dataId), c = n(u.values, p);
            return o.makeTensorInfo(l.shape, p, c);
        }
        return i = H().getBool("WEBGL_PACK_UNARY_OPERATIONS") && t != null ? new Gr(l.shape, t) : new Ba(l.shape, e), 
        o.runWebGLProgram(i, [ l ], p);
    };
}

function en({
    opSnippet: e,
    packedOpSnippet: t,
    checkOutOfBounds: n = !1,
    supportsComplex: a = !1,
    cpuKernelImpl: r,
    dtype: s
}) {
    return ({
        inputs: i,
        backend: l
    }) => {
        let {
            a: o,
            b: p
        } = i, u = l;
        if (a && o.dtype === "complex64") {
            let h = u.texData.get(o.dataId), f = u.texData.get(p.dataId), [ m, g ] = [ [ h.complexTensorInfos.real, f.complexTensorInfos.real ], [ h.complexTensorInfos.imag, f.complexTensorInfos.imag ] ].map(A => {
                let [ x, b ] = A, v = {
                    dataId: x.dataId,
                    dtype: x.dtype,
                    shape: o.shape
                }, I = {
                    dataId: b.dataId,
                    dtype: b.dtype,
                    shape: p.shape
                }, N = new To(e, o.shape, p.shape);
                return u.runWebGLProgram(N, [ v, I ], Zt(x.dtype, b.dtype));
            }), y = Hr({
                inputs: {
                    real: m,
                    imag: g
                },
                backend: u
            });
            return u.disposeIntermediateTensorInfo(m), u.disposeIntermediateTensorInfo(g), 
            y;
        }
        let c, d = s || Zt(o.dtype, p.dtype);
        if ((o.dtype === "string" || p.dtype === "string" || u.shouldExecuteOnCPU([ o, p ])) && r != null) {
            let h = u.texData.get(o.dataId).values, f = u.texData.get(p.dataId).values, m = o.dtype === "string" ? C.fromUint8ToStringArray(h) : h, g = o.dtype === "string" ? C.fromUint8ToStringArray(f) : f, [ y, A ] = r(o.shape, p.shape, m, g, d), x = u.makeTensorInfo(A, d);
            return u.texData.get(x.dataId).values = y, x;
        }
        return c = H().getBool("WEBGL_PACK_BINARY_OPERATIONS") && t != null ? new mu(t, o.shape, p.shape, n) : new To(e, o.shape, p.shape), 
        u.runWebGLProgram(c, [ o, p ], d);
    };
}

function ep(e, t = !1) {
    if (e === "linear") return t ? _M : RM;
    if (e === "relu") return t ? PM : $M;
    if (e === "elu") return t ? OM : EM;
    if (e === "relu6") return t ? DM : MM;
    if (e === "prelu") return t ? Gb : Ub;
    if (e === "leakyrelu") return t ? Vb : Bb;
    if (e === "sigmoid") return t ? zM : FM;
    throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`);
}

var Hb = class {
    constructor(e, t, n, a = !1, r = !1, s = !1, i = null, l = !1, o = !1) {
        this.variableNames = [ "matrixA", "matrixB" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outputShape = n, this.enableShapeUniforms = on(this.outputShape.length);
        let p = a ? e[1] : e[2], u = Math.ceil(p / 2), c = a ? "i * 2, rc.y" : "rc.y, i * 2", d = r ? "rc.z, i * 2" : "i * 2, rc.z", h = a ? [ "a.xxyy", "a.zzww" ] : [ "a.xxzz", "a.yyww" ], f = r ? [ "b.xzxz", "b.ywyw" ] : [ "b.xyxy", "b.zwzw" ], m = "", g = "";
        i && (m = l ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }` : o ? `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }` : `vec4 activation(vec4 x) {
          ${i}
        }`, g = "result = activation(result);");
        let y = s ? "result += getBiasAtOutCoords();" : "";
        s && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), 
        o && this.variableNames.push("leakyreluAlpha");
        let A = "rc.x", x = "rc.x";
        e[0] < t[0] ? A = `imod(rc.x, ${e[0]})` : t[0] < e[0] && (x = `imod(rc.x, ${t[0]})`), 
        this.userCode = `
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${u}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${A};
        int batchB = ${x};
        for (int i = 0; i < ${u}; i++) {
          vec4 a = getMatrixA(batchA, ${c});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${f[0]});
          result += (${h[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `;
    }
}, jb = {
    REAL: "return areal * breal - aimag * bimag;",
    IMAG: "return areal * bimag + aimag * breal;"
}, qb = class {
    constructor(e, t, n) {
        this.variableNames = [ "AReal", "AImag", "BReal", "BImag" ], this.outputShape = C.assertAndGetBroadcastShape(t, n), 
        this.userCode = `
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `;
    }
}, Xb = "return a * b;";

function h1(e) {
    let t, {
        inputs: n,
        backend: a
    } = e, {
        a: r,
        b: s
    } = n, i = C.upcastType(r.dtype, s.dtype);
    if (r.dtype === "complex64") {
        let l = a.texData.get(r.dataId), o = a.texData.get(s.dataId), p = new qb(jb.REAL, r.shape, s.shape), u = new qb(jb.IMAG, r.shape, s.shape), c = [ {
            dataId: l.complexTensorInfos.real.dataId,
            dtype: l.complexTensorInfos.real.dtype,
            shape: r.shape
        }, {
            dataId: l.complexTensorInfos.imag.dataId,
            dtype: l.complexTensorInfos.imag.dtype,
            shape: r.shape
        }, {
            dataId: o.complexTensorInfos.real.dataId,
            dtype: o.complexTensorInfos.real.dtype,
            shape: s.shape
        }, {
            dataId: o.complexTensorInfos.imag.dataId,
            dtype: o.complexTensorInfos.imag.dtype,
            shape: s.shape
        } ], d = a.runWebGLProgram(p, c, "float32"), h = a.runWebGLProgram(u, c, "float32"), f = Hr({
            inputs: {
                real: d,
                imag: h
            },
            backend: a
        });
        return a.disposeIntermediateTensorInfo(d), a.disposeIntermediateTensorInfo(h), 
        f;
    }
    if (a.shouldExecuteOnCPU([ r, s ])) {
        let l = a.texData.get(r.dataId), o = a.texData.get(s.dataId), [ p, u ] = aM(r.shape, s.shape, l.values, o.values, i), c = a.makeTensorInfo(u, i);
        return a.texData.get(c.dataId).values = p, c;
    }
    return t = H().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new mu(Xb, r.shape, s.shape) : new To(Xb, r.shape, s.shape), 
    a.runWebGLProgram(t, [ r, s ], i);
}

var XM = {
    kernelName: vi,
    backendName: "webgl",
    kernelFunc: h1
};

function he(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        shape: s
    } = a, i = n, l = k.sizeFromShape(r.shape), o = k.inferFromImplicitShape(s, l), p = k.sizeFromShape(o);
    k.assert(l === p, () => `The new shape (${o}) has ${p} elements and the old shape (${r.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);
    let u = i.texData.get(r.dataId);
    return !u.isPacked || Yd(r.shape, o) || u.texture !== null && Yd(u.shape, o) ? (i.incRef(r.dataId), 
    {
        dataId: r.dataId,
        shape: o,
        dtype: r.dtype
    }) : function(c, d, h) {
        let f = [ Io(c.shape), ...So(c.shape) ], m = {
            dtype: c.dtype,
            shape: f,
            dataId: c.dataId
        }, g = [ Io(d), ...So(d) ], y = new Ob(g, f), A = [ f ], x = h.runWebGLProgram(y, [ m ], c.dtype, A, !0);
        return {
            dataId: x.dataId,
            shape: d,
            dtype: x.dtype
        };
    }(r, o, i);
}

var KM = {
    kernelName: Ml,
    backendName: "webgl",
    kernelFunc: he
}, Kb = class {
    constructor(e, t) {
        this.variableNames = [ "x" ];
        let {
            windowSize: n,
            batchSize: a,
            inSize: r,
            outSize: s
        } = e;
        this.outputShape = [ a, s ];
        let i = 4 * Math.floor(n / 4), l = n % 4, o = "sumValue += dot(values, ones);";
        if (t != null) {
            let u = 1 / t;
            o = `sumValue += dot(values * ${k.isInt(u) ? u.toPrecision(2) : u}, ones);`;
        }
        let p = "";
        r % n > 0 && (p = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `), this.userCode = `
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${o}
        }

        int inIdx = inOffset + ${i};
        if (${l === 1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${o}
        } else if (${l === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${o}
        } else if (${l === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${o}
        }
        setOutput(sumValue);
      }
    `;
    }
}, ZM = class {
    constructor(e, t) {
        this.variableNames = [ "x" ];
        let {
            windowSize: n,
            batchSize: a,
            inSize: r,
            outSize: s
        } = e;
        this.outputShape = [ a, s ];
        let i = "0.0", l = "";
        t === "prod" ? i = "1.0" : t === "min" ? (i = "1.0 / 1e-20", l = "min") : t === "max" && (i = "-1.0 / 1e-20", 
        l = "max");
        let o = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        t === "sum" ? o = "sumValue" : t === "prod" ? o = "prodValue" : t === "all" ? o = "allValue" : t === "any" && (o = "anyValue");
        let p = 4 * Math.floor(n / 4), u = n % 4, c = `
      if (${t === "sum"}) {
        sumValue += dot(values, ones);
      } else if (${t === "prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t === "min"} || ${t === "max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `, d = "vec4";
        t === "all" ? (i = "1.0", c = `
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `, d = "bvec4") : t === "any" && (i = "0.0", c = `
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `, d = "bvec4");
        let h = "";
        r % n > 0 && (h = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `), this.userCode = `
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${p};
        if (${u === 1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${u === 2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${u === 3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${c}
        }
        setOutput(${o});
      }
    `;
    }
};

function Eo(e, t, n, a) {
    let r = function(i) {
        let l = [];
        for (;l.length === 0 || l[l.length - 1].outSize !== 1; ) {
            let o = l.length ? l[l.length - 1].outSize : i[1], p = C.computeOptimalWindowSize(o);
            l.push({
                inSize: o,
                windowSize: p,
                outSize: Math.ceil(o / p)
            });
        }
        return l;
    }(e.shape), s = e;
    for (let i = 0; i < r.length; i++) {
        let l, o, {
            inSize: p,
            windowSize: u,
            outSize: c
        } = r[i];
        l = n === "mean" ? i === 0 ? new Kb({
            windowSize: u,
            inSize: p,
            batchSize: e.shape[0],
            outSize: c
        }, p) : new Kb({
            windowSize: u,
            inSize: p,
            batchSize: e.shape[0],
            outSize: c
        }) : new ZM({
            windowSize: u,
            inSize: p,
            batchSize: e.shape[0],
            outSize: c
        }, n), o = s, s = a.runWebGLProgram(l, [ s ], t), o.dataId !== e.dataId && a.disposeIntermediateTensorInfo(o);
    }
    return s;
}

var YM = class {
    constructor(e, t) {
        this.variableNames = [ "A" ];
        let n = new Array(e.length);
        for (let s = 0; s < n.length; s++) n[s] = e[t[s]];
        this.outputShape = n, this.rank = n.length;
        let a = ft(this.rank), r = function(s) {
            let i = s.length;
            if (i > 6) throw Error(`Transpose for rank ${i} is not yet supported`);
            let l = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v" ], o = new Array(i);
            for (let p = 0; p < s.length; p++) o[s[p]] = l[p];
            return o.join();
        }(t);
        this.userCode = `
    void main() {
      ${a} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `;
    }
}, JM = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0;
        let n = new Array(e.length);
        for (let p = 0; p < n.length; p++) n[p] = e[t[p]];
        if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);
        let a = ft(this.rank), r = _b("rc", this.rank), s = new Array(this.rank);
        for (let p = 0; p < t.length; p++) s[t[p]] = r[p];
        let i = `vec2(${s.slice(-2).join()})`, l = `++${r[this.rank - 1]} < ${n[this.rank - 1]}`, o = `getChannel(getA(${s.join()}), ${i})`;
        this.userCode = `
    void main() {
      ${a} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${o};
      if(${l}) {
        result[1] = ${o};
      }
      --${r[this.rank - 1]};
      if(++${r[this.rank - 2]} < ${n[this.rank - 2]}) {
        result[2] = ${o};
        if(${l}) {
          result[3] = ${o};
        }
      }
      setOutput(result);
    }
    `;
    }
};

function Bc(e, t, n) {
    let a = H().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new JM(e.shape, t) : new YM(e.shape, t);
    return n.runWebGLProgram(a, [ e ], e.dtype);
}

function Vc(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        axis: s,
        keepDims: i
    } = a;
    return function(l, o, p, u) {
        let c = o, d = l.shape.length, h = k.parseAxisParam(c, l.shape), f = h, m = C.getAxesPermutation(f, d), g = m != null, y = l;
        g && (y = Bc(l, m, u), f = C.getInnerMostAxes(f.length, d)), C.assertAxesAreInnerMostDims("sum", f, d);
        let [ A, x ] = C.computeOutAndReduceShapes(y.shape, f), b = A;
        p && (b = C.expandShapeToKeepDim(A, h));
        let v = k.sizeFromShape(x), I = he({
            inputs: {
                x: y
            },
            attrs: {
                shape: [ k.sizeFromShape(l.shape) / v, v ]
            },
            backend: u
        }), N = Eo(I, kd(l.dtype), "sum", u), T = he({
            inputs: {
                x: N
            },
            attrs: {
                shape: b
            },
            backend: u
        });
        return u.disposeIntermediateTensorInfo(I), u.disposeIntermediateTensorInfo(N), 
        g && u.disposeIntermediateTensorInfo(y), T;
    }(r, s, i, n);
}

var QM = {
    kernelName: Xi,
    backendName: "webgl",
    kernelFunc: Vc
};

function mn(e) {
    let t, {
        inputs: n,
        backend: a,
        attrs: r
    } = e, {
        x: s
    } = n, {
        perm: i
    } = r, l = a, o = s.shape.length, p = new Array(o);
    for (let u = 0; u < p.length; u++) p[u] = s.shape[i[u]];
    if (l.shouldExecuteOnCPU([ s ])) {
        let u = l.texData.get(s.dataId).values, c = d1(u, s.shape, s.dtype, i, p);
        t = l.makeTensorInfo(p, s.dtype), l.texData.get(t.dataId).values = c;
    } else t = Bc(s, i, l);
    return t;
}

var eF = {
    kernelName: Xa,
    backendName: "webgl",
    kernelFunc: mn
}, Zb = 1e3;

function Uc({
    a: e,
    b: t,
    transposeA: n,
    transposeB: a,
    backend: r,
    bias: s = null,
    preluActivationWeights: i = null,
    leakyreluAlpha: l = 0,
    activation: o = null
}) {
    let p = e.shape.length, u = t.shape.length, c = n ? e.shape[p - 2] : e.shape[p - 1], d = a ? t.shape[u - 1] : t.shape[u - 2], h = n ? e.shape[p - 1] : e.shape[p - 2], f = a ? t.shape[u - 2] : t.shape[u - 1], m = e.shape.slice(0, -2), g = t.shape.slice(0, -2), y = k.sizeFromShape(m), A = k.sizeFromShape(g), x = mo.assertAndGetBroadcastShape(e.shape.slice(0, -2), t.shape.slice(0, -2)).concat([ h, f ]);
    k.assert(c === d, () => `Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);
    let b, v = n ? [ y, c, h ] : [ y, h, c ], I = a ? [ A, f, d ] : [ A, d, f ], N = he({
        inputs: {
            x: e
        },
        backend: r,
        attrs: {
            shape: v
        }
    }), T = he({
        inputs: {
            x: t
        },
        backend: r,
        attrs: {
            shape: I
        }
    }), R = [ N, T ], w = Math.max(y, A), E = n ? N.shape[1] : N.shape[2], $ = s != null, M = i != null, F = o === "leakyrelu", P = o != null ? ep(o, !0) : null;
    if ((h === 1 || f === 1) && E > Zb && ($ || M || F || P != null) === !1) {
        let O = N, B = T;
        n && (O = mn({
            inputs: {
                x: N
            },
            backend: r,
            attrs: {
                perm: [ 0, 2, 1 ]
            }
        }), R.push(O)), a && (B = mn({
            inputs: {
                x: T
            },
            backend: r,
            attrs: {
                perm: [ 0, 2, 1 ]
            }
        }), R.push(B));
        let G = f === 1, W = O;
        f !== 1 && (W = he({
            inputs: {
                x: O
            },
            backend: r,
            attrs: {
                shape: [ w, E, 1 ]
            }
        }), R.push(W));
        let z = f === 1 ? 2 : 1, X = B;
        G && (X = he({
            inputs: {
                x: B
            },
            backend: r,
            attrs: {
                shape: [ w, 1, E ]
            }
        }), R.push(X));
        let q = h1({
            inputs: {
                a: W,
                b: X
            },
            backend: r
        });
        b = Vc({
            inputs: {
                x: q
            },
            backend: r,
            attrs: {
                axis: z,
                keepDims: !0
            }
        }), R.push(q);
    } else {
        let O = Zt(e.dtype, t.dtype), B = new Hb(v, I, [ w, h, f ], n, a, $, P, M, F), G = [ N, T ];
        if (s != null && G.push(s), M && G.push(i), F) {
            let W = r.makeTensorInfo([], "float32", k.createScalarValue(l, "float32"));
            G.push(W), R.push(W);
        }
        b = r.runWebGLProgram(B, G, O);
    }
    let L = he({
        inputs: {
            x: b
        },
        backend: r,
        attrs: {
            shape: x
        }
    });
    R.push(b);
    for (let O of R) r.disposeIntermediateTensorInfo(O);
    return L;
}

var tF = {
    kernelName: wr,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            a: r,
            b: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            transposeA: o,
            transposeB: p,
            activation: u,
            leakyreluAlpha: c
        } = a;
        return Uc({
            a: r,
            b: s,
            transposeA: o,
            transposeB: p,
            backend: n,
            bias: i,
            preluActivationWeights: l,
            leakyreluAlpha: c,
            activation: u
        });
    }
}, Yb = "return abs(x);", nF = {
    kernelName: ol,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a
        } = e, {
            x: r
        } = n;
        if (a.shouldExecuteOnCPU([ r ]) && r.dtype !== "complex64") {
            let s = a.texData.get(r.dataId), i = Mb(s.values);
            return a.makeTensorInfo(r.shape, r.dtype, i);
        }
        return t = H().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new Gr(r.shape, Yb) : new Ba(r.shape, Yb), 
        a.runWebGLProgram(t, [ r ], r.dtype);
    }
}, aF = rt({
    opSnippet: ca + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`
}), rF = {
    kernelName: cs,
    backendName: "webgl",
    kernelFunc: aF
}, sF = rt({
    opSnippet: ca + `
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`
}), iF = {
    kernelName: hs,
    backendName: "webgl",
    kernelFunc: sF
}, Jb = "return a + b;", oF = en({
    opSnippet: Jb,
    packedOpSnippet: Jb,
    supportsComplex: !0,
    cpuKernelImpl: P$
}), lF = {
    kernelName: Ar,
    backendName: "webgl",
    kernelFunc: oF
}, uF = class {
    constructor(e, t) {
        this.outputShape = [], this.outputShape = e, this.variableNames = t.map((r, s) => `T${s}`);
        let n = [];
        this.variableNames.forEach(r => {
            n.push(`float v${r} = get${r}AtOutCoords();`);
        });
        let a = this.variableNames.map(r => `v${r}`).join(" + ");
        this.userCode = `
      void main() {
        ${n.join(`
        `)}

        float result = ${a};
        setOutput(result);
      }
    `;
    }
}, dF = class {
    constructor(e, t) {
        this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e, 
        this.variableNames = t.map((r, s) => `T${s}`);
        let n = [];
        this.variableNames.forEach(r => {
            n.push(`vec4 v${r} = get${r}AtOutCoords();`);
        });
        let a = this.variableNames.map(r => `v${r}`).join(" + ");
        this.userCode = `
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${a};
        setOutput(result);
      }
    `;
    }
}, pF = {
    kernelName: fs,
    backendName: "webgl",
    kernelFunc: function e(t) {
        let {
            inputs: n,
            backend: a
        } = t, r = n;
        if (r.length === 1) return Hn({
            inputs: {
                x: r[0]
            },
            backend: a
        });
        if (r.length > H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
            let o = Math.floor(r.length / 2), p = e({
                inputs: r.slice(0, o),
                backend: a
            }), u = e({
                inputs: r.slice(o),
                backend: a
            });
            return e({
                inputs: [ p, u ],
                backend: a
            });
        }
        let s = r.map(o => o.dtype).reduce((o, p) => Zt(o, p)), i = r.map(o => o.shape), l = H().getBool("WEBGL_PACK") ? new dF(r[0].shape, i) : new uF(r[0].shape, i);
        return a.runWebGLProgram(l, r, s);
    }
}, cF = {
    kernelName: ms,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a, l = r.shape.length, o = k.parseAxisParam(s, r.shape), p = o, u = C.getAxesPermutation(p, l), c = r;
        u != null && (c = mn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: u
            }
        }), p = C.getInnerMostAxes(p.length, l)), C.assertAxesAreInnerMostDims("all", p, l);
        let d, [ h, f ] = C.computeOutAndReduceShapes(c.shape, p), m = he({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                shape: [ -1, k.sizeFromShape(f) ]
            }
        }), g = Eo(m, m.dtype, "all", n);
        return i ? d = he({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: C.expandShapeToKeepDim(h, o)
            }
        }) : d = he({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: h
            }
        }), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(g), 
        u != null && n.disposeIntermediateTensorInfo(c), d;
    }
}, hF = {
    kernelName: gs,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a, l = r.shape.length, o = k.parseAxisParam(s, r.shape), p = o, u = C.getAxesPermutation(p, l), c = r;
        u != null && (c = mn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: u
            }
        }), p = C.getInnerMostAxes(p.length, l)), C.assertAxesAreInnerMostDims("any", p, l);
        let d, [ h, f ] = C.computeOutAndReduceShapes(c.shape, p), m = he({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                shape: [ -1, k.sizeFromShape(f) ]
            }
        }), g = Eo(m, m.dtype, "any", n);
        return i ? d = he({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: C.expandShapeToKeepDim(h, o)
            }
        }) : d = he({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: h
            }
        }), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(g), 
        u != null && n.disposeIntermediateTensorInfo(c), d;
    }
}, fF = class {
    constructor(e, t, n) {
        this.variableNames = [ "A" ];
        let {
            windowSize: a,
            batchSize: r,
            outSize: s
        } = e;
        n || this.variableNames.push("bestIndicesA"), this.outputShape = [ r, s ];
        let i = t === "max" ? ">" : "<", l = n ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
        this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `;
    }
}, mF = class {
    constructor(e, t, n, a) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        k.assert(e.length > 2, () => `Packed arg${n.charAt(0).toUpperCase() + n.slice(1)} supports only inputs with rank above 2.`);
        let r = e[e.length - 1], s = Math.ceil(r / t);
        this.outputShape = e.slice(0, -1), s > 1 && this.outputShape.push(s), a || this.variableNames.push("bestIndicesA");
        let i, l, o = this.outputShape, p = o.length, u = ft(p), c = fn("coords", p);
        if (s === 1) {
            l = p + 1;
            let N = ft(l);
            i = `
        ${N} sourceLocR = ${N}(${c.join()}, 0);
        ++${c[p - 1]};
        ${N} sourceLocG = ${N}(${c.join()}, 0);
        ++${c[p - 2]};
        ${N} sourceLocA = ${N}(${c.join()}, 0);
        --${c[p - 1]};
        ${N} sourceLocB = ${N}(${c.join()}, 0);
        --${c[p - 2]};`;
        } else l = p, i = `
        ${u} sourceLocR = coords;
        ++${c[p - 1]};
        ${u} sourceLocG = coords;
        ++${c[p - 2]};
        ${u} sourceLocA = coords;
        --${c[p - 1]};
        ${u} sourceLocB = coords;
        --${c[p - 2]};`;
        let d = [ "x", "y", "z", "w", "u", "v" ].slice(0, l), h = "." + d[l - 1], f = d.map(N => "int " + N), m = fn("sourceLocR", l - 1).concat("inIdx.r"), g = fn("sourceLocG", l - 1).concat("inIdx.g"), y = fn("sourceLocB", l - 1).concat("inIdx.b"), A = fn("sourceLocA", l - 1).concat("inIdx.a"), x = n === "max" ? "greaterThan" : "lessThan", b = a ? "" : `
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${A.join()})));`, v = `vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${A.join()}) : 0.)`, I = a ? "" : `
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;
        this.userCode = `
      float getAChannel(${f.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[p - 1]} < ${o[p - 1] - 1};
        bool hasNextRow = ${c[p - 2]} < ${o[p - 2] - 1};
        ${i}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${v};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${b}
          vec4 candidate = ${v};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `;
    }
};

function Qb(e, t, n, a = null) {
    let r = t.shape[0], s = t.shape[1];
    a != null && (r = a.shape[0], s = a.shape[1]);
    let i = C.computeOptimalWindowSize(s), l = {
        windowSize: i,
        inSize: s,
        batchSize: r,
        outSize: Math.ceil(s / i)
    }, o = new fF(l, n, a == null), p = [ t ];
    a != null && p.push(a);
    let u = e.runWebGLProgram(o, p, "int32");
    if (u.shape[1] === 1) return u;
    let c = Qb(e, t, n, u);
    return e.disposeIntermediateTensorInfo(u), c;
}

function e3(e, t, n, a = null) {
    let r = a != null ? a.shape : t.shape, s = r[r.length - 1], i = C.computeOptimalWindowSize(s), l = new mF(r, i, n, a == null), o = a == null ? [ t ] : [ t, a ], p = e.runWebGLProgram(l, o, "int32");
    if (p.shape.length === t.shape.length) {
        let u = e3(e, t, n, p);
        return e.disposeIntermediateTensorInfo(p), u;
    }
    return p;
}

function t3(e, t, n, a) {
    let r = [ n ];
    if (C.assertAxesAreInnerMostDims("arg" + a.charAt(0).toUpperCase() + a.slice(1), r, t.shape.length), 
    !H().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
        let s = [], i = e.texData.get(t.dataId), l = t;
        i !== null && i.isPacked && (l = e.unpackTensor(t), s.push(l));
        let [ o, p ] = C.computeOutAndReduceShapes(l.shape, r), u = k.sizeFromShape(p), c = he({
            inputs: {
                x: l
            },
            backend: e,
            attrs: {
                shape: [ -1, u ]
            }
        });
        s.push(c);
        let d = Qb(e, c, a);
        s.push(d);
        let h = he({
            inputs: {
                x: d
            },
            backend: e,
            attrs: {
                shape: o
            }
        });
        return s.forEach(f => e.disposeIntermediateTensorInfo(f)), h;
    }
    return e3(e, t, a);
}

var gF = {
    kernelName: ll,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s
        } = a, i = k.parseAxisParam(s, r.shape), l = C.getAxesPermutation(i, r.shape.length), o = r, p = [];
        l != null && (o = mn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: l
            }
        }), p.push(o), i = C.getInnerMostAxes(i.length, o.shape.length)), C.assertAxesAreInnerMostDims("argMax", [ i[0] ], o.shape.length);
        let u = t3(n, o, i[0], "max");
        return p.forEach(c => n.disposeIntermediateTensorInfo(c)), u;
    }
}, yF = {
    kernelName: ul,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s
        } = a, i = k.parseAxisParam(s, r.shape), l = C.getAxesPermutation(i, r.shape.length), o = r, p = [];
        l != null && (o = mn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: l
            }
        }), p.push(o), i = C.getInnerMostAxes(i.length, o.shape.length)), C.assertAxesAreInnerMostDims("argMin", [ i[0] ], o.shape.length);
        let u = t3(n, o, i[0], "min");
        return p.forEach(c => n.disposeIntermediateTensorInfo(c)), u;
    }
}, AF = rt({
    opSnippet: ca + `
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`
}), xF = {
    kernelName: ys,
    backendName: "webgl",
    kernelFunc: AF
}, bF = rt({
    opSnippet: ca + "return log(x + sqrt(x * x + 1.0));"
}), vF = {
    kernelName: As,
    backendName: "webgl",
    kernelFunc: bF
}, wF = rt({
    opSnippet: ca + `
  return atan(x);
`
}), kF = {
    kernelName: xs,
    backendName: "webgl",
    kernelFunc: wF
}, IF = en({
    opSnippet: c1 + `
  return atan(a, b);
`,
    packedOpSnippet: `
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Ro + `
  return result;
`
}), SF = {
    kernelName: vs,
    backendName: "webgl",
    kernelFunc: IF
}, NF = rt({
    opSnippet: ca + `
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`
}), CF = {
    kernelName: bs,
    backendName: "webgl",
    kernelFunc: NF
}, tp = class {
    constructor(e, t, n, a = !1, r = !1) {
        if (this.variableNames = [ "x" ], t === "avg" && n) throw new Error("Cannot compute positions for average pool.");
        let s = e.filterWidth, i = e.strideHeight, l = e.strideWidth, o = e.dilationHeight, p = e.dilationWidth, u = e.effectiveFilterHeight, c = e.effectiveFilterWidth, d = e.padInfo.top, h = e.padInfo.left;
        this.outputShape = e.outShape;
        let f = t === "avg", m = `((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`, g = `(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`, y = "0.0";
        if (f || (y = "-1.0 / 1e-20"), n) {
            let I = ">=";
            return void (this.userCode = `
        const ivec2 strides = ivec2(${i}, ${l});
        const ivec2 pads = ivec2(${d}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${u};
              wR += ${o}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a ? r ? m : g : `wR * ${c} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `);
        }
        let A = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        t === "avg" && (A = "avgValue / max(count, 1.0)");
        let x = 4 * Math.floor(s / 4), b = s % 4, v = `
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec2 strides = ivec2(${i}, ${l});
      const ivec2 pads = ivec2(${d}, ${h});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${x}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${v}
          }

          int xC = xCCorner + ${x};
          if (${b === 1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${v}
          } else if (${b === 2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${v}
          } else if (${b === 3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${v}
          }
        }
        setOutput(${A});
      }
    `;
    }
}, f1 = class {
    constructor(e, t, n, a = !1, r = !1) {
        if (this.variableNames = [ "x" ], t === "avg" && n) throw new Error("Cannot compute positions for average pool.");
        let s = e.filterWidth, i = e.strideDepth, l = e.strideHeight, o = e.strideWidth, p = e.dilationDepth, u = e.dilationHeight, c = e.dilationWidth, d = e.effectiveFilterDepth, h = e.effectiveFilterHeight, f = e.effectiveFilterWidth, m = e.padInfo.front, g = e.padInfo.top, y = e.padInfo.left;
        this.outputShape = e.outShape;
        let A = t === "avg", x = "0.0";
        if (A || (x = "-1.0 / 1e-20"), n) {
            let T = ">=";
            return void (this.userCode = `
        const ivec3 strides =
            ivec3(${i}, ${l}, ${o});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${u}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${c}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a ? r ? `(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch` : `wD * ${h} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `);
        }
        let b = `${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;
        t === "avg" && (b = "avgValue / max(count, 1.0)");
        let v = 4 * Math.floor(s / 4), I = s % 4, N = `
      if (${A}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;
        this.userCode = `
      const ivec3 strides =
        ivec3(${i}, ${l}, ${o});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${v}; wC += 4) {
              int xC = xCCorner + wC * ${c};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                getValue(batch, xD, xR, xC + 3 * ${c}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${v};
            if (${I === 1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I === 2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I === 3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                initializationValue
              );

              ${N}
            }
          }
        }
        setOutput(${b});
      }
    `;
    }
}, TF = {
    kernelName: ws,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t;
        du(r, "avgPool");
        let {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o
        } = a;
        k.assert(C.eitherStridesOrDilationsAreOne(i, 1), () => `Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);
        let p = C.computePool2DInfo(r.shape, s, i, 1, l, o);
        if (p.filterWidth === 1 && p.filterHeight === 1 && k.arraysEqual(p.inShape, p.outShape)) return Hn({
            inputs: {
                x: r
            },
            backend: n
        });
        let u = new tp(p, "avg", !1);
        return n.runWebGLProgram(u, [ r ], "float32");
    }
}, RF = {
    kernelName: dl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o,
            dataFormat: p
        } = a, u = C.computePool3DInfo(r.shape, s, i, [ 1, 1, 1 ], l, o, p), c = new f1(u, "avg", !1);
        return n.runWebGLProgram(c, [ r ], "float32");
    }
}, EF = class {
    constructor(e) {
        this.variableNames = [ "dy" ], this.outputShape = e.inShape;
        let t = e.filterHeight, n = e.filterWidth, a = e.strideHeight, r = e.strideWidth, s = e.dilationHeight, i = e.dilationWidth, l = e.effectiveFilterHeight, o = e.effectiveFilterWidth, p = l - 1 - e.padInfo.top, u = o - 1 - e.padInfo.left, c = 1 / (t * n);
        this.userCode = `
      const ivec2 pads = ivec2(${p}, ${u});
      const float avgMultiplier = float(${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, $F = class {
    constructor(e) {
        this.variableNames = [ "dy" ], this.outputShape = e.inShape;
        let t = e.filterDepth, n = e.filterHeight, a = e.filterWidth, r = e.strideDepth, s = e.strideHeight, i = e.strideWidth, l = e.dilationDepth, o = e.dilationHeight, p = e.dilationWidth, u = e.effectiveFilterDepth, c = e.effectiveFilterHeight, d = e.effectiveFilterWidth, h = u - 1 - e.padInfo.front, f = c - 1 - e.padInfo.top, m = d - 1 - e.padInfo.left, g = 1 / (t * n * a);
        this.userCode = `
      const ivec3 pads = ivec3(${h}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, MF = {
    kernelName: ju,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s, {
            filterSize: l,
            strides: o,
            pad: p,
            dimRoundingMode: u
        } = a, c = C.computePool3DInfo(i.shape, l, o, [ 1, 1, 1 ], p, u), d = new $F(c);
        return n.runWebGLProgram(d, [ r ], i.dtype);
    }
}, FF = {
    kernelName: Hu,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s;
        du([ r, s ], "avgPoolGrad");
        let {
            filterSize: l,
            strides: o,
            pad: p
        } = a, u = C.computePool2DInfo(i.shape, l, o, 1, p), c = new EF(u);
        return n.runWebGLProgram(c, [ r ], i.dtype);
    }
}, _F = {
    kernelName: ks,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            a: r,
            b: s
        } = t, {
            transposeA: i,
            transposeB: l
        } = a;
        return Uc({
            a: r,
            b: s,
            transposeA: i,
            transposeB: l,
            backend: n
        });
    }
}, OF = class {
    constructor(e, t, n, a, r, s) {
        this.outputShape = [], this.variableNames = [ "x", "mean", "variance" ], 
        C.assertAndGetBroadcastShape(e, t), C.assertAndGetBroadcastShape(e, n);
        let i = "0.0";
        a != null && (C.assertAndGetBroadcastShape(e, a), this.variableNames.push("offset"), 
        i = "getOffsetAtOutCoords()");
        let l = "1.0";
        r != null && (C.assertAndGetBroadcastShape(e, r), this.variableNames.push("scale"), 
        l = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `;
    }
}, PF = class {
    constructor(e, t, n, a, r, s) {
        this.packedInputs = !0, this.packedOutput = !0, this.variableNames = [ "x", "mean", "variance" ], 
        C.assertAndGetBroadcastShape(e, t), C.assertAndGetBroadcastShape(e, n);
        let i = "vec4(0.0)";
        a != null && (C.assertAndGetBroadcastShape(e, a), this.variableNames.push("offset"), 
        i = "getOffsetAtOutCoords()");
        let l = "vec4(1.0)";
        r != null && (C.assertAndGetBroadcastShape(e, r), this.variableNames.push("scale"), 
        l = "getScaleAtOutCoords()"), this.outputShape = e, this.userCode = `
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `;
    }
}, DF = {
    kernelName: Xs,
    backendName: "webgl",
    kernelFunc: ({
        inputs: e,
        backend: t,
        attrs: n
    }) => {
        let {
            x: a,
            mean: r,
            variance: s,
            offset: i,
            scale: l
        } = e;
        k.assert(r.shape.length === s.shape.length, () => "Batch normalization gradient requires mean and variance to have equal ranks."), 
        k.assert(i == null || r.shape.length === i.shape.length, () => "Batch normalization gradient requires mean and offset to have equal ranks."), 
        k.assert(l == null || r.shape.length === l.shape.length, () => "Batch normalization gradient requires mean and scale to have equal ranks.");
        let {
            varianceEpsilon: o
        } = n;
        o == null && (o = .001);
        let p = [ a, r, s ], u = null;
        i != null && (u = i.shape, p.push(i));
        let c = null;
        l != null && (c = l.shape, p.push(l));
        let d = H().getBool("WEBGL_PACK_NORMALIZATION") ? new PF(a.shape, r.shape, s.shape, u, c, o) : new OF(a.shape, r.shape, s.shape, u, c, o);
        return t.runWebGLProgram(d, p, p[0].dtype);
    }
}, zF = class {
    constructor(e) {
        this.variableNames = [ "source" ], this.outputShape = e, this.rank = e.length;
        let t = ft(this.rank);
        this.customUniforms = [ {
            name: "start",
            arrayIndex: this.rank,
            type: "int"
        } ];
        let n, a = function(r) {
            if (r === 1) return "sourceLoc";
            if (r <= 6) return m1.slice(0, r).map(s => "sourceLoc." + s).join(",");
            throw Error(`Slicing for rank ${r} is not yet supported`);
        }(this.rank);
        n = `
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${e.map((r, s) => `sourceLoc.${m1[s]} = start[${s}] + coords.${m1[s]};`).join(`
`)}
      `, this.userCode = `
      void main() {
        ${n}
        setOutput(getSource(${a}));
      }
    `;
    }
}, m1 = [ "x", "y", "z", "w", "u", "v" ], LF = class {
    constructor(e) {
        this.variableNames = [ "source" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outputShape = e, this.rank = e.length, this.customUniforms = [ {
            name: "start",
            arrayIndex: this.rank,
            type: "int"
        } ];
        let t = ft(this.rank), n = fn("coords", this.rank), a = fn("sourceLoc", this.rank), r = this.rank === 1 ? "sourceLoc" : `vec2(${a.slice(-2).join()})`, s = `getChannel(getSource(${a.join()}), ${r})`, i = `
      result.x = ${s};
      if (++${n[this.rank - 1]} < ${e[this.rank - 1]}) {
        ++${a[this.rank - 1]};
        result.y = ${s};
        --${a[this.rank - 1]};
      }
    `, l = this.rank === 1 ? "" : `
      --${n[this.rank - 1]};
      if (++${n[this.rank - 2]} < ${e[this.rank - 2]}) {
        ++${a[this.rank - 2]};
        result.z = ${s};
        if (++${n[this.rank - 1]} < ${e[this.rank - 1]}) {
          ++${a[this.rank - 1]};
          result.w = ${s};
        }
      }
    `, o = this.rank <= 4 ? `sourceLoc = coords +
            ${t}(${e.map((p, u) => `start[${u}]`).join()});` : e.map((p, u) => `${a[u]} = ${n[u]} + start[${u}];`).join(`
`);
        this.userCode = `
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${o}
        vec4 result = vec4(0.);
        ${i}
        ${l}
        setOutput(result);
      }
    `;
    }
};

function yu(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        begin: s,
        size: i
    } = a, [ l, o ] = St.parseSliceParams(r, s, i);
    if (St.assertParamsValid(r, l, o), k.sizeFromShape(o) === 0) return n.makeTensorInfo(o, r.dtype, []);
    if (n.shouldExecuteOnCPU([ r ]) || r.dtype === "string") {
        let c = n.texData.get(r.dataId), d = fM(c.values, l, o, r.shape, r.dtype);
        return n.makeTensorInfo(o, r.dtype, d);
    }
    let {
        isPacked: p
    } = n.texData.get(r.dataId), u = St.isSliceContinous(r.shape, l, o);
    if (p || !u) {
        let c = H().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new LF(o) : new zF(o), d = [ l ];
        return n.runWebGLProgram(c, [ r ], r.dtype, d);
    }
    return n.uploadToGPU(r.dataId), function(c, d, h, f) {
        let m = f.texData.get(c.dataId), g = f.makeTensorInfo(h, c.dtype), y = f.texData.get(g.dataId);
        Object.assign(y, m), y.refCount = 1, y.shape = h, y.dtype = c.dtype;
        let A = St.computeFlatOffset(d, k.computeStrides(c.shape));
        m.slice && (A += m.slice.flatOffset), y.slice = {
            flatOffset: A,
            origDataId: m.slice && m.slice.origDataId || c.dataId
        };
        let x = f.dataRefCount.get(y.slice.origDataId) || 1;
        return f.dataRefCount.set(y.slice.origDataId, x + 1), g;
    }(r, l, o, n);
}

var WF = {
    kernelName: Pl,
    backendName: "webgl",
    kernelFunc: yu
}, BF = {
    kernelName: pl,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            crops: i
        } = a;
        k.assert(r.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");
        let l = s.reduce((A, x) => A * x), o = C.getReshaped(r.shape, s, l), p = C.getPermuted(o.length, s.length), u = C.getReshapedPermuted(r.shape, s, l), c = C.getSliceBeginCoords(i, s.length), d = C.getSliceSize(u, i, s.length), h = [], f = he({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: o
            }
        }), m = mn({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), g = he({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                shape: u
            }
        }), y = yu({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                begin: c,
                size: d
            }
        });
        return h.push(f), h.push(m), h.push(g), h.forEach(A => n.disposeIntermediateTensorInfo(A)), 
        y;
    }
}, VF = {
    kernelName: Is,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = t, {
            size: i
        } = a, l = n.readSync(r.dataId), o = n.readSync(s.dataId), p = $b(l, o, s.dtype, s.shape, i);
        return n.makeTensorInfo([ i ], s.dtype, p);
    }
}, UF = {
    kernelName: cl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a
        } = e, {
            a: r,
            b: s
        } = n, i = H().getBool("WEBGL_PACK_BINARY_OPERATIONS"), l = H().getNumber("WEBGL_VERSION");
        if (a.shouldExecuteOnCPU([ r, s ]) || l === 1) {
            let o = a.texData.get(r.dataId).values, p = a.texData.get(s.dataId).values, [ u, c ] = z$(r.shape, s.shape, o, p, r.dtype), d = a.makeTensorInfo(c, r.dtype);
            return a.texData.get(d.dataId).values = u, d;
        }
        return t = i ? new mu(`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`, r.shape, s.shape, !1) : new To(`
  return float(int(a.r) & int(b.r));
`, r.shape, s.shape), a.runWebGLProgram(t, [ r, s ], r.dtype);
    }
}, GF = {
    kernelName: hl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            s0: a,
            s1: r
        } = t, s = n.readSync(a.dataId), i = n.readSync(r.dataId), l = C.assertAndGetBroadcastShape(Array.from(s), Array.from(i));
        return n.makeTensorInfo([ l.length ], "int32", Int32Array.from(l));
    }
}, n3 = en({
    opSnippet: "return float(a != b);",
    cpuKernelImpl: sM,
    dtype: "bool"
}), HF = {
    kernelName: wi,
    backendName: "webgl",
    kernelFunc: n3
};

function np(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        input: a
    } = t;
    return Hn({
        inputs: {
            x: n.texData.get(a.dataId).complexTensorInfos.real
        },
        backend: n
    });
}

var jF = {
    kernelName: sd,
    backendName: "webgl",
    kernelFunc: np
}, qF = "return float(int(x));", XF = {
    kernelName: Ss,
    backendName: "webgl",
    kernelFunc: function e(t) {
        let {
            inputs: n,
            backend: a,
            attrs: r
        } = t, {
            x: s
        } = n, {
            dtype: i
        } = r;
        if (i === "complex64") {
            if (s.dtype === "complex64") return Hn({
                inputs: {
                    x: s
                },
                backend: a
            });
            let l = ka(s.shape), o = e({
                inputs: {
                    x: s
                },
                backend: a,
                attrs: {
                    dtype: "float32"
                }
            }), p = Hr({
                inputs: {
                    real: o,
                    imag: l
                },
                backend: a
            });
            return l.dispose(), a.disposeIntermediateTensorInfo(o), p;
        }
        if (s.dtype === "complex64") {
            let l = np({
                inputs: {
                    input: s
                },
                backend: a
            }), o = e({
                inputs: {
                    x: l
                },
                backend: a,
                attrs: {
                    dtype: i
                }
            });
            return a.disposeIntermediateTensorInfo(l), o;
        }
        if (!k.hasEncodingLoss(s.dtype, i)) {
            let l = Hn({
                inputs: {
                    x: s
                },
                backend: a
            });
            return {
                dataId: l.dataId,
                shape: l.shape,
                dtype: i
            };
        }
        if (a.shouldExecuteOnCPU([ s ])) {
            let l = a.texData.get(s.dataId).values, [ o, p, u ] = L$(l, s.shape, s.dtype, i);
            return a.makeTensorInfo(o, p, u);
        }
        if (i === "int32") return function(l, o) {
            let p = new Ba(l.shape, qF), u = o.runWebGLProgram(p, [ l ], "int32");
            return {
                dataId: u.dataId,
                shape: u.shape,
                dtype: u.dtype
            };
        }(s, a);
        if (i === "bool") {
            let l = a.makeTensorInfo([], "bool", k.getTypedArrayFromDType("bool", 1)), o = n3({
                inputs: {
                    a: s,
                    b: l
                },
                backend: a
            });
            return a.disposeIntermediateTensorInfo(l), o;
        }
        throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`);
    }
}, a3 = "return ceil(x);", KF = rt({
    opSnippet: a3,
    packedOpSnippet: a3,
    cpuKernelImpl: W$
}), ZF = {
    kernelName: Ns,
    backendName: "webgl",
    kernelFunc: KF
}, YF = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.customUniforms = [ {
            name: "minVal",
            type: "float"
        }, {
            name: "maxVal",
            type: "float"
        } ], this.outputShape = e, this.userCode = `

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `;
    }
}, JF = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "minVal",
            type: "float"
        }, {
            name: "maxVal",
            type: "float"
        } ], this.outputShape = e, this.userCode = `
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `;
    }
}, QF = {
    kernelName: xr,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s
        } = n, {
            clipValueMin: i,
            clipValueMax: l
        } = r;
        t = H().getBool("WEBGL_PACK_CLIP") ? new JF(s.shape) : new YF(s.shape);
        let o = [ [ i ], [ l ] ];
        return a.runWebGLProgram(t, [ s ], s.dtype, o);
    }
}, e_ = class {
    constructor(e) {
        this.variableNames = [ "real", "imag" ], this.outputShape = e, this.userCode = `
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `;
    }
};

function r3(e, t) {
    return {
        dataId: t.dataId,
        dtype: t.dtype,
        shape: e.shape
    };
}

var t_ = {
    kernelName: Xu,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t, r = n.texData.get(a.dataId), s = new e_(a.shape), i = [ r3(a, r.complexTensorInfos.real), r3(a, r.complexTensorInfos.imag) ];
        return n.runWebGLProgram(s, i, i[0].dtype);
    }
}, n_ = class {
    constructor(e) {
        this.outputShape = [], this.outputShape = C.computeOutShape(e, 1), this.variableNames = e.map((s, i) => `T${i}`);
        let t = new Array(e.length - 1);
        t[0] = e[0][1];
        for (let s = 1; s < t.length; s++) t[s] = t[s - 1] + e[s][1];
        let n = [ `if (yC < ${t[0]}) setOutput(getT0(yR, yC));` ];
        for (let s = 1; s < t.length; s++) {
            let i = t[s - 1];
            n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`);
        }
        let a = t.length, r = t[t.length - 1];
        n.push(`else setOutput(getT${a}(yR, yC-${r}));`), this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `;
    }
}, a_ = class {
    constructor(e, t) {
        this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = C.computeOutShape(e, t);
        let n = this.outputShape, a = n.length, r = ft(a), s = fn("coords", a), i = [ "x", "y", "z", "w", "u", "v" ].slice(0, a);
        this.variableNames = e.map((f, m) => `T${m}`);
        let l = new Array(e.length - 1);
        l[0] = e[0][t];
        for (let f = 1; f < l.length; f++) l[f] = l[f - 1] + e[f][t];
        let o = i[t], p = i.slice(-2), u = i.join(), c = `if (${o} < ${l[0]}) {
        return getChannel(
            getT0(${u}), vec2(${p.join()}));
        }`;
        for (let f = 1; f < l.length; f++) {
            let m = l[f - 1];
            c += `
        if (${o} < ${l[f]}  && ${o} >= ${l[f - 1]}) {
          return getChannel(
            getT${f}(${Gc(i, o, m)}),
            vec2(${Gc(p, o, m)}));
        }`;
        }
        let d = l.length, h = l[l.length - 1];
        c += `
        return getChannel(
          getT${d}(${Gc(i, o, h)}),
          vec2(${Gc(p, o, h)}));`, this.userCode = `
      float getValue(${i.map(f => "int " + f)}) {
        ${c}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[a - 1]} = ${s[a - 1]} + 1;
        if (${s[a - 1]} < ${n[a - 1]}) {
          result.g = getValue(${s});
        }

        ${s[a - 2]} = ${s[a - 2]} + 1;
        if (${s[a - 2]} < ${n[a - 2]}) {
          result.a = getValue(${s});
        }

        ${s[a - 1]} = ${s[a - 1]} - 1;
        if (${s[a - 2]} < ${n[a - 2]} &&
            ${s[a - 1]} < ${n[a - 1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `;
    }
};

function Gc(e, t, n) {
    let a = e.indexOf(t);
    return e.map((r, s) => s === a ? `${r} - ${n}` : r).join();
}

function Hc(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        input: a
    } = t;
    return Hn({
        inputs: {
            x: n.texData.get(a.dataId).complexTensorInfos.imag
        },
        backend: n
    });
}

var r_ = {
    kernelName: nd,
    backendName: "webgl",
    kernelFunc: Hc
};

function ap(e, t, n) {
    let a = e[0].dtype;
    if (a === "complex64") {
        let h = e.map(A => np({
            inputs: {
                input: A
            },
            backend: n
        })), f = e.map(A => Hc({
            inputs: {
                input: A
            },
            backend: n
        })), m = ap(h, t, n), g = ap(f, t, n), y = Hr({
            inputs: {
                real: m,
                imag: g
            },
            backend: n
        });
        return h.forEach(A => n.disposeIntermediateTensorInfo(A)), f.forEach(A => n.disposeIntermediateTensorInfo(A)), 
        n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(g), 
        y;
    }
    let r = n.shouldExecuteOnCPU(e);
    if (a === "string" && (r = !0), r) {
        let h = e.map(b => {
            let v = [ -1, k.sizeFromShape(b.shape.slice(t)) ];
            return he({
                inputs: {
                    x: b
                },
                backend: n,
                attrs: {
                    shape: v
                }
            });
        }), f = h.map(b => ({
            vals: n.readSync(b.dataId),
            shape: b.shape
        })), m = C.computeOutShape(h.map(b => b.shape), 1), g = h[0].shape[0] === 1, y = B$(f, m, a, g), A = C.computeOutShape(e.map(b => b.shape), t), x = n.makeTensorInfo(A, a, y);
        return h.forEach(b => n.disposeIntermediateTensorInfo(b)), x;
    }
    let s = e.filter(h => k.sizeFromShape(h.shape) > 0), i = H().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && s[0].shape.length > 1;
    if (s.length === 1) {
        let h = i ? new Ba(e[0].shape, Ur) : new Gr(e[0].shape, Ur);
        return n.runWebGLProgram(h, e, a);
    }
    let l = H().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
    if (s.length > l) {
        let h = [];
        for (let m = 0; m < s.length; m += l) {
            let g = s.slice(m, m + l);
            h.push(ap(g, t, n));
        }
        let f = ap(h, t, n);
        for (let m of h) n.disposeIntermediateTensorInfo(m);
        return f;
    }
    if (i) {
        let h = new a_(s.map(f => f.shape), t);
        return n.runWebGLProgram(h, s, a);
    }
    let {
        tensors2D: o,
        outShape: p
    } = function(h, f, m) {
        let g = C.computeOutShape(h.map(y => y.shape), f);
        return {
            tensors2D: h.map(y => he({
                inputs: {
                    x: y
                },
                attrs: {
                    shape: [ -1, k.sizeFromShape(y.shape.slice(f)) ]
                },
                backend: m
            })),
            outShape: g
        };
    }(s, t, n), u = new n_(o.map(h => h.shape)), c = n.runWebGLProgram(u, o, a);
    o.forEach(h => n.disposeIntermediateTensorInfo(h));
    let d = he({
        inputs: {
            x: c
        },
        attrs: {
            shape: p
        },
        backend: n
    });
    return n.disposeIntermediateTensorInfo(c), d;
}

function s3(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        axis: r
    } = a, s = k.parseAxisParam(r, t[0].shape)[0], i = t.map(p => p.shape);
    C.assertParamsConsistent(i, s);
    let l = C.computeOutShape(t.map(p => p.shape), s);
    if (k.sizeFromShape(l) === 0) return n.makeTensorInfo(l, t[0].dtype, []);
    let o = t.filter(p => k.sizeFromShape(p.shape) > 0);
    return o.length === 1 ? Hn({
        inputs: {
            x: o[0]
        },
        backend: n
    }) : ap(o, s, n);
}

var s_ = {
    kernelName: fl,
    backendName: "webgl",
    kernelFunc: s3
}, i3 = class {
    constructor(e, t = !1, n = null, a = !1, r = !1) {
        this.variableNames = [ "x", "W" ], this.outputShape = e.outShape;
        let s = e.padInfo.top, i = e.padInfo.left, l = e.strideHeight, o = e.strideWidth, p = e.dilationHeight, u = e.dilationWidth, c = e.filterHeight, d = e.filterWidth, h = 4 * Math.floor(e.inChannels / 4), f = e.inChannels % 4, m = e.dataFormat === "channelsLast", g = m ? 1 : 2, y = m ? 2 : 3, A = m ? 3 : 1, x = "", b = "";
        n && (x = a ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }` : r ? `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }` : `
          float activation(float x) {
            ${n}
          }
        `, b = "result = activation(result);");
        let v = t ? "result += getBiasAtOutCoords();" : "";
        t && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), 
        r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${x}

      const ivec2 strides = ivec2(${l}, ${o});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${A}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${u};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f === 1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${f === 2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f === 3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${v}
        ${b}
        setOutput(result);
      }
    `;
    }
}, i_ = class {
    constructor(e) {
        this.variableNames = [ "x", "W" ], this.outputShape = e.outShape;
        let t = e.padInfo.front, n = e.padInfo.top, a = e.padInfo.left, r = e.strideDepth, s = e.strideHeight, i = e.strideWidth, l = e.dilationDepth, o = e.dilationHeight, p = e.dilationWidth, u = e.filterDepth, c = e.filterHeight, d = e.filterWidth, h = 4 * Math.floor(e.inChannels / 4), f = e.inChannels % 4;
        this.userCode = `
      const ivec3 strides = ivec3(${r}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${u}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c}; wR++) {
            int xR = xRCorner + wR * ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f === 1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${f === 2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f === 3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, o3 = class {
    constructor(e, t = !1, n = null, a = !1, r = !1) {
        this.variableNames = [ "x", "W" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "pads",
            type: "ivec2"
        }, {
            name: "strides",
            type: "ivec2"
        }, {
            name: "dilations",
            type: "ivec2"
        }, {
            name: "inDims",
            type: "ivec2"
        } ], this.outputShape = e.outShape, this.enableShapeUniforms = on(this.outputShape.length);
        let s = e.padInfo.left, i = e.strideWidth, l = e.dilationWidth, o = e.filterHeight, p = e.filterWidth, u = p, c = `
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;
        for (let m = 0; m < p; m++) c += `
           vec4 xTexelC${2 * m};
           int xTexelC${2 * m}Ready;
           vec4 xTexelC${2 * m + 1};
           int xTexelC${2 * m + 1}Ready;
           vec4 xC${m};`;
        c += `
     for (int r = 0; r < ${o}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;
        for (let m = 0; m < p; m++) c += `
           xTexelC${2 * m} = vec4(0.0);
           xTexelC${2 * m}Ready = 0;
           xTexelC${2 * m + 1} = vec4(0.0);
           xTexelC${2 * m + 1}Ready = 0;
           xC${m} = vec4(0.0);`;
        c += `
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;
        for (let m = 0; m < (u + 1) / 2; m++) {
            let g = 2 * m;
            if (c += `
           xC = xCCorner + ${g * l};
           `, i === 1) {
                if (g < p && (s % 2 == 1 ? (c += `
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `, c += l === 1 && g > 0 ? `
                 xC${g} = vec4(xTexelC${g - 2}.zw, xTexelC${g}.xy);
                 ` : `
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `) : c += `
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `, g + 1 < p)) {
                    let y = s % 2 == 0 ? k.nearestLargerEven(l) : l;
                    l % 2 == 0 && s % 2 == 1 || l % 2 != 0 && s % 2 != 1 ? (c += `
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g + 1}Ready == 0) {
                     xTexelC${g + 1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g + 1}.zw = vec2(0.0);
                     }
                     xTexelC${g + 1}Ready = 1;
                   }
                   `, c += l > 1 ? `
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g + 1} = vec4(previous.zw, xTexelC${g + 1}.xy);
                     } else {
                      xC${g + 1} = vec4(0.0, 0.0, xTexelC${g + 1}.xy);
                     }
                     ` : `
                     xC${g + 1} = vec4(xTexelC${g}.zw, xTexelC${g + 1}.xy);
                     `) : c += y === 1 ? `
                     xC${g + 1} = xTexelC${g};
                     ` : `
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g + 1}Ready == 0) {
                       xTexelC${g + 1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g + 1}.zw = vec2(0.0);
                       }
                       xTexelC${g + 1}Ready = 1;
                     }

                     xC${g + 1} = xTexelC${g + 1};
                     `;
                }
            } else g < p && (s % 2 == 1 ? (c += `
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g + 1}Ready == 0) {
                   xTexelC${g + 1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g + 1}.zw = vec2(0.0);
                   }
                   xTexelC${g + 1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g + 1}.zw);
               `, g + 1 < p && (c += `
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g + 1} = vec4(xTexelC${g + 1}.xy, final.xy);
                 `)) : (c += `
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g + 1}Ready == 0) {
                   xTexelC${g + 1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g + 1}.zw = vec2(0.);
                   }
                   xTexelC${g + 1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g + 1}.xy);
               `, g + 1 < p && (c += `
                   xC${g + 1} = vec4(xTexelC${g}.zw, xTexelC${g + 1}.zw);
                 `)));
            g < p && (c += `
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `, g + 1 < p && (c += `
               wTexel = getW(r, ${g + 1}, d1, d2);
               dotProd += xC${g + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g + 1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `));
        }
        c += `
     }
   `, c += `
     }
   `, c += `
     }
   `;
        let d = "", h = "";
        n && (d = a ? `vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }` : r ? `vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }` : `vec4 activation(vec4 x) {
           ${n}
         }`, h = "result = activation(result);");
        let f = t ? "result += getBiasAtOutCoords();" : "";
        t && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), 
        r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${h}
         setOutput(result);
       }
     `;
    }
}, o_ = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "inputShape",
            type: "ivec4"
        }, {
            name: "pad",
            type: "ivec2"
        }, {
            name: "stride",
            type: "ivec2"
        }, {
            name: "dilation",
            type: "ivec2"
        }, {
            name: "inChannels",
            type: "int"
        }, {
            name: "itemsPerBlockRow",
            type: "int"
        }, {
            name: "outWidth",
            type: "int"
        } ], this.outputShape = e, this.enableShapeUniforms = on(this.outputShape.length);
        let {
            dataFormat: n
        } = t, a = hn(), r = n === "channelsLast", s = r ? 1 : 2, i = r ? 2 : 3, l = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : `if(blockIndex < ${e[2]} && pos < ${e[1]}) {`, o = "";
        for (let p = 0; p <= 1; p++) for (let u = 0; u <= 1; u++) o += `
          blockIndex = rc.z + ${u};
          pos = rc.y + ${p};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${2 * p + u}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2 * p + u}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;
        this.userCode = `
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${o}

        ${a.output} = result;
      }
    `;
    }
};

function jc(e, t) {
    let n = e.length;
    return n >= 3 ? t ? [ ...e.slice(0, -3), e[n - 3] * e[n - 2], e[n - 1] ] : [ ...e.slice(0, -3), e[n - 3], e[n - 2] * e[n - 1] ] : !t && n === 1 && e[0] > 1 ? [ e[0], 1 ] : null;
}

function l3({
    x: e,
    filter: t,
    convInfo: n,
    backend: a,
    bias: r = null,
    preluActivationWeights: s = null,
    leakyreluAlpha: i = 0,
    activation: l = null
}) {
    let o, p = e.shape, u = a.texData.get(e.dataId), c = n.inChannels, d = p[0] * p[1] * p[2], h = n.outChannels, f = n.dataFormat === "channelsLast", m = !1, g = [];
    if (s != null) {
        let y = jc(s.shape, f);
        y != null && (s = he({
            inputs: {
                x: s
            },
            backend: a,
            attrs: {
                shape: y
            }
        }), g.push(s));
    }
    if (r != null) {
        let y = jc(r.shape, f);
        y != null && (r = he({
            inputs: {
                x: r
            },
            backend: a,
            attrs: {
                shape: y
            }
        }), g.push(r));
    }
    if ((d !== 1 && h !== 1 || !(c > Zb)) && u.isPacked && f && u.texture != null && p[2] % 2 != 0 && k.arraysEqual(u.shape.slice(-3), p.slice(-3))) {
        let y = p[0] * p[1] * (p[2] + 1), A = {
            dataId: e.dataId,
            shape: [ 1, y, n.inChannels ],
            dtype: e.dtype
        }, x = u.shape;
        u.shape = u.shape.slice(), u.shape[u.shape.length - 2]++, k.assert(Yd(u.shape, A.shape), () => `packed reshape ${u.shape} to ${A.shape} isn't free`);
        let b = he({
            inputs: {
                x: t
            },
            backend: a,
            attrs: {
                shape: [ 1, n.inChannels, n.outChannels ]
            }
        });
        g.push(b);
        let v = Uc({
            a: A,
            b: b,
            backend: a,
            transposeA: !1,
            transposeB: m,
            bias: r,
            activation: l,
            preluActivationWeights: s,
            leakyreluAlpha: i
        }), I = a.texData.get(v.dataId);
        k.assert(I.isPacked, () => "batchMatMul result is expected to be packed"), 
        u.shape = x, I.shape = n.outShape, o = Hn({
            inputs: {
                x: v
            },
            backend: a
        }), o.shape = n.outShape, g.push(v);
    } else {
        let y = n.outHeight * n.outWidth, A = he({
            inputs: {
                x: e
            },
            backend: a,
            attrs: {
                shape: f ? [ n.batchSize, y, n.inChannels ] : [ n.batchSize, n.inChannels, y ]
            }
        }), x = he({
            inputs: {
                x: t
            },
            backend: a,
            attrs: {
                shape: [ 1, n.inChannels, n.outChannels ]
            }
        }), b = Uc({
            a: f ? A : x,
            b: f ? x : A,
            transposeA: !f,
            transposeB: m,
            backend: a,
            bias: r,
            activation: l,
            preluActivationWeights: s,
            leakyreluAlpha: i
        });
        o = he({
            inputs: {
                x: b
            },
            backend: a,
            attrs: {
                shape: n.outShape
            }
        }), g.push(A), g.push(x), g.push(b);
    }
    for (let y of g) a.disposeIntermediateTensorInfo(y);
    return o;
}

function u3({
    x: e,
    filter: t,
    convInfo: n,
    backend: a,
    bias: r = null,
    preluActivationWeights: s = null,
    leakyreluAlpha: i = 0,
    activation: l = null
}) {
    let {
        filterWidth: o,
        filterHeight: p,
        inChannels: u,
        outWidth: c,
        outHeight: d,
        dataFormat: h
    } = n, f = h === "channelsLast", m = o * p * u, g = d * c, y = [ n.batchSize, m, g ], A = [];
    if (s != null) {
        let L = jc(s.shape, f);
        L != null && (s = he({
            inputs: {
                x: s
            },
            backend: a,
            attrs: {
                shape: L
            }
        }), A.push(s));
    }
    if (r != null) {
        let L = jc(r.shape, f);
        L != null && (r = he({
            inputs: {
                x: r
            },
            backend: a,
            attrs: {
                shape: L
            }
        }), A.push(r));
    }
    let x = he({
        inputs: {
            x: t
        },
        backend: a,
        attrs: {
            shape: [ 1, m, k.sizeFromShape(t.shape) / m ]
        }
    });
    A.push(x);
    let b = new o_(y, n), v = [ e.shape, [ n.padInfo.top, n.padInfo.left ], [ n.strideHeight, n.strideWidth ], [ n.dilationHeight, n.dilationWidth ], [ n.inChannels ], [ n.filterWidth * n.inChannels ], [ n.outWidth ] ], I = a.runWebGLProgram(b, [ e ], "float32", v), N = he({
        inputs: {
            x: I
        },
        backend: a,
        attrs: {
            shape: y
        }
    });
    A.push(I), A.push(N);
    let T = r != null, R = s != null, w = l === "leakyrelu", E = l ? ep(l, !0) : null, $ = new Hb(f ? N.shape : x.shape, f ? x.shape : N.shape, f ? [ n.batchSize, g, n.outChannels ] : [ n.batchSize, n.outChannels, g ], !0, !1, T, E, R, w), M = f ? [ N, x ] : [ x, N ];
    if (r && M.push(r), R && M.push(s), w) {
        let L = a.makeTensorInfo([], "float32", k.createScalarValue(i, "float32"));
        M.push(L), A.push(L);
    }
    let F = a.runWebGLProgram($, M, "float32"), P = he({
        inputs: {
            x: F
        },
        backend: a,
        attrs: {
            shape: n.outShape
        }
    });
    A.push(F);
    for (let L of A) a.disposeIntermediateTensorInfo(L);
    return P;
}

var l_ = {
    kernelName: Cs,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s,
            filter: i
        } = n, {
            strides: l,
            pad: o,
            dataFormat: p,
            dilations: u,
            dimRoundingMode: c
        } = r, d = C.convertConv2DDataFormat(p), h = C.computeConv2DInfo(s.shape, i.shape, l, u, o, c, !1, d);
        if (h.filterHeight !== 1 || h.filterWidth !== 1 || h.dilationHeight !== 1 || h.dilationWidth !== 1 || h.strideHeight !== 1 || h.strideWidth !== 1 || h.padInfo.type !== "SAME" && h.padInfo.type !== "VALID") if (h.strideWidth <= 2 && d === "channelsLast" && H().getBool("WEBGL_EXP_CONV")) {
            let m = new o3(h), g = [ [ h.padInfo.top, h.padInfo.left ], [ h.strideHeight, h.strideWidth ], [ h.dilationHeight, h.dilationWidth ], [ h.inHeight, h.inWidth ] ];
            t = a.runWebGLProgram(m, [ s, i ], "float32", g);
        } else if (H().getBool("WEBGL_CONV_IM2COL")) t = u3({
            x: s,
            filter: i,
            convInfo: h,
            backend: a
        }); else {
            let m = new i3(h);
            t = a.runWebGLProgram(m, [ s, i ], "float32");
        } else t = l3({
            x: s,
            filter: i,
            convInfo: h,
            backend: a
        });
        let f = he({
            inputs: {
                x: t
            },
            backend: a,
            attrs: {
                shape: h.outShape
            }
        });
        return a.disposeIntermediateTensorInfo(t), f;
    }
}, u_ = class {
    constructor(e) {
        this.variableNames = [ "x", "dy" ], this.outputShape = e.filterShape;
        let t = e.strideHeight, n = e.strideWidth, a = e.padInfo.top, r = e.padInfo.left, s = e.dataFormat === "channelsLast";
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s ? `float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);` : `float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, d_ = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.outputShape = e.inShape;
        let t = e.filterHeight, n = e.filterWidth, a = e.strideHeight, r = e.strideWidth, s = e.dataFormat === "channelsLast", i = t - 1 - e.padInfo.top, l = n - 1 - e.padInfo.left, o = s ? 1 : 2, p = s ? 2 : 3, u = s ? 3 : 1;
        this.userCode = `
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${u}];

        ivec2 dyCorner = ivec2(coords[${o}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, p_ = class {
    constructor(e) {
        this.variableNames = [ "x", "dy" ], this.outputShape = e.filterShape;
        let t = e.strideDepth, n = e.strideHeight, a = e.strideWidth, r = e.padInfo.front, s = e.padInfo.top, i = e.padInfo.left;
        this.userCode = `
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, c_ = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.outputShape = e.inShape;
        let t = e.filterDepth, n = e.filterHeight, a = e.filterWidth, r = e.strideDepth, s = e.strideHeight, i = e.strideWidth, l = t - 1 - e.padInfo.front, o = n - 1 - e.padInfo.top, p = a - 1 - e.padInfo.left;
        this.userCode = `
      const ivec3 pads = ivec3(${l}, ${o}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, h_ = {
    kernelName: Ku,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p,
            filterShape: u
        } = a, c = C.convertConv2DDataFormat(o), d = C.computeConv2DInfo(r.shape, u, i, 1, l, p, !1, c), h = new u_(d);
        return n.runWebGLProgram(h, [ r, s ], "float32");
    }
}, f_ = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "strides",
            type: "vec2"
        } ], this.outputShape = e.inShape, this.enableShapeUniforms = on(this.outputShape.length);
        let t = e.filterHeight, n = e.filterWidth, a = t - 1 - e.padInfo.top, r = n - 1 - e.padInfo.left;
        this.userCode = `
      const ivec2 pads = ivec2(${a}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `;
    }
}, m_ = {
    kernelName: Ts,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            inputShape: i,
            strides: l,
            pad: o,
            dataFormat: p,
            dimRoundingMode: u
        } = a, c = C.convertConv2DDataFormat(p), d = C.computeConv2DInfo(i, s.shape, l, 1, o, u, !1, c);
        if (H().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && c === "channelsLast") {
            let h = [ [ d.strideHeight, d.strideWidth ] ], f = new f_(d);
            return n.runWebGLProgram(f, [ r, s ], "float32", h);
        }
        {
            let h = new d_(d);
            return n.runWebGLProgram(h, [ r, s ], "float32");
        }
    }
}, g_ = {
    kernelName: Rs,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o
        } = a, p = C.computeConv3DInfo(r.shape, s.shape, i, o, l), u = new i_(p);
        return n.runWebGLProgram(u, [ r, s ], "float32");
    }
}, y_ = {
    kernelName: ml,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            filterShape: o
        } = a, p = C.computeConv3DInfo(r.shape, o, i, 1, l), u = new p_(p);
        return n.runWebGLProgram(u, [ r, s ], "float32");
    }
}, rp, A_ = {
    kernelName: Es,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            pad: i,
            strides: l,
            inputShape: o
        } = a, p = C.computeConv3DInfo(o, s.shape, l, 1, i), u = new c_(p);
        return n.runWebGLProgram(u, [ r, s ], "float32");
    }
}, x_ = rt({
    opSnippet: gu + `
  return cos(x);
`,
    packedOpSnippet: `
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ro}
  return result;
`
}), b_ = {
    kernelName: $s,
    backendName: "webgl",
    kernelFunc: x_
}, v_ = rt({
    opSnippet: `
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`
}), w_ = {
    kernelName: Ms,
    backendName: "webgl",
    kernelFunc: v_
}, k_ = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "Image", "Boxes", "BoxInd" ], this.outputShape = [];
        let [ s, i, l, o ] = e, [ p ] = t, [ u, c ] = n;
        this.outputShape = [ p, u, c, o ];
        let d = a === "bilinear" ? 1 : 0, [ h, f ] = [ i - 1 + ".0", l - 1 + ".0" ], [ m, g, y ] = u > 1 ? [ "" + (i - 1) / (u - 1), "(y2-y1) * height_ratio", `y1*${h} + float(y)*(height_scale)` ] : [ "0.0", "0.0", `0.5 * (y1+y2) * ${h}` ], [ A, x, b ] = c > 1 ? [ "" + (l - 1) / (c - 1), "(x2-x1) * width_ratio", `x1*${f} + float(x)*(width_scale)` ] : [ "0.0", "0.0", `0.5 * (x1+x2) * ${f}` ];
        this.userCode = `
      const float height_ratio = float(${m});
      const float width_ratio = float(${A});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${b};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `;
    }
}, I_ = {
    kernelName: Os,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r,
            boxes: s,
            boxInd: i
        } = t, {
            cropSize: l,
            method: o,
            extrapolationValue: p
        } = a, u = new k_(r.shape, s.shape, l, o, p);
        return n.runWebGLProgram(u, [ r, s, i ], "float32");
    }
};

(function(e) {
    e.Prod = "*", e.Sum = "+";
})(rp || (rp = {}));

var d3 = class {
    constructor(e, t, n, a) {
        this.op = e, this.outputShape = t, this.variableNames = [ "x" ], this.customUniforms = [ {
            name: "index",
            type: "float"
        } ];
        let r = this.outputShape.length, s = this.op === rp.Prod ? "1.0" : "0.0", i = n ? s : `getX(${p3(r, "coords", this.op)})`, l = this.outputShape[this.outputShape.length - 1], o = "", p = "";
        n ? (o = a ? "end != " + (l - 1) : "end != 0", p = a ? "end + 1" : "end - 1") : (o = a ? `end + pow2 < ${l}` : "end >= pow2", 
        p = a ? "end + pow2" : "end - pow2"), this.userCode = `
      void main() {
        ${ft(r)} coords = getOutputCoords();
        int end = ${c3(r, "coords", this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${o}) {
          int idx = ${p};
          ${c3(r, "coords", this.op)} = idx;
          val ${this.op}= getX(${p3(r, "coords", this.op)});
        }
        setOutput(val);
      }
    `;
    }
};

function p3(e, t, n) {
    if (e === 1) return `${t}`;
    if (e === 2) return `${t}.x, ${t}.y`;
    if (e === 3) return `${t}.x, ${t}.y, ${t}.z`;
    if (e === 4) return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
    throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`);
}

function c3(e, t, n) {
    if (e === 1) return `${t}`;
    if (e === 2) return `${t}.y`;
    if (e === 3) return `${t}.z`;
    if (e === 4) return `${t}.w`;
    throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`);
}

function h3(e, t, n, a, r, s) {
    let i = t.shape.length, l = C.getAxesPermutation([ a ], i), o = t;
    l != null && (o = mn({
        inputs: {
            x: t
        },
        backend: n,
        attrs: {
            perm: l
        }
    }));
    let p = C.getInnerMostAxes(1, i)[0];
    if (p !== i - 1) throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${a}`);
    let u = o.shape[p], c = Hn({
        inputs: {
            x: o
        },
        backend: n
    });
    for (let d = 0; d <= Math.ceil(Math.log2(u)) - 1; d++) {
        let h = new d3(e, o.shape, !1, s), f = [ [ d ] ], m = c;
        c = n.runWebGLProgram(h, [ c ], c.dtype, f), n.disposeIntermediateTensorInfo(m);
    }
    if (r) {
        let d = new d3(e, o.shape, r, s), h = c;
        c = n.runWebGLProgram(d, [ c ], c.dtype), n.disposeIntermediateTensorInfo(h);
    }
    if (l != null) {
        let d = mn({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                perm: C.getUndoAxesPermutation(l)
            }
        });
        return n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(o), 
        d;
    }
    return c;
}

var S_ = {
    kernelName: Fs,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a;
        return h3(rp.Prod, r, n, s, i, l);
    }
}, N_ = {
    kernelName: _s,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a;
        return h3(rp.Sum, r, n, s, i, l);
    }
}, C_ = {
    kernelName: gl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = t, {
            size: i,
            binaryOutput: l
        } = a;
        if (r.shape.length === 1) {
            let o = n.readSync(r.dataId), p = n.readSync(s.dataId), u = $b(o, p, s.dtype, s.shape, i);
            return n.makeTensorInfo([ i ], s.dtype, u);
        }
        if (r.shape.length === 2) {
            let o = n.bufferSync(r), p = n.bufferSync(s), u = D$(o, p, i, l);
            return n.makeTensorInfo(u.shape, s.dtype, u.values);
        }
        throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`);
    }
}, T_ = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.outputShape = [], this.outputShape = e, 
        this.blockSize = t, this.dataFormat = n, this.userCode = `
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `;
    }
    getHeightCoordString() {
        return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
        return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
        return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
        return this.dataFormat === "NHWC" ? this.outputShape[3] : this.outputShape[1];
    }
    getInputSamplingString() {
        return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
}, R_ = {
    kernelName: Ps,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockSize: s,
            dataFormat: i
        } = a, l = r.shape[0], o = (i === "NHWC" ? r.shape[1] : r.shape[2]) * s, p = (i === "NHWC" ? r.shape[2] : r.shape[3]) * s, u = (i === "NHWC" ? r.shape[3] : r.shape[1]) / (s * s), c = new T_(i === "NHWC" ? [ l, o, p, u ] : [ l, u, o, p ], s, i);
        return n.runWebGLProgram(c, [ r ], r.dtype);
    }
}, f3 = class {
    constructor(e, t = !1, n = null, a = !1, r = !1) {
        this.variableNames = [ "x", "W" ], this.customUniforms = [ {
            name: "pads",
            type: "ivec2"
        }, {
            name: "strides",
            type: "ivec2"
        }, {
            name: "dilations",
            type: "ivec2"
        }, {
            name: "inDims",
            type: "ivec2"
        } ], this.outputShape = e.outShape, this.enableShapeUniforms = on(this.outputShape.length);
        let s = e.filterHeight, i = e.filterWidth, l = e.outChannels / e.inChannels, o = "", p = "";
        n && (o = a ? `float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }` : r ? `float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }` : `
          float activation(float x) {
            ${n}
          }
        `, p = "result = activation(result);");
        let u = t ? "result += getBiasAtOutCoords();" : "";
        t && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), 
        r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${o}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${u}
        ${p}
        setOutput(result);
      }
    `;
    }
}, m3 = class {
    constructor(e, t = !1, n = null, a = !1, r = !1) {
        this.variableNames = [ "x", "W" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "pads",
            type: "ivec2"
        }, {
            name: "strides",
            type: "ivec2"
        }, {
            name: "dilations",
            type: "ivec2"
        }, {
            name: "inDims",
            type: "ivec2"
        } ], this.outputShape = e.outShape, this.enableShapeUniforms = on(this.outputShape.length);
        let s = e.outChannels / e.inChannels, i = e.padInfo.left, l = e.strideWidth, o = e.dilationWidth, p = e.filterHeight, u = e.filterWidth, c = u, d = `
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;
        for (let g = 0; g < u; g++) d += `
          vec4 xTexelC${2 * g};
          int xTexelC${2 * g}Ready;
          vec4 xTexelC${2 * g + 1};
          int xTexelC${2 * g + 1}Ready;
          vec4 xC${g};`;
        d += `
    for (int r = 0; r < ${p}; r++) {
      `;
        for (let g = 0; g < u; g++) d += `
          xTexelC${2 * g} = vec4(0.0);
          xTexelC${2 * g}Ready = 0;
          xTexelC${2 * g + 1} = vec4(0.0);
          xTexelC${2 * g + 1}Ready = 0;
          xC${g} = vec4(0.0);`;
        d += `
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;
        for (let g = 0; g < (c + 1) / 2; g++) {
            let y = 2 * g;
            if (d += `
          xC = xCCorner + ${y * o};
          `, l === 1) {
                if (y < u && (i % 2 == 1 ? (d += `
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `, d += o === 1 && y > 0 ? `
                xC${y} = vec4(xTexelC${y - 2}.zw, xTexelC${y}.xy);
                ` : `
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `) : d += `
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `, y + 1 < u)) {
                    let A = i % 2 == 0 ? k.nearestLargerEven(o) : o;
                    o % 2 == 0 && i % 2 == 1 || o % 2 != 0 && i % 2 != 1 ? (d += `
                  xCOffset = xC + imod(pads[1], 2) + ${A};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                    xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y + 1}.zw = vec2(0.0);
                    }
                    xTexelC${y + 1}Ready = 1;
                  }
                  `, d += o > 1 ? `
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y + 1} = vec4(previous.zw, xTexelC${y + 1}.xy);
                    } else {
                     xC${y + 1} = vec4(0.0, 0.0, xTexelC${y + 1}.xy);
                    }
                    ` : `
                    xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.xy);
                    `) : d += A === 1 ? `
                    xC${y + 1} = xTexelC${y};
                    ` : `
                    xCOffset = xC + ${A};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                      xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y + 1}.zw = vec2(0.0);
                      }
                      xTexelC${y + 1}Ready = 1;
                    }

                    xC${y + 1} = xTexelC${y + 1};
                    `;
                }
            } else y < u && (i % 2 == 1 ? (d += `
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.0);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
              `, y + 1 < u && (d += `
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y + 1} = vec4(xTexelC${y + 1}.xy, final.xy);
                `)) : (d += `
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y + 1}Ready == 0) {
                  xTexelC${y + 1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y + 1}.zw = vec2(0.);
                  }
                  xTexelC${y + 1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y + 1}.xy);
              `, y + 1 < u && (d += `
                  xC${y + 1} = vec4(xTexelC${y}.zw, xTexelC${y + 1}.zw);
                `)));
            y < u && (d += `
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `, y + 1 < u && (d += `
              wTexel = getW(r, ${y + 1}, d1, q);
              dotProd += xC${y + 1} * vec4(wTexel.xz, wTexel.xz);
            `));
        }
        d += `
    }
  `, d += `
      }
    `;
        let h = "", f = "";
        n && (h = a ? `vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }` : r ? `vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }` : `vec4 activation(vec4 x) {
          ${n}
        }`, f = "result = activation(result);");
        let m = t ? "result += getBiasAtOutCoords();" : "";
        t && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), 
        r && this.variableNames.push("leakyreluAlpha"), this.userCode = `
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `;
    }
}, E_ = {
    kernelName: Ds,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o,
            dimRoundingMode: p
        } = a, u = o;
        u == null && (u = [ 1, 1 ]), k.assert(C.eitherStridesOrDilationsAreOne(i, u), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);
        let c, d = C.computeConv2DInfo(r.shape, s.shape, i, u, l, p, !0);
        c = H().getBool("WEBGL_PACK_DEPTHWISECONV") && d.strideWidth <= 2 && d.outChannels / d.inChannels == 1 ? new m3(d) : new f3(d);
        let h = [ [ d.padInfo.top, d.padInfo.left ], [ d.strideHeight, d.strideWidth ], [ d.dilationHeight, d.dilationWidth ], [ d.inHeight, d.inWidth ] ];
        return n.runWebGLProgram(c, [ r, s ], "float32", h);
    }
}, $_ = class {
    constructor(e) {
        this.variableNames = [ "x", "dy" ], this.outputShape = e.filterShape;
        let t = e.strideHeight, n = e.strideWidth, a = e.padInfo.top, r = e.padInfo.left, s = e.outChannels / e.inChannels;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${a};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, M_ = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.outputShape = e.inShape;
        let t = e.filterHeight, n = e.filterWidth, a = e.strideHeight, r = e.strideWidth, s = t - 1 - e.padInfo.top, i = n - 1 - e.padInfo.left, l = e.outChannels / e.inChannels;
        this.userCode = `
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, F_ = {
    kernelName: Zu,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            dilations: l,
            pad: o,
            dimRoundingMode: p,
            filterShape: u
        } = a, c = C.computeConv2DInfo(r.shape, u, i, l, o, p, !0), d = new $_(c);
        return n.runWebGLProgram(d, [ r, s ], "float32");
    }
}, __ = {
    kernelName: Yu,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            strides: i,
            dilations: l,
            pad: o,
            dimRoundingMode: p,
            inputShape: u
        } = a, c = C.computeConv2DInfo(u, s.shape, i, l, o, p, !0), d = new M_(c);
        return n.runWebGLProgram(d, [ r, s ], "float32");
    }
}, O_ = class {
    constructor(e) {
        this.variableNames = [ "X" ], this.outputShape = [ e, e ], this.userCode = `
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `;
    }
}, P_ = {
    kernelName: yl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t, r = [ ...a.shape, ...a.shape ], s = k.sizeFromShape(a.shape), i = he({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: [ s ]
            }
        }), l = new O_(s), o = n.runWebGLProgram(l, [ i ], i.dtype), p = he({
            inputs: {
                x: o
            },
            backend: n,
            attrs: {
                shape: r
            }
        });
        return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), 
        p;
    }
}, D_ = class {
    constructor(e) {
        this.variableNames = [ "x", "W" ], this.outputShape = e.outShape;
        let {
            inHeight: t,
            inWidth: n,
            padInfo: a,
            strideHeight: r,
            strideWidth: s,
            filterHeight: i,
            filterWidth: l,
            dilationHeight: o,
            dilationWidth: p
        } = e, {
            top: u,
            left: c
        } = a;
        this.userCode = `
      const ivec2 strides = ivec2(${r}, ${s});
      const ivec2 pads = ivec2(${u}, ${c});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${o};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `;
    }
}, z_ = {
    kernelName: zs,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s,
            filter: i
        } = n, {
            strides: l,
            pad: o,
            dilations: p
        } = r, u = C.computeDilation2DInfo(s.shape, i.shape, l, o, "NHWC", p), c = new D_(u);
        t = a.runWebGLProgram(c, [ s, i ], "float32");
        let d = he({
            inputs: {
                x: t
            },
            backend: a,
            attrs: {
                shape: u.outShape
            }
        });
        return a.disposeIntermediateTensorInfo(t), d;
    }
}, L_ = {
    kernelName: Qu,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            equation: r
        } = a, s = t, {
            allDims: i,
            summedDims: l,
            idDims: o
        } = C.decodeEinsumEquation(r, s.length);
        C.checkEinsumDimSizes(i.length, o, s);
        let {
            path: p,
            steps: u
        } = C.getEinsumComputePath(l, o), c = u.length, d = null, h = i.length, f = [];
        for (let m = 0; m < c; ++m) {
            for (let g of u[m]) {
                let y, {
                    permutationIndices: A,
                    expandDims: x
                } = C.getEinsumPermutation(h, o[g]);
                C.isIdentityPermutation(A) ? y = s[g] : (y = mn({
                    inputs: {
                        x: s[g]
                    },
                    backend: n,
                    attrs: {
                        perm: A
                    }
                }), f.push(y));
                let b = y.shape.slice();
                for (let v = 0; v < x.length; ++v) b.splice(x[v], 0, 1);
                k.arraysEqual(y.shape, b) || (y = he({
                    inputs: {
                        x: y
                    },
                    backend: n,
                    attrs: {
                        shape: b
                    }
                }), f.push(y)), d === null ? d = y : (d = h1({
                    inputs: {
                        a: y,
                        b: d
                    },
                    backend: n
                }), f.push(d));
            }
            m < c - 1 && (p[m] >= 0 && (d = Vc({
                inputs: {
                    x: d
                },
                backend: n,
                attrs: {
                    axis: p[m] - (i.length - h),
                    keepDims: !1
                }
            }), f.push(d)), h--);
        }
        for (let m of f) m !== d && n.disposeIntermediateTensorInfo(m);
        return d;
    }
}, W_ = rt({
    opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
    packedOpSnippet: `
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`
}), B_ = {
    kernelName: Ws,
    backendName: "webgl",
    kernelFunc: W_
}, V_ = {
    kernelName: bl,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n
        } = e, {
            dy: a,
            y: r
        } = t, s = H().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new mu(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`, a.shape, r.shape) : new To("return (b >= 0.0) ? a : a * (b + 1.0);", a.shape, r.shape);
        return n.runWebGLProgram(s, [ a, r ], a.dtype);
    }
}, U_ = en({
    opSnippet: "return float(a == b);",
    packedOpSnippet: `
  return vec4(equal(a, b));
`,
    dtype: "bool",
    cpuKernelImpl: V$
}), G_ = {
    kernelName: Vs,
    backendName: "webgl",
    kernelFunc: U_
}, H_ = rt({
    opSnippet: `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${C.ERF_P};
  float a1 = ${C.ERF_A1};
  float a2 = ${C.ERF_A2};
  float a3 = ${C.ERF_A3};
  float a4 = ${C.ERF_A4};
  float a5 = ${C.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`
}), j_ = {
    kernelName: Bs,
    backendName: "webgl",
    kernelFunc: H_
}, g3 = rt({
    opSnippet: gu + `
  return exp(x);
`,
    packedOpSnippet: `
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,
    cpuKernelImpl: U$,
    dtype: "float32"
}), q_ = {
    kernelName: Us,
    backendName: "webgl",
    kernelFunc: g3
};

function g1(e) {
    let {
        inputs: t,
        attrs: n,
        backend: a
    } = e, {
        dim: r
    } = n, {
        input: s
    } = t, i = s.shape.length, l = s.shape.slice(), o = r;
    return r < 0 && (k.assert(-(i + 1) <= r, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), 
    o = i + r + 1), l.splice(o, 0, 1), he({
        inputs: {
            x: s
        },
        backend: a,
        attrs: {
            shape: l
        }
    });
}

var X_ = {
    kernelName: vl,
    backendName: "webgl",
    kernelFunc: g1
}, y3 = "return exp(x) - 1.0;", K_ = rt({
    opSnippet: y3,
    packedOpSnippet: y3,
    cpuKernelImpl: G$
}), Z_ = {
    kernelName: Gs,
    backendName: "webgl",
    kernelFunc: K_
}, A3 = class {
    constructor(e, t, n) {
        this.variableNames = [ "real", "imag" ];
        let a = t[1];
        this.outputShape = t;
        let r, s = n ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`, i = n ? `${a}.0` : "1.0";
        if (e === "real") r = "return real * expR - imag * expI;"; else {
            if (e !== "imag") throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);
            r = "return real * expI + imag * expR;";
        }
        this.userCode = `
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${r}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `;
    }
};

function x3(e, t, n) {
    let a = n.texData.get(e.dataId), r = k.sizeFromShape(e.shape), s = e.shape[e.shape.length - 1], i = he({
        inputs: {
            x: e
        },
        backend: n,
        attrs: {
            shape: [ r / s, s ]
        }
    }), l = i.shape, o = new A3("real", l, t), p = new A3("imag", l, t), u = [ {
        dataId: a.complexTensorInfos.real.dataId,
        dtype: a.complexTensorInfos.real.dtype,
        shape: l
    }, {
        dataId: a.complexTensorInfos.imag.dataId,
        dtype: a.complexTensorInfos.imag.dtype,
        shape: l
    } ], c = n.runWebGLProgram(o, u, "float32"), d = n.runWebGLProgram(p, u, "float32"), h = Hr({
        inputs: {
            real: c,
            imag: d
        },
        backend: n
    });
    n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(d);
    let f = he({
        inputs: {
            x: h
        },
        backend: n,
        attrs: {
            shape: e.shape
        }
    });
    return n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(h), 
    f;
}

var Y_ = {
    kernelName: ed,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            input: a
        } = t;
        return x3(a, !1, n);
    }
}, J_ = class {
    constructor(e, t) {
        this.outputShape = [], this.customUniforms = [ {
            name: "value",
            type: "float"
        } ], this.variableNames = [ "x" ], this.outputShape = e, this.userCode = `
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `;
    }
};

function sp(e) {
    let {
        backend: t,
        attrs: n
    } = e, {
        shape: a,
        value: r
    } = n, {
        dtype: s
    } = n;
    if (s = s || k.inferDtype(r), s === "string") {
        let i = k.getArrayFromDType(s, k.sizeFromShape(a));
        return i.fill(r), t.makeTensorInfo(a, s, i);
    }
    {
        let i = new J_(a, r), l = [ [ r ] ];
        return t.runWebGLProgram(i, [], s, l);
    }
}

var Au, Q_ = {
    kernelName: wl,
    backendName: "webgl",
    kernelFunc: sp
}, eO = class {
    constructor(e) {
        this.variableNames = [ "Image" ], this.outputShape = [];
        let t = e[2];
        this.outputShape = e, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
}, tO = {
    kernelName: Hs,
    backendName: "webgl",
    kernelFunc: ({
        inputs: e,
        backend: t
    }) => {
        let {
            image: n
        } = e, a = t, r = new eO(n.shape);
        return a.runWebGLProgram(r, [ n ], n.dtype);
    }
}, b3 = "return floor(x);", nO = rt({
    opSnippet: b3,
    packedOpSnippet: b3,
    cpuKernelImpl: H$
}), aO = {
    kernelName: js,
    backendName: "webgl",
    kernelFunc: nO
}, rO = en({
    opSnippet: `
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,
    packedOpSnippet: `
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,
    dtype: "int32"
}), sO = {
    kernelName: qs,
    backendName: "webgl",
    kernelFunc: rO
}, iO = class {
    constructor(e) {
        this.variableNames = [ "A" ];
        let t = hn(), [ n, a ] = e;
        this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `;
    }
}, oO = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.packedInputs = !1, this.packedOutput = !0;
        let t = hn(), [ n, a ] = e;
        this.outputShape = e, this.userCode = `
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${a}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `;
    }
}, lO = {
    kernelName: hd,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            pixels: r
        } = t, {
            numChannels: s
        } = a, i = typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement, l = typeof HTMLImageElement < "u" && r instanceof HTMLImageElement, [ o, p ] = i ? [ r.videoWidth, r.videoHeight ] : [ r.width, r.height ], u = [ p, o ], c = [ p, o, s ];
        if (l || i) {
            let m = H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
            (Au == null || m !== y1) && (y1 = m, Au = document.createElement("canvas").getContext("2d", {
                willReadFrequently: y1
            })), Au.canvas.width = o, Au.canvas.height = p, Au.drawImage(r, 0, 0, o, p), 
            r = Au.canvas;
        }
        let d = n.makeTensorInfo(u, "int32");
        n.texData.get(d.dataId).usage = Qn.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), r);
        let h = H().getBool("WEBGL_PACK") ? new oO(c) : new iO(c), f = n.runWebGLProgram(h, [ d ], "int32");
        return n.disposeData(d.dataId), f;
    }
}, y1 = H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"), uO = {
    kernelName: kr,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s,
            filter: i,
            bias: l,
            preluActivationWeights: o
        } = n, {
            strides: p,
            pad: u,
            dataFormat: c,
            dilations: d,
            dimRoundingMode: h,
            activation: f,
            leakyreluAlpha: m
        } = r, g = C.convertConv2DDataFormat(c), y = C.computeConv2DInfo(s.shape, i.shape, p, d, u, h, !1, g), A = [], x = l != null, b = o != null, v = f === "leakyrelu", I = () => {
            let T = [ s, i ], R = (w, E) => {
                if (E === "NCHW" && w.shape.length === 1 && w.shape[0] !== 1) {
                    let $ = he({
                        inputs: {
                            x: w
                        },
                        backend: a,
                        attrs: {
                            shape: [ w.shape[0], 1, 1 ]
                        }
                    });
                    return A.push($), $;
                }
                return w;
            };
            if (x && T.push(R(l, c)), b && T.push(R(o, c)), v) {
                let w = a.makeTensorInfo([], "float32", k.createScalarValue(m, "float32"));
                T.push(w), A.push(w);
            }
            return T;
        };
        if (y.filterHeight !== 1 || y.filterWidth !== 1 || y.dilationHeight !== 1 || y.dilationWidth !== 1 || y.strideHeight !== 1 || y.strideWidth !== 1 || y.padInfo.type !== "SAME" && y.padInfo.type !== "VALID") if (y.strideWidth <= 2 && g === "channelsLast" && H().getBool("WEBGL_EXP_CONV")) {
            let T = f ? ep(f, !0) : null, R = new o3(y, x, T, b, v), w = [ [ y.padInfo.top, y.padInfo.left ], [ y.strideHeight, y.strideWidth ], [ y.dilationHeight, y.dilationWidth ], [ y.inHeight, y.inWidth ] ], E = I();
            t = a.runWebGLProgram(R, E, "float32", w);
        } else if (H().getBool("WEBGL_CONV_IM2COL")) t = u3({
            x: s,
            filter: i,
            convInfo: y,
            backend: a,
            bias: l,
            activation: f,
            preluActivationWeights: o,
            leakyreluAlpha: m
        }); else {
            let T = f ? ep(f, !1) : null, R = new i3(y, x, T, b, v), w = I();
            t = a.runWebGLProgram(R, w, "float32");
        } else t = l3({
            x: s,
            filter: i,
            convInfo: y,
            backend: a,
            bias: l,
            activation: f,
            preluActivationWeights: o,
            leakyreluAlpha: m
        });
        let N = he({
            inputs: {
                x: t
            },
            backend: a,
            attrs: {
                shape: y.outShape
            }
        });
        return A.push(t), A.forEach(T => a.disposeIntermediateTensorInfo(T)), N;
    }
}, dO = {
    kernelName: Ir,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dilations: u,
            dimRoundingMode: c,
            activation: d,
            leakyreluAlpha: h
        } = a, f = [], m = u;
        m == null && (m = [ 1, 1 ]), k.assert(C.eitherStridesOrDilationsAreOne(o, m), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${m}'`);
        let g, y = C.computeConv2DInfo(r.shape, s.shape, o, m, p, c, !0), A = H().getBool("WEBGL_PACK_DEPTHWISECONV") && y.strideWidth <= 2 && y.outChannels / y.inChannels == 1, x = d ? ep(d, A) : null, b = [ r, s ], v = i != null, I = l != null, N = d === "leakyrelu";
        if (v && b.push(i), I && b.push(l), N) {
            let w = n.makeTensorInfo([], "float32", k.createScalarValue(h, "float32"));
            b.push(w), f.push(w);
        }
        g = A ? new m3(y, v, x, I, N) : new f3(y, v, x, I, N);
        let T = [ [ y.padInfo.top, y.padInfo.left ], [ y.strideHeight, y.strideWidth ], [ y.dilationHeight, y.dilationWidth ], [ y.inHeight, y.inWidth ] ], R = n.runWebGLProgram(g, b, "float32", T);
        return f.forEach(w => n.disposeIntermediateTensorInfo(w)), R;
    }
}, pO = class {
    constructor(e, t, n, a) {
        this.sliceDim = e, this.strides = t, this.paramsShape = a, this.variableNames = [ "x", "indices" ], 
        this.outputShape = n;
        let r = ft(n.length), s = `
    int index;`;
        for (let i = 0; i < this.sliceDim; i++) s += `
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;
        this.userCode = `
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `;
    }
}, cO = {
    kernelName: Ks,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            params: a,
            indices: r
        } = t, s = r.shape, i = s[s.length - 1], l = k.sizeFromShape(a.shape), [ o, p, u, c ] = C.prepareAndValidate(a, r), d = he({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ p, i ]
            }
        }), h = he({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: [ k.sizeFromShape(a.shape) / u, u ]
            }
        });
        if (n.shouldExecuteOnCPU([ a, r ]) || a.dtype === "string") {
            let y = n.readSync(r.dataId), A = n.bufferSync(a), x = j$(y, A, a.dtype, p, i, u, c, a.shape, l);
            return n.makeTensorInfo(o, a.dtype, x.values);
        }
        let f = new pO(i, c, [ p, u ], a.shape), m = n.runWebGLProgram(f, [ h, d ], h.dtype), g = he({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                shape: o
            }
        });
        return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(h), 
        n.disposeIntermediateTensorInfo(m), g;
    }
}, hO = class {
    constructor(e, t) {
        this.variableNames = [ "A", "indices" ], this.outputShape = t, this.rank = t.length;
        let n = ft(this.rank), a = function(r, s) {
            let i = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w" ], l = [];
            for (let o = 0; o < r.length; o++) o === 2 ? l.push("index") : l.push(`${i[o]}`);
            return l.join();
        }(e);
        this.userCode = `
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `;
    }
};

function v3(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r,
        indices: s
    } = t, {
        axis: i,
        batchDims: l
    } = a, o = k.parseAxisParam(i, r.shape)[0];
    if (H().get("DEBUG")) {
        let A = n.readSync(s.dataId), x = r.shape[o];
        for (let b = 0; b < A.length; ++b) {
            let v = A[b];
            k.assert(v <= x - 1 && v >= 0, () => `GatherV2: the index value ${v} is not in [0, ${x - 1}]`);
        }
    }
    let p = C.segment_util.collectGatherOpShapeInfo(r, s, o, l), u = k.sizeFromShape(s.shape), c = [], d = he({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            shape: [ p.batchSize, p.outerSize, p.dimSize, p.sliceSize ]
        }
    }), h = he({
        inputs: {
            x: s
        },
        backend: n,
        attrs: {
            shape: [ p.batchSize, u / p.batchSize ]
        }
    });
    c.push(d), c.push(h);
    let f = [ p.batchSize, p.outerSize, u / p.batchSize, p.sliceSize ];
    if (n.shouldExecuteOnCPU([ r, s ]) || r.dtype === "string") {
        let A = n.bufferSync(h), x = n.bufferSync(d), b = q$(x, A, f);
        return c.forEach(v => n.disposeIntermediateTensorInfo(v)), n.makeTensorInfo(p.outputShape, b.dtype, b.values);
    }
    let m = new hO(d.shape, f), g = n.runWebGLProgram(m, [ d, h ], d.dtype);
    c.push(g);
    let y = he({
        inputs: {
            x: g
        },
        backend: n,
        attrs: {
            shape: p.outputShape
        }
    });
    return c.forEach(A => n.disposeIntermediateTensorInfo(A)), y;
}

var fO = {
    kernelName: kl,
    backendName: "webgl",
    kernelFunc: v3
}, mO = en({
    opSnippet: "return float(a > b);",
    packedOpSnippet: `
  return vec4(greaterThan(a, b));
`,
    cpuKernelImpl: X$,
    dtype: "bool"
}), gO = {
    kernelName: Zs,
    backendName: "webgl",
    kernelFunc: mO
}, yO = en({
    opSnippet: "return float(a >= b);",
    packedOpSnippet: `
  return vec4(greaterThanEqual(a, b));
`,
    dtype: "bool",
    cpuKernelImpl: K$
}), AO = {
    kernelName: Ys,
    backendName: "webgl",
    kernelFunc: yO
}, xO = {
    kernelName: td,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            input: a
        } = t;
        return x3(a, !0, n);
    }
}, bO = rt({
    opSnippet: "return float(!isnan(x) && !isinf(x));",
    dtype: "bool"
}), vO = {
    kernelName: Qs,
    backendName: "webgl",
    kernelFunc: bO
}, wO = rt({
    opSnippet: "return float(isinf(x));",
    dtype: "bool"
}), kO = {
    kernelName: ei,
    backendName: "webgl",
    kernelFunc: wO
}, IO = rt({
    opSnippet: "return float(isnan(x));",
    dtype: "bool"
}), SO = {
    kernelName: ti,
    backendName: "webgl",
    kernelFunc: IO
}, NO = en({
    opSnippet: "return float(a < b);",
    packedOpSnippet: `
  return vec4(lessThan(a, b));
`,
    cpuKernelImpl: Z$,
    dtype: "bool"
}), CO = {
    kernelName: ai,
    backendName: "webgl",
    kernelFunc: NO
}, TO = en({
    opSnippet: "return float(a <= b);",
    packedOpSnippet: `
  return vec4(lessThanEqual(a, b));
`,
    cpuKernelImpl: Y$,
    dtype: "bool"
}), RO = {
    kernelName: ri,
    backendName: "webgl",
    kernelFunc: TO
}, EO = {
    kernelName: si,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            backend: t,
            attrs: n
        } = e, {
            start: a,
            stop: r,
            num: s
        } = n, i = J$(a, r, s);
        return t.makeTensorInfo([ i.length ], "float32", i);
    }
}, $O = rt({
    opSnippet: gu + `
  return x < 0.0 ? 0./0. : log(x);
`,
    packedOpSnippet: `
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,
    cpuKernelImpl: Q$
}), MO = {
    kernelName: ii,
    backendName: "webgl",
    kernelFunc: $O
}, FO = rt({
    opSnippet: gu + `
  return log(1.0 + x);
`
}), _O = {
    kernelName: oi,
    backendName: "webgl",
    kernelFunc: FO
}, OO = en({
    opSnippet: "return float(a >= 1.0 && b >= 1.0);",
    packedOpSnippet: `
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,
    dtype: "bool"
}), PO = {
    kernelName: li,
    backendName: "webgl",
    kernelFunc: OO
}, DO = rt({
    opSnippet: "return float(!(x >= 1.0));"
}), zO = {
    kernelName: ui,
    backendName: "webgl",
    kernelFunc: DO
}, LO = en({
    opSnippet: "return float(a >= 1.0 || b >= 1.0);",
    packedOpSnippet: `
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,
    dtype: "bool"
}), WO = {
    kernelName: di,
    backendName: "webgl",
    kernelFunc: LO
}, BO = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "x" ], this.outputShape = [];
        let s = t, i = e[3] - 1;
        this.outputShape = e;
        let l, o = `float(${n}) + float(${a}) * sum`;
        l = r === .5 ? `inversesqrt(${o})` : r === 1 ? `1.0/(${o})` : `exp(log(${o}) * float(-${r}));`, 
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `;
    }
}, VO = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "x" ], this.outputShape = [], this.packedInputs = !0, 
        this.packedOutput = !0;
        let s = t, i = e[3] - 1;
        this.outputShape = e;
        let l, o = `float(${n}) + float(${a}) * sum`;
        l = r === .5 ? `inversesqrt(${o})` : r === 1 ? `1.0/(${o})` : `exp(log(${o}) * float(-${r}));`, 
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `;
    }
}, UO = {
    kernelName: pi,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            depthRadius: s,
            bias: i,
            alpha: l,
            beta: o
        } = a, p = H().getBool("WEBGL_PACK_NORMALIZATION") ? new VO(r.shape, s, i, l, o) : new BO(r.shape, s, i, l, o);
        return n.runWebGLProgram(p, [ r ], r.dtype);
    }
}, GO = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "inputImage", "outputImage", "dy" ], this.outputShape = [], 
        this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = n, 
        this.alpha = a, this.beta = r, this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `;
    }
}, HO = {
    kernelName: Il,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            y: s,
            dy: i
        } = t, {
            depthRadius: l,
            bias: o,
            alpha: p,
            beta: u
        } = a, c = new GO(r.shape, l, o, p, u);
        return n.runWebGLProgram(c, [ r, s, i ], r.dtype);
    }
};

function w3(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        reductionIndices: s,
        keepDims: i
    } = a, l = r.shape.length, o = k.parseAxisParam(s, r.shape), p = o, u = C.getAxesPermutation(p, l), c = u != null, d = n.shouldExecuteOnCPU([ r ]), h = r;
    if (c) {
        if (d) {
            let A = n.texData.get(h.dataId).values, x = new Array(l);
            for (let v = 0; v < x.length; v++) x[v] = r.shape[u[v]];
            let b = d1(A, r.shape, r.dtype, u, x);
            h = n.makeTensorInfo(x, r.dtype), n.texData.get(h.dataId).values = b;
        } else h = Bc(r, u, n);
        p = C.getInnerMostAxes(p.length, l);
    }
    C.assertAxesAreInnerMostDims("max", p, l);
    let f, [ m, g ] = C.computeOutAndReduceShapes(h.shape, p), y = m;
    if (i && (y = C.expandShapeToKeepDim(m, o)), d) {
        let A = n.texData.get(h.dataId).values, x = eM(A, k.sizeFromShape(g), y, r.dtype);
        f = n.makeTensorInfo(y, r.dtype), n.texData.get(f.dataId).values = x;
    } else f = function(A, x, b, v) {
        let I = k.sizeFromShape(x), N = he({
            inputs: {
                x: A
            },
            attrs: {
                shape: [ k.sizeFromShape(A.shape) / I, I ]
            },
            backend: v
        }), T = Eo(N, A.dtype, "max", v), R = he({
            inputs: {
                x: T
            },
            attrs: {
                shape: b
            },
            backend: v
        });
        return v.disposeIntermediateTensorInfo(N), v.disposeIntermediateTensorInfo(T), 
        R;
    }(h, g, y, n);
    return c && n.disposeIntermediateTensorInfo(h), f;
}

var jO = {
    kernelName: ci,
    backendName: "webgl",
    kernelFunc: w3
}, qO = en({
    opSnippet: c1 + `
  return max(a, b);
`,
    packedOpSnippet: `
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Ro + `
  return result;
`,
    cpuKernelImpl: tM
}), XO = {
    kernelName: hi,
    backendName: "webgl",
    kernelFunc: qO
}, KO = {
    kernelName: fi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t;
        du(r, "maxPool");
        let {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o
        } = a;
        k.assert(C.eitherStridesOrDilationsAreOne(i, 1), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);
        let p = C.computePool2DInfo(r.shape, s, i, 1, l, o);
        if (p.filterWidth === 1 && p.filterHeight === 1 && k.arraysEqual(p.inShape, p.outShape)) return Hn({
            inputs: {
                x: r
            },
            backend: n
        });
        let u = new tp(p, "max", !1);
        return n.runWebGLProgram(u, [ r ], r.dtype);
    }
}, ZO = {
    kernelName: Sl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p
        } = a, u = C.computePool3DInfo(r.shape, s, i, [ 1, 1, 1 ], l, p, o), c = new f1(u, "max", !1);
        return n.runWebGLProgram(c, [ r ], r.dtype);
    }
}, YO = class {
    constructor(e) {
        this.variableNames = [ "dy", "maxPos" ], this.outputShape = e.inShape;
        let t = e.strideHeight, n = e.strideWidth, a = e.dilationHeight, r = e.effectiveFilterHeight, s = e.effectiveFilterWidth, i = r - 1 - e.padInfo.top, l = s - 1 - e.padInfo.left, o = r * s - 1;
        this.userCode = `
      const ivec2 pads = ivec2(${i}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${o} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, JO = class {
    constructor(e) {
        this.variableNames = [ "dy", "maxPos" ], this.outputShape = e.inShape;
        let t = e.strideDepth, n = e.strideHeight, a = e.strideWidth, r = e.dilationDepth, s = e.dilationHeight, i = e.dilationWidth, l = e.effectiveFilterDepth, o = e.effectiveFilterHeight, p = e.effectiveFilterWidth, u = l - 1 - e.padInfo.front, c = o - 1 - e.padInfo.top, d = p - 1 - e.padInfo.left, h = l * o * p - 1;
        this.userCode = `
      const ivec3 pads = ivec3(${u}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${o};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${o} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `;
    }
}, QO = {
    kernelName: rd,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s, {
            filterSize: l,
            strides: o,
            pad: p,
            dimRoundingMode: u
        } = a, c = C.computePool3DInfo(i.shape, l, o, [ 1, 1, 1 ], p, u), d = new f1(c, "max", !0), h = n.runWebGLProgram(d, [ i ], i.dtype), f = new JO(c), m = n.runWebGLProgram(f, [ r, h ], i.dtype);
        return n.disposeIntermediateTensorInfo(h), m;
    }
}, eP = {
    kernelName: ad,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s,
            output: i
        } = t, l = s;
        du([ s, i ], "maxPoolGrad");
        let {
            filterSize: o,
            strides: p,
            pad: u,
            dimRoundingMode: c
        } = a, d = C.computePool2DInfo(l.shape, o, p, 1, u, c), h = new tp(d, "max", !0), f = n.runWebGLProgram(h, [ l ], l.dtype), m = new YO(d), g = n.runWebGLProgram(m, [ r, f ], l.dtype);
        return n.disposeIntermediateTensorInfo(f), g;
    }
}, tP = {
    kernelName: Nl,
    backendName: "webgl",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            x: a
        } = e, {
            filterSize: r,
            strides: s,
            pad: i,
            includeBatchInIndex: l
        } = t, o = n;
        k.assert(a.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);
        let p = [ 1, 1 ];
        k.assert(C.eitherStridesOrDilationsAreOne(s, p), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);
        let u = C.computePool2DInfo(a.shape, r, s, p, i), [ c, d ] = function(h, f, m, g) {
            let y = new tp(m, "max", !1), A = g.runWebGLProgram(y, [ h ], "float32");
            return y = new tp(m, "max", !0, !0, f), [ A, g.runWebGLProgram(y, [ h ], "float32") ];
        }(a, l, u, o);
        return [ c, d ];
    }
}, nP = {
    kernelName: mi,
    backendName: "webgl",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            x: a
        } = e, {
            keepDims: r,
            axis: s
        } = t, i = n, l = a.shape.length, o = k.parseAxisParam(s, a.shape), p = o, u = C.getAxesPermutation(p, l), c = u != null, d = i.shouldExecuteOnCPU([ a ]), h = [], f = a;
        if (c) {
            if (d) {
                let x = i.texData.get(f.dataId).values, b = new Array(l);
                for (let I = 0; I < b.length; I++) b[I] = a.shape[u[I]];
                let v = d1(x, a.shape, a.dtype, u, b);
                f = i.makeTensorInfo(b, a.dtype), i.texData.get(f.dataId).values = v;
            } else f = Bc(a, u, i);
            h.push(f), p = C.getInnerMostAxes(p.length, l);
        }
        C.assertAxesAreInnerMostDims("sum", p, l);
        let [ m, g ] = C.computeOutAndReduceShapes(f.shape, p), y = m;
        r && (y = C.expandShapeToKeepDim(m, o));
        let A = function(x, b, v, I) {
            let N = k.sizeFromShape(b), T = he({
                inputs: {
                    x: x
                },
                attrs: {
                    shape: [ k.sizeFromShape(x.shape) / N, N ]
                },
                backend: I
            }), R = Eo(T, "float32", "mean", I), w = he({
                inputs: {
                    x: R
                },
                attrs: {
                    shape: v
                },
                backend: I
            });
            return I.disposeIntermediateTensorInfo(T), I.disposeIntermediateTensorInfo(R), 
            w;
        }(f, g, y, i);
        for (let x of h) i.disposeIntermediateTensorInfo(x);
        return A;
    }
}, aP = {
    kernelName: gi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a, l = r.shape.length, o = k.parseAxisParam(s, r.shape), p = o, u = C.getAxesPermutation(p, l), c = r;
        u != null && (c = mn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: u
            }
        }), p = C.getInnerMostAxes(p.length, r.shape.length)), C.assertAxesAreInnerMostDims("min", p, l);
        let d, [ h, f ] = C.computeOutAndReduceShapes(c.shape, p), m = he({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                shape: [ -1, k.sizeFromShape(f) ]
            }
        }), g = Eo(m, m.dtype, "min", n);
        return i ? d = he({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: C.expandShapeToKeepDim(h, o)
            }
        }) : d = he({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: h
            }
        }), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(g), 
        u != null && n.disposeIntermediateTensorInfo(c), d;
    }
}, rP = en({
    opSnippet: c1 + `
  return min(a, b);
`,
    packedOpSnippet: `
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  ` + Ro + `
  return result;
`,
    cpuKernelImpl: nM
}), sP = {
    kernelName: yi,
    backendName: "webgl",
    kernelFunc: rP
}, iP = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.outputShape = t.map((p, u) => p[0] + e[u] + p[1]);
        let a = e.length, r = ft(a), s = t.map(p => p[0]).join(","), i = t.map((p, u) => p[0] + e[u]).join(","), l = [ "coords[0]", "coords[1]", "coords[2]", "coords[3]" ].slice(0, a), o = n === "reflect" ? 0 : 1;
        this.userCode = a !== 1 ? `
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${o};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${o};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    ` : `
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${o};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${o};
          }
          setOutput(getX(outC - start));
        }
      `;
    }
}, oP = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outputShape = t.map((h, f) => h[0] + e[f] + h[1]);
        let a = e.length, r = ft(a), s = t.map(h => h[0]).join(","), i = t.map((h, f) => h[0] + e[f]).join(","), l = fn("rc", a), o = fn("source", a), p = `${l[a - 1]} < ${this.outputShape[a - 1]}`, u = a === 1 ? "source" : `vec2(${o.slice(-2).join()})`, c = n === "reflect" ? 0 : 1, d = "";
        if (a === 1) {
            let h = `
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${c};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${c};
        }
        source -= start;
      `;
            d = `
        ${r} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${o.join()}), ${u});
        ${l[a - 1]} += 1;
        if(${p}) {
          ${h}
          result[1] = getChannel(getX(${o.join()}), ${u});
        }
      `;
        } else {
            let h = `
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${c}) +
                gte * ((end - 1) * 2 - source + ${c});
        source -= start;
      `;
            d = `
        ${r} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${o.join()}), ${u});
        ${l[a - 1]} += 1;
        if(${p}) {
          ${h}
          result[1] = getChannel(getX(${o.join()}), ${u});
        }
        rc = outputLoc;
        ${l[a - 2]} += 1;
        if(${l[a - 2]} < ${this.outputShape[a - 2]}) {
          ${h}
          result[2] = getChannel(getX(${o.join()}), ${u});
          ${l[a - 1]} += 1;
          if(${p}) {
            ${h}
            result[3] = getChannel(getX(${o.join()}), ${u});
          }
        }
      `;
        }
        this.userCode = `
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `;
    }
}, lP = {
    kernelName: Ai,
    backendName: "webgl",
    kernelFunc: ({
        inputs: e,
        backend: t,
        attrs: n
    }) => {
        let {
            x: a
        } = e, {
            paddings: r,
            mode: s
        } = n, i = H().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new oP(a.shape, r, s) : new iP(a.shape, r, s);
        return t.runWebGLProgram(i, [ a ], a.dtype);
    }
}, uP = en({
    opSnippet: `if (b == 0.0) return NAN;
  return mod(a, b);`,
    packedOpSnippet: `
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  ` + Ro + `
  return result;
`
}), dP = {
    kernelName: xi,
    backendName: "webgl",
    kernelFunc: uP
}, pP = class {
    constructor(e, t, n) {
        this.variableNames = [ "probs" ], this.customUniforms = [ {
            name: "seed",
            type: "float"
        } ], this.outputShape = [ e, n ], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t - 1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t - 1}));
      }
    `;
    }
}, k3 = en({
    opSnippet: `
if (a == b) {
  return 1.0;
};
return a / b;`,
    packedOpSnippet: `
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,
    checkOutOfBounds: !0
}), cP = {
    kernelName: Ls,
    backendName: "webgl",
    kernelFunc: k3
}, I3 = "return a - b;", S3 = en({
    opSnippet: I3,
    packedOpSnippet: I3,
    supportsComplex: !0,
    cpuKernelImpl: kM
}), hP = {
    kernelName: Qi,
    backendName: "webgl",
    kernelFunc: S3
};

function N3(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        logits: r
    } = t, {
        dim: s
    } = a, i = k.parseAxisParam([ s ], r.shape), l = w3({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            reductionIndices: i,
            keepDims: !1
        }
    }), o = C.expandShapeToKeepDim(l.shape, i), p = he({
        inputs: {
            x: l
        },
        backend: n,
        attrs: {
            shape: o
        }
    }), u = S3({
        inputs: {
            a: r,
            b: p
        },
        backend: n
    }), c = g3({
        inputs: {
            x: u
        },
        backend: n
    }), d = Vc({
        inputs: {
            x: c
        },
        backend: n,
        attrs: {
            axis: i,
            keepDims: !1
        }
    }), h = he({
        inputs: {
            x: d
        },
        backend: n,
        attrs: {
            shape: o
        }
    }), f = k3({
        inputs: {
            a: c,
            b: h
        },
        backend: n
    });
    return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(p), 
    n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(d), 
    n.disposeIntermediateTensorInfo(h), f;
}

var fP = {
    kernelName: Ki,
    backendName: "webgl",
    kernelFunc: N3
}, mP = {
    kernelName: bi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            logits: r
        } = t, {
            numSamples: s,
            seed: i,
            normalized: l
        } = a, o = l ? r : N3({
            inputs: {
                logits: r
            },
            backend: n,
            attrs: {
                dim: r.shape.length - 1
            }
        }), p = o.shape[0], u = o.shape[1], c = new pP(p, u, s), d = [ [ i ] ], h = n.runWebGLProgram(c, [ o ], "int32", d);
        return l || n.disposeIntermediateTensorInfo(o), h;
    }
}, gP = ca + `
  return -x;
`, yP = {
    kernelName: Cl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a
        } = e, {
            x: r
        } = n;
        if (a.shouldExecuteOnCPU([ r ])) {
            let s = a.texData.get(r.dataId), [ i, l ] = rM(s.values, r.shape, r.dtype);
            return a.makeTensorInfo(l, r.dtype, i);
        }
        return t = H().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new Gr(r.shape, `
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`) : new Ba(r.shape, gP), a.runWebGLProgram(t, [ r ], r.dtype);
    }
}, AP = ua.nonMaxSuppressionV3Impl, xP = {
    kernelName: ki,
    backendName: "webgl",
    kernelFunc: function(e) {
        C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o
        } = a, p = n.readSync(r.dataId), u = n.readSync(s.dataId), {
            selectedIndices: c
        } = AP(p, u, i, l, o);
        return n.makeTensorInfo([ c.length ], "int32", new Int32Array(c));
    }
}, bP = ua.nonMaxSuppressionV4Impl, vP = {
    kernelName: Tl,
    backendName: "webgl",
    kernelFunc: function(e) {
        C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o,
            padToMaxOutputSize: p
        } = a, u = n.readSync(r.dataId), c = n.readSync(s.dataId), {
            selectedIndices: d,
            validOutputs: h
        } = bP(u, c, i, l, o, p);
        return [ n.makeTensorInfo([ d.length ], "int32", new Int32Array(d)), n.makeTensorInfo([], "int32", new Int32Array([ h ])) ];
    }
}, wP = ua.nonMaxSuppressionV5Impl, kP = {
    kernelName: Ii,
    backendName: "webgl",
    kernelFunc: function(e) {
        C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o,
            softNmsSigma: p
        } = a, u = n.readSync(r.dataId), c = n.readSync(s.dataId), d = i, h = l, f = o, m = p, {
            selectedIndices: g,
            selectedScores: y
        } = wP(u, c, d, h, f, m);
        return [ n.makeTensorInfo([ g.length ], "int32", new Int32Array(g)), n.makeTensorInfo([ y.length ], "float32", new Float32Array(y)) ];
    }
}, IP = class {
    constructor(e, t, n, a) {
        this.variableNames = [ "indices" ], this.outputShape = [ e, t ], this.userCode = `
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${n}),
                      float(index == coords.y)));
      }
    `;
    }
}, SP = {
    kernelName: Si,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r
        } = t, {
            dtype: s,
            depth: i,
            onValue: l,
            offValue: o
        } = a, p = k.sizeFromShape(r.shape), u = new IP(p, i, l, o), c = he({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ p ]
            }
        }), d = n.runWebGLProgram(u, [ c ], s);
        n.disposeIntermediateTensorInfo(c);
        let h = he({
            inputs: {
                x: d
            },
            backend: n,
            attrs: {
                shape: [ ...r.shape, i ]
            }
        });
        return n.disposeIntermediateTensorInfo(d), h;
    }
};

function qc(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        x: a
    } = t;
    if (a.dtype === "complex64") {
        let r = np({
            inputs: {
                input: a
            },
            backend: n
        }), s = qc({
            inputs: {
                x: r
            },
            backend: n
        }), i = Hc({
            inputs: {
                input: a
            },
            backend: n
        }), l = qc({
            inputs: {
                x: i
            },
            backend: n
        }), o = Hr({
            inputs: {
                real: s,
                imag: l
            },
            backend: n
        });
        return n.disposeIntermediateTensorInfo(r), n.disposeIntermediateTensorInfo(s), 
        n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(l), 
        o;
    }
    return sp({
        attrs: {
            shape: a.shape,
            dtype: a.dtype,
            value: a.dtype === "string" ? "" : 0
        },
        backend: n
    });
}

var NP = {
    kernelName: Gl,
    backendName: "webgl",
    kernelFunc: qc
}, CP = {
    kernelName: Rl,
    backendName: "webgl",
    kernelFunc: function e(t) {
        let {
            inputs: n,
            backend: a
        } = t, {
            x: r
        } = n;
        if (r.dtype === "string") throw new Error("onesLike is not supported under string dtype");
        if (r.dtype === "complex64") {
            let s = np({
                inputs: {
                    input: r
                },
                backend: a
            }), i = e({
                inputs: {
                    x: s
                },
                backend: a
            }), l = Hc({
                inputs: {
                    input: r
                },
                backend: a
            }), o = qc({
                inputs: {
                    x: l
                },
                backend: a
            }), p = Hr({
                inputs: {
                    real: i,
                    imag: o
                },
                backend: a
            });
            return a.disposeIntermediateTensorInfo(s), a.disposeIntermediateTensorInfo(i), 
            a.disposeIntermediateTensorInfo(l), a.disposeIntermediateTensorInfo(o), 
            p;
        }
        return sp({
            attrs: {
                shape: r.shape,
                dtype: r.dtype,
                value: 1
            },
            backend: a
        });
    }
}, TP = {
    kernelName: El,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            axis: r
        } = a;
        if (t.length === 1) return g1({
            inputs: {
                input: t[0]
            },
            backend: n,
            attrs: {
                dim: r
            }
        });
        let s = t[0].shape, i = t[0].dtype;
        t.forEach(p => {
            k.assertShapesMatch(s, p.shape, "All tensors passed to stack must have matching shapes"), 
            k.assert(i === p.dtype, () => "All tensors passed to stack must have matching dtypes");
        });
        let l = [], o = s3({
            inputs: t.map(p => {
                let u = g1({
                    inputs: {
                        input: p
                    },
                    backend: n,
                    attrs: {
                        dim: r
                    }
                });
                return l.push(u), u;
            }),
            backend: n,
            attrs: {
                axis: r
            }
        });
        return l.forEach(p => n.disposeIntermediateTensorInfo(p)), o;
    }
}, RP = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.customUniforms = [ {
            name: "value",
            type: "float"
        } ], this.outputShape = t.map((o, p) => o[0] + e[p] + o[1]);
        let a = e.length, r = ft(a), s = t.map(o => o[0]).join(","), i = t.map((o, p) => o[0] + e[p]).join(","), l = [ "coords[0]", "coords[1]", "coords[2]", "coords[3]" ].slice(0, a);
        this.userCode = a !== 1 ? `
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    ` : `
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;
    }
}, EP = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.customUniforms = [ {
            name: "value",
            type: "float"
        } ], this.outputShape = t.map((f, m) => f[0] + e[m] + f[1]);
        let a = e.length, r = ft(a), s = t.map(f => f[0]).join(","), i = t.map((f, m) => f[0] + e[m]).join(","), l = fn("rc", a), o = fn("source", a), p = `${l[a - 1]} < ${this.outputShape[a - 1]}`, u = a === 1 ? "source" : `vec2(${o.slice(-2).join()})`, c = [ `${r} rc = outputLoc;`, `${l[a - 1]} += 1;
       if(${p}) {
      `, a === 1 ? "" : `}
       rc = outputLoc;
       ${l[a - 2]} += 1;
       if(${l[a - 2]} < ${this.outputShape[a - 2]}) {`, a === 1 ? "" : `  ${l[a - 1]} += 1;
         if(${p}) {` ], d = a === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", h = "";
        for (let f = 0, m = a === 1 ? 2 : 4; f < m; f++) h += `
        ${c[f]}
        if (${d}) {
          result[${f}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${f}] = getChannel(getX(${o.join()}), ${u});
        }
      `;
        h += a === 1 ? "} " : "}}", this.userCode = `
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `;
    }
}, C3 = e => {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        paddings: s,
        constantValue: i
    } = a;
    if (k.sizeFromShape(r.shape) === 0) return sp({
        backend: n,
        attrs: {
            shape: s.map((p, u) => p[0] + r.shape[u] + p[1]),
            value: i,
            dtype: r.dtype
        }
    });
    let l = H().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new EP(r.shape, s, i) : new RP(r.shape, s, i), o = [ [ i ] ];
    return n.runWebGLProgram(l, [ r ], r.dtype, o);
}, $P = {
    kernelName: Ni,
    backendName: "webgl",
    kernelFunc: C3
}, MP = en({
    opSnippet: `
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,
    packedOpSnippet: `
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  ` + Ro + `
  return result;
`
}), FP = {
    kernelName: Ci,
    backendName: "webgl",
    kernelFunc: MP
}, _P = {
    kernelName: Ri,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s
        } = n, {
            axis: i,
            keepDims: l
        } = r, o = s.shape.length, p = [], u = k.parseAxisParam(i, s.shape), c = u, d = C.getAxesPermutation(c, o), h = s;
        if (d != null && (h = mn({
            inputs: {
                x: s
            },
            backend: a,
            attrs: {
                perm: d
            }
        }), c = C.getInnerMostAxes(c.length, o), p.push(h)), C.assertAxesAreInnerMostDims("prod", c, o), 
        a.shouldExecuteOnCPU([ h ])) {
            let f = a.texData.get(h.dataId).values, {
                outVals: m,
                outShape: g,
                outDtype: y
            } = iM(h.shape, h.dtype, f, c);
            t = a.makeTensorInfo(g, y, m);
        } else {
            let [ f, m ] = C.computeOutAndReduceShapes(h.shape, c), g = k.sizeFromShape(m), y = he({
                inputs: {
                    x: h
                },
                backend: a,
                attrs: {
                    shape: [ -1, g ]
                }
            }), A = Eo(y, kd(s.dtype), "prod", a);
            t = he({
                inputs: {
                    x: A
                },
                backend: a,
                attrs: {
                    shape: f
                }
            }), p.push(y), p.push(A);
        }
        if (l) {
            p.push(t);
            let f = C.expandShapeToKeepDim(t.shape, u);
            t = he({
                inputs: {
                    x: t
                },
                backend: a,
                attrs: {
                    shape: f
                }
            });
        }
        return p.forEach(f => a.disposeIntermediateTensorInfo(f)), t;
    }
}, OP = {
    kernelName: Bp,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            paramsNestedSplits: r,
            paramsDenseValues: s,
            indices: i
        } = t, {
            outputRaggedRank: l
        } = a, o = r.map(y => n.readSync(y.dataId)), p = r.map(y => y.shape), u = n.readSync(s.dataId), c = n.readSync(i.dataId), [ d, h, f ] = oM(o, p, u, s.shape, s.dtype, c, i.shape, l), m = d.map(y => n.makeTensorInfo([ y.length ], "int32", y)), g = n.makeTensorInfo(f, s.dtype, h);
        return m.concat([ g ]);
    }
}, PP = {
    kernelName: Vp,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            starts: a,
            limits: r,
            deltas: s
        } = t, i = n.readSync(a.dataId), l = n.readSync(r.dataId), o = n.readSync(s.dataId), [ p, u ] = lM(i, a.shape, a.dtype, l, r.shape, o, s.shape);
        return [ n.makeTensorInfo([ p.length ], "int32", p), n.makeTensorInfo([ u.length ], a.dtype, u) ];
    }
}, DP = {
    kernelName: Up,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            shape: r,
            values: s,
            defaultValue: i,
            rowPartitionTensors: l
        } = t, {
            rowPartitionTypes: o
        } = a, p = n.readSync(r.dataId), u = n.readSync(s.dataId), c = n.readSync(i.dataId), d = l.map(g => n.readSync(g.dataId)), h = l.map(g => g.shape), [ f, m ] = uM(p, r.shape, u, s.shape, s.dtype, c, i.shape, d, h, o);
        return n.makeTensorInfo(f, s.dtype, m);
    }
}, T3 = e => {
    let {
        backend: t,
        attrs: n
    } = e, {
        start: a,
        stop: r,
        step: s,
        dtype: i
    } = n, l = dM(a, r, s, i);
    return t.makeTensorInfo([ l.length ], i, l);
}, zP = {
    kernelName: $l,
    backendName: "webgl",
    kernelFunc: T3
}, LP = rt({
    opSnippet: "return 1.0 / x;"
}), WP = {
    kernelName: Ei,
    backendName: "webgl",
    kernelFunc: LP
}, BP = rt({
    opSnippet: ca + `
  return (x < 0.0) ? 0.0 : x;
`,
    packedOpSnippet: `
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`
}), VP = {
    kernelName: $i,
    backendName: "webgl",
    kernelFunc: BP
}, UP = rt({
    opSnippet: ca + `
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,
    packedOpSnippet: `
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`
}), GP = {
    kernelName: _i,
    backendName: "webgl",
    kernelFunc: UP
}, HP = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "A" ], this.outputShape = [];
        let [ s, i, l, o ] = e;
        this.outputShape = [ s, t, n, o ];
        let p, u = [ a && t > 1 ? i - 1 : i, a && n > 1 ? l - 1 : l ], c = [ a && t > 1 ? t - 1 : t, a && n > 1 ? n - 1 : n ];
        p = r ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", 
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0] / c[0]},
          ${u[1] / c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `;
    }
}, jP = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outputShape = [];
        let [ s, i, l, o ] = e;
        this.outputShape = [ s, t, n, o ];
        let p, u = [ a && t > 1 ? i - 1 : i, a && n > 1 ? l - 1 : l ], c = [ a && t > 1 ? t - 1 : t, a && n > 1 ? n - 1 : n ];
        p = r ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", 
        this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0] / c[0]},
          ${u[1] / c[1]},
          ${u[1] / c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${o - 1};
        bool hasNextRow = coords.z < ${n - 1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `;
    }
}, qP = {
    kernelName: Fi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r
        } = t, {
            alignCorners: s,
            halfPixelCenters: i,
            size: l
        } = a, [ o, p ] = l, u = H().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new jP(r.shape, o, p, s, i) : new HP(r.shape, o, p, s, i);
        return n.runWebGLProgram(u, [ r ], "float32");
    }
}, XP = class {
    constructor(e, t, n) {
        this.variableNames = [ "dy" ], this.outputShape = [], this.outputShape = t;
        let [ , a, r ] = t, [ , s, i ] = e, l = [ n && s > 1 ? a - 1 : a, n && i > 1 ? r - 1 : r ], o = [ n && s > 1 ? s - 1 : s, n && i > 1 ? i - 1 : i ], p = l[0] / o[0], u = l[1] / o[1], c = 1 / p, d = 1 / u, h = 2 * Math.ceil(c) + 2, f = 2 * Math.ceil(d) + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${u});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${a - 1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r - 1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
}, KP = {
    kernelName: _l,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r,
            dy: s
        } = t, {
            alignCorners: i
        } = a, l = new XP(s.shape, r.shape, i);
        return n.runWebGLProgram(l, [ s ], s.dtype);
    }
}, ZP = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "A" ], this.outputShape = [];
        let [ s, i, l, o ] = e;
        this.outputShape = [ s, t, n, o ];
        let p, u = [ a && t > 1 ? i - 1 : i, a && n > 1 ? l - 1 : l ], c = [ a && t > 1 ? t - 1 : t, a && n > 1 ? n - 1 : n ], d = a ? "0.5" : "0.0";
        p = r ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", 
        this.userCode = `
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0] / c[0]},
          ${u[1] / c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `;
    }
}, YP = class {
    constructor(e, t, n, a, r) {
        this.variableNames = [ "A" ], this.packedInputs = !0, this.packedOutput = !0, 
        this.outputShape = [];
        let [ s, i, l, o ] = e;
        this.outputShape = [ s, t, n, o ];
        let p, u = [ a && t > 1 ? i - 1 : i, a && n > 1 ? l - 1 : l ], c = [ a && t > 1 ? t - 1 : t, a && n > 1 ? n - 1 : n ], d = a ? "0.5" : "0.0";
        p = r ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", 
        this.userCode = `
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0] / c[0]},
          ${u[1] / c[1]},
          ${u[1] / c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${o - 1};
        bool hasNextRow = coords.z < ${n - 1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `;
    }
}, JP = {
    kernelName: Mi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r
        } = t, {
            alignCorners: s,
            halfPixelCenters: i,
            size: l
        } = a, [ o, p ] = l, u = H().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new YP(r.shape, o, p, s, i) : new ZP(r.shape, o, p, s, i);
        return n.runWebGLProgram(u, [ r ], r.dtype);
    }
}, QP = class {
    constructor(e, t, n) {
        this.variableNames = [ "dy" ], this.outputShape = [], this.outputShape = t;
        let [ , a, r ] = t, [ , s, i ] = e, l = [ n && s > 1 ? a - 1 : a, n && i > 1 ? r - 1 : r ], o = [ n && s > 1 ? s - 1 : s, n && i > 1 ? i - 1 : i ], p = l[0] / o[0], u = l[1] / o[1], c = 1 / p, d = 1 / u, h = 2 * Math.ceil(c) + 2, f = 2 * Math.ceil(d) + 2;
        this.userCode = `
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${u});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${o[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${o[1]}));

            int sourceNearestRow = int(min(
                float(int(${a}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `;
    }
}, eD = {
    kernelName: Fl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r,
            dy: s
        } = t, {
            alignCorners: i
        } = a, l = new QP(s.shape, r.shape, i);
        return n.runWebGLProgram(l, [ s ], s.dtype);
    }
}, tD = class {
    constructor(e, t) {
        this.variableNames = [ "x" ];
        let n = e.length;
        if (n > 4) throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);
        if (this.outputShape = e, n === 1) return void (this.userCode = `
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `);
        let a = e.map((s, i) => (l => t.indexOf(l) !== -1 && e[l] !== 1 ? `${e[l]} - coords[${l}] - 1` : `coords[${l}]`)(i)).join(","), r = ft(n);
        this.userCode = `
      void main() {
        ${r} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `;
    }
}, nD = class {
    constructor(e, t) {
        this.variableNames = [ "x" ], this.packedInputs = !0, this.packedOutput = !0;
        let n = e.length;
        if (n > 4) throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);
        this.outputShape = e;
        let a = fn("rc", n), r = `${a[n - 1]} + 1 < ${this.outputShape[n - 1]}`, s = `${a[n - 2]} + 1 < ${this.outputShape[n - 2]}`, i = ft(n);
        var l;
        function o(p) {
            let u = e.map((c, d) => function(h, f) {
                return t.indexOf(h) !== -1 && e[h] !== 1 ? `${e[h]} - ${f[h]} - 1` : `${f[h]}`;
            }(d, p));
            return `getChannel(getX(${u.join(",")}), vec2(${u.slice(-2).join(",")}))`;
        }
        this.userCode = n === 1 ? `
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      ` : `
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l = a.slice(), o(l)};
          if(${r}){
            result.g = ${function(p) {
            return p[n - 1] = "(" + p[n - 1] + " + 1)", o(p);
        }(a.slice())};
          }
          if(${s}) {
            result.b = ${function(p) {
            return p[n - 2] = "(" + p[n - 2] + " + 1)", o(p);
        }(a.slice())};
            if(${r}) {
              result.a = ${function(p) {
            return p[n - 1] = "(" + p[n - 1] + " + 1)", p[n - 2] = "(" + p[n - 2] + " + 1)", 
            o(p);
        }(a.slice())};
            }
          }
          setOutput(result);
        }
    `;
    }
}, aD = {
    kernelName: Oi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            dims: s
        } = a, i = r.shape.length, l = k.parseAxisParam(s, r.shape);
        if (i === 0) return Hn({
            inputs: {
                x: r
            },
            backend: n
        });
        let o = H().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new nD(r.shape, l) : new tD(r.shape, l);
        return n.runWebGLProgram(o, [ r ], r.dtype);
    }
}, rD = class {
    constructor(e, t) {
        this.variableNames = [ "Image" ], this.outputShape = [], this.customUniforms = [ {
            name: "params",
            type: "vec4"
        } ];
        let n = e[1], a = e[2];
        this.outputShape = e;
        let r = "";
        r = typeof t == "number" ? `float outputValue = ${t.toFixed(2)};` : `
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`, this.userCode = `
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `;
    }
}, sD = {
    kernelName: ro,
    backendName: "webgl",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            image: a
        } = e, {
            radians: r,
            fillValue: s,
            center: i
        } = t, l = n, o = new rD(a.shape, s), [ p, u ] = C.getImageCenter(i, a.shape[1], a.shape[2]), c = [ [ p, u, Math.sin(r), Math.cos(r) ] ];
        return l.runWebGLProgram(o, [ a ], a.dtype, c);
    }
}, iD = rt({
    opSnippet: `
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`
}), oD = {
    kernelName: Pi,
    backendName: "webgl",
    kernelFunc: iD
}, lD = rt({
    opSnippet: "return inversesqrt(x);",
    cpuKernelImpl: pM
}), uD = {
    kernelName: Di,
    backendName: "webgl",
    kernelFunc: lD
}, A1 = class {
    constructor(e, t, n, a, r, s, i = !0, l = !1) {
        this.variableNames = [ "updates", "indices", "defaultValue" ], this.outputShape = s;
        let o = ft(r.length), p = ft(s.length), u = "";
        n === 1 ? u = "i" : n === 2 && (u = "i, j");
        let c = `getIndices(${u})`, d = "";
        a === 1 ? d = "i" : a === 2 && (d = "i, coords[1]");
        let h = `getUpdates(${d})`, f = "";
        l && (f = "coords[0], coords[1]");
        let m = `getDefaultValue(${f})`, g = t > 1 ? "strides[j]" : "strides";
        this.userCode = `
        ${o} strides = ${o}(${r});

        void main() {
          ${p} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `;
    }
}, dD = class {
    constructor(e, t, n, a, r, s, i = !0, l = !1) {
        this.variableNames = [ "updates", "indices", "defaultValue" ], this.packedInputs = !0, 
        this.packedOutput = !0, this.outputShape = s;
        let o = ft(r.length), p = ft(s.length), u = "";
        n === 1 ? u = "i" : n === 2 && (u = "i, j");
        let c = `getIndices(${u})`, d = "";
        a === 1 ? d = "i" : a === 2 && (d = "i, coords[1]");
        let h = `getUpdates(${d})`, f = "";
        l && (f = "coords[0], coords[1]");
        let m = `getDefaultValue(${f})`, g = t > 1 ? "strides[j]" : "strides", y = t > 1 ? "strides[j + 1]" : "strides";
        this.userCode = `
        ${o} strides = ${o}(${r});

        void main() {
          ${p} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${c});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `;
    }
}, pD = {
    kernelName: zi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r,
            updates: s
        } = t, {
            shape: i
        } = a, {
            sliceRank: l,
            numUpdates: o,
            sliceSize: p,
            strides: u,
            outputSize: c
        } = C.calculateShapes(s, r, i), d = [ c / p, p ];
        if (c === 0) return n.makeTensorInfo(i, r.dtype);
        let h, f = he({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ o, l ]
            }
        }), m = he({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: [ o, p ]
            }
        }), g = n.makeTensorInfo([], "float32", new Float32Array([ 0 ]));
        h = H().getBool("WEBGL_PACK") ? new dD(o, l, f.shape.length, m.shape.length, u, d) : new A1(o, l, f.shape.length, m.shape.length, u, d);
        let y = n.runWebGLProgram(h, [ m, f, g ], m.dtype), A = he({
            inputs: {
                x: y
            },
            backend: n,
            attrs: {
                shape: i
            }
        });
        return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(m), 
        n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(g), 
        A;
    }
}, cD = class {
    constructor(e, t, n, a) {
        this.variableNames = [ "sortedSequence", "values" ], this.customUniforms = [ {
            name: "numInputs",
            type: "int"
        } ], this.outputShape = [ e, n ];
        let r = `for (int i = 0; i < ${Math.ceil(Math.log2(t + 1))}; ++i) { if (left >= right) break;`, s = H().getNumber("WEBGL_VERSION") === 2 ? "while (left < right) {" : r, i = a === "left" ? "<" : "<=";
        this.userCode = `
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${s}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${i} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `;
    }
}, hD = {
    kernelName: Wi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            sortedSequence: r,
            values: s
        } = t, {
            side: i
        } = a, l = new cD(r.shape[0], r.shape[1], s.shape[1], i), o = [ [ r.shape[1] ] ];
        return n.runWebGLProgram(l, [ r, s ], "int32", o);
    }
}, fD = class {
    constructor(e, t, n) {
        let a, r;
        if (this.variableNames = [ "c", "a", "b" ], this.outputShape = t, n > 4) throw Error(`Where for rank ${n} is not yet supported`);
        if (n === 1) r = "resRC", a = "resRC"; else {
            let i = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w" ], l = [], o = [];
            for (let p = 0; p < t.length; p++) o.push(`${i[p]}`), p < e && l.push(`${i[p]}`);
            a = l.join(), r = o.join();
        }
        let s = ft(n);
        this.userCode = `
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `;
    }
}, mD = {
    kernelName: Ol,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            condition: a,
            t: r,
            e: s
        } = t, i = new fD(a.shape.length, r.shape, r.shape.length);
        return n.runWebGLProgram(i, [ a, r, s ], Zt(r.dtype, s.dtype));
    }
}, gD = rt({
    opSnippet: `
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${C.SELU_SCALEALPHA};
  float scale = ${C.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`
}), yD = {
    kernelName: Bi,
    backendName: "webgl",
    kernelFunc: gD
}, AD = rt({
    opSnippet: gu + `
  return 1.0 / (1.0 + exp(-1.0 * x));
`,
    packedOpSnippet: `
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,
    cpuKernelImpl: hM
}), xD = {
    kernelName: Hi,
    backendName: "webgl",
    kernelFunc: AD
}, bD = rt({
    opSnippet: `
  if (isnan(x)) { return 0.0; }
  return sign(x);
`
}), vD = {
    kernelName: Gi,
    backendName: "webgl",
    kernelFunc: bD
}, wD = rt({
    opSnippet: gu + `
  return sin(x);
`,
    packedOpSnippet: `
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ro}
  return result;
`
}), kD = {
    kernelName: Vi,
    backendName: "webgl",
    kernelFunc: wD
}, ID = rt({
    opSnippet: `
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`
}), SD = {
    kernelName: Ui,
    backendName: "webgl",
    kernelFunc: ID
}, ND = rt({
    opSnippet: `
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`
}), CD = {
    kernelName: ji,
    backendName: "webgl",
    kernelFunc: ND
}, TD = {
    kernelName: Dl,
    backendName: "webgl",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            paddings: i
        } = a;
        k.assert(r.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");
        let l = s.reduce((y, A) => y * A), o = [ [ 0, 0 ] ];
        o.push(...i);
        for (let y = 1 + s.length; y < r.shape.length; ++y) o.push([ 0, 0 ]);
        let p = [], u = C3({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                paddings: o,
                constantValue: 0
            }
        }), c = C.getReshaped(u.shape, s, l, !1), d = C.getPermuted(c.length, s.length, !1), h = C.getReshapedPermuted(u.shape, s, l, !1), f = he({
            inputs: {
                x: u
            },
            backend: n,
            attrs: {
                shape: c
            }
        }), m = mn({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                perm: d
            }
        }), g = he({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                shape: h
            }
        });
        return p.push(u), p.push(f), p.push(m), p.forEach(y => n.disposeIntermediateTensorInfo(y)), 
        g;
    }
}, RD = {
    kernelName: id,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            indices: a,
            values: r,
            denseShape: s,
            defaultValue: i
        } = t;
        if (s.shape.length !== 1) throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);
        if (a.shape.length !== 2) throw new Error(`Indices must be a matrix, saw:
         ${a.shape}`);
        if (r.shape.length !== 1) throw new Error(`Values must be a vector, saw:
         ${r.shape}`);
        if (i.shape.length !== 0) throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);
        let l = n.readSync(a.dataId), o = n.readSync(r.dataId), p = n.readSync(s.dataId), u = n.readSync(i.dataId)[0], [ c, d, h, f, m ] = mM(l, a.shape, a.dtype, o, r.dtype, p, u);
        return [ n.makeTensorInfo(d, a.dtype, c), n.makeTensorInfo([ d[0] ], r.dtype, h), n.makeTensorInfo([ f.length ], "bool", new Uint8Array(f.map(g => Number(g)))), n.makeTensorInfo([ m.length ], a.dtype, new Int32Array(m)) ];
    }
}, ED = {
    kernelName: Ll,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            inputIndices: a,
            inputShape: r,
            newShape: s
        } = t;
        if (a.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);
        if (r.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
        let i = Array.from(n.readSync(r.dataId)), l = n.readSync(a.dataId), o = Array.from(n.readSync(s.dataId)), [ p, u, c ] = gM(l, a.shape, a.dtype, i, o);
        return [ n.makeTensorInfo(u, a.dtype, p), n.makeTensorInfo([ c.length ], s.dtype, new Int32Array(c)) ];
    }
}, $D = {
    kernelName: Wl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            data: a,
            indices: r,
            segmentIds: s
        } = t;
        if (a.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (r.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);
        let i = n.readSync(a.dataId), l = n.readSync(r.dataId), o = n.readSync(s.dataId), [ p, u ] = Fb(i, a.shape, a.dtype, l, o, !0);
        return n.makeTensorInfo(u, a.dtype, p);
    }
}, MD = {
    kernelName: Bl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            data: a,
            indices: r,
            segmentIds: s
        } = t;
        if (a.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
        if (r.shape.length !== 1) throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);
        let i = n.readSync(a.dataId), l = n.readSync(r.dataId), o = n.readSync(s.dataId), [ p, u ] = Fb(i, a.shape, a.dtype, l, o);
        return n.makeTensorInfo(u, a.dtype, p);
    }
}, FD = {
    kernelName: Zi,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            sparseIndices: r,
            sparseValues: s,
            defaultValue: i
        } = t, {
            outputShape: l
        } = a, {
            sliceRank: o,
            numUpdates: p,
            sliceSize: u,
            strides: c,
            outputSize: d
        } = C.calculateShapes(s, r, l), h = !1;
        if (s.dtype === "string") {
            let y = n.bufferSync(r), A = n.bufferSync(s), x = k.decodeString(n.readSync(i.dataId)[0]), b = cM(y, A, l, d, u, p, o, c, x, h);
            return n.makeTensorInfo(l, b.dtype, b.values);
        }
        let f = new A1(p, o, r.shape.length, s.shape.length, c, [ d, 1 ], h), m = n.runWebGLProgram(f, [ s, r, i ], s.dtype), g = he({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                shape: l
            }
        });
        return n.disposeIntermediateTensorInfo(m), g;
    }
}, _D = {
    kernelName: zl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            numOrSizeSplits: s,
            axis: i
        } = a, l = k.parseAxisParam(i, r.shape)[0], o = C.prepareSplitSize(r, s, l), p = r.shape.length, u = new Array(p).fill(0), c = r.shape.slice();
        return o.map(d => {
            let h = [ ...c ];
            h[l] = d;
            let f = yu({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    begin: u,
                    size: h
                }
            });
            return u[l] += d, f;
        });
    }
}, R3 = "return sqrt(x);", OD = rt({
    opSnippet: R3,
    packedOpSnippet: R3,
    cpuKernelImpl: yM
}), PD = {
    kernelName: qi,
    backendName: "webgl",
    kernelFunc: OD
}, DD = rt({
    opSnippet: "return x * x;"
}), zD = {
    kernelName: od,
    backendName: "webgl",
    kernelFunc: DD
}, E3 = "return (a - b) * (a - b);", LD = en({
    opSnippet: E3,
    packedOpSnippet: E3
}), WD = {
    kernelName: Yi,
    backendName: "webgl",
    kernelFunc: LD
}, BD = {
    kernelName: ld,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t;
        if (r.dtype !== "string") throw new Error("Input must be of datatype string");
        let s = n.readSync(r.dataId), i = C.fromUint8ToStringArray(s), l = AM(i, "string", a);
        return n.makeTensorInfo(r.shape, "string", l);
    }
}, VD = {
    kernelName: vr,
    backendName: "webgl",
    kernelFunc: function({
        inputs: e,
        attrs: t,
        backend: n
    }) {
        let {
            x: a
        } = e, r = ca + `
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `, s = new Ba(a.shape, r);
        return n.runWebGLProgram(s, [ a ], a.dtype);
    }
}, UD = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.outputShape = n;
        let a = n.length, r = ft(n.length), s = ft(n.length), i = "";
        if (a === 1) i = "coords * strides + begin"; else {
            let l = 0;
            i = n.map((o, p) => (l++, n.length === 1 ? `coords * strides[${p}] + begin[${p}]` : `coords[${l - 1}] * strides[${p}] + begin[${p}]`)).join(",");
        }
        this.userCode = `
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `;
    }
}, GD = {
    kernelName: Ji,
    backendName: "webgl",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s
        } = n, {
            begin: i,
            end: l,
            strides: o,
            beginMask: p,
            endMask: u,
            ellipsisMask: c,
            newAxisMask: d,
            shrinkAxisMask: h
        } = r, {
            finalShapeSparse: f,
            finalShape: m,
            isIdentity: g,
            sliceDim0: y,
            isSimpleSlice: A,
            begin: x,
            end: b,
            strides: v
        } = St.sliceInfo(s.shape, i, l, o, p, u, c, d, h);
        if (g) t = he({
            inputs: {
                x: s
            },
            backend: a,
            attrs: {
                shape: m
            }
        }); else if (y || A) {
            k.assert(s.shape.length >= 1, () => `Input must have rank at least 1, got: ${s.shape.length}`);
            let N = St.computeOutShape(x, b, v), T = yu({
                inputs: {
                    x: s
                },
                backend: a,
                attrs: {
                    begin: x,
                    size: N
                }
            });
            t = he({
                inputs: {
                    x: T
                },
                backend: a,
                attrs: {
                    shape: m
                }
            }), a.disposeIntermediateTensorInfo(T);
        } else if (a.shouldExecuteOnCPU([ s ])) {
            let N = a.readSync(s.dataId), T = We(s.shape, s.dtype, N), R = xM(f, T, v, x);
            t = a.makeTensorInfo(m, s.dtype, R.values);
        } else {
            let N = new UD(x, v, f);
            t = a.runWebGLProgram(N, [ s ], s.dtype);
        }
        let I = he({
            inputs: {
                x: t
            },
            backend: a,
            attrs: {
                shape: m
            }
        });
        return a.disposeIntermediateTensorInfo(t), I;
    }
}, HD = {
    kernelName: Vl,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            separator: r,
            nGramWidths: s,
            leftPad: i,
            rightPad: l,
            padWidth: o,
            preserveShortSequences: p
        } = a, {
            data: u,
            dataSplits: c
        } = t, d = n.readSync(u.dataId), h = n.readSync(c.dataId), [ f, m ] = bM(d, h, r, s, i, l, o, p);
        return [ n.makeTensorInfo([ f.length ], "string", f), n.makeTensorInfo(c.shape, "int32", m) ];
    }
}, jD = {
    kernelName: ud,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            skipEmpty: r
        } = a, {
            input: s,
            delimiter: i
        } = t;
        if (s.dtype !== "string") throw new Error("Input must be of datatype string");
        if (s.shape.length !== 1) throw new Error(`Input must be a vector, got shape: ${s.shape}`);
        if (i.shape.length !== 0) throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);
        let l = n.readSync(s.dataId), o = n.readSync(i.dataId)[0], [ p, u, c ] = vM(l, o, r), d = u.length;
        return [ n.makeTensorInfo([ d, 2 ], "int32", p), n.makeTensorInfo([ d ], "string", u), n.makeTensorInfo([ 2 ], "int32", new Int32Array(c)) ];
    }
}, qD = {
    kernelName: dd,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            numBuckets: r
        } = a, {
            input: s
        } = t;
        if (s.dtype !== "string") throw new Error("Input must be of datatype string");
        if (r <= 0) throw new Error("Number of buckets must be at least 1");
        let i = n.readSync(s.dataId), l = wM(i, r);
        return n.makeTensorInfo(s.shape, "int32", l);
    }
}, XD = rt({
    opSnippet: "return tan(x);"
}), KD = {
    kernelName: eo,
    backendName: "webgl",
    kernelFunc: XD
}, ZD = rt({
    opSnippet: `
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`
}), YD = {
    kernelName: to,
    backendName: "webgl",
    kernelFunc: ZD
}, JD = {
    kernelName: Li,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            tensor: r,
            indices: s,
            updates: i
        } = t, {
            sliceRank: l,
            numUpdates: o,
            sliceSize: p,
            strides: u,
            outputSize: c
        } = C.calculateShapes(i, s, r.shape), d = [ c / p, p ];
        if (c === 0) return n.makeTensorInfo(r.shape, s.dtype);
        let h = he({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: [ o, l ]
            }
        }), f = he({
            inputs: {
                x: i
            },
            backend: n,
            attrs: {
                shape: [ o, p ]
            }
        }), m = he({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: d
            }
        }), g = new A1(o, l, h.shape.length, f.shape.length, u, d, !1, !0), y = n.runWebGLProgram(g, [ f, h, m ], m.dtype), A = he({
            inputs: {
                x: y
            },
            backend: n,
            attrs: {
                shape: r.shape
            }
        });
        return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(f), 
        n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(y), 
        A;
    }
}, QD = class {
    constructor(e, t) {
        this.variableNames = [ "A" ];
        let n = new Array(e.length);
        for (let s = 0; s < n.length; s++) n[s] = e[s] * t[s];
        this.outputShape = n, this.rank = n.length;
        let a = ft(this.rank), r = function(s) {
            let i = s.length;
            if (i > 5) throw Error(`Tile for rank ${i} is not yet supported`);
            if (i === 1) return `imod(resRC, ${s[0]})`;
            let l = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u" ], o = [];
            for (let p = 0; p < s.length; p++) o.push(`imod(${l[p]}, ${s[p]})`);
            return o.join();
        }(e);
        this.userCode = `
      void main() {
        ${a} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `;
    }
};

function $3(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        reps: s
    } = a;
    if (r.dtype === "string" || r.shape.length > 5) {
        let l = n.readSync(r.dataId), o = r.dtype === "string" ? l.map(c => k.decodeString(c)) : l, p = We(r.shape, r.dtype, o), u = IM(p, s);
        return n.makeTensorInfo(u.shape, u.dtype, u.values);
    }
    let i = new QD(r.shape, s);
    return n.runWebGLProgram(i, [ r ], r.dtype);
}

var ez = {
    kernelName: br,
    backendName: "webgl",
    kernelFunc: $3
}, tz = class {
    constructor(e) {
        this.variableNames = [ "x", "indices" ], this.customUniforms = [ {
            name: "n",
            type: "int"
        }, {
            name: "firstPass",
            type: "int"
        }, {
            name: "negativeInf",
            type: "float"
        }, {
            name: "dir",
            type: "int"
        }, {
            name: "inc",
            type: "int"
        } ], this.outputShape = e, this.userCode = `
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `;
    }
}, nz = class {
    constructor(e) {
        this.variableNames = [ "x", "indices" ], this.customUniforms = [ {
            name: "n",
            type: "int"
        }, {
            name: "firstPass",
            type: "int"
        }, {
            name: "k",
            type: "int"
        } ], this.outputShape = e, this.userCode = `
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `;
    }
};

function $o(e, t) {
    t !== null && e.disposeIntermediateTensorInfo(t);
}

function M3(e) {
    let t = 1;
    for (;t < e; ) t *= 2;
    return t;
}

var az = {
    kernelName: no,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            k: s,
            sorted: i
        } = a, l = H().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"), o = H().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"), p = r.shape, u = p[p.length - 1];
        if (n.shouldExecuteOnCPU([ r ]) || u < l || s > o) {
            let R = n.readSync(r.dataId), [ w, E ] = SM(R, p, r.dtype, s, i);
            return [ n.makeTensorInfo(w.shape, w.dtype, w.values), n.makeTensorInfo(E.shape, E.dtype, E.values) ];
        }
        if (s === 0) return p[p.length - 1] = 0, [ n.makeTensorInfo(p, r.dtype, []), n.makeTensorInfo(p, "int32", []) ];
        if (u === 1) return [ r, sp({
            attrs: {
                shape: p,
                dtype: "int32",
                value: 0
            },
            backend: n
        }) ];
        let c = n.texData.get(r.dataId), d = c !== null && c.isPacked, h = d ? n.unpackTensor(r) : r, f = k.sizeFromShape(p) / u, m = he({
            inputs: {
                x: h
            },
            attrs: {
                shape: [ f, u ]
            },
            backend: n
        });
        d && $o(n, h);
        let g = M3(s), y = M3(u), A = null, x = () => A === null ? [ m, m ] : [ m, A ], b = (R, w, E) => {
            let $ = x(), M = new tz(E), F = [ [ u ], [ A === null ? 1 : 0 ], [ Number.NEGATIVE_INFINITY ], [ R ], [ w ] ], P = A;
            A = n.runWebGLProgram(M, $, "int32", F), $o(n, P);
        };
        for (let R = 1; R < g; R *= 2) {
            let w = 2 * R;
            for (let E = R; E >= 1; E /= 2) b(w, E, [ f, y ]);
        }
        for (let R = y; R > g; R /= 2) {
            let w = x(), E = new nz([ f, R / 2 ]), $ = [ [ u ], [ A === null ? 1 : 0 ], [ g ] ], M = A;
            A = n.runWebGLProgram(E, w, "int32", $), $o(n, M);
            let F = g / 2, P = 2 * F;
            for (let L = F; L >= 1; L /= 2) b(P, L, A.shape);
        }
        let v = A;
        A = yu({
            inputs: {
                x: A
            },
            backend: n,
            attrs: {
                begin: 0,
                size: [ f, s ]
            }
        }), $o(n, v);
        let I = v3({
            inputs: {
                x: m,
                indices: A
            },
            backend: n,
            attrs: {
                axis: 1,
                batchDims: 1
            }
        });
        $o(n, m);
        let N = p.slice(0, -1);
        N.push(s), v = A, A = he({
            inputs: {
                x: A
            },
            attrs: {
                shape: N
            },
            backend: n
        }), $o(n, v);
        let T = I;
        return I = he({
            inputs: {
                x: I
            },
            attrs: {
                shape: N
            },
            backend: n
        }), $o(n, T), [ I, A ];
    }
}, rz = class {
    constructor(e, t, n, a, r, s) {
        this.variableNames = [ "Image", "Transforms" ], this.outputShape = s;
        let i, l = n === "nearest" ? 1 : 2;
        switch (a) {
          case "constant":
          default:
            i = 1;
            break;

          case "reflect":
            i = 2;
            break;

          case "wrap":
            i = 3;
            break;

          case "nearest":
            i = 4;
        }
        this.userCode = `
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${i} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${i} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${l} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `;
    }
}, sz = {
    kernelName: ao,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r,
            transforms: s
        } = t, {
            interpolation: i,
            fillMode: l,
            fillValue: o,
            outputShape: p
        } = a, [ u, c, d, h ] = r.shape, [ f, m ] = p ?? [ c, d ], g = new rz(c, d, i, l, o, [ u, f, m, h ]);
        return n.runWebGLProgram(g, [ r, s ], "float32");
    }
}, iz = {
    kernelName: pd,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            axis: r
        } = n, {
            x: s
        } = t;
        du(s, "unique");
        let i = a.readSync(s.dataId), {
            outputValues: l,
            outputShape: o,
            indices: p
        } = NM(i, r, s.shape, s.dtype);
        return [ a.makeTensorInfo(o, s.dtype, l), a.makeTensorInfo([ p.length ], "int32", p) ];
    }
}, oz = {
    kernelName: Ul,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            value: r
        } = t, {
            axis: s
        } = a;
        s < 0 && (s += r.shape.length);
        let i = r, l = i.shape.length, o = r.shape[s], p = new Array(l - 1), u = 0;
        for (let m = 0; m < l; m++) m !== s && (p[u++] = i.shape[m]);
        let c = [], d = new Array(l).fill(0), h = i.shape.slice();
        h[s] = 1;
        let f = new Array(o);
        for (let m = 0; m < f.length; m++) {
            d[s] = m;
            let g = yu({
                inputs: {
                    x: i
                },
                backend: n,
                attrs: {
                    begin: d,
                    size: h
                }
            }), y = he({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    shape: p
                }
            });
            f[m] = y, c.push(g);
        }
        return c.forEach(m => n.disposeIntermediateTensorInfo(m)), f;
    }
}, lz = class {
    constructor(e, t) {
        this.variableNames = [ "x", "segmentIds" ];
        let n = e.windowSize, a = e.batchSize, r = e.inSize, s = e.numSegments, i = s * Math.ceil(r / n);
        this.outputShape = [ a, i ];
        let l = 4 * Math.floor(n / 4), o = n % 4, p = `
        sumValue += dot(values, segFilter);
    `, u = "";
        r % n > 0 && (u = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);
        let c = "";
        r % n > 0 && (c = `
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `), this.userCode = `
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${c}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${l};
        if (${o === 1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${o === 2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${o === 3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(sumValue);
      }
    `;
    }
}, it, ip, F3, uz = {
    kernelName: cd,
    backendName: "webgl",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            segmentIds: s
        } = t, {
            numSegments: i
        } = a, l = r.shape.length, o = [], p = 0, u = C.getAxesPermutation([ p ], l), c = r;
        u != null && (c = mn({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: u
            }
        }), o.push(c), p = C.getInnerMostAxes(1, l)[0]);
        let d = C.segment_util.computeOutShape(c.shape, p, i), h = k.sizeFromShape([ c.shape[p] ]), f = he({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                shape: [ -1, h ]
            }
        });
        o.push(f);
        let m = kd(r.dtype), g = (x, b, v, I, N) => {
            let T = x.shape[0], R = x.shape[1], w = C.segment_util.segOpComputeOptimalWindowSize(R, N), E = new lz({
                windowSize: w,
                inSize: R,
                batchSize: T,
                numSegments: N
            }, b), $ = n.compileAndRun(E, [ x, v ], I);
            if (o.push($), $.shape[1] === N) return $;
            let M = T3({
                backend: n,
                attrs: {
                    start: 0,
                    stop: N,
                    step: 1,
                    dtype: "float32"
                }
            }), F = $3({
                inputs: {
                    x: M
                },
                backend: n,
                attrs: {
                    reps: [ R / w ]
                }
            });
            return o.push(M), o.push(F), g($, b, F, I, N);
        }, y = he({
            inputs: {
                x: g(f, "unsortedSegmentSum", s, m, i)
            },
            backend: n,
            attrs: {
                shape: d
            }
        }), A = y;
        if (u != null) {
            o.push(y);
            let x = C.getUndoAxesPermutation(u);
            A = mn({
                inputs: {
                    x: A
                },
                backend: n,
                attrs: {
                    perm: x
                }
            });
        }
        return o.forEach(x => n.disposeIntermediateTensorInfo(x)), A;
    }
}, dz = [ tF, nF, rF, iF, lF, pF, cF, hF, gF, yF, xF, vF, kF, SF, CF, TF, RF, MF, FF, _F, DF, BF, VF, UF, GF, XF, ZF, QF, HM, t_, s_, l_, h_, m_, g_, y_, A_, b_, w_, I_, S_, N_, C_, R_, E_, F_, __, P_, z_, L_, B_, V_, G_, j_, q_, X_, Z_, Y_, Q_, tO, aO, sO, lO, uO, dO, cO, fO, gO, AO, GM, xO, r_, vO, kO, SO, jM, CO, RO, EO, MO, _O, PO, zO, WO, UO, HO, jO, XO, KO, ZO, QO, eP, tP, nP, aP, sP, lP, dP, mP, XM, yP, xP, vP, kP, HF, SP, CP, TP, $P, FP, qM, _P, OP, PP, DP, zP, jF, cP, WP, VP, GP, KM, qP, KP, JP, eD, aD, sD, oD, uD, pD, hD, mD, yD, xD, vD, kD, SD, WF, fP, CD, TD, RD, ED, $D, MD, FD, _D, PD, zD, WD, BD, VD, GD, HD, jD, qD, hP, QM, KD, YD, JD, ez, az, sz, eF, iz, oz, uz, NP ];

for (let e of dz) Aa(e);

(function(e) {
    e[e.float32 = 0] = "float32", e[e.int32 = 1] = "int32", e[e.bool = 2] = "bool", 
    e[e.string = 3] = "string", e[e.complex64 = 4] = "complex64";
})(it || (it = {})), function(e) {
    e[e.linear = 0] = "linear", e[e.relu = 1] = "relu", e[e.relu6 = 2] = "relu6", 
    e[e.prelu = 3] = "prelu", e[e.leakyrelu = 4] = "leakyrelu", e[e.sigmoid = 5] = "sigmoid", 
    e[e.elu = 6] = "elu";
}(ip || (ip = {}));

var pz = {
    kernelName: wr,
    backendName: "wasm",
    setupFunc: function(e) {
        F3 = e.wasm.cwrap(wr, null, [ "number", "array", "number", "number", "array", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            a: r,
            b: s,
            bias: i,
            preluActivationWeights: l
        } = t;
        if (r.dtype !== "float32" || s.dtype !== "float32") throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");
        let {
            transposeA: o,
            transposeB: p,
            activation: u,
            leakyreluAlpha: c
        } = a, d = n.dataIdMap.get(r.dataId).id, h = n.dataIdMap.get(s.dataId).id, f = 0;
        if (i != null) {
            let T = n.dataIdMap.get(i.dataId);
            if (T.shape.length !== 1) throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${T.shape.length}.`);
            f = T.id;
        }
        let m = l == null ? 0 : n.dataIdMap.get(l.dataId).id, g = ip[u];
        if (g == null) throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);
        let y = o ? r.shape[2] : r.shape[1], A = p ? s.shape[1] : s.shape[2], x = mo.assertAndGetBroadcastShape(r.shape.slice(0, -2), s.shape.slice(0, -2)), b = n.makeOutput([ ...x, y, A ], r.dtype), v = n.dataIdMap.get(b.dataId).id, I = new Uint8Array(new Int32Array(r.shape).buffer), N = new Uint8Array(new Int32Array(s.shape).buffer);
        return F3(d, I, r.shape.length, h, N, s.shape.length, o, p, g, f, m, c || 0, v), 
        b;
    }
};

function tt(e, t) {
    let n;
    return {
        kernelName: e,
        backendName: "wasm",
        setupFunc: function(a) {
            n = a.wasm.cwrap(e, null, [ "number", "number", "number" ]);
        },
        kernelFunc: function(a) {
            let {
                backend: r,
                inputs: {
                    x: s
                }
            } = a, i = r.dataIdMap.get(s.dataId).id, l = r.makeOutput(s.shape, t || s.dtype), o = r.dataIdMap.get(l.dataId).id;
            return k.sizeFromShape(l.shape) === 0 || n(i, it[s.dtype], o), l;
        }
    };
}

var cz = tt(ol), hz = tt(cs), fz = tt(hs);

function _t(e, t, n) {
    let a;
    return {
        kernelName: e,
        backendName: "wasm",
        setupFunc: function(r) {
            a = r.wasm.cwrap(e, null, [ "number", "array", "number", "number", "array", "number", "number", "number" ]);
        },
        kernelFunc: function(r) {
            let {
                backend: s,
                inputs: i
            } = r, {
                a: l,
                b: o
            } = i, p = s.dataIdMap.get(l.dataId).id, u = s.dataIdMap.get(o.dataId).id, c = n ?? l.dtype, d = C.assertAndGetBroadcastShape(l.shape, o.shape), h = s.makeOutput(d, c);
            if (k.sizeFromShape(d) === 0) return h;
            let f = new Uint8Array(new Int32Array(l.shape).buffer), m = new Uint8Array(new Int32Array(o.shape).buffer), g = s.dataIdMap.get(h.dataId).id;
            return a(p, f, l.shape.length, u, m, o.shape.length, it[l.dtype], g), 
            h;
        }
    };
}

var _3, mz = _t(Ar), gz = {
    kernelName: fs,
    backendName: "wasm",
    setupFunc: function(e) {
        _3 = e.wasm.cwrap(fs, null, [ "array", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, a = n.makeOutput(t[0].shape, t[0].dtype);
        if (k.sizeFromShape(a.shape) === 0) return a;
        let r = t.map(l => n.dataIdMap.get(l.dataId).id), s = new Uint8Array(new Int32Array(r).buffer), i = n.dataIdMap.get(a.dataId).id;
        return _3(s, r.length, it[a.dtype], i), a;
    }
};

function Xc(e) {
    let {
        inputs: {
            x: t
        },
        backend: n
    } = e;
    if (t.dtype === "string") return Ye(n.readSync(t.dataId), t.shape, t.dtype);
    let a = n.makeOutput(t.shape, t.dtype), r = n.typedArrayFromHeap(t);
    return n.typedArrayFromHeap(a).set(r), a;
}

var O3, yz = {
    kernelName: Js,
    backendName: "wasm",
    kernelFunc: Xc
};

function jr(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, [ r, s ] = function(f, m) {
        let g = [], y = [];
        for (let A = 0; A < f.length; ++A) f[A] !== 1 && g.push(f[A]), f[m[A]] !== 1 && y.push(m[A]);
        for (let A = 0; A < y.length; ++A) {
            let x = -1;
            for (let b = 0; b < y.length; ++b) y[b] >= A && (x === -1 || y[x] > y[b]) && (x = b);
            y[x] = A;
        }
        return [ g, y ];
    }(t.x.shape, a.perm), i = !0;
    for (let f = 0; f < s.length; f++) s[f] !== f && (i = !1);
    let l = function(f, m) {
        let g = new Array(f.length);
        for (let y = 0; y < g.length; y++) g[y] = f[m[y]];
        return g;
    }(t.x.shape, a.perm), o = {
        dataId: t.x.dataId,
        shape: r,
        dtype: t.x.dtype
    };
    if (i) {
        let f = Xc({
            inputs: t,
            backend: n
        });
        return f.shape = l, f;
    }
    let p = n.makeOutput(l, o.dtype), u = n.dataIdMap.get(o.dataId).id, c = n.dataIdMap.get(p.dataId).id, d = new Uint8Array(new Int32Array(s).buffer), h = new Uint8Array(new Int32Array(o.shape).buffer);
    return O3(u, h, o.shape.length, it[o.dtype], c, d, s.length), p;
}

var P3, Az = {
    kernelName: Xa,
    backendName: "wasm",
    kernelFunc: jr,
    setupFunc: function(e) {
        O3 = e.wasm.cwrap(Xa, null, [ "number", "array", "number", "number", "number", "array", "number" ]);
    }
};

function qr(e, t, n) {
    let a = e.shape, r = e.shape.length, s = k.parseAxisParam(t, a), i = s, l = C.getAxesPermutation(i, r), o = null, p = !1;
    if (l != null) {
        let u = new Array(r);
        for (let d = 0; d < u.length; d++) u[d] = a[l[d]];
        i = C.getInnerMostAxes(i.length, r), o = jr({
            inputs: {
                x: e
            },
            attrs: {
                perm: l
            },
            backend: n
        });
        let c = n.dataIdMap.get(e.dataId).id;
        n.dataIdMap.get(o.dataId).id !== c && (p = !0);
    }
    return {
        transposed: o,
        originalAxes: s,
        axes: i,
        inputWasTransposed: p
    };
}

var D3, xz = {
    kernelName: ms,
    backendName: "wasm",
    setupFunc: function(e) {
        P3 = e.wasm.cwrap(ms, null, [ "number, number, number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            axis: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = i, {
            transposed: p,
            axes: u,
            originalAxes: c,
            inputWasTransposed: d
        } = qr(i, r, t);
        d && (o = p, l = t.dataIdMap.get(p.dataId).id);
        let h = o.shape.length;
        C.assertAxesAreInnerMostDims("all", u, h);
        let [ f, m ] = C.computeOutAndReduceShapes(o.shape, u), g = k.sizeFromShape(m), y = t.makeOutput(f, i.dtype);
        if (k.sizeFromShape(o.shape) !== 0) {
            let A = t.dataIdMap.get(y.dataId).id;
            P3(l, g, A);
        }
        if (d && t.disposeData(p.dataId), s) {
            let A = C.expandShapeToKeepDim(y.shape, c);
            y.shape = A;
        }
        return y;
    }
}, bz = {
    kernelName: gs,
    backendName: "wasm",
    setupFunc: function(e) {
        D3 = e.wasm.cwrap(gs, null, [ "number, number, number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            axis: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = i, {
            transposed: p,
            axes: u,
            originalAxes: c,
            inputWasTransposed: d
        } = qr(i, r, t);
        d && (o = p, l = t.dataIdMap.get(p.dataId).id);
        let h = o.shape.length;
        C.assertAxesAreInnerMostDims("any", u, h);
        let [ f, m ] = C.computeOutAndReduceShapes(o.shape, u), g = k.sizeFromShape(m), y = t.makeOutput(f, i.dtype);
        if (k.sizeFromShape(o.shape) !== 0) {
            let A = t.dataIdMap.get(y.dataId).id;
            D3(l, g, A);
        }
        if (d && t.disposeData(p.dataId), s) {
            let A = C.expandShapeToKeepDim(y.shape, c);
            y.shape = A;
        }
        return y;
    }
};

function z3(e) {
    let t;
    return {
        kernelName: e,
        backendName: "wasm",
        setupFunc: function(n) {
            t = n.wasm.cwrap(e, null, [ "number", "number", "number", "number", "number" ]);
        },
        kernelFunc: function(n) {
            let {
                backend: a,
                inputs: r,
                attrs: s
            } = n, {
                axis: i
            } = s, {
                x: l
            } = r, o = a.dataIdMap.get(l.dataId).id, p = o, u = l, {
                transposed: c,
                axes: d,
                inputWasTransposed: h
            } = qr(l, i, a);
            if (h) {
                let x = a.dataIdMap.get(c.dataId).id;
                x !== o && (u = c, p = x);
            }
            let f = u.shape.slice(0, -1), m = a.makeOutput(f, "int32"), g = a.dataIdMap.get(m.dataId).id, y = k.sizeFromShape(m.shape), A = u.shape[d[0]];
            return t(p, it[u.dtype], y, A, g), h && a.disposeData(c.dataId), m;
        }
    };
}

var L3, vz = z3(ll), wz = z3(ul), kz = tt(ys), Iz = tt(As), Sz = tt(xs), Nz = _t(vs), Cz = tt(bs), W3, Tz = {
    kernelName: ws,
    backendName: "wasm",
    setupFunc: function(e) {
        L3 = e.wasm.cwrap(ws, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, r = t.x, s = a.dataIdMap.get(r.dataId).id, {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = n, u = C.computePool2DInfo(r.shape, i, l, 1, o, p), c = u.filterHeight, d = u.filterWidth, h = u.padInfo.top, f = u.padInfo.right, m = u.padInfo.bottom, g = u.padInfo.left, y = u.strideHeight, A = u.strideWidth, x = u.inChannels;
        if (u.dataFormat !== "channelsLast") throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);
        if (u.dilationWidth !== 1 || u.dilationHeight !== 1) throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);
        let b = a.makeOutput(u.outShape, "float32"), v = a.dataIdMap.get(b.dataId).id;
        return L3(s, r.shape[0], r.shape[1], r.shape[2], c, d, h, f, m, g, y, A, x, v), 
        b;
    }
}, B3, Rz = {
    kernelName: dl,
    backendName: "wasm",
    setupFunc: function(e) {
        W3 = e.wasm.cwrap("AvgPool3D", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o,
            dataFormat: p
        } = a, u = C.computePool3DInfo(r.shape, s, i, 1, l, o, p), c = n.makeOutput(u.outShape, r.dtype);
        return W3(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inDepth, u.inHeight, u.inWidth, u.outDepth, u.outHeight, u.outWidth, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.effectiveFilterDepth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), 
        c;
    }
}, V3, Ez = {
    kernelName: ju,
    backendName: "wasm",
    setupFunc: function(e) {
        B3 = e.wasm.cwrap("AvgPool3DGrad", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = a, u = C.computePool3DInfo(s.shape, i, l, 1, o, p), c = n.makeOutput(s.shape, s.dtype);
        return B3(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inDepth, u.inHeight, u.inWidth, u.outDepth, u.outHeight, u.outWidth, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.effectiveFilterDepth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left, u.filterDepth, u.filterHeight, u.filterWidth), 
        c;
    }
}, $z = {
    kernelName: Hu,
    backendName: "wasm",
    setupFunc: function(e) {
        V3 = e.wasm.cwrap("AvgPoolGrad", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, {
            filterSize: i,
            strides: l,
            pad: o
        } = a, p = C.computePool2DInfo(s.shape, i, l, 1, o), u = n.makeOutput(s.shape, s.dtype);
        return V3(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(u.dataId).id, p.batchSize, p.inChannels, p.inHeight, p.inWidth, p.outHeight, p.outWidth, p.strideHeight, p.strideWidth, p.dilationHeight, p.dilationWidth, p.effectiveFilterHeight, p.effectiveFilterWidth, p.padInfo.top, p.padInfo.left, p.filterHeight, p.filterWidth), 
        u;
    }
};

function In(e) {
    let {
        inputs: t,
        attrs: n
    } = e, {
        x: a
    } = t, {
        shape: r
    } = n, s = k.sizeFromShape(a.shape), i = k.inferFromImplicitShape(r, s);
    return k.assert(s === k.sizeFromShape(i), () => `new shape: ${i}, old shape: ${a.shape}. New shape and old shape must have the same number of elements.`), 
    e.backend.incRef(a.dataId), {
        dataId: a.dataId,
        shape: i,
        dtype: a.dtype
    };
}

var U3, Mz = {
    kernelName: Ml,
    backendName: "wasm",
    kernelFunc: In
}, Fz = {
    kernelName: ks,
    backendName: "wasm",
    setupFunc: function(e) {
        U3 = e.wasm.cwrap(ks, null, [ "number", "array", "number", "number", "array", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            a: r,
            b: s
        } = t, {
            transposeA: i,
            transposeB: l
        } = a;
        if (r.dtype !== "float32" || s.dtype !== "float32") throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");
        let o = r.shape.length, p = s.shape.length, u = i ? r.shape[o - 2] : r.shape[o - 1], c = l ? s.shape[p - 1] : s.shape[p - 2], d = i ? r.shape[o - 1] : r.shape[o - 2], h = l ? s.shape[p - 2] : s.shape[p - 1], f = r.shape.slice(0, -2), m = s.shape.slice(0, -2), g = k.sizeFromShape(f), y = k.sizeFromShape(m), A = mo.assertAndGetBroadcastShape(r.shape.slice(0, -2), s.shape.slice(0, -2)).concat([ d, h ]);
        k.assert(u === c, () => `Error in matMul: inner shapes (${u}) and (${c}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${l} must match.`);
        let x = l ? [ y, h, c ] : [ y, c, h ], b = In({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: i ? [ g, u, d ] : [ g, d, u ]
            }
        }), v = In({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: x
            }
        }), I = n.dataIdMap.get(b.dataId).id, N = n.dataIdMap.get(v.dataId).id, T = i ? b.shape[2] : b.shape[1], R = l ? v.shape[1] : v.shape[2], w = Math.max(g, y), E = n.makeOutput([ w, T, R ], b.dtype), $ = n.dataIdMap.get(E.dataId).id, M = new Uint8Array(new Int32Array(b.shape).buffer), F = new Uint8Array(new Int32Array(v.shape).buffer);
        return U3(I, M, b.shape.length, N, F, v.shape.length, i, l, $), n.disposeData(b.dataId), 
        n.disposeData(v.dataId), E.shape = A, E;
    }
};

function Mo(e) {
    let {
        inputs: {
            x: t
        },
        attrs: {
            begin: n,
            size: a
        },
        backend: r
    } = e, [ s, i ] = St.parseSliceParams(t, n, a), l = St.isSliceContinous(t.shape, s, i), o = r.readSync(t.dataId), p = r.makeOutput(i, t.dtype), u = k.computeStrides(t.shape), c = r.dataIdMap.get(p.dataId);
    if (l) {
        let f = St.computeFlatOffset(s, u);
        return t.dtype === "string" ? c.stringBytes = o.slice(f, f + k.sizeFromShape(i)) : r.typedArrayFromHeap(p).set(o.subarray(f, f + k.sizeFromShape(i))), 
        p;
    }
    if (t.dtype === "string") {
        let f = Tc(o, s, i, t.shape, t.dtype);
        return c.stringBytes = f, p;
    }
    let d = r.typedArrayFromHeap(p), h = t.shape.length;
    if (h === 2) (function(f, m, g, y, A) {
        let x = 0, b = y[0], v = y[1], I = b + A[0];
        for (let N = b; N < I; N++) {
            let T = N * m + v;
            g.set(f.subarray(T, T + A[1]), x), x += A[1];
        }
    })(o, u[0], d, s, i); else if (h === 3) (function(f, m, g, y, A, x) {
        let b = 0, v = A[0], I = A[1], N = A[2], T = v + x[0], R = I + x[1];
        for (let w = v; w < T; w++) for (let E = I; E < R; E++) {
            let $ = w * m + E * g + N;
            y.set(f.subarray($, $ + x[2]), b), b += x[2];
        }
    })(o, u[0], u[1], d, s, i); else if (h === 4) (function(f, m, g, y, A, x, b) {
        let v = 0, I = x[0], N = x[1], T = x[2], R = I + b[0], w = N + b[1], E = T + b[2], $ = x[3];
        for (let M = I; M < R; M++) for (let F = N; F < w; F++) for (let P = T; P < E; P++) {
            let L = M * m + F * g + P * y + $;
            A.set(f.subarray(L, L + b[3]), v), v += b[3];
        }
    })(o, u[0], u[1], u[2], d, s, i); else {
        let f = Tc(o, s, i, t.shape, t.dtype);
        d.set(f);
    }
    return p;
}

var _z = {
    kernelName: Pl,
    backendName: "wasm",
    kernelFunc: Mo
}, G3, Oz = {
    kernelName: pl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            crops: i
        } = a, l = s.reduce((y, A) => y * A), o = C.getReshaped(r.shape, s, l), p = C.getPermuted(o.length, s.length), u = C.getReshapedPermuted(r.shape, s, l), c = C.getSliceBeginCoords(i, s.length), d = C.getSliceSize(u, i, s.length), h = In({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: o
            }
        }), f = jr({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), m = In({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: u
            }
        }), g = Mo({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                begin: c,
                size: d
            }
        });
        return n.disposeData(h.dataId), n.disposeData(f.dataId), n.disposeData(m.dataId), 
        g;
    }
}, Pz = {
    kernelName: Is,
    backendName: "wasm",
    setupFunc: function(e) {
        G3 = e.wasm.cwrap(Is, null, [ "number", "number", "boolean", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = n, {
            size: i
        } = a, l = s.shape.reduce((c, d) => c * d, 1) !== 0, o = r.shape.length === 1 ? [ i ] : [ r.shape[0], i ], p = t.makeOutput(o, s.dtype);
        function u(c) {
            return t.dataIdMap.get(c.dataId).id;
        }
        return G3(u(r), i, l, u(s), it[s.dtype], u(p)), p;
    }
}, Dz = _t(cl), zz = {
    kernelName: hl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            s0: a,
            s1: r
        } = t, s = n.typedArrayFromHeap(a), i = n.typedArrayFromHeap(r), l = C.assertAndGetBroadcastShape(Array.from(s), Array.from(i));
        return n.makeOutput([ l.length ], "int32", void 0, new Int32Array(l));
    }
};

function Xr(e) {
    let {
        inputs: {
            x: t
        },
        attrs: {
            dtype: n
        },
        backend: a
    } = e, r = a.makeOutput(t.shape, n), s = a.typedArrayFromHeap(t);
    return a.typedArrayFromHeap(r).set(s), r;
}

var H3, Lz = {
    kernelName: Ss,
    backendName: "wasm",
    kernelFunc: Xr
}, Wz = tt(Ns), Bz = {
    kernelName: xr,
    backendName: "wasm",
    setupFunc: function(e) {
        H3 = e.wasm.cwrap(xr, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            clipValueMin: s,
            clipValueMax: i
        } = a, l = n.dataIdMap.get(r.dataId).id, o = n.makeOutput(r.shape, r.dtype), p = n.dataIdMap.get(o.dataId).id;
        return H3(l, s, i, p), o;
    }
};

function j3(e) {
    let {
        inputs: t,
        backend: n
    } = e, a = k.parseAxisParam(e.attrs.axis, t[0].shape)[0], r = t.map(h => h.shape);
    C.assertParamsConsistent(r, a);
    let s = C.computeOutShape(t.map(h => h.shape), a), i = t.filter(h => k.sizeFromShape(h.shape) > 0);
    if (i.length === 1) return Xc({
        inputs: {
            x: i[0]
        },
        backend: n
    });
    let l = n.makeOutput(s, t[0].dtype);
    if (k.sizeFromShape(s) === 0) return l;
    if (i[0].dtype === "string") {
        let h = i.map(A => {
            let x = [ -1, k.sizeFromShape(A.shape.slice(a)) ];
            return In({
                inputs: {
                    x: A
                },
                backend: n,
                attrs: {
                    shape: x
                }
            });
        }), f = h.map(A => ({
            vals: n.readSync(A.dataId),
            shape: A.shape
        }));
        s = C.computeOutShape(h.map(A => A.shape), 1);
        let m = h[0].shape[0] === 1, g = Om(f, s, t[0].dtype, m), y = C.computeOutShape(i.map(A => A.shape), a);
        return l.shape = y, n.dataIdMap.get(l.dataId).stringBytes = C.fromStringArrayToUint8(g), 
        h.forEach(A => n.disposeData(A.dataId)), l;
    }
    let o = k.sizeFromShape(i[0].shape.slice(0, a)), p = 0, u = i.map(h => {
        let f = k.sizeFromShape(h.shape.slice(a));
        return p += f, f;
    }), c = i.map(h => n.typedArrayFromHeap(h)), d = n.typedArrayFromHeap(l);
    for (let h = 0; h < o; h++) {
        let f = h * p;
        for (let m = 0; m < c.length; m++) {
            let g = u[m], y = h * g, A = c[m].subarray(y, y + g);
            d.set(A, f), f += g;
        }
    }
    return l;
}

var q3, Vz = {
    kernelName: fl,
    backendName: "wasm",
    kernelFunc: j3
}, X3, Uz = {
    kernelName: Cs,
    backendName: "wasm",
    setupFunc: function(e) {
        q3 = e.wasm.cwrap(Cs, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            x: r,
            filter: s
        } = t, i = a.dataIdMap.get(r.dataId).id, l = a.dataIdMap.get(s.dataId).id, {
            strides: o,
            dilations: p,
            pad: u,
            dimRoundingMode: c,
            dataFormat: d
        } = n, h = C.convertConv2DDataFormat(d), f = C.computeConv2DInfo(r.shape, s.shape, o, p, u, c, !1, h), m = f.filterHeight, g = f.filterWidth, y = f.padInfo.top, A = f.padInfo.right, x = f.padInfo.bottom, b = f.padInfo.left, v = f.dilationHeight, I = f.dilationWidth, N = f.strideHeight, T = f.strideWidth, R = f.inChannels, w = f.outChannels, E = f.padInfo.type === "SAME" ? 1 : 0;
        if (f.dataFormat !== "channelsLast") throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);
        let $ = a.makeOutput(f.outShape, "float32"), M = a.dataIdMap.get($.dataId).id;
        return q3(i, r.shape[0], r.shape[1], r.shape[2], l, m, g, y, A, x, b, E, v, I, N, T, R, w, M), 
        $;
    }
}, K3, Gz = {
    kernelName: Ts,
    backendName: "wasm",
    setupFunc: function(e) {
        X3 = e.wasm.cwrap(Ts, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = n, {
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p,
            inputShape: u
        } = a, c = C.convertConv2DDataFormat(o), d = C.computeConv2DInfo(u, s.shape, i, 1, l, p, !1, c), {
            batchSize: h,
            filterHeight: f,
            filterWidth: m,
            inChannels: g,
            inHeight: y,
            inWidth: A,
            outChannels: x,
            outHeight: b,
            outWidth: v,
            strideHeight: I,
            strideWidth: N
        } = d, T = f - 1 - d.padInfo.top, R = m - 1 - d.padInfo.left, w = d.dataFormat === "channelsLast", E = k.computeStrides(d.inShape), $ = k.computeStrides(r.shape), [ M, F, P ] = k.computeStrides(s.shape), L = E[0], O = w ? E[1] : E[2], B = w ? E[2] : 1, G = w ? 1 : E[1], W = $[0], z = w ? $[1] : $[2], X = w ? $[2] : 1, q = w ? 1 : $[1], Z = t.makeOutput(d.inShape, "float32"), Y = t.dataIdMap.get(Z.dataId).id, te = t.dataIdMap.get(r.dataId).id, re = t.dataIdMap.get(s.dataId).id;
        return X3(te, re, h, f, m, y, A, g, b, v, x, I, N, T, R, M, F, P, L, O, B, G, W, z, X, q, Y), 
        Z;
    }
}, Z3, Hz = {
    kernelName: Rs,
    backendName: "wasm",
    setupFunc: function(e) {
        K3 = e.wasm.cwrap(Rs, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o
        } = a;
        if (r.dtype !== "float32") throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);
        if (s.dtype !== "float32") throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
        let p = C.computeConv3DInfo(r.shape, s.shape, i, o, l), u = n.makeOutput(p.outShape, r.dtype);
        return K3(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(u.dataId).id, p.batchSize, p.inDepth, p.inHeight, p.inWidth, p.inChannels, p.outDepth, p.outHeight, p.outWidth, p.outChannels, p.strideDepth, p.strideHeight, p.strideWidth, p.dilationDepth, p.dilationHeight, p.dilationWidth, p.filterDepth, p.filterHeight, p.filterWidth, p.padInfo.front, p.padInfo.top, p.padInfo.left), 
        u;
    }
}, Y3, jz = {
    kernelName: ml,
    backendName: "wasm",
    setupFunc: function(e) {
        Z3 = e.wasm.cwrap(ml, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            filterShape: o
        } = a;
        if (r.dtype !== "float32") throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);
        if (s.dtype !== "float32") throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
        let p = C.computeConv3DInfo(r.shape, o, i, 1, l), u = n.makeOutput(p.filterShape, s.dtype);
        return Z3(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(u.dataId).id, p.batchSize, p.inDepth, p.inHeight, p.inWidth, p.inChannels, p.outDepth, p.outHeight, p.outWidth, p.outChannels, p.strideDepth, p.strideHeight, p.strideWidth, p.dilationDepth, p.dilationHeight, p.dilationWidth, p.filterDepth, p.filterHeight, p.filterWidth, p.padInfo.front, p.padInfo.top, p.padInfo.left), 
        u;
    }
}, x1, J3, qz = {
    kernelName: Es,
    backendName: "wasm",
    setupFunc: function(e) {
        Y3 = e.wasm.cwrap(Es, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            pad: i,
            strides: l,
            inputShape: o
        } = a;
        if (r.dtype !== "float32") throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);
        if (s.dtype !== "float32") throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);
        let p = C.computeConv3DInfo(o, s.shape, l, 1, i), u = n.makeOutput(p.inShape, r.dtype);
        return Y3(n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(u.dataId).id, p.batchSize, p.inDepth, p.inHeight, p.inWidth, p.inChannels, p.outDepth, p.outHeight, p.outWidth, p.outChannels, p.strideDepth, p.strideHeight, p.strideWidth, p.dilationDepth, p.dilationHeight, p.dilationWidth, p.filterDepth, p.filterHeight, p.filterWidth, p.padInfo.front, p.padInfo.top, p.padInfo.left), 
        u;
    }
}, Xz = tt($s), Kz = tt(Ms);

(function(e) {
    e[e.bilinear = 0] = "bilinear", e[e.nearest = 1] = "nearest";
})(x1 || (x1 = {}));

var Q3, Zz = {
    kernelName: Os,
    backendName: "wasm",
    setupFunc: function(e) {
        J3 = e.wasm.cwrap(Os, null, [ "number", "number", "number", "number", "array", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let t, {
            backend: n,
            inputs: a,
            attrs: r
        } = e, {
            method: s,
            extrapolationValue: i,
            cropSize: l
        } = r, {
            image: o,
            boxes: p,
            boxInd: u
        } = a, c = p.shape[0], [ d, h ] = l, f = [ c, d, h, o.shape[3] ], m = n.dataIdMap.get(o.dataId);
        o.dtype !== "float32" && (t = Xr({
            backend: n,
            inputs: {
                x: o
            },
            attrs: {
                dtype: "float32"
            }
        }), m = n.dataIdMap.get(t.dataId));
        let g = m.id, y = n.dataIdMap.get(p.dataId).id, A = n.dataIdMap.get(u.dataId).id, x = n.makeOutput(f, "float32"), b = n.dataIdMap.get(x.dataId).id, v = new Uint8Array(new Int32Array(o.shape).buffer);
        return J3(g, y, A, c, v, d, h, x1[s], i, b), t != null && n.disposeData(t.dataId), 
        x;
    }
}, ev, Yz = {
    kernelName: Fs,
    backendName: "wasm",
    setupFunc: function(e) {
        Q3 = e.wasm.cwrap(Fs, null, [ "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a, o = r.shape.length;
        k.assert(r.dtype === "float32" || r.dtype === "int32", () => `cumprod does not support ${r.dtype} tensors in the WASM backend`);
        let p = C.getAxesPermutation([ s ], o), u = r;
        p !== null && (u = jr({
            inputs: {
                x: r
            },
            attrs: {
                perm: p
            },
            backend: n
        }));
        let c = C.getInnerMostAxes(1, o)[0];
        C.assertAxesAreInnerMostDims("cumprod", [ c ], o);
        let d = n.makeOutput(u.shape, u.dtype), h = u.shape[c], f = n.dataIdMap.get(u.dataId).id, m = n.dataIdMap.get(d.dataId).id;
        Q3(f, i ? 1 : 0, l ? 1 : 0, h, m, it[r.dtype]);
        let g = d;
        return p !== null && (g = jr({
            inputs: {
                x: d
            },
            attrs: {
                perm: C.getUndoAxesPermutation(p)
            },
            backend: n
        }), n.disposeData(u.dataId), n.disposeData(d.dataId)), g;
    }
}, tv, Jz = {
    kernelName: _s,
    backendName: "wasm",
    setupFunc: function(e) {
        ev = e.wasm.cwrap(_s, null, [ "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a, o = r.shape.length;
        k.assert(r.dtype === "float32" || r.dtype === "int32", () => `cumsum does not support ${r.dtype} tensors in the WASM backend`);
        let p = C.getAxesPermutation([ s ], o), u = r;
        p !== null && (u = jr({
            inputs: {
                x: r
            },
            attrs: {
                perm: p
            },
            backend: n
        }));
        let c = C.getInnerMostAxes(1, o)[0];
        C.assertAxesAreInnerMostDims("cumsum", [ c ], o);
        let d = n.makeOutput(u.shape, u.dtype), h = u.shape[c], f = n.dataIdMap.get(u.dataId).id, m = n.dataIdMap.get(d.dataId).id;
        ev(f, i ? 1 : 0, l ? 1 : 0, h, m, it[r.dtype]);
        let g = d;
        return p !== null && (g = jr({
            inputs: {
                x: d
            },
            attrs: {
                perm: C.getUndoAxesPermutation(p)
            },
            backend: n
        }), n.disposeData(u.dataId), n.disposeData(d.dataId)), g;
    }
}, nv, Qz = {
    kernelName: gl,
    backendName: "wasm",
    setupFunc: function(e) {
        tv = e.wasm.cwrap("DenseBincount", null, [ "number", "array", "number", "number", "boolean", "number", "number", "boolean", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = n, {
            size: i,
            binaryOutput: l
        } = a, o = s.shape.reduce((d, h) => d * h, 1) !== 0, p = r.shape.length === 1 ? [ i ] : [ r.shape[0], i ], u = t.makeOutput(p, s.dtype);
        function c(d) {
            return t.dataIdMap.get(d.dataId).id;
        }
        return tv(c(r), new Uint8Array(new Int32Array(r.shape).buffer), r.shape.length, i, o, c(s), it[s.dtype], l, c(u)), 
        u;
    }
}, av, eL = {
    kernelName: Ps,
    backendName: "wasm",
    setupFunc: function(e) {
        nv = e.wasm.cwrap(Ps, null, [ "number", "number", "number", "array", "number", "array", "array", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            x: r
        } = n, {
            blockSize: s,
            dataFormat: i
        } = a, l = r.shape[0], o = (i === "NHWC" ? r.shape[1] : r.shape[2]) * s, p = (i === "NHWC" ? r.shape[2] : r.shape[3]) * s, u = (i === "NHWC" ? r.shape[3] : r.shape[1]) / (s * s), c = i === "NHWC" ? [ l, o, p, u ] : [ l, u, o, p ], d = t.makeOutput(c, "float32"), h = t.dataIdMap.get(r.dataId).id, f = new Uint8Array(new Int32Array(k.computeStrides(r.shape)).buffer), m = new Uint8Array(new Int32Array(c).buffer), g = new Uint8Array(new Int32Array(k.computeStrides(c)).buffer), y = t.dataIdMap.get(d.dataId).id;
        return nv(h, s, i === "NHWC" ? 1 : 0, f, r.shape.length - 1, m, g, c.length, y), 
        d;
    }
}, rv, tL = {
    kernelName: Ds,
    backendName: "wasm",
    setupFunc: function(e) {
        av = e.wasm.cwrap(Ds, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            x: r,
            filter: s
        } = t, i = a.dataIdMap.get(r.dataId).id, l = a.dataIdMap.get(s.dataId).id, {
            strides: o,
            dilations: p,
            pad: u,
            dimRoundingMode: c
        } = n, d = p ?? [ 1, 1 ], h = C.computeConv2DInfo(r.shape, s.shape, o, d, u, c, !0), f = h.filterHeight, m = h.filterWidth, g = h.padInfo.top, y = h.padInfo.right, A = h.padInfo.bottom, x = h.padInfo.left, b = h.dilationHeight, v = h.dilationWidth, I = h.strideHeight, N = h.strideWidth, T = h.inChannels, R = h.outChannels, w = h.padInfo.type === "SAME" ? 1 : 0;
        if (h.dataFormat !== "channelsLast") throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);
        let E = a.makeOutput(h.outShape, "float32"), $ = a.dataIdMap.get(E.dataId).id;
        return av(i, r.shape[0], r.shape[1], r.shape[2], l, f, m, g, y, A, x, w, b, v, I, N, T, R, $), 
        E;
    }
}, sv, nL = {
    kernelName: yl,
    backendName: "wasm",
    setupFunc: function(e) {
        rv = e.wasm.cwrap("Diag", null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t, r = k.sizeFromShape(a.shape), s = n.makeOutput([ ...a.shape, ...a.shape ], a.dtype);
        return rv(n.dataIdMap.get(a.dataId).id, it[a.dtype], r, n.dataIdMap.get(s.dataId).id), 
        s;
    }
}, iv, aL = {
    kernelName: zs,
    backendName: "wasm",
    setupFunc: function(e) {
        sv = e.wasm.cwrap(zs, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o
        } = a;
        if (r.dtype !== s.dtype) throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);
        let p = C.computeDilation2DInfo(r.shape, s.shape, i, l, "NHWC", o), u = n.makeOutput(p.outShape, r.dtype);
        return sv(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(u.dataId).id, it[r.dtype], p.batchSize, p.inChannels, p.inHeight, p.inWidth, p.outHeight, p.outWidth, p.strideHeight, p.strideWidth, p.dilationHeight, p.dilationWidth, p.filterHeight, p.filterWidth, p.padInfo.top, p.padInfo.left), 
        u;
    }
}, ov, rL = {
    kernelName: xl,
    backendName: "wasm",
    setupFunc: function(e) {
        iv = e.wasm.cwrap(xl, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            dy: i
        } = t, {
            strides: l,
            pad: o,
            dilations: p
        } = a;
        if (r.dtype !== s.dtype || r.dtype !== i.dtype) throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);
        let u = C.computeDilation2DInfo(r.shape, s.shape, l, o, "NHWC", p), c = n.makeOutput(s.shape, s.dtype);
        return iv(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(i.dataId).id, n.dataIdMap.get(c.dataId).id, it[r.dtype], u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.filterHeight, u.filterWidth, u.padInfo.top, u.padInfo.left), 
        c;
    }
}, lv, sL = {
    kernelName: Al,
    backendName: "wasm",
    setupFunc: function(e) {
        ov = e.wasm.cwrap(Al, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            dy: i
        } = t, {
            strides: l,
            pad: o,
            dilations: p
        } = a;
        if (r.dtype !== s.dtype || r.dtype !== i.dtype) throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);
        let u = C.computeDilation2DInfo(r.shape, s.shape, l, o, "NHWC", p), c = n.makeOutput(r.shape, r.dtype);
        return ov(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(i.dataId).id, n.dataIdMap.get(c.dataId).id, it[r.dtype], u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.filterHeight, u.filterWidth, u.padInfo.top, u.padInfo.left), 
        c;
    }
}, iL = tt(Ws), oL = {
    kernelName: bl,
    backendName: "wasm",
    setupFunc: function(e) {
        lv = e.wasm.cwrap(bl, null, [ "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            dy: a,
            y: r
        } = t, s = n.makeOutput(r.shape, "float32"), i = l => n.dataIdMap.get(l.dataId).id;
        return lv(i(r), i(a), i(s)), s;
    }
}, lL = _t(Vs, 0, "bool"), uL = tt(Bs), dL = tt(Us, "float32");

function b1(e) {
    let {
        inputs: t,
        attrs: n,
        backend: a
    } = e, {
        input: r
    } = t, {
        dim: s
    } = n, i = r.shape.length, l = r.shape.slice(), o = s;
    return s < 0 && (k.assert(-(i + 1) <= s, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), 
    o = i + s + 1), l.splice(o, 0, 1), In({
        inputs: {
            x: r
        },
        backend: a,
        attrs: {
            shape: l
        }
    });
}

var pL = {
    kernelName: vl,
    backendName: "wasm",
    kernelFunc: b1
}, cL = tt(Gs, "float32");

function uv(e) {
    let {
        attrs: {
            shape: t,
            value: n
        },
        backend: a
    } = e, {
        attrs: {
            dtype: r
        }
    } = e;
    r = r || k.inferDtype(n);
    let s = a.makeOutput(t, r);
    return a.typedArrayFromHeap(s).fill(n), s;
}

var dv, hL = {
    kernelName: wl,
    backendName: "wasm",
    kernelFunc: uv
}, pv, fL = {
    kernelName: Hs,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            image: a
        } = t, r = n.makeOutput(a.shape, a.dtype), s = n.dataIdMap.get(a.dataId).id, i = n.dataIdMap.get(r.dataId).id, [ l, o, p, u ] = a.shape;
        return dv(s, l, o, p, u, i), r;
    },
    setupFunc: function(e) {
        dv = e.wasm.cwrap(Hs, null, [ "number", "number", "number", "number", "number", "number" ]);
    }
}, mL = tt(js), gL = _t(qs), cv, yL = {
    kernelName: Xs,
    backendName: "wasm",
    setupFunc: function(e) {
        pv = e.wasm.cwrap(Xs, null, [ "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            varianceEpsilon: r
        } = a, {
            x: s,
            mean: i,
            variance: l,
            offset: o,
            scale: p
        } = n, u = t.dataIdMap.get(s.dataId).id, c = t.dataIdMap.get(i.dataId).id, d = t.dataIdMap.get(l.dataId).id, h = o != null ? t.dataIdMap.get(o.dataId).id : 0, f = p != null ? t.dataIdMap.get(p.dataId).id : 0, m = t.makeOutput(s.shape, s.dtype);
        if (k.sizeFromShape(s.shape) === 0) return m;
        let g = t.dataIdMap.get(m.dataId).id;
        return pv(u, c, d, h, f, r, g), m;
    }
}, hv, AL = {
    kernelName: kr,
    backendName: "wasm",
    setupFunc: function(e) {
        cv = e.wasm.cwrap(kr, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dilations: u,
            dataFormat: c,
            dimRoundingMode: d,
            activation: h,
            leakyreluAlpha: f
        } = n, m = C.computeConv2DInfo(r.shape, s.shape, o, u, p, d), g = ip[h];
        if (g == null) throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);
        let y = a.dataIdMap.get(r.dataId).id, A = a.dataIdMap.get(s.dataId).id, x = m.outChannels, b = 0;
        if (i != null) {
            let q = a.dataIdMap.get(i.dataId);
            if (q.shape.length !== 1) throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${q.shape.length}.`);
            if (q.shape[0] !== x) throw new Error(`FusedConv2D bias shape (${q.shape}) does not match the number of output channels (${x})`);
            b = q.id;
        }
        let v = m.filterHeight, I = m.filterWidth, N = m.padInfo.top, T = m.padInfo.right, R = m.padInfo.bottom, w = m.padInfo.left, E = m.dilationHeight, $ = m.dilationWidth, M = m.strideHeight, F = m.strideWidth, P = m.inChannels, L = m.padInfo.type === "SAME" ? 1 : 0, O = m.batchSize, B = m.inHeight, G = m.inWidth;
        if (c !== "NHWC") throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);
        let W = a.makeOutput(m.outShape, "float32"), z = a.dataIdMap.get(W.dataId).id, X = l == null ? 0 : a.dataIdMap.get(l.dataId).id;
        return cv(y, O, B, G, A, v, I, b, N, T, R, w, L, E, $, M, F, P, x, g, X, f || 0, z), 
        W;
    }
}, fv, xL = {
    kernelName: Ir,
    backendName: "wasm",
    setupFunc: function(e) {
        hv = e.wasm.cwrap(Ir, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dilations: u,
            dataFormat: c,
            dimRoundingMode: d,
            activation: h,
            leakyreluAlpha: f
        } = n, m = C.computeConv2DInfo(r.shape, s.shape, o, u, p, d, !0), g = ip[h];
        if (g == null) throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);
        let y = a.dataIdMap.get(r.dataId).id, A = a.dataIdMap.get(s.dataId).id, x = m.outChannels, b = 0;
        if (i != null) {
            let q = a.dataIdMap.get(i.dataId);
            if (q.shape.length !== 1) throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${q.shape.length}.`);
            if (q.shape[0] !== x) throw new Error(`FusedDepthwiseConv2D bias shape (${q.shape}) does not match the number of output channels (${x})`);
            b = q.id;
        }
        let v = m.filterHeight, I = m.filterWidth, N = m.padInfo.top, T = m.padInfo.right, R = m.padInfo.bottom, w = m.padInfo.left, E = m.dilationHeight, $ = m.dilationWidth, M = m.strideHeight, F = m.strideWidth, P = m.inChannels, L = m.padInfo.type === "SAME" ? 1 : 0, O = m.batchSize, B = m.inHeight, G = m.inWidth;
        if (c !== "NHWC") throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);
        let W = a.makeOutput(m.outShape, "float32"), z = a.dataIdMap.get(W.dataId).id, X = l == null ? 0 : a.dataIdMap.get(l.dataId).id;
        return hv(y, O, B, G, A, v, I, b, N, T, R, w, L, E, $, M, F, P, x, g, X, f || 0, z), 
        W;
    }
}, mv, bL = {
    kernelName: Ks,
    backendName: "wasm",
    setupFunc: function(e) {
        fv = e.wasm.cwrap(Ks, null, [ "number", "number", "number", "number", "number", "number", "array", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n
        } = e, {
            params: a,
            indices: r
        } = n, [ s, i, l, o ] = fm.prepareAndValidate(a, r), p = t.makeOutput(s, a.dtype);
        if (i === 0) return p;
        let u = r.shape, c = u[u.length - 1], d = t.dataIdMap.get(a.dataId).id, h = t.dataIdMap.get(r.dataId).id, f = new Uint8Array(new Int32Array(o).buffer), m = t.dataIdMap.get(p.dataId).id;
        return fv(d, it[a.dtype], h, i, c, l, f, m), p;
    }
}, gv, vL = {
    kernelName: kl,
    backendName: "wasm",
    setupFunc: function(e) {
        mv = e.wasm.cwrap("Gather", null, [ "number", "number", "array", "number", "number", "number", "array", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            x: r,
            indices: s
        } = n, {
            axis: i,
            batchDims: l
        } = a, o = k.parseAxisParam(i, r.shape)[0], p = t.readSync(s.dataId), u = r.shape[o];
        for (let N = 0; N < p.length; ++N) {
            let T = p[N];
            k.assert(T <= u - 1 && T >= 0, () => `GatherV2: the index value ${T} is not in [0, ${u - 1}]`);
        }
        let c = C.segment_util.collectGatherOpShapeInfo(r, s, o, l), d = In({
            inputs: {
                x: r
            },
            attrs: {
                shape: [ c.batchSize, c.outerSize, c.dimSize, c.sliceSize ]
            },
            backend: t
        }), h = k.sizeFromShape(s.shape), f = In({
            inputs: {
                x: s
            },
            attrs: {
                shape: [ c.batchSize, h / c.batchSize ]
            },
            backend: t
        }), m = [ c.batchSize, c.outerSize, h / c.batchSize, c.sliceSize ], g = t.makeOutput(m, r.dtype);
        if (k.sizeFromShape(r.shape) === 0) return g;
        let y = d.shape.length - 1, A = t.dataIdMap.get(d.dataId).id, x = t.dataIdMap.get(f.dataId).id, b = t.dataIdMap.get(g.dataId).id, v = new Uint8Array(new Int32Array(k.computeStrides(d.shape)).buffer), I = new Uint8Array(new Int32Array(k.computeStrides(m)).buffer);
        return mv(A, it[r.dtype], v, y, x, c.batchSize, I, b), t.disposeData(d.dataId), 
        t.disposeData(f.dataId), g.shape = c.outputShape, g;
    }
}, wL = _t(Zs, 0, "bool"), kL = _t(Ys, 0, "bool"), IL = tt(Qs, "bool"), SL = tt(ei, "bool"), NL = tt(ti, "bool"), yv, CL = {
    kernelName: ni,
    backendName: "wasm",
    setupFunc: function(e) {
        gv = e.wasm.cwrap(ni, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: {
                x: t
            },
            attrs: {
                alpha: n
            },
            backend: a
        } = e, r = a.dataIdMap.get(t.dataId).id, s = a.makeOutput(t.shape, "float32");
        if (k.sizeFromShape(t.shape) !== 0) {
            let i = a.dataIdMap.get(s.dataId).id;
            gv(r, it[t.dtype], n, i);
        }
        return s;
    }
}, TL = _t(ai, 0, "bool"), RL = _t(ri, 0, "bool"), Av, EL = {
    kernelName: si,
    backendName: "wasm",
    setupFunc: function(e) {
        yv = e.wasm.cwrap(si, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            attrs: t,
            backend: n
        } = e, {
            start: a,
            stop: r,
            num: s
        } = t, i = Math.floor(s), l = n.makeOutput([ i ], "float32");
        return yv(n.dataIdMap.get(l.dataId).id, a, r, i), l;
    }
}, $L = tt(ii), ML = tt(oi), FL = _t(li, 0, "bool"), _L = tt(ui), OL = _t(di, 0, "bool"), PL = _t(f0, 0, "bool"), xv, DL = {
    kernelName: pi,
    backendName: "wasm",
    setupFunc: function(e) {
        Av = e.wasm.cwrap(pi, null, [ "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            depthRadius: s,
            bias: i,
            alpha: l,
            beta: o
        } = a;
        if (r.dtype !== "float32") throw new Error("LRN error: x must have dtype float32");
        let p = n.makeOutput(r.shape, r.dtype);
        return Av(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(p.dataId).id, r.shape[3], s, i, l, o), 
        p;
    }
}, bv, zL = {
    kernelName: Il,
    backendName: "wasm",
    setupFunc: function(e) {
        xv = e.wasm.cwrap(Il, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            y: s,
            dy: i
        } = t, {
            depthRadius: l,
            bias: o,
            alpha: p,
            beta: u
        } = a;
        if (r.dtype !== "float32" || s.dtype !== "float32" || i.dtype !== "float32") throw new Error("LRNGrad error: x, y, and dy must have dtype float32");
        let c = n.makeOutput(r.shape, r.dtype);
        return xv(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(i.dataId).id, n.dataIdMap.get(c.dataId).id, i.shape[3], l, o, p, u), 
        c;
    }
}, vv, LL = {
    kernelName: ci,
    backendName: "wasm",
    setupFunc: function(e) {
        bv = e.wasm.cwrap(ci, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            reductionIndices: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = i, {
            transposed: p,
            axes: u,
            originalAxes: c,
            inputWasTransposed: d
        } = qr(i, r, t);
        d && (o = p, l = t.dataIdMap.get(p.dataId).id);
        let h = o.shape.length;
        C.assertAxesAreInnerMostDims("max", u, h);
        let [ f, m ] = C.computeOutAndReduceShapes(o.shape, u), g = k.sizeFromShape(m), y = t.makeOutput(f, i.dtype);
        if (k.sizeFromShape(o.shape) !== 0) {
            let A = t.dataIdMap.get(y.dataId).id;
            bv(l, it[i.dtype], g, A);
        }
        if (d && t.disposeData(p.dataId), s) {
            let A = C.expandShapeToKeepDim(y.shape, c);
            y.shape = A;
        }
        return y;
    }
}, WL = _t(hi), wv, BL = {
    kernelName: fi,
    backendName: "wasm",
    setupFunc: function(e) {
        vv = e.wasm.cwrap(fi, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, r = t.x, s = a.dataIdMap.get(r.dataId).id;
        k.assert(r.dtype === "float32", () => `Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);
        let {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = n, u = C.computePool2DInfo(r.shape, i, l, 1, o, p), c = u.filterHeight, d = u.filterWidth, h = u.padInfo.top, f = u.padInfo.right, m = u.padInfo.bottom, g = u.padInfo.left, y = u.dilationHeight, A = u.dilationWidth, x = u.strideHeight, b = u.strideWidth, v = u.inChannels, I = u.outChannels;
        if (u.dataFormat !== "channelsLast") throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);
        let N = a.makeOutput(u.outShape, "float32"), T = a.dataIdMap.get(N.dataId).id;
        return vv(s, r.shape[0], r.shape[1], r.shape[2], c, d, h, f, m, g, y, A, x, b, v, I, T), 
        N;
    }
}, kv, VL = {
    kernelName: Sl,
    backendName: "wasm",
    setupFunc: function(e) {
        wv = e.wasm.cwrap("MaxPool3D", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o,
            dataFormat: p
        } = a, u = C.computePool3DInfo(r.shape, s, i, 1, l, o, p), c = n.makeOutput(u.outShape, r.dtype);
        return wv(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inDepth, u.inHeight, u.inWidth, u.outDepth, u.outHeight, u.outWidth, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.effectiveFilterDepth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), 
        c;
    }
}, Iv, UL = {
    kernelName: rd,
    backendName: "wasm",
    setupFunc: function(e) {
        kv = e.wasm.cwrap("MaxPool3DGrad", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = a, u = C.computePool3DInfo(s.shape, i, l, 1, o, p), c = n.makeOutput(s.shape, s.dtype);
        return kv(n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inDepth, u.inHeight, u.inWidth, u.outDepth, u.outHeight, u.outWidth, u.strideDepth, u.strideHeight, u.strideWidth, u.dilationDepth, u.dilationHeight, u.dilationWidth, u.effectiveFilterDepth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.front, u.padInfo.top, u.padInfo.left), 
        c;
    }
}, Sv, GL = {
    kernelName: ad,
    backendName: "wasm",
    setupFunc: function(e) {
        Iv = e.wasm.cwrap("MaxPoolGrad", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, {
            filterSize: i,
            strides: l,
            pad: o,
            dimRoundingMode: p
        } = a, u = C.computePool2DInfo(s.shape, i, l, 1, o, p), c = n.makeOutput(s.shape, s.dtype);
        return Iv(n.dataIdMap.get(s.dataId).id, n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(c.dataId).id, u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.top, u.padInfo.left), 
        c;
    }
}, Nv, HL = {
    kernelName: Nl,
    backendName: "wasm",
    setupFunc: function(e) {
        Sv = e.wasm.cwrap("MaxPoolWithArgmax", null, [ "number", "number", "number", "number", "boolean", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            includeBatchInIndex: o
        } = a;
        k.assert(r.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);
        let p = [ 1, 1 ];
        k.assert(C.eitherStridesOrDilationsAreOne(i, p), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);
        let u = C.computePool2DInfo(r.shape, s, i, [ 1, 1 ], l), c = n.makeOutput(u.outShape, r.dtype), d = n.makeOutput(u.outShape, "int32");
        return Sv(n.dataIdMap.get(r.dataId).id, n.dataIdMap.get(c.dataId).id, n.dataIdMap.get(d.dataId).id, it[r.dtype], o, u.batchSize, u.inChannels, u.inHeight, u.inWidth, u.outHeight, u.outWidth, u.strideHeight, u.strideWidth, u.dilationHeight, u.dilationWidth, u.effectiveFilterHeight, u.effectiveFilterWidth, u.padInfo.top, u.padInfo.left), 
        [ c, d ];
    }
}, Cv, jL = {
    kernelName: mi,
    backendName: "wasm",
    setupFunc: function(e) {
        Nv = e.wasm.cwrap(mi, null, [ "number, number, number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            axis: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = l, p = i, {
            transposed: u,
            axes: c,
            originalAxes: d,
            inputWasTransposed: h
        } = qr(i, r, t), f = c;
        if (h) {
            let b = t.dataIdMap.get(u.dataId).id;
            b !== l && (p = u, o = b, f = C.getInnerMostAxes(f.length, p.shape.length));
        }
        C.assertAxesAreInnerMostDims("mean", f, p.shape.length);
        let [ m, g ] = C.computeOutAndReduceShapes(p.shape, f), y = k.sizeFromShape(g), A = p;
        p.dtype !== "float32" && (A = Xr({
            backend: t,
            inputs: {
                x: p
            },
            attrs: {
                dtype: "float32"
            }
        }), o = t.dataIdMap.get(A.dataId).id);
        let x = t.makeOutput(m, "float32");
        if (k.sizeFromShape(p.shape) !== 0) {
            let b = t.dataIdMap.get(x.dataId).id;
            Nv(o, y, b);
        }
        if (h && t.disposeData(u.dataId), s) {
            let b = C.expandShapeToKeepDim(x.shape, d);
            x.shape = b;
        }
        return p.dtype !== "float32" && t.disposeData(A.dataId), x;
    }
}, v1, Tv, qL = {
    kernelName: gi,
    backendName: "wasm",
    setupFunc: function(e) {
        Cv = e.wasm.cwrap(gi, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            axis: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = l, p = i, {
            transposed: u,
            axes: c,
            originalAxes: d,
            inputWasTransposed: h
        } = qr(i, r, t);
        if (h) {
            let x = t.dataIdMap.get(u.dataId).id;
            x !== l && (p = u, o = x);
        }
        let f = p.shape.length;
        C.assertAxesAreInnerMostDims("min", c, f);
        let [ m, g ] = C.computeOutAndReduceShapes(p.shape, c), y = k.sizeFromShape(g), A = t.makeOutput(m, p.dtype);
        if (k.sizeFromShape(p.shape) !== 0) {
            let x = t.dataIdMap.get(A.dataId).id;
            Cv(o, it[i.dtype], y, x);
        }
        if (h && t.disposeData(u.dataId), s) {
            let x = C.expandShapeToKeepDim(A.shape, d);
            A.shape = x;
        }
        return A;
    }
}, XL = _t(yi);

(function(e) {
    e[e.reflect = 0] = "reflect", e[e.symmetric = 1] = "symmetric";
})(v1 || (v1 = {}));

var Rv, KL = {
    kernelName: Ai,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: {
                x: t
            },
            backend: n,
            attrs: {
                paddings: a,
                mode: r
            }
        } = e, s = a.map((f, m) => f[0] + t.shape[m] + f[1]), i = n.dataIdMap.get(t.dataId).id, l = n.makeOutput(s, t.dtype), o = n.dataIdMap.get(l.dataId).id, p = new Uint8Array(new Int32Array(t.shape).buffer), u = a.map(f => f[0]), c = a.map(f => f[1]), d = new Uint8Array(new Int32Array(u).buffer), h = new Uint8Array(new Int32Array(c).buffer);
        return Tv(i, p, t.shape.length, it[t.dtype], d, h, v1[r], o), l;
    },
    setupFunc: function(e) {
        Tv = e.wasm.cwrap(Ai, null, [ "number", "array", "number", "number", "array", "array", "number", "number" ]);
    }
};

function Ev(e) {
    let {
        backend: t,
        inputs: {
            logits: n
        },
        attrs: {
            dim: a
        }
    } = e, r = t.dataIdMap.get(n.dataId).id, s = t.makeOutput(n.shape, n.dtype), i = t.dataIdMap.get(s.dataId).id, l = n.shape[a], o = k.sizeFromShape(n.shape) / l;
    return k.sizeFromShape(s.shape) === 0 || Rv(r, i, l, o), s;
}

var $v, ZL = {
    kernelName: Ki,
    backendName: "wasm",
    setupFunc: function(e) {
        Rv = e.wasm.cwrap(Ki, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: Ev
}, Mv, YL = {
    kernelName: bi,
    backendName: "wasm",
    setupFunc: function(e) {
        $v = e.wasm.cwrap(bi, null, [ "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            logits: r
        } = t, {
            numSamples: s,
            seed: i,
            normalized: l
        } = a;
        if (r.dtype !== "float32") throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);
        let o = l ? r : Ev({
            inputs: {
                logits: r
            },
            backend: n,
            attrs: {
                dim: r.shape.length - 1
            }
        }), [ p, u ] = o.shape, c = n.makeOutput([ p, s ], "int32");
        return $v(n.dataIdMap.get(o.dataId).id, p, u, s, i, n.dataIdMap.get(c.dataId).id), 
        l || n.disposeData(o.dataId), c;
    }
}, JL = _t(xi), QL = _t(vi), eW = tt(Cl);

function w1(e, t) {
    let n = new Int32Array(e.wasm.HEAPU8.buffer, t, 4), a = n[0], r = n[1], s = n[2], i = n[3];
    return e.wasm._free(t), {
        pSelectedIndices: a,
        selectedSize: r,
        pSelectedScores: s,
        pValidOutputs: i
    };
}

var Fv, tW = {
    kernelName: ki,
    backendName: "wasm",
    setupFunc: function(e) {
        Mv = e.wasm.cwrap(ki, "number", [ "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            iouThreshold: r,
            maxOutputSize: s,
            scoreThreshold: i
        } = a, {
            boxes: l,
            scores: o
        } = n, p = t.dataIdMap.get(l.dataId).id, u = t.dataIdMap.get(o.dataId).id, c = Mv(p, u, s, r, i), {
            pSelectedIndices: d,
            selectedSize: h,
            pSelectedScores: f,
            pValidOutputs: m
        } = w1(t, c);
        return t.wasm._free(f), t.wasm._free(m), t.makeOutput([ h ], "int32", d);
    }
}, _v, nW = {
    kernelName: Tl,
    backendName: "wasm",
    setupFunc: function(e) {
        Fv = e.wasm.cwrap(Tl, "number", [ "number", "number", "number", "number", "number", "bool" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            iouThreshold: r,
            maxOutputSize: s,
            scoreThreshold: i,
            padToMaxOutputSize: l
        } = a, {
            boxes: o,
            scores: p
        } = n, u = t.dataIdMap.get(o.dataId).id, c = t.dataIdMap.get(p.dataId).id, d = Fv(u, c, s, r, i, l), {
            pSelectedIndices: h,
            selectedSize: f,
            pSelectedScores: m,
            pValidOutputs: g
        } = w1(t, d);
        return t.wasm._free(m), [ t.makeOutput([ f ], "int32", h), t.makeOutput([], "int32", g) ];
    }
}, Ov, aW = {
    kernelName: Ii,
    backendName: "wasm",
    setupFunc: function(e) {
        _v = e.wasm.cwrap(Ii, "number", [ "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            iouThreshold: r,
            maxOutputSize: s,
            scoreThreshold: i,
            softNmsSigma: l
        } = a, {
            boxes: o,
            scores: p
        } = n, u = t.dataIdMap.get(o.dataId).id, c = t.dataIdMap.get(p.dataId).id, d = _v(u, c, s, r, i, l), {
            pSelectedIndices: h,
            selectedSize: f,
            pSelectedScores: m,
            pValidOutputs: g
        } = w1(t, d);
        return t.wasm._free(g), [ t.makeOutput([ f ], "int32", h), t.makeOutput([ f ], "float32", m) ];
    }
}, rW = _t(wi, 0, "bool"), sW = {
    kernelName: Si,
    backendName: "wasm",
    setupFunc: function(e) {
        Ov = e.wasm.cwrap(Si, null, [ "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r
        } = t, {
            dtype: s,
            depth: i,
            onValue: l,
            offValue: o
        } = a, p = n.makeOutput([ ...r.shape, i ], s), u = n.dataIdMap.get(p.dataId).id, c = n.dataIdMap.get(r.dataId).id;
        return Ov(c, i, l, o, u), p;
    }
}, iW = {
    kernelName: Rl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: {
                x: t
            },
            backend: n
        } = e, a = n.makeOutput(t.shape, t.dtype);
        return n.typedArrayFromHeap(a).fill(1), a;
    }
}, Pv, oW = {
    kernelName: El,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            axis: r
        } = a;
        if (t.length === 1) return b1({
            inputs: {
                input: t[0]
            },
            backend: n,
            attrs: {
                dim: r
            }
        });
        let s = t[0].shape, i = t[0].dtype;
        t.forEach(p => {
            k.assertShapesMatch(s, p.shape, "All tensors passed to stack must have matching shapes"), 
            k.assert(i === p.dtype, () => "All tensors passed to stack must have matching dtypes");
        });
        let l = [], o = j3({
            inputs: t.map(p => {
                let u = b1({
                    inputs: {
                        input: p
                    },
                    backend: n,
                    attrs: {
                        dim: r
                    }
                });
                return l.push(u), u;
            }),
            backend: n,
            attrs: {
                axis: r
            }
        });
        return l.forEach(p => n.disposeData(p.dataId)), o;
    }
}, Dv, zv = {
    kernelName: Ni,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: {
                x: t
            },
            backend: n,
            attrs: {
                paddings: a,
                constantValue: r
            }
        } = e, s = a.map((f, m) => f[0] + t.shape[m] + f[1]);
        if (k.sizeFromShape(t.shape) === 0) return uv({
            backend: n,
            attrs: {
                shape: s,
                value: r,
                dtype: t.dtype
            }
        });
        let i = n.dataIdMap.get(t.dataId).id, l = n.makeOutput(s, t.dtype), o = n.dataIdMap.get(l.dataId).id, p = new Uint8Array(new Int32Array(t.shape).buffer), u = a.map(f => f[0]), c = a.map(f => f[1]), d = new Uint8Array(new Int32Array(u).buffer), h = new Uint8Array(new Int32Array(c).buffer);
        return Pv(i, p, t.shape.length, it[t.dtype], d, h, r, o), l;
    },
    setupFunc: function(e) {
        Pv = e.wasm.cwrap(Ni, null, [ "number", "array", "number", "number", "array", "array", "number", "number" ]);
    }
}, lW = _t(Ci), Lv, uW = {
    kernelName: Ti,
    backendName: "wasm",
    setupFunc: function(e) {
        Dv = e.wasm.cwrap(Ti, null, [ "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a,
            alpha: r
        } = t, s = n.dataIdMap.get(a.dataId).id, i = n.dataIdMap.get(r.dataId).id, l = s, o = a, p = o;
        o.dtype !== "float32" && (p = Xr({
            backend: n,
            inputs: {
                x: a
            },
            attrs: {
                dtype: "float32"
            }
        }), l = n.dataIdMap.get(p.dataId).id);
        let u = n.makeOutput(a.shape, "float32"), c = n.dataIdMap.get(u.dataId).id;
        return Dv(l, i, c), o.dtype !== "float32" && n.disposeData(p.dataId), u;
    }
}, Wv, dW = {
    kernelName: Ri,
    backendName: "wasm",
    setupFunc: function(e) {
        Lv = e.wasm.cwrap(Ri, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            axis: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = l, p = i, {
            transposed: u,
            axes: c,
            originalAxes: d,
            inputWasTransposed: h
        } = qr(i, r, t), f = c;
        if (h) {
            let x = t.dataIdMap.get(u.dataId).id;
            x !== l && (p = u, o = x, f = C.getInnerMostAxes(f.length, p.shape.length));
        }
        C.assertAxesAreInnerMostDims("prod", f, p.shape.length);
        let [ m, g ] = C.computeOutAndReduceShapes(p.shape, f), y = k.sizeFromShape(g), A = t.makeOutput(m, p.dtype);
        if (k.sizeFromShape(p.shape) !== 0) {
            let x = t.dataIdMap.get(A.dataId).id;
            Lv(o, y, it[A.dtype], x);
        }
        if (h && t.disposeData(u.dataId), s) {
            let x = C.expandShapeToKeepDim(A.shape, d);
            A.shape = x;
        }
        return A;
    }
}, pW = {
    kernelName: $l,
    backendName: "wasm",
    kernelFunc: e => {
        let {
            backend: t,
            attrs: n
        } = e, {
            start: a,
            stop: r,
            step: s,
            dtype: i
        } = n, l = zm(a, r, s, i), o = t.makeOutput([ l.length ], i);
        return t.typedArrayFromHeap(o).set(l), o;
    }
}, cW = _t(Ls), hW = tt(Ei), fW = tt($i), mW = tt(_i), Bv, gW = {
    kernelName: Fi,
    backendName: "wasm",
    setupFunc: function(e) {
        Wv = e.wasm.cwrap(Fi, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let t, {
            backend: n,
            inputs: a,
            attrs: r
        } = e, {
            images: s
        } = a, {
            alignCorners: i,
            halfPixelCenters: l,
            size: o
        } = r, [ p, u ] = o, [ c, d, h, f ] = s.shape, m = [ c, p, u, f ], g = n.dataIdMap.get(s.dataId);
        g.dtype !== "float32" && (t = Xr({
            backend: n,
            inputs: {
                x: s
            },
            attrs: {
                dtype: "float32"
            }
        }), g = n.dataIdMap.get(t.dataId));
        let y = g.id, A = n.makeOutput(m, "float32");
        if (k.sizeFromShape(s.shape) === 0) return A;
        let x = n.dataIdMap.get(A.dataId).id;
        return Wv(y, c, d, h, f, p, u, i ? 1 : 0, l ? 1 : 0, x), t != null && n.disposeData(t.dataId), 
        A;
    }
}, Vv, yW = {
    kernelName: _l,
    backendName: "wasm",
    setupFunc: function(e) {
        Bv = e.wasm.cwrap(_l, null, [ "number", "number", "number", "array", "array", "boolean" ]);
    },
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            images: s,
            dy: i
        } = n, {
            alignCorners: l
        } = r, o = a.makeOutput(s.shape, "float32"), p = a.dataIdMap.get(s.dataId);
        return p.dtype !== "float32" && (t = Xr({
            backend: a,
            inputs: {
                x: s
            },
            attrs: {
                dtype: "float32"
            }
        }), p = a.dataIdMap.get(t.dataId)), Bv(a.dataIdMap.get(s.dataId).id, a.dataIdMap.get(i.dataId).id, a.dataIdMap.get(o.dataId).id, new Uint8Array(new Int32Array(s.shape).buffer), new Uint8Array(new Int32Array(i.shape).buffer), l), 
        t != null && a.disposeData(t.dataId), o;
    }
}, Uv, AW = {
    kernelName: Mi,
    backendName: "wasm",
    setupFunc: function(e) {
        Vv = e.wasm.cwrap(Mi, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            images: r
        } = n, {
            alignCorners: s,
            halfPixelCenters: i,
            size: l
        } = a, [ o, p ] = l, [ u, c, d, h ] = r.shape, f = [ u, o, p, h ], m = t.makeOutput(f, "float32");
        if (k.sizeFromShape(r.shape) === 0) return m;
        let g, y = t.dataIdMap.get(r.dataId);
        y.dtype !== "float32" && (g = Xr({
            backend: t,
            inputs: {
                x: r
            },
            attrs: {
                dtype: "float32"
            }
        }), y = t.dataIdMap.get(g.dataId));
        let A = y.id, x = t.dataIdMap.get(m.dataId).id;
        return Vv(A, u, c, d, h, o, p, s ? 1 : 0, i ? 1 : 0, x), g != null && t.disposeData(g.dataId), 
        m;
    }
}, Gv, xW = {
    kernelName: Fl,
    backendName: "wasm",
    setupFunc: function(e) {
        Uv = e.wasm.cwrap(Fl, null, [ "number", "number", "number", "array", "array", "boolean" ]);
    },
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            images: s,
            dy: i
        } = n, {
            alignCorners: l
        } = r, o = a.makeOutput(s.shape, "float32"), p = a.dataIdMap.get(s.dataId);
        return p.dtype !== "float32" && (t = Xr({
            backend: a,
            inputs: {
                x: s
            },
            attrs: {
                dtype: "float32"
            }
        }), p = a.dataIdMap.get(t.dataId)), Uv(a.dataIdMap.get(s.dataId).id, a.dataIdMap.get(i.dataId).id, a.dataIdMap.get(o.dataId).id, new Uint8Array(new Int32Array(s.shape).buffer), new Uint8Array(new Int32Array(i.shape).buffer), l), 
        t != null && a.disposeData(t.dataId), o;
    }
}, Hv, bW = {
    kernelName: Oi,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            dims: s
        } = a, i = k.parseAxisParam(s, r.shape);
        if (r.shape.length === 0) return Xc({
            inputs: {
                x: r
            },
            backend: n
        });
        let l = n.makeOutput(r.shape, r.dtype), o = n.dataIdMap.get(r.dataId).id, p = n.dataIdMap.get(l.dataId).id, u = new Uint8Array(new Int32Array(i).buffer), c = new Uint8Array(new Int32Array(r.shape).buffer);
        Gv(o, u, i.length, c, r.shape.length, p);
        let d = In({
            inputs: {
                x: l
            },
            attrs: {
                shape: r.shape
            },
            backend: n
        });
        return n.disposeData(l.dataId), d;
    },
    setupFunc: function(e) {
        Gv = e.wasm.cwrap(Oi, null, [ "number", "array", "number", "array", "number", "number" ]);
    }
}, jv, vW = {
    kernelName: ro,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r
        } = t, {
            radians: s,
            fillValue: i,
            center: l
        } = a, o = n.makeOutput(r.shape, r.dtype), p = n.dataIdMap.get(r.dataId).id, u = n.dataIdMap.get(o.dataId).id, [ c, d, h, f ] = r.shape, [ m, g ] = C.getImageCenter(l, d, h), y = typeof i == "number" ? [ i, i, i, i === 0 ? 0 : 255 ] : [ ...i, 255 ], A = new Uint8Array(new Int32Array(y).buffer);
        return Hv(p, c, d, h, f, s, m, g, A, y.length, u), o;
    },
    setupFunc: function(e) {
        Hv = e.wasm.cwrap(ro, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number" ]);
    }
}, wW = tt(Pi), kW = tt(Di), qv, IW = {
    kernelName: zi,
    backendName: "wasm",
    setupFunc: function(e) {
        jv = e.wasm.cwrap(zi, null, [ "number", "number", "number", "number", "number", "number", "array", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            indices: r,
            updates: s
        } = n, {
            shape: i
        } = a, l = t.makeOutput(i, s.dtype);
        if (k.sizeFromShape(i) === 0) return l;
        let {
            sliceRank: o,
            numUpdates: p,
            sliceSize: u,
            strides: c,
            outputSize: d
        } = pc.calculateShapes(s, r, i), h = t.dataIdMap.get(r.dataId).id, f = t.dataIdMap.get(s.dataId).id, m = new Uint8Array(new Int32Array(c).buffer), g = t.dataIdMap.get(l.dataId).id;
        return jv(h, f, it[s.dtype], o, p, u, m, d, g), l;
    }
}, Xv, SW = {
    kernelName: Wi,
    backendName: "wasm",
    setupFunc: function(e) {
        qv = e.wasm.cwrap(Wi, null, [ "number", "number", "number", "number", "number", "number", "bool", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            sortedSequence: r,
            values: s
        } = t, {
            side: i
        } = a;
        if (r.dtype !== s.dtype) throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);
        let l = n.makeOutput(s.shape, "int32");
        function o(p) {
            return n.dataIdMap.get(p.dataId).id;
        }
        return qv(o(r), o(s), r.shape[0], r.shape[1], s.shape[1], it[r.dtype], i === "left", o(l)), 
        l;
    }
}, Kv, NW = {
    kernelName: Ol,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            condition: a,
            t: r,
            e: s
        } = t, i = n.dataIdMap.get(a.dataId).id, l = n.dataIdMap.get(r.dataId).id, o = n.dataIdMap.get(s.dataId).id, p = n.makeOutput(r.shape, r.dtype), u = n.dataIdMap.get(p.dataId).id, c = a.shape.length, d = r.shape.length, h = c === 0 || c > 1 || d === 1 ? 1 : k.sizeFromShape(r.shape.slice(1));
        return Xv(i, l, o, h, u), p;
    },
    setupFunc: function(e) {
        Xv = e.wasm.cwrap("SelectV2", null, [ "number", "number", "number", "number", "number" ]);
    }
}, CW = tt(Bi), TW = {
    kernelName: "Sigmoid",
    backendName: "wasm",
    setupFunc: function(e) {
        Kv = e.wasm.cwrap(Hi, null, [ "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: {
                x: n
            }
        } = e, a = t.dataIdMap.get(n.dataId).id, r = t.makeOutput(n.shape, n.dtype), s = t.dataIdMap.get(r.dataId).id;
        return k.sizeFromShape(r.shape) === 0 || Kv(a, s), r;
    }
}, RW = tt(Gi), EW = tt(Vi), $W = tt(Ui), MW = tt(ji), Zv, FW = {
    kernelName: Dl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            paddings: i
        } = a, l = k.sizeFromShape(s), o = [ [ 0, 0 ] ];
        o.push(...i);
        for (let g = 1 + s.length; g < r.shape.length; ++g) o.push([ 0, 0 ]);
        let p = zv.kernelFunc({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                paddings: o,
                constantValue: 0
            }
        }), u = C.getReshaped(p.shape, s, l, !1), c = C.getPermuted(u.length, s.length, !1), d = C.getReshapedPermuted(p.shape, s, l, !1), h = In({
            inputs: {
                x: p
            },
            backend: n,
            attrs: {
                shape: u
            }
        }), f = jr({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                perm: c
            }
        }), m = In({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: d
            }
        });
        return n.disposeData(p.dataId), n.disposeData(h.dataId), n.disposeData(f.dataId), 
        m;
    }
}, Yv, _W = {
    kernelName: id,
    backendName: "wasm",
    setupFunc: function(e) {
        Zv = e.wasm.cwrap("SparseFillEmptyRows", "number", [ "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let t, {
            backend: n,
            inputs: a
        } = e, {
            indices: r,
            values: s,
            denseShape: i,
            defaultValue: l
        } = a, o = r.shape[0], p = r.shape[1], u = n.readSync(i.dataId)[0], c = [ o + u, p ], d = n.dataIdMap.get(r.dataId).id, h = n.dataIdMap.get(s.dataId).id, f = n.dataIdMap.get(l.dataId).id, m = n.makeOutput(c, r.dtype), g = n.dataIdMap.get(m.dataId).id, y = n.makeOutput(c.slice(0, 1), s.dtype), A = n.dataIdMap.get(y.dataId).id, x = n.makeOutput([ u ], "bool"), b = n.dataIdMap.get(x.dataId).id, v = n.makeOutput([ o ], r.dtype), I = n.dataIdMap.get(v.dataId).id, N = n.makeOutput([ 4 ], "int32"), T = n.dataIdMap.get(N.dataId).id, R = Zv(d, h, it[s.dtype], o, u, p, f, g, A, b, I, T), w = n.readSync(N.dataId);
        switch (w[0]) {
          case 1:
            t = C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(w[1]);
            break;

          case 2:
            t = C.getSparseFillEmptyRowsNegativeIndexErrorMessage(w[1], w[2]);
            break;

          case 3:
            t = C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(w[1], w[2], w[3]);
            break;

          default:
            t = "";
        }
        if (n.disposeData(N.dataId), t) throw n.disposeData(m.dataId), n.disposeData(y.dataId), 
        n.disposeData(x.dataId), n.disposeData(v.dataId), new Error(t);
        let E = m, $ = y;
        return R !== c[0] && (E = Mo({
            inputs: {
                x: m
            },
            attrs: {
                begin: 0,
                size: [ R, p ]
            },
            backend: n
        }), $ = Mo({
            inputs: {
                x: y
            },
            attrs: {
                begin: 0,
                size: R
            },
            backend: n
        }), n.disposeData(m.dataId), n.disposeData(y.dataId)), [ E, $, x, v ];
    }
}, Jv, OW = {
    kernelName: Ll,
    backendName: "wasm",
    setupFunc: function(e) {
        Yv = e.wasm.cwrap(Ll, null, [ "number", "number", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n
        } = e, {
            inputIndices: a,
            inputShape: r,
            newShape: s
        } = n;
        if (a.shape.length !== 2) throw new Error(`Input indices should be a matrix but received shape
        ${a.shape}`);
        if (r.shape.length !== 1) throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);
        if (s.shape.length !== 1) throw new Error(`Target shape should be a vector but received shape ${s.shape}`);
        let i = t.dataIdMap.get(a.dataId).id, l = t.dataIdMap.get(r.dataId).id, o = t.dataIdMap.get(s.dataId).id, p = a.shape[0], u = k.sizeFromShape(s.shape), c = t.makeOutput([ p, u ], a.dtype), d = t.dataIdMap.get(c.dataId).id, h = t.makeOutput([ u ], s.dtype), f = t.dataIdMap.get(h.dataId).id, m = t.makeOutput([ 3 ], "int32"), g = t.dataIdMap.get(m.dataId).id;
        Yv(i, l, o, p, d, f, g);
        let y, A = t.readSync(m.dataId);
        switch (A[0]) {
          case 0:
            y = C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(A[1], A[2]);
            break;

          case 1:
            y = C.getSparseReshapeNegativeOutputDimErrorMessage(A[1], A[2]);
            break;

          case 2:
            y = C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();
            break;

          case 3:
            {
                let x = Array.from(t.readSync(r.dataId)), b = Array.from(t.readSync(h.dataId));
                y = C.getSparseReshapeInputOutputMultipleErrorMessage(x, b);
                break;
            }

          case 4:
            {
                let x = Array.from(t.readSync(r.dataId)), b = Array.from(t.readSync(h.dataId));
                y = C.getSparseReshapeInputOutputMismatchErrorMessage(x, b);
                break;
            }

          default:
            y = "";
        }
        if (t.disposeData(m.dataId), y) throw t.disposeData(c.dataId), t.disposeData(h.dataId), 
        new Error(y);
        return [ c, h ];
    }
};

function Qv(e) {
    Jv = e.wasm.cwrap("SparseSegmentReduction", null, [ "number", "number", "number", "number", "number", "number", "number", "number", "number" ]);
}

function ew(e, t) {
    let {
        backend: n,
        inputs: a
    } = e, {
        data: r,
        indices: s,
        segmentIds: i
    } = a, l = s.shape[0], o = n.readSync(i.dataId, l - 1, l)[0], p = l > 0 ? o + 1 : 0;
    if (p < 0) throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());
    let u = r.shape.slice();
    u[0] = p;
    let c = n.dataIdMap.get(r.dataId).id, d = n.dataIdMap.get(s.dataId).id, h = n.dataIdMap.get(i.dataId).id, f = n.makeOutput(u, r.dtype), m = n.dataIdMap.get(f.dataId).id, g = n.makeOutput([ 4 ], "int32"), y = n.dataIdMap.get(g.dataId).id;
    Jv(c, it[r.dtype], r.shape[0], d, h, m, y, t, 0);
    let A, x = n.readSync(g.dataId);
    switch (x[0]) {
      case 0:
        A = C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();
        break;

      case 1:
        A = C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();
        break;

      case 2:
        A = C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1], x[2]);
        break;

      case 3:
        A = C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1], x[2], x[3]);
        break;

      default:
        A = "";
    }
    if (n.disposeData(g.dataId), A) throw n.disposeData(f.dataId), new Error(A);
    return f;
}

var PW = {
    kernelName: Wl,
    backendName: "wasm",
    setupFunc: Qv,
    kernelFunc: function(e) {
        return ew(e, !0);
    }
}, tw, DW = {
    kernelName: Bl,
    backendName: "wasm",
    setupFunc: Qv,
    kernelFunc: function(e) {
        return ew(e, !1);
    }
}, zW = {
    kernelName: Zi,
    backendName: "wasm",
    setupFunc: function(e) {
        tw = e.wasm.cwrap(Zi, null, [ "number", "number", "number", "number", "number", "number", "number", "number", "array", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            sparseIndices: r,
            sparseValues: s,
            defaultValue: i
        } = n, {
            outputShape: l
        } = a, o = t.makeOutput(l, i.dtype);
        if (k.sizeFromShape(l) === 0) return o;
        let {
            sliceRank: p,
            numUpdates: u,
            sliceSize: c,
            strides: d,
            outputSize: h
        } = C.calculateShapes(s, r, l), f = t.dataIdMap.get(r.dataId).id, m = t.dataIdMap.get(s.dataId).id, g = t.dataIdMap.get(i.dataId).id, y = new Uint8Array(new Int32Array(d).buffer), A = t.dataIdMap.get(o.dataId).id;
        return tw(f, m, s.shape.length, g, it[i.dtype], p, u, c, y, h, A), o;
    }
}, nw, LW = {
    kernelName: zl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            x: r
        } = t, {
            numOrSizeSplits: s,
            axis: i
        } = n, l = k.parseAxisParam(i, r.shape)[0], o = C.prepareSplitSize(r, s, l), p = new Array(r.shape.length).fill(0), u = r.shape.slice();
        return o.map(c => {
            let d = [ ...u ];
            d[l] = c;
            let h = Mo({
                inputs: {
                    x: r
                },
                attrs: {
                    begin: p,
                    size: d
                },
                backend: a
            });
            return p[l] += c, h;
        });
    }
}, WW = tt(qi), BW = tt(od), VW = _t(Yi), aw, UW = {
    kernelName: vr,
    backendName: "wasm",
    setupFunc: function(e) {
        nw = e.wasm.cwrap(vr, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            alpha: r
        } = a, {
            x: s
        } = n, i = t.dataIdMap.get(s.dataId).id, l = t.makeOutput(s.shape, s.dtype), o = t.dataIdMap.get(l.dataId).id;
        return nw(i, r, it[s.dtype], o), l;
    }
}, GW = {
    kernelName: Ji,
    backendName: "wasm",
    setupFunc: function(e) {
        aw = e.wasm.cwrap(Ji, null, [ "number", "array", "number", "array", "array", "array", "array", "array", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let t, {
            backend: n,
            inputs: a,
            attrs: r
        } = e, {
            x: s
        } = a, {
            begin: i,
            end: l,
            strides: o,
            beginMask: p,
            endMask: u,
            ellipsisMask: c,
            newAxisMask: d,
            shrinkAxisMask: h
        } = r, {
            finalShapeSparse: f,
            finalShape: m,
            isIdentity: g,
            sliceDim0: y,
            isSimpleSlice: A,
            begin: x,
            end: b,
            strides: v
        } = St.sliceInfo(s.shape, i, l, o, p, u, c, d, h);
        if (g) t = In({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: m
            }
        }); else if (y || A) {
            k.assert(s.shape.length >= 1, () => `Input must have rank at least 1, got: ${s.shape.length}`);
            let I = St.computeOutShape(x, b, v), N = Mo({
                inputs: {
                    x: s
                },
                backend: n,
                attrs: {
                    begin: x,
                    size: I
                }
            });
            t = In({
                inputs: {
                    x: N
                },
                backend: n,
                attrs: {
                    shape: m
                }
            }), n.disposeData(N.dataId);
        } else {
            let I = n.makeOutput(f, "float32"), N = n.dataIdMap.get(s.dataId).id, T = new Uint8Array(new Int32Array(k.computeStrides(s.shape)).buffer), R = new Uint8Array(new Int32Array(x).buffer), w = new Uint8Array(new Int32Array(b).buffer), E = new Uint8Array(new Int32Array(v).buffer), $ = new Uint8Array(new Int32Array(f).buffer), M = new Uint8Array(new Int32Array(k.computeStrides(f)).buffer), F = n.dataIdMap.get(I.dataId).id;
            aw(N, T, s.shape.length, R, w, E, $, M, f.length, F), t = In({
                inputs: {
                    x: I
                },
                backend: n,
                attrs: {
                    shape: m
                }
            }), n.disposeData(I.dataId);
        }
        return t;
    }
}, HW = {
    kernelName: Vl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            data: r,
            dataSplits: s
        } = n, {
            separator: i,
            nGramWidths: l,
            leftPad: o,
            rightPad: p,
            padWidth: u,
            preserveShortSequences: c
        } = a, d = t.readSync(r.dataId), h = t.readSync(s.dataId), [ f, m ] = Wm(d, h, i, l, o, p, u, c), g = t.makeOutput([ f.length ], "string");
        t.dataIdMap.get(g.dataId).stringBytes = f;
        let y = t.makeOutput(s.shape, "int32");
        return t.typedArrayFromHeap(y).set(m), [ g, y ];
    }
}, jW = {
    kernelName: ud,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            input: r,
            delimiter: s
        } = n, {
            skipEmpty: i
        } = a, l = t.readSync(r.dataId), o = t.readSync(s.dataId), [ p, u, c ] = Bm(l, o[0], i), d = u.length, h = t.makeOutput([ d, 2 ], "int32");
        t.typedArrayFromHeap(h).set(p);
        let f = t.makeOutput([ d ], "string");
        t.dataIdMap.get(f.dataId).stringBytes = u;
        let m = t.makeOutput([ 2 ], "int32");
        return t.typedArrayFromHeap(m).set(c), [ h, f, m ];
    }
}, rw, qW = {
    kernelName: dd,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            input: r
        } = n, {
            numBuckets: s
        } = a, i = Vm(t.readSync(r.dataId), s), l = t.makeOutput(r.shape, "int32");
        return t.typedArrayFromHeap(l).set(i), l;
    }
}, XW = _t(Qi), sw, KW = {
    kernelName: Xi,
    backendName: "wasm",
    setupFunc: function(e) {
        rw = e.wasm.cwrap(Xi, null, [ "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            axis: r,
            keepDims: s
        } = a, {
            x: i
        } = n, l = t.dataIdMap.get(i.dataId).id, o = l, p = i, {
            transposed: u,
            axes: c,
            originalAxes: d,
            inputWasTransposed: h
        } = qr(i, r, t), f = c;
        if (h) {
            let x = t.dataIdMap.get(u.dataId).id;
            x !== l && (p = u, o = x, f = C.getInnerMostAxes(f.length, p.shape.length));
        }
        C.assertAxesAreInnerMostDims("sum", f, p.shape.length);
        let [ m, g ] = C.computeOutAndReduceShapes(p.shape, f), y = k.sizeFromShape(g), A = t.makeOutput(m, p.dtype);
        if (k.sizeFromShape(p.shape) !== 0) {
            let x = t.dataIdMap.get(A.dataId).id;
            rw(o, y, it[A.dtype], x);
        }
        if (h && t.disposeData(u.dataId), s) {
            let x = C.expandShapeToKeepDim(A.shape, d);
            A.shape = x;
        }
        return A;
    }
}, ZW = tt(eo), YW = tt(to), iw, JW = {
    kernelName: Li,
    backendName: "wasm",
    setupFunc: function(e) {
        sw = e.wasm.cwrap(Li, null, [ "number", "number", "number", "number", "number", "number", "array", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            backend: t,
            inputs: n,
            attrs: a
        } = e, {
            tensor: r,
            indices: s,
            updates: i
        } = n, l = t.makeOutput(r.shape, r.dtype);
        if (k.sizeFromShape(r.shape) === 0) return l;
        let {
            sliceRank: o,
            numUpdates: p,
            sliceSize: u,
            strides: c,
            outputSize: d
        } = pc.calculateShapes(i, s, r.shape), h = t.dataIdMap.get(s.dataId).id, f = t.dataIdMap.get(i.dataId).id, m = t.dataIdMap.get(r.dataId).id, g = new Uint8Array(new Int32Array(c).buffer), y = t.dataIdMap.get(l.dataId).id;
        return sw(h, f, it[i.dtype], o, p, u, g, d, y, m), l;
    }
}, ow, QW = {
    kernelName: br,
    backendName: "wasm",
    setupFunc: function(e) {
        iw = e.wasm.cwrap(br, null, [ "number", "array", "number", "array", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, s = n.dataIdMap.get(r.dataId).id, {
            reps: i
        } = a, l = new Array(r.shape.length);
        for (let d = 0; d < l.length; d++) l[d] = r.shape[d] * i[d];
        let o = new Uint8Array(new Int32Array(r.shape).buffer), p = new Uint8Array(new Int32Array(l).buffer), u = n.makeOutput(l, r.dtype), c = n.dataIdMap.get(u.dataId).id;
        return iw(s, o, r.shape.length, p, l.length, it[u.dtype], c), u;
    }
}, lw, eB = {
    kernelName: no,
    backendName: "wasm",
    setupFunc: function(e) {
        ow = e.wasm.cwrap(no, null, [ "number", "array", "number", "number", "number", "bool", "number", "number" ]);
    },
    kernelFunc: ({
        inputs: e,
        backend: t,
        attrs: n
    }) => {
        let {
            x: a
        } = e, {
            k: r,
            sorted: s
        } = n, i = t.dataIdMap.get(a.dataId).id, l = new Uint8Array(new Int32Array(a.shape).buffer), o = a.shape.slice();
        o[o.length - 1] = r;
        let p = t.makeOutput(o, a.dtype), u = t.dataIdMap.get(p.dataId).id, c = t.makeOutput(o, "int32"), d = t.dataIdMap.get(c.dataId).id;
        return ow(i, l, a.shape.length, it[a.dtype], r, s, u, d), [ p, c ];
    }
}, tB = {
    kernelName: ao,
    backendName: "wasm",
    setupFunc: function(e) {
        lw = e.wasm.cwrap(ao, null, [ "number", "number", "bool", "number", "number", "number", "number", "number", "number", "array", "number", "array", "number", "number", "number", "number", "number" ]);
    },
    kernelFunc: function(e) {
        let t, {
            backend: n,
            inputs: a,
            attrs: r
        } = e, {
            image: s,
            transforms: i
        } = a, {
            interpolation: l,
            fillMode: o,
            fillValue: p,
            outputShape: u
        } = r, [ c, d, h, f ] = s.shape, [ m, g ] = u ?? [ d, h ], y = [ c, m, g, f ], A = new Uint8Array(new Int32Array(k.computeStrides(s.shape)).buffer), x = new Uint8Array(new Int32Array(k.computeStrides(y)).buffer), b = n.makeOutput(y, s.dtype), v = n.dataIdMap.get(b.dataId).id, I = n.dataIdMap.get(s.dataId).id, N = n.dataIdMap.get(i.dataId).id, T = l === "nearest" ? 1 : 2;
        switch (o) {
          case "constant":
          default:
            t = 1;
            break;

          case "reflect":
            t = 2;
            break;

          case "wrap":
            t = 3;
            break;

          case "nearest":
            t = 4;
        }
        return lw(I, N, i.shape[0] > 1, c, m, g, f, h, d, A, s.shape.length - 1, x, y.length - 1, T, t, p, v), 
        b;
    }
}, nB = {
    kernelName: pd,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            axis: r
        } = n, {
            x: s
        } = t, {
            outputValues: i,
            outputShape: l,
            indices: o
        } = Gm(a.readSync(s.dataId), r, s.shape, s.dtype);
        return [ a.makeOutput(l, s.dtype, void 0, i), a.makeOutput([ o.length ], "int32", void 0, o) ];
    }
}, aB = {
    kernelName: Ul,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            value: r
        } = t, {
            axis: s
        } = a;
        s < 0 && (s += r.shape.length);
        let i = r.shape[s], l = r.shape.length, o = new Array(l - 1), p = 0;
        for (let h = 0; h < l; h++) h !== s && (o[p++] = r.shape[h]);
        let u = new Array(i), c = new Array(l).fill(0), d = r.shape.slice();
        d[s] = 1;
        for (let h = 0; h < u.length; h++) c[s] = h, u[h] = Mo({
            inputs: {
                x: r
            },
            attrs: {
                begin: c,
                size: d
            },
            backend: n
        });
        return u.map(({
            dataId: h,
            dtype: f
        }) => ({
            dataId: h,
            dtype: f,
            shape: o
        }));
    }
}, rB = {
    kernelName: Gl,
    backendName: "wasm",
    kernelFunc: function(e) {
        let {
            inputs: {
                x: t
            },
            backend: n
        } = e, a = n.makeOutput(t.shape, t.dtype);
        return n.typedArrayFromHeap(a).fill(0), a;
    }
}, sB = [ pz, cz, hz, fz, mz, gz, xz, bz, vz, wz, kz, Iz, Sz, Nz, Cz, Tz, $z, Rz, Ez, Fz, Oz, Pz, Dz, zz, Lz, Wz, Bz, Vz, Uz, Gz, Hz, jz, qz, Xz, Kz, Zz, Yz, Jz, Qz, eL, tL, nL, aL, rL, sL, iL, oL, lL, uL, dL, pL, cL, hL, fL, mL, gL, yL, AL, xL, bL, vL, wL, kL, yz, IL, SL, NL, CL, TL, RL, EL, ML, $L, FL, _L, OL, PL, DL, zL, LL, WL, BL, VL, UL, GL, HL, jL, qL, XL, KL, YL, JL, QL, eW, tW, nW, aW, rW, sW, iW, oW, zv, lW, uW, dW, pW, cW, hW, fW, mW, Mz, gW, yW, AW, xW, bW, vW, wW, kW, IW, SW, NW, CW, TW, RW, EW, $W, _z, ZL, MW, FW, _W, OW, PW, DW, zW, LW, WW, BW, VW, UW, GW, HW, jW, qW, XW, KW, ZW, YW, JW, QW, eB, tB, Az, nB, aB, rB ];

for (let e of sB) Aa(e);

var k1 = H();

k1.registerFlag("WASM_HAS_SIMD_SUPPORT", async () => {
    try {
        return WebAssembly.validate(new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11 ]));
    } catch {
        return !1;
    }
}), k1.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT", async () => {
    if (k1.get("IS_NODE")) return !1;
    try {
        return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), 
        WebAssembly.validate(new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11 ]));
    } catch {
        return !1;
    }
});

var uw = nl(U6()), iB = nl(G6()), dw = nl(H6()), pw = uw.default || uw, oB = dw.default || dw, cw = class extends al {
    constructor(e) {
        super(), this.wasm = e, this.dataIdNextNumber = 1, this.wasm.tfjs.initWithThreadsCount(fw), 
        N1 = this.wasm.tfjs.getThreadsCount(), this.dataIdMap = new Wu(this, Mt());
    }
    write(e, t, n) {
        let a = {
            id: this.dataIdNextNumber++
        };
        return this.move(a, e, t, n, 1), a;
    }
    numDataIds() {
        return this.dataIdMap.numDataIds();
    }
    async time(e) {
        let t = k.now();
        return e(), {
            kernelMs: k.now() - t
        };
    }
    move(e, t, n, a, r) {
        let s = this.dataIdNextNumber++;
        if (a === "string") {
            let p = t;
            return void this.dataIdMap.set(e, {
                id: s,
                stringBytes: p,
                shape: n,
                dtype: a,
                memoryOffset: null,
                refCount: r
            });
        }
        let i = k.sizeFromShape(n), l = i * k.bytesPerElement(a), o = this.wasm._malloc(l) >>> 0;
        this.dataIdMap.set(e, {
            id: s,
            memoryOffset: o,
            shape: n,
            dtype: a,
            refCount: r
        }), this.wasm.tfjs.registerTensor(s, i, o), t != null && this.wasm.HEAPU8.set(new Uint8Array(t.buffer, t.byteOffset, l), o);
    }
    async read(e) {
        return this.readSync(e);
    }
    readSync(e, t, n) {
        let {
            memoryOffset: a,
            dtype: r,
            shape: s,
            stringBytes: i
        } = this.dataIdMap.get(e);
        if (r === "string") return t != null && t !== 0 || !(n == null || n >= i.length) ? i.slice(t, n) : i;
        t = t || 0, n = n || k.sizeFromShape(s);
        let l = k.bytesPerElement(r);
        return function(o, p) {
            switch (p) {
              case "float32":
                return new Float32Array(o);

              case "int32":
                return new Int32Array(o);

              case "bool":
                return new Uint8Array(o);

              default:
                throw new Error(`Unknown dtype ${p}`);
            }
        }(this.wasm.HEAPU8.slice(a + t * l, a + n * l).buffer, r);
    }
    disposeData(e, t = !1) {
        if (this.dataIdMap.has(e)) {
            let n = this.dataIdMap.get(e);
            if (n.refCount--, !t && n.refCount > 0) return !1;
            this.wasm._free(n.memoryOffset), this.wasm.tfjs.disposeData(n.id), this.dataIdMap.delete(e);
        }
        return !0;
    }
    refCount(e) {
        return this.dataIdMap.has(e) ? this.dataIdMap.get(e).refCount : 0;
    }
    incRef(e) {
        let t = this.dataIdMap.get(e);
        t != null && t.refCount++;
    }
    floatPrecision() {
        return 32;
    }
    getMemoryOffset(e) {
        return this.dataIdMap.get(e).memoryOffset;
    }
    dispose() {
        this.wasm.tfjs.dispose(), "PThread" in this.wasm && this.wasm.PThread.terminateAllThreads(), 
        this.wasm = null;
    }
    memory() {
        return {
            unreliable: !1
        };
    }
    makeOutput(e, t, n, a) {
        let r;
        if (n == null) r = this.write(a ?? null, e, t); else {
            let s = this.dataIdNextNumber++;
            r = {
                id: s
            }, this.dataIdMap.set(r, {
                id: s,
                memoryOffset: n,
                shape: e,
                dtype: t,
                refCount: 1
            });
            let i = k.sizeFromShape(e);
            this.wasm.tfjs.registerTensor(s, i, n);
        }
        return {
            dataId: r,
            shape: e,
            dtype: t
        };
    }
    typedArrayFromHeap({
        shape: e,
        dtype: t,
        dataId: n
    }) {
        let a = this.wasm.HEAPU8.buffer, {
            memoryOffset: r
        } = this.dataIdMap.get(n), s = k.sizeFromShape(e);
        switch (t) {
          case "float32":
            return new Float32Array(a, r, s);

          case "int32":
            return new Int32Array(a, r, s);

          case "bool":
            return new Uint8Array(a, r, s);

          default:
            throw new Error(`Unknown dtype ${t}`);
        }
    }
};

function hw(e, t, n) {
    if (Kc != null) return Kc;
    let a = "tfjs-backend-wasm.wasm";
    return e && t ? a = "tfjs-backend-wasm-threaded-simd.wasm" : e && (a = "tfjs-backend-wasm-simd.wasm"), 
    lp != null && lp[a] != null ? lp[a] : n + a;
}

async function lB() {
    let [ e, t ] = await Promise.all([ H().getAsync("WASM_HAS_SIMD_SUPPORT"), H().getAsync("WASM_HAS_MULTITHREAD_SUPPORT") ]);
    return new Promise((n, a) => {
        let r = {
            locateFile: (l, o) => {
                if (l.endsWith(".worker.js")) {
                    let p = iB.wasmWorkerContents.replace(/\n/g, "\\n"), u = new Blob([ p ], {
                        type: "application/javascript"
                    });
                    return URL.createObjectURL(u);
                }
                return l.endsWith(".wasm") ? hw(e, t, op ?? o) : o + l;
            }
        };
        I1 && (r.instantiateWasm = function(l) {
            return (o, p) => (k.fetch(l, {
                credentials: "same-origin"
            }).then(u => {
                u.ok || o.env.a(`failed to load wasm binary file at '${l}'`), u.arrayBuffer().then(c => {
                    WebAssembly.instantiate(c, o).then(d => {
                        p(d.instance, d.module);
                    });
                });
            }), {});
        }(hw(e, t, op ?? "")));
        let s, i = !1;
        r.onAbort = () => {
            i || up || (up = !0, a({
                message: "Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"
            }));
        }, t && e && Kc == null ? (r.mainScriptUrlOrBlob = new Blob([ "var WasmBackendModuleThreadedSimd = " + pw.toString() ], {
            type: "text/javascript"
        }), s = pw(r)) : s = oB(r), s.then(l => {
            i = !0, up = !1, l.tfjs = {
                init: l.cwrap("init", null, []),
                initWithThreadsCount: l.cwrap("init_with_threads_count", null, [ "number" ]),
                getThreadsCount: l.cwrap("get_threads_count", "number", []),
                registerTensor: l.cwrap("register_tensor", null, [ "number", "number", "number" ]),
                disposeData: l.cwrap("dispose_data", null, [ "number" ]),
                dispose: l.cwrap("dispose", null, [])
            }, n({
                wasm: l
            });
        }).catch(a);
    });
}

var uB = [ "tfjs-backend-wasm.wasm", "tfjs-backend-wasm-simd.wasm", "tfjs-backend-wasm-threaded-simd.wasm" ], Kc = null, op = null, lp = {}, up = !1, I1 = !1;

function dB(e, t = !1) {
    if (_0(), up) throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");
    Kc = e, I1 = t;
}

function S1(e, t = !1) {
    if (up) throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");
    if (typeof e == "string") op = e; else {
        lp = e;
        let n = uB.filter(a => lp[a] == null);
        if (n.length > 0) throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`);
    }
    I1 = t;
}

var fw = -1, N1 = -1;

function pB(e) {
    fw = e;
}

function cB() {
    if (N1 === -1) throw new Error("WASM backend not initialized.");
    return N1;
}

var hB = "4.17.0";

ql("wasm", async () => {
    let {
        wasm: e
    } = await lB();
    return new cw(e);
}, 2);

var ta = H();

ta.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE", () => 15), ta.registerFlag("WEBGPU_CPU_FORWARD", () => !0), 
ta.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE", () => -1), ta.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE", () => !0), 
ta.registerFlag("WEBGPU_USE_LOW_POWER_GPU", () => !1), ta.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e3), 
ta.registerFlag("WEBGPU_USE_PROFILE_TOOL", () => !1), ta.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE", () => !0), 
ta.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG", () => !1), ta.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL", () => -1), 
ta.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER", () => !1), ta.registerFlag("WEBGPU_PRINT_SHADER", () => ""), 
ta.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY", () => !1);

var fB = class {
    constructor(e) {
        e && (this.vendor = e.vendor, this.architecture = e.architecture, this.intelGPUGeneration = this.getIntelGPUGeneration());
    }
    getIntelGPUGeneration() {
        if (this.isIntel()) {
            if (this.architecture.startsWith("gen")) return Number(this.architecture.match(/\d+/));
            if (this.architecture.startsWith("xe")) return 12;
        }
        return 0;
    }
    isIntel() {
        return this.vendor === "intel";
    }
}, mB = class {
    constructor(e) {
        this.device = e, this.numUsedBuffers = 0, this.numFreeBuffers = 0, this.freeBuffers = new Map(), 
        this.usedBuffers = new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireBuffer(e, t, n = !1, a = !0) {
        let r, s = mw(e, t);
        return a ? (this.freeBuffers.has(s) || this.freeBuffers.set(s, []), this.freeBuffers.get(s).length > 0 ? (r = this.freeBuffers.get(s).pop(), 
        this.numFreeBuffers--) : (r = this.device.createBuffer({
            size: e,
            usage: t,
            mappedAtCreation: n
        }), this.numBytesAllocated += e)) : (r = this.device.createBuffer({
            size: e,
            usage: t,
            mappedAtCreation: n
        }), this.numBytesAllocated += e), this.usedBuffers.has(s) || this.usedBuffers.set(s, []), 
        this.usedBuffers.get(s).push(r), this.numUsedBuffers++, this.numBytesUsed += e, 
        r;
    }
    releaseBuffer(e, t = !0) {
        if (this.freeBuffers.size === 0) return;
        let n = e.size, a = mw(n, e.usage), r = this.usedBuffers.get(a), s = r.indexOf(e);
        if (s < 0) throw new Error("Cannot find the buffer in buffer manager");
        r[s] = r[r.length - 1], r.pop(), this.numUsedBuffers--, this.numBytesUsed -= n, 
        t ? (this.freeBuffers.get(a).push(e), this.numFreeBuffers++) : (e.destroy(), 
        this.numBytesAllocated -= n);
    }
    getNumUsedBuffers() {
        return this.numUsedBuffers;
    }
    getNumFreeBuffers() {
        return this.numFreeBuffers;
    }
    dispose() {
        this.freeBuffers.forEach((e, t) => {
            e.forEach(n => {
                n.destroy();
            });
        }), this.usedBuffers.forEach((e, t) => {
            e.forEach(n => {
                n.destroy();
            });
        }), this.freeBuffers = new Map(), this.usedBuffers = new Map(), this.numUsedBuffers = 0, 
        this.numFreeBuffers = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
};

function mw(e, t) {
    return `${e}_${t}`;
}

var gB = class {
    constructor(e) {
        this.device = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = new Map(), 
        this.usedTextures = new Map(), this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
    acquireTexture(e, t, n, a) {
        let r = e * t * yw(n), s = gw(e, t, n, a);
        if (this.freeTextures.has(s) || this.freeTextures.set(s, []), this.usedTextures.has(s) || this.usedTextures.set(s, []), 
        this.numBytesUsed += r, this.numUsedTextures++, this.freeTextures.get(s).length > 0) {
            this.numFreeTextures--;
            let l = this.freeTextures.get(s).shift();
            return this.usedTextures.get(s).push(l), l;
        }
        this.numBytesAllocated += r;
        let i = this.device.createTexture({
            size: [ e, t ],
            format: n,
            usage: a
        });
        return this.usedTextures.get(s).push(i), i;
    }
    releaseTexture(e) {
        if (this.freeTextures.size === 0) return;
        let t = e.width, n = e.height, a = e.format, r = gw(t, n, a, e.usage);
        this.freeTextures.has(r) || this.freeTextures.set(r, []), this.freeTextures.get(r).push(e), 
        this.numFreeTextures++, this.numUsedTextures--;
        let s = this.usedTextures.get(r), i = s.indexOf(e);
        if (i < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
        s.splice(i, 1);
        let l = t * n * yw(a);
        this.numBytesUsed -= l;
    }
    getNumUsedTextures() {
        return this.numUsedTextures;
    }
    getNumFreeTextures() {
        return this.numFreeTextures;
    }
    dispose() {
        this.freeTextures.forEach((e, t) => {
            e.forEach(n => {
                n.destroy();
            });
        }), this.usedTextures.forEach((e, t) => {
            e.forEach(n => {
                n.destroy();
            });
        }), this.freeTextures = new Map(), this.usedTextures = new Map(), this.numUsedTextures = 0, 
        this.numFreeTextures = 0, this.numBytesUsed = 0, this.numBytesAllocated = 0;
    }
};

function gw(e, t, n, a) {
    return `${e}_${t}_${n}_${a}`;
}

function yw(e) {
    if (e === "rgba8unorm") return 16;
    throw new Error(`${e} is not supported!`);
}

function yB(e, t) {
    if (Math.max(...e) > 5) throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");
    let n = e.length, a = e.map(s => `${t}.${"xyzwuv"[s]}`), r = new Array(n - 1);
    r[n - 2] = a[n - 1];
    for (let s = n - 3; s >= 0; --s) r[s] = `(${r[s + 1]} * ${a[s + 1]})`;
    return r;
}

var xu, Kr = (e, t, n) => n === "int32" ? `atomicAdd(${e}, bitcast<i32>(${t}));` : `
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;

(function(e) {
    e[e.FROM_PIXELS = 0] = "FROM_PIXELS", e[e.DRAW = 1] = "DRAW";
})(xu || (xu = {}));

var AB = (e, t, n, a, r) => {
    let s = function(o, p, u) {
        let c = [], d = u.workgroupSize[0] * u.workgroupSize[1] * u.workgroupSize[2];
        if (u.outputComponent = u.outputComponent ? u.outputComponent : 1, c.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${bw(u) ? "  return i32(globalId.x);" : `  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${d}u +
                localIndex);
        `}
      }
    `), u.pixelsOpType != null) {
            let v = u.pixelsOpType === xu.FROM_PIXELS ? `@group(0) @binding(0) var<storage, read_write> result: array<${Fo(p.dtype, u.outputComponent)}>;` : `@group(0) @binding(1) var<storage, read> inBuf : array<${Fo(o[0].dtype, u.outputComponent)}>;`, I = p.shape.length === 3 ? "vec2<i32>" : "i32";
            c.push(`
        struct Uniform {
          outShapeStrides : ${I},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${v}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);
            let N = vw(u);
            return [ xw, c.join(`
`), Zc(p.shape), u.getUserCode(), Aw(N, u) ].join(`
`);
        }
        let h, f, m = "struct Uniforms { NAN : f32, INFINITY : f32, ";
        u.variableNames.forEach((v, I) => {
            let N = Tt(o[I].shape.length);
            m += `${v.charAt(0).toLowerCase() + v.slice(1)}Shape : ${N}, `, h = o[I].shape.length - 1, 
            f = Tt(h), m += `${v.charAt(0).toLowerCase() + v.slice(1)}ShapeStrides: ${f}, `;
        });
        let g = Tt(p.shape.length);
        m += `outShape : ${g}, `, h = p.shape.length - 1, f = Tt(h), m += `
         outShapeStrides: ${f}, `, u.size && (m += "size : i32, "), u.uniforms && (m += u.uniforms), 
        m += "};", m = function(v) {
            let I = /(\w+)\s*:\s*vec(5|6)/g;
            v = v.replace(I, T => "@align(16) " + T);
            let N = /vec(5|6)\s*,\s*(\w+)/g;
            return v = v.replace(N, (T, R, w) => `vec${R}, @align(16) ${w}`), v;
        }(m), c.push(m), u.atomic ? c.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `) : c.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Fo(p.dtype, u.outputComponent)}>;
    `), u.variableNames.forEach((v, I) => {
            c.push(`
      @group(0) @binding(${1 + I}) var<storage, read> ${v}: array<${u.variableComponents ? Fo(o[I].dtype, u.variableComponents[I]) : Fo(o[I].dtype, u.outputComponent)}>;
        `);
        }), m !== "" && c.push(`
      @group(0) @binding(${1 + u.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);
        let y = function(v, I) {
            let {
                x: N,
                y: T = [],
                z: R = []
            } = I, w = v.length, E = N.length + T.length + R.length;
            if (E !== w) return "";
            if (N.length === w) return `fn getOutputCoords() -> ${Tt(w)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;
            let $ = "", M = [ N, T, R ];
            for (let O = 0; O < M.length; O++) {
                let B = M[O];
                if (B.length !== 0) if (B.length === 1) $ += `let d${B[0]} = i32(globalId[${O}]);`; else {
                    let G = yB(B, "uniforms.outShape");
                    $ += `var index${O} = i32(globalId[${O}]);`;
                    for (let W = 0; W < G.length; W++) $ += `let d${B[W]} = index${O} / ${G[W]};`, 
                    W === G.length - 1 ? $ += `let d${B[W + 1]} = index${O} - d${B[W]} * ${G[W]};` : $ += `index${O} = index${O} - d${B[W]} * ${G[W]};`;
                }
            }
            let F = [];
            for (let O = 0; O < E; O++) F.push(`d${O}`);
            let P = Tt(E), L = `fn getOutputCoords() -> ${P} {
  ${$}
`;
            return F.length === 0 ? L += `return ${P}(0); }` : L += `return ${P}(${F.join(",")}); }`, 
            L;
        }(p.shape, u.dispatchLayout), A = [ xw, c.join(`
`) + xB, Zc(p.shape), y, bB(p.shape.length) ];
        u.atomic || A.push(function(v, I, N) {
            let T = v.length, R = Fo(I, N), w = `fn setOutputAtIndex(flatIndex : i32, value : ${Je(N)}) {
      result[flatIndex] = ${R}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${Je(N, "i32")}) {
      result[flatIndex] = ${R}(value);
    }
    `;
            if (T >= 2) {
                let E = [ "d0", "d1", "d2", "d3", "d4", "d5" ].slice(0, T), $ = Tt(T);
                w += `
      fn setOutputAtCoords(${E.map(M => `${M} : i32`).join(", ")}, value : ${Je(N)}) {
        let flatIndex = getOutputIndexFromCoords(${$}(${E.join(", ")}));
        setOutputAtIndex(flatIndex${N === 1 ? "" : ` / ${N}`}, value);
      }
      fn setOutputAtCoordsI32(${E.map(M => `${M} : i32`).join(", ")}, value : ${Je(N, "i32")}) {
        let flatIndex = getOutputIndexFromCoords(${$}(${E.join(", ")}));
        setOutputAtIndexI32(flatIndex${N === 1 ? "" : ` / ${N}`}, value);
      }
    `;
            }
            return w;
        }(p.shape, p.dtype, u.outputComponent)), u.variableNames.forEach((v, I) => {
            A.push(`${Zc(o[I].shape, v)}`);
        });
        let x = o.map((v, I) => function(N, T, R, w) {
            let E = function($, M) {
                let F = $.name, P = $.shape.length, L = Tt(P), O = "get" + F.charAt(0).toUpperCase() + F.slice(1), B = [ "d0", "d1", "d2", "d3", "d4", "d5" ].slice(0, P), G = B.map(X => `${X} : i32`).join(", ");
                if (P < 1) return `
      fn ${O}() -> ${Je(M)} {
        return ${Je(M)}(${F}[0]);
      }
    `;
                let W = `uniforms.${F.charAt(0).toLowerCase() + F.slice(1)}Shape`, z = `${P}D`;
                return P === 0 && (z = "1D"), `
    fn ${O}(${G}) -> ${Je(M)} {
      return ${Je(M)}(${F}[getIndexFromCoords${z}(${L}(${B.join(",")}),
        ${W})${M === 1 ? "" : ` / ${M}`}]);
    }
   `;
            }(N, R);
            return N.shape.length <= T.length && (E += function($, M, F, P) {
                let L = $.name, O = L.charAt(0).toUpperCase() + L.slice(1), B = "get" + O + "ByOutput", G = $.shape.length, W = M.length, z = Tt(W);
                if (k.arraysEqual($.shape, M) && P) return `
    fn ${B}Index(globalIndex : i32) -> ${Je(F)} {
      return ${Je(F)}(${L}[globalIndex]);
    }

    fn ${B}Coords(coords : ${z}) -> ${Je(F)} {
      return ${Je(F)}(${L}[${W > 1 ? "getOutputIndexFromCoords(coords)" : "coords"}${F === 1 ? "" : ` / ${F}`}]);
    }
    `;
                let X = C.getBroadcastDims($.shape, M), q = W - G, Z = "";
                if (G === 0) return `
    fn ${B}Index(globalIndex : i32) -> ${Je(F)}{
      return get${O}();
    }

    fn ${B}Coords(coords : ${z}) -> ${Je(F)}{
      return get${O}();
    }
  `;
                Z = W < 2 && X.length >= 1 ? "coords = 0;" : X.map(pe => `coords.${sr(pe + q)} = 0;`).join(`
`);
                let Y = "";
                W < 2 && G > 0 ? Y = "coords" : W > 1 ? Y = `${Tt(G)}(${$.shape.map((pe, ge) => `coords.${sr(ge + q)}`).join(", ")})` : Y = "coords";
                let te = `uniforms.${L.charAt(0).toLowerCase() + L.slice(1)}Shape`, re = `${G}D`;
                return `
  fn ${B}Index(globalIndex : i32) -> ${Je(F)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${Z}
    return ${Je(F)}(${L}[getIndexFromCoords${re}(${Y}, ${te})${F === 1 ? "" : ` / ${F}`}]);
  }

  fn ${B}Coords(coordsIn : ${z}) -> ${Je(F)} {
    var coords = coordsIn;
    ${Z}
    return ${Je(F)}(${L}[getIndexFromCoords${re}(${Y}, ${te})${F === 1 ? "" : ` / ${F}`}]);
  }
`;
            }(N, T, R, w)), E;
        }(v, p.shape, u.variableComponents ? u.variableComponents[I] : u.outputComponent, u.dispatchLayout.x.length === p.shape.length)).join(`
`);
        A.push(x), A.push(u.getUserCode());
        let b = vw(u);
        return A.push(Aw(b, u)), A.join(`
`);
    }(n, {
        dtype: a.dtype,
        shape: a.shape
    }, t), i = e.createShaderModule({
        code: s,
        label: t.constructor.name
    }), l = H().get("WEBGPU_PRINT_SHADER");
    if (l !== "") {
        l = l.toLowerCase();
        let o = l.split(",");
        l === "all" || o.some(p => t.shaderKey.toLowerCase().includes(p));
    }
    return r ? e.createComputePipelineAsync({
        compute: {
            module: i,
            entryPoint: "_start"
        },
        label: t.constructor.name,
        layout: "auto"
    }) : e.createComputePipeline({
        compute: {
            module: i,
            entryPoint: "_start"
        },
        label: t.constructor.name,
        layout: "auto"
    });
}, Je = (e, t = "f32") => {
    switch (e) {
      case 1:
        return `${t}`;

      case 2:
        return `vec2<${t}>`;

      case 3:
        return `vec3<${t}>`;

      case 4:
        return `vec4<${t}>`;

      default:
        throw new Error(`${e}-component ${t} is not supported.`);
    }
};

function Tt(e) {
    if (e <= 1) return "i32";
    if (e === 2) return "vec2<i32>";
    if (e === 3) return "vec3<i32>";
    if (e === 4) return "vec4<i32>";
    if (e === 5) return "vec5";
    if (e === 6) return "vec6";
    throw Error(`GPU for rank ${e} is not yet supported`);
}

function sr(e) {
    if (e === 0) return "x";
    if (e === 1) return "y";
    if (e === 2) return "z";
    if (e === 3) return "w";
    if (e === 4) return "u";
    if (e === 5) return "v";
    throw Error(`Index ${e} is not yet supported`);
}

function le(...e) {
    let t;
    switch (e.length) {
      case 0:
        t = `
        fn main()
      `;
        break;

      case 1:
        t = `
        fn main(${e[0]} : i32)
      `;
        break;

      default:
        throw Error("Unreachable");
    }
    return t;
}

function Aw(e, t) {
    let n;
    return n = `
     ${function(a) {
        return `
  @compute @workgroup_size(${a.workgroupSize[0]}, ${a.workgroupSize[1]}, ${a.workgroupSize[2]})
`;
    }(t)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${e ? "main(getGlobalIndex());" : "main();"};
      }
    `, n;
}

var xw = `
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`, xB = `
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;

function Zc(e, t = "") {
    let n = e.length, a = t !== "" ? `get${t.charAt(0).toUpperCase() + t.slice(1)}CoordsFromIndex` : "getCoordsFromIndex", r = t !== "" ? `${t.charAt(0).toLowerCase() + t.slice(1)}ShapeStrides` : "outShapeStrides";
    if (n <= 1) return `fn ${a}(index : i32) -> i32 { return index; }`;
    let s, i = k.computeStrides(e), l = Tt(n), o = [];
    for (let p = 0; p < n; p++) o.push(`d${p}`);
    return i.length === 1 ? `    fn ${a}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }` : (s = "var index2 = index;" + i.map((p, u) => `${`let ${o[u]} = index2 / uniforms.${r}.${sr(u)}`}; ${u === i.length - 1 ? `let ${o[u + 1]} = index2 - ${o[u]} * uniforms.${r}.${sr(u)}` : `index2 = index2 - ${o[u]} * uniforms.${r}.${sr(u)}`};`).join(""), 
    `
    fn ${a}(index : i32) -> ${l} {
      ${s}
      return ${l}(${o.join(",")});
    }
  `);
}

function bB(e) {
    let t = "";
    switch (e) {
      case 0:
      case 1:
        t += `
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;
        break;

      case 2:
        t += `
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;
        break;

      case 3:
        t += `
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;
        break;

      case 4:
        t += `
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;
        break;

      case 5:
        t += `
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;
        break;

      case 6:
        t += `
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;
        break;

      default:
        k.assert(!1, () => `Unsupported ${e}D shape`);
    }
    return t;
}

function bw(e) {
    return e.dispatch[1] === 1 && e.dispatch[2] === 1;
}

function Fo(e, t = 1) {
    if (e === "float32") return Je(t, "f32");
    if (e === "int32" || e === "bool") return Je(t, "i32");
    throw new Error(`type ${e} is not supported.`);
}

function vw(e) {
    return !(e.dispatchLayout.hasOwnProperty("y") && e.dispatchLayout.y.length !== 0 || e.dispatchLayout.hasOwnProperty("z") && e.dispatchLayout.z.length !== 0);
}

var ww = {};

Ze(ww, {
    GPUBytesPerElement: () => R1,
    MatMulProgramType: () => Na,
    assertNotComplex: () => $1,
    computeDispatch: () => de,
    computeWorkPerThreadForConv2d: () => T1,
    computeWorkgroupInfoForMatMul: () => kw,
    computeWorkgroupSizeForConv2d: () => C1,
    flatDispatchLayout: () => xe,
    isWebGPUSupported: () => E1,
    tilesFitEvenlyIntoShape: () => vB
});

var Na, _o = e => {
    let t = 1;
    for (let n = 0; n < e.length; n++) t *= e[n];
    return t;
};

function vB(e, t) {
    if (e.length !== t.length) throw new Error(`Cannot compute whether rank ${e.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);
    return t.every((n, a) => n % e[a] == 0);
}

function de(e, t, n = [ 1, 1, 1 ], a = [ 1, 1, 1 ]) {
    let [ r, s, i ] = [ Math.ceil(_o(e.x.map(l => t[l])) / (n[0] * a[0])), e.y ? Math.ceil(_o(e.y.map(l => t[l])) / (n[1] * a[1])) : 1, e.z ? Math.ceil(_o(e.z.map(l => t[l])) / (n[2] * a[2])) : 1 ];
    return [ r, s, i ];
}

function kw(e, t, n, a = !1) {
    let r = [ 8, 8, 1 ], s = [ 4, 4, 1 ];
    return a || (e <= 8 && (s[1] = 1), t <= 16 && n <= 16 && (r[0] = 4)), {
        workgroupSize: r,
        elementsPerThread: s
    };
}

function C1(e, t, n = !1) {
    if (n) return [ 8, 8, 1 ];
    let a = _o(e.x.map(s => t[s])), r = _o(e.y.map(s => t[s]));
    return a <= 4 ? [ 4, 16, 1 ] : r <= 4 ? [ 16, 4, 1 ] : [ 16, 16, 1 ];
}

function T1(e, t, n = !1) {
    if (n) return [ 4, 4, 1 ];
    let a = _o(e.x.map(s => t[s])), r = _o(e.y.map(s => t[s]));
    return a <= 4 ? [ 1, 2, 1 ] : r <= 4 ? [ 2, 1, 1 ] : [ 2, 2, 1 ];
}

function xe(e) {
    return {
        x: e.map((t, n) => n)
    };
}

function R1(e) {
    if (e === "float32" || e === "int32" || e === "bool" || e === "string") return 4;
    if (e === "complex64") return 8;
    throw new Error(`Unknown dtype ${e}`);
}

function E1() {
    return !(typeof globalThis > "u" || !globalThis.navigator || !globalThis.navigator.gpu);
}

function $1(e, t) {
    Array.isArray(e) || (e = [ e ]), e.forEach(n => {
        n != null && k.assert(n.dtype !== "complex64", () => `${t} does not support complex64 tensors in the WebGPU backend.`);
    });
}

(function(e) {
    e[e.MatMulReduceProgram = 0] = "MatMulReduceProgram", e[e.MatMulSplitKProgram = 1] = "MatMulSplitKProgram", 
    e[e.MatMulSmallOutputSizeProgram = 2] = "MatMulSmallOutputSizeProgram", e[e.MatMulPackedProgram = 3] = "MatMulPackedProgram", 
    e[e.MatMulMax = 4] = "MatMulMax";
})(Na || (Na = {}));

var Le, wB = H().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"), M1 = class A6 extends al {
    nextDataId() {
        return A6.nextDataId++;
    }
    constructor(t, n) {
        if (super(), this.commandQueueOwnedIds = new WeakSet(), this.dispatchCountInPass = 0, 
        this.disposed = !1, this.downloadWaitMs = 0, this.tensorDataPendingDisposal = [], 
        this.queryResolveBuffer = null, this.querySet = null, this.querySetCount = 2, 
        this.stagingPendingDisposal = [], this.uniformPendingDisposal = [], this.uploadWaitMs = 0, 
        this.hasReadSyncWarned = !1, this.hasTimestampQueryWarned = !1, !E1()) throw new Error("WebGPU is not supported on this device");
        this.pipelineCache = {}, this.device = t, this.queue = t.queue, this.commandEncoder = null, 
        this.computePassEncoder = null, this.adapterInfo = new fB(n), this.supportTimestampQuery = this.device.features.has("timestamp-query"), 
        this.thresholdToIncreaseWorkgroups = this.adapterInfo.intelGPUGeneration >= 12 ? 16 : 8, 
        this.bufferManager = new mB(this.device), this.textureManager = new gB(this.device), 
        this.tensorMap = new Wu(this, Mt()), H().getBool("WEBGPU_USE_PROFILE_TOOL") && (this.dummyCanvas = document.createElement("canvas"), 
        this.dummyCanvas.width = 1, this.dummyCanvas.height = 1, this.dummyContext = this.dummyCanvas.getContext("webgpu"), 
        this.dummyContext.configure({
            device: t,
            format: "bgra8unorm"
        }), document.body.appendChild(this.dummyCanvas));
    }
    floatPrecision() {
        return 32;
    }
    disposeData(t, n = !1) {
        if (!this.tensorMap.has(t)) return !0;
        let a = this.tensorMap.get(t);
        return n ? a.refCount = 0 : a.refCount--, !(a.refCount > 0) && (a.complexTensorInfos != null && (this.disposeData(a.complexTensorInfos.real.dataId), 
        this.disposeData(a.complexTensorInfos.imag.dataId)), this.commandQueueOwnedIds.has(t) ? (this.tensorDataPendingDisposal.push(t), 
        !0) : (this.releaseResource(t), this.tensorMap.delete(t), !0));
    }
    memory() {
        return {
            numBytesInGPU: this.bufferManager.numBytesUsed,
            numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,
            unreliable: !1
        };
    }
    releaseResource(t) {
        let n = this.tensorMap.get(t);
        if (n && n.resource) {
            if (n.external) return void (n.resource = null);
            n.resource instanceof GPUBuffer ? this.bufferManager.releaseBuffer(n.resource) : n.resource instanceof GPUTexture && this.textureManager.releaseTexture(n.resource), 
            n.resource = null;
        }
    }
    refCount(t) {
        return this.tensorMap.has(t) ? this.tensorMap.get(t).refCount : 0;
    }
    incRef(t) {
        this.tensorMap.get(t).refCount++;
    }
    decRef(t) {
        this.tensorMap.has(t) && this.tensorMap.get(t).refCount--;
    }
    write(t, n, a) {
        if (a === "complex64" && t != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        let r = {
            id: this.nextDataId()
        };
        return this.tensorMap.set(r, {
            dtype: a,
            shape: n,
            values: t,
            refCount: 1
        }), r;
    }
    move(t, n, a, r, s) {
        if (r === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
        this.tensorMap.set(t, {
            dtype: r,
            shape: a,
            values: n,
            refCount: s
        });
    }
    submitQueue() {
        this.queue.submit([ this.commandEncoder.finish() ]), this.commandEncoder = null, 
        this.dispatchCountInPass = 0, this.commandQueueOwnedIds = new WeakSet(), 
        this.tensorDataPendingDisposal.forEach(t => {
            this.releaseResource(t), this.tensorMap.delete(t);
        }), this.uniformPendingDisposal.forEach(t => this.bufferManager.releaseBuffer(t)), 
        this.stagingPendingDisposal.forEach(t => this.bufferManager.releaseBuffer(t, !1)), 
        this.tensorDataPendingDisposal = [], this.uniformPendingDisposal = [], this.stagingPendingDisposal = [];
    }
    ensureCommandEncoderReady() {
        this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder());
    }
    endComputePassEncoder() {
        this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);
    }
    async checkCompileCompletionAsync() {
        let t;
        try {
            t = await Promise.all(Object.values(this.pipelineCache));
        } catch (n) {
            throw new Error(n.message);
        }
        Object.keys(this.pipelineCache).map((n, a) => {
            this.pipelineCache[n] = t[a];
        });
    }
    async getBufferData(t) {
        if (H().getBool("WEBGPU_ENGINE_COMPILE_ONLY")) return null;
        let n = t.size, a = this.bufferManager.acquireBuffer(n, GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
        this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(t, 0, a, 0, n), 
        this.submitQueue(), await a.mapAsync(GPUMapMode.READ);
        let r = a.getMappedRange().slice(0);
        return a.unmap(), a != null && this.bufferManager.releaseBuffer(a), H().getBool("WEBGPU_USE_PROFILE_TOOL") && (k.assert(this.dummyContext !== void 0, () => "Fail to get context for profiling tool"), 
        this.dummyContext.getCurrentTexture()), r;
    }
    convertAndCacheOnCPU(t, n) {
        let a = this.tensorMap.get(t);
        return a.values = n, a.values;
    }
    readSync(t) {
        let n = this.tensorMap.get(t), {
            values: a,
            complexTensorInfos: r
        } = n;
        if (a != null || n.dtype === "string") return a;
        if (n.dtype === "complex64") {
            let m = this.readSync(r.real.dataId), g = this.readSync(r.imag.dataId), y = k.convertBackendValuesAndArrayBuffer(C.mergeRealAndImagArrays(m, g).buffer, "float32");
            return this.convertAndCacheOnCPU(t, y), y;
        }
        this.hasReadSyncWarned || (this.hasReadSyncWarned = !0);
        let s = [ "opaque", "premultiplied" ], i = n.resource, l = i.size;
        k.assert(l % 4 == 0, () => "Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");
        let o = l / 4, p = new ArrayBuffer(l), u = 256, c = 256, d = s.map(m => new OffscreenCanvas(u, c)), h = new OffscreenCanvas(u, c);
        this.endComputePassEncoder(), d.map((m, g) => {
            let y = m.getContext("webgpu");
            return y.configure({
                device: this.device,
                format: "bgra8unorm",
                usage: GPUTextureUsage.COPY_DST,
                alphaMode: s[g]
            }), y.getCurrentTexture();
        }).map((m, g) => {
            let y = (N, T, R) => {
                this.ensureCommandEncoderReady(), this.commandEncoder.copyBufferToTexture({
                    buffer: i,
                    bytesPerRow: 1024,
                    offset: R
                }, {
                    texture: m
                }, {
                    width: N,
                    height: T
                }), this.submitQueue();
                let w = h.getContext("2d", {
                    willReadFrequently: !0
                });
                w.clearRect(0, 0, N, T), w.drawImage(d[g], 0, 0);
                let E = w.getImageData(0, 0, N, T).data, $ = s[g], M = new Uint8ClampedArray(p, R, N * T * 4);
                for (let F = 0; F < M.length; F += 4) if ($ === "premultiplied") M[F + 3] = E[F + 3]; else {
                    let P = E[F];
                    M[F] = E[F + 2], M[F + 1] = E[F + 1], M[F + 2] = P;
                }
            }, A = Math.floor(o / (u * c)), x = u, b = c, v = 0;
            for (let N = 0; N < A; N++) y(x, b, v), v += u * c * 4;
            let I = o % (u * c);
            b = Math.floor(I / u), b > 0 && (y(x, b, v), v += b * (4 * u)), x = I % u, 
            x > 0 && y(x, 1, v);
        });
        let f = k.convertBackendValuesAndArrayBuffer(p, n.dtype);
        return this.convertAndCacheOnCPU(t, f), f;
    }
    async read(t) {
        if (!this.tensorMap.has(t)) throw new Error(`Tensor ${t} was not registered!`);
        let n, a = this.tensorMap.get(t), {
            values: r
        } = a;
        if (r != null) return r;
        if (a.dtype === "complex64") {
            let s = await Promise.all([ this.read(a.complexTensorInfos.real.dataId), this.read(a.complexTensorInfos.imag.dataId) ]), i = s[0], l = s[1];
            n = C.mergeRealAndImagArrays(i, l);
        } else {
            let s = await this.getBufferData(a.resource);
            n = k.convertBackendValuesAndArrayBuffer(s, a.dtype);
        }
        return this.convertAndCacheOnCPU(t, n), n;
    }
    copyBuffer(t) {
        let n = t.size, a = t.usage, r = this.bufferManager.acquireBuffer(n, a);
        return this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(t, 0, r, 0, n), 
        this.submitQueue(), r;
    }
    createTensorFromGPUData(t, n, a) {
        let r = t.buffer;
        if (a === "complex64") throw new Error("Cannot write to a complex64 dtype. ");
        let s = {
            id: this.nextDataId()
        };
        this.tensorMap.set(s, {
            dtype: a,
            shape: n,
            values: null,
            refCount: 1,
            external: t.zeroCopy
        });
        let i = this.tensorMap.get(s), l = R1(i.dtype) * k.sizeFromShape(i.shape);
        if (t.buffer.size < l) throw new Error(`GPUBuffer size(${t.buffer.size}) is smaller than tensor size(${l})!`);
        if ((t.buffer.usage & (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) != (GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC)) throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");
        return t.zeroCopy !== !0 && (r = this.copyBuffer(r)), i.resource = r, Mt().makeTensorFromDataId(s, n, a, this);
    }
    readToGPU(t) {
        let n = this.tensorMap.get(t), {
            values: a,
            dtype: r,
            shape: s,
            resource: i
        } = n;
        if (r === "complex64") throw new Error("Does not support reading buffer for complex64 dtype.");
        if (i == null) throw a != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
        let l = i, o = l.size, p = l.usage, u = this.bufferManager.acquireBuffer(o, p);
        this.ensureCommandEncoderReady(), this.endComputePassEncoder(), this.commandEncoder.copyBufferToBuffer(i, 0, u, 0, o), 
        this.submitQueue();
        let c = this.makeTensorInfo(s, r), d = Mt().makeTensorFromTensorInfo(c);
        return this.tensorMap.get(c.dataId).resource = u, {
            tensorRef: d,
            buffer: u
        };
    }
    bufferSync(t) {
        let n = this.readSync(t.dataId);
        if (t.dtype === "string") try {
            let a = n.map(r => k.decodeString(r));
            return We(t.shape, t.dtype, a);
        } catch {
            throw new Error("Failed to decode encoded string bytes into utf-8");
        }
        return We(t.shape, t.dtype, n);
    }
    async time(t) {
        !this.supportTimestampQuery && !this.hasTimestampQueryWarned && (this.hasTimestampQueryWarned = !0);
        let n = this.activeTimers, a = [], r = !1;
        this.programTimersStack == null ? (this.programTimersStack = a, r = !0) : this.activeTimers.push(a), 
        this.activeTimers = a, t();
        let s = k.flatten(this.activeTimers.map(p => p.query)).filter(p => p != null), i = k.flatten(this.activeTimers.map(p => p.name)).filter(p => p != null);
        this.activeTimers = n, r && (this.programTimersStack = null);
        let l = {
            uploadWaitMs: this.uploadWaitMs,
            downloadWaitMs: this.downloadWaitMs,
            kernelMs: null,
            wallMs: null
        }, o = await Promise.all(s);
        return l.kernelMs = k.sum(o), l.getExtraProfileInfo = () => o.map((p, u) => ({
            name: i[u],
            ms: p
        })).map(p => `${p.name}: ${p.ms}`).join(", "), this.uploadWaitMs = 0, this.downloadWaitMs = 0, 
        l;
    }
    makeTensorInfo(t, n, a) {
        return n === "string" && a != null && a.length > 0 && k.isString(a[0]) && (a = a.map(r => k.encodeString(r))), 
        {
            dataId: this.write(a, t, n),
            shape: t,
            dtype: n
        };
    }
    tensorToBinding(t) {
        if (!t) return null;
        let n = this.tensorMap.get(t.dataId).resource;
        return n instanceof GPUBuffer ? {
            buffer: n
        } : n instanceof GPUTexture ? n.createView() : n;
    }
    uploadToGPU(t) {
        let n = this.tensorMap.get(t);
        if (n.resource != null) return;
        let a, r = R1(n.dtype) * k.sizeFromShape(n.shape), s = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
        if (n.values) {
            if (a = this.bufferManager.acquireBuffer(r, s, !0), a.mapState === "unmapped") {
                let i = this.bufferManager.acquireBuffer(r, GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC, !0, !1), l = i.getMappedRange();
                n.dtype === "int32" || n.dtype === "bool" ? new Int32Array(l).set(n.values) : new Float32Array(l).set(n.values), 
                i.unmap(), this.ensureCommandEncoderReady(), this.endComputePassEncoder(), 
                this.commandEncoder.copyBufferToBuffer(i, 0, a, 0, r), this.stagingPendingDisposal.push(i);
            } else {
                let i = a.getMappedRange();
                n.dtype === "int32" || n.dtype === "bool" ? new Int32Array(i).set(n.values) : new Float32Array(i).set(n.values), 
                a.unmap();
            }
            n.values = null;
        } else a = this.bufferManager.acquireBuffer(r, s);
        n.resource = a;
    }
    makeUniforms(t) {
        let n = 0, a = 0, r = [], s = 1;
        t.forEach(o => {
            let p;
            switch (o.data.length === 0 && (o.data = [ 1 ]), o.data.length) {
              case 1:
                p = 4;
                break;

              case 2:
                p = 8;
                break;

              case 3:
              case 4:
              case 5:
              case 6:
                p = 16;
                break;

              default:
                k.assert(!1, () => `Unsupported ${o.data.length}D shape`);
            }
            (a === 5 || a === 6) && (p = 16), p > s && (s = p), n = Math.ceil(n / p) * p, 
            a = o.data.length, r.push(n), n += 4 * o.data.length;
        }), n = Math.ceil(n / s) * s;
        let i = new ArrayBuffer(n);
        t.forEach((o, p) => {
            let u = r[p];
            o.type === "int32" ? new Int32Array(i, u, o.data.length).set(o.data) : o.type === "uint32" ? new Uint32Array(i, u, o.data.length).set(o.data) : new Float32Array(i, u, o.data.length).set(o.data);
        });
        let l = this.bufferManager.acquireBuffer(n, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);
        return this.queue.writeBuffer(l, 0, i, 0, n), this.uniformPendingDisposal.push(l), 
        {
            offset: 0,
            size: n,
            buffer: l
        };
    }
    runWebGPUProgram(t, n, a, r, s) {
        if (s || (s = this.makeTensorInfo(t.outputShape, a)), k.sizeFromShape(s.shape) === 0) return this.tensorMap.get(s.dataId).values = k.getTypedArrayFromDType(s.dtype, 0), 
        s;
        this.uploadToGPU(s.dataId), t.dispatch = ((o, p) => {
            let u = o.limits.maxComputeWorkgroupsPerDimension, c = p.dispatchLayout, d = p.dispatch;
            if (d.every(f => f <= u)) return d;
            k.assert(d[0] > u && c.y === void 0 && c.z === void 0, () => "Dispatch size exceeds WebGPU limits in Y or Z dimension.");
            let h = Math.ceil(Math.sqrt(d[0]));
            return h > u ? (h = Math.ceil(Math.cbrt(d[0])), k.assert(h <= u, () => "Total dispatch size exceeds WebGPU maximum."), 
            [ h, h, h ]) : [ h, h, 1 ];
        })(this.device, t);
        let i = n.map((o, p) => {
            if (o.dtype === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
            return this.uploadToGPU(o.dataId), {
                dtype: this.tensorMap.get(o.dataId).dtype,
                shape: o.shape,
                name: t.variableNames[p]
            };
        });
        t.shaderKey = function(o, p, u) {
            let c = o.shaderKey;
            if (o.pixelsOpType != null) return c;
            let d = [], h = [];
            p.forEach(A => {
                d.push(A.shape), h.push(A.dtype);
            }), d.push(u.shape), h.push(u.dtype);
            let f = p.map(A => C.getBroadcastDims(A.shape, u.shape)), m = p.map(A => k.arraysEqual(A.shape, u.shape)).join("_"), g = f.map(A => A.join("_")).join(";"), y = bw(o) ? "flatDispatch" : "";
            return c += "_" + (o.workgroupSize ? o.workgroupSize.join(",") : "") + d.map(A => A.length).join(",") + h.join(",") + o.variableNames.join(",") + g + m + y, 
            c;
        }(t, i, s);
        let l = H().getBool("WEBGPU_ENGINE_COMPILE_ONLY");
        return t.shaderKey in this.pipelineCache || (this.pipelineCache[t.shaderKey] = AB(this.device, t, i, s, l)), 
        t.pipeline = this.pipelineCache[t.shaderKey], l || this.recordAndSubmit(t, s, n, r), 
        s;
    }
    recordAndSubmit(t, n, a, r) {
        if (t.pipeline instanceof Promise) throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");
        let s = [], i = [], l = "int32";
        if (t.pixelsOpType == null) {
            s.push({
                type: "float32",
                data: [ NaN ]
            }, {
                type: "float32",
                data: [ 1 / 0 ]
            }), i = a.concat(n).map(h => h.shape);
            let d = "int32";
            i.map(h => {
                s.push({
                    type: d,
                    data: h
                });
                let f = k.computeStrides(h);
                s.push({
                    type: d,
                    data: f
                });
            });
        } else {
            let d = k.computeStrides(n.shape);
            s.push({
                type: l,
                data: d
            });
        }
        if (t.size) {
            let d = k.sizeFromShape(t.outputShape);
            s.push({
                type: l,
                data: [ t.outputComponent ? d / t.outputComponent : d ]
            });
        }
        r && (s = [ ...s, ...r ]);
        let o = [ this.tensorToBinding(n), ...a.map(d => this.tensorToBinding(d)), this.makeUniforms(s) ];
        a.forEach(d => {
            this.commandQueueOwnedIds.add(d.dataId);
        }), this.commandQueueOwnedIds.add(n.dataId);
        let p = this.device.createBindGroup({
            layout: t.pipeline.getBindGroupLayout(0),
            entries: o.map((d, h) => ({
                binding: h,
                resource: d
            }))
        }), u = this.activeTimers != null;
        this.ensureCommandEncoderReady();
        let c = {};
        u && this.supportTimestampQuery ? (this.endComputePassEncoder(), this.querySet == null && (this.querySet = this.device.createQuerySet({
            type: "timestamp",
            count: this.querySetCount
        })), c.timestampWrites = {
            querySet: this.querySet,
            beginningOfPassWriteIndex: 0,
            endOfPassWriteIndex: 1
        }, this.computePassEncoder = this.commandEncoder.beginComputePass(c)) : this.computePassEncoder || (this.computePassEncoder = this.commandEncoder.beginComputePass(c)), 
        this.computePassEncoder.setPipeline(t.pipeline), this.computePassEncoder.setBindGroup(0, p), 
        this.computePassEncoder.dispatchWorkgroups(t.dispatch[0], t.dispatch[1], t.dispatch[2]), 
        this.dispatchCountInPass++, (u || H().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE") <= this.dispatchCountInPass || t.pixelsOpType === xu.DRAW) && (this.endComputePassEncoder(), 
        u ? this.activeTimers.push({
            name: t.constructor.name,
            query: this.getQueryTime()
        }) : this.submitQueue());
    }
    async getQueryTime() {
        if (!this.supportTimestampQuery) return 0;
        this.queryResolveBuffer == null && (this.queryResolveBuffer = this.bufferManager.acquireBuffer(8 * this.querySetCount, GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST | GPUBufferUsage.QUERY_RESOLVE)), 
        this.commandEncoder.resolveQuerySet(this.querySet, 0, this.querySetCount, this.queryResolveBuffer, 0);
        let t = this.bufferManager.acquireBuffer(8 * this.querySetCount, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
        this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, t, 0, 8 * this.querySetCount), 
        this.submitQueue(), await t.mapAsync(GPUMapMode.READ);
        let n = new BigUint64Array(t.getMappedRange()), a = Number(n[1] - n[0]) / 1e6;
        return t.unmap(), this.bufferManager.releaseBuffer(t), a;
    }
    shouldExecuteOnCPU(t, n = wB) {
        return H().getBool("WEBGPU_CPU_FORWARD") && t.every(a => this.tensorMap.get(a.dataId).resource == null && k.sizeFromShape(a.shape) < n);
    }
    numDataIds() {
        return this.tensorMap.numDataIds() - this.tensorDataPendingDisposal.length;
    }
    dispose() {
        this.disposed || (this.querySet != null && this.querySet.destroy(), this.bufferManager.dispose(), 
        this.textureManager.dispose(), this.disposed = !0);
    }
};

M1.nextDataId = 0, E1() && ql("webgpu", async () => {
    let e = {
        powerPreference: H().get("WEBGPU_USE_LOW_POWER_GPU") ? "low-power" : "high-performance"
    }, t = await navigator.gpu.requestAdapter(e), n = {}, a = [];
    t.features.has("timestamp-query") && a.push("timestamp-query"), t.features.has("bgra8unorm-storage") && a.push([ "bgra8unorm-storage" ]), 
    n.requiredFeatures = a;
    let r = t.limits;
    n.requiredLimits = {
        maxComputeWorkgroupStorageSize: r.maxComputeWorkgroupStorageSize,
        maxComputeWorkgroupsPerDimension: r.maxComputeWorkgroupsPerDimension,
        maxStorageBufferBindingSize: r.maxStorageBufferBindingSize,
        maxBufferSize: r.maxBufferSize,
        maxComputeWorkgroupSizeX: r.maxComputeWorkgroupSizeX,
        maxComputeInvocationsPerWorkgroup: r.maxComputeInvocationsPerWorkgroup
    };
    let s = await t.requestDevice(n), i = await t.requestAdapterInfo();
    return new M1(s, i);
}, 3), function(e) {
    e[e.ADD = 0] = "ADD", e[e.ATAN2 = 1] = "ATAN2", e[e.COMPLEX_MULTIPLY_IMAG = 2] = "COMPLEX_MULTIPLY_IMAG", 
    e[e.COMPLEX_MULTIPLY_REAL = 3] = "COMPLEX_MULTIPLY_REAL", e[e.DIV = 4] = "DIV", 
    e[e.ELU_DER = 5] = "ELU_DER", e[e.EQUAL = 6] = "EQUAL", e[e.FLOOR_DIV = 7] = "FLOOR_DIV", 
    e[e.GREATER = 8] = "GREATER", e[e.GREATER_EQUAL = 9] = "GREATER_EQUAL", e[e.LESS = 10] = "LESS", 
    e[e.LESS_EQUAL = 11] = "LESS_EQUAL", e[e.LOGICAL_AND = 12] = "LOGICAL_AND", 
    e[e.LOGICAL_OR = 13] = "LOGICAL_OR", e[e.MAX = 14] = "MAX", e[e.MIN = 15] = "MIN", 
    e[e.MOD = 16] = "MOD", e[e.MUL = 17] = "MUL", e[e.NOT_EQUAL = 18] = "NOT_EQUAL", 
    e[e.POW = 19] = "POW", e[e.PRELU = 20] = "PRELU", e[e.SQUARED_DIFFERENCE = 21] = "SQUARED_DIFFERENCE", 
    e[e.SUB = 22] = "SUB";
}(Le || (Le = {}));

var oe, kB = "let resultTemp = a + b;", IB = "let resultTemp = atan2(a, b);", SB = "let resultTemp = areal * breal - aimag * bimag;", NB = "let resultTemp = areal * bimag + aimag * breal;", CB = "let resultTemp = a / b;", TB = "let resultTemp = select(a * (b + 1.0), a, b >= b - b);", RB = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`, EB = `
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`, $B = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`, MB = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`, FB = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`, _B = `
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`, OB = "return f32(a >= 1.0 && b >= 1.0);", PB = `return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`, DB = "return f32(a >= 1.0 || b >= 1.0);", zB = `return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`, LB = "let resultTemp = max(a, b);", WB = "let resultTemp = min(a, b);", BB = `
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`, VB = `
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`, UB = "let resultTemp = a * b;", GB = `
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`, HB = `
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`, jB = `
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`, qB = `
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`, XB = "if (a < 0.0) { return b * a; }  return a;", KB = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`, ZB = "let resultTemp = (a - b) * (a - b);", YB = "let resultTemp = a - b;";

function F1(e, t) {
    let n;
    do {
        switch (e) {
          case Le.ATAN2:
            n = IB;
            break;

          case Le.MAX:
            n = LB;
            break;

          case Le.MIN:
            n = WB;
            break;

          case Le.MOD:
            n = t ? VB : BB;
            break;

          case Le.NOT_EQUAL:
            n = t ? HB : GB;
            break;

          case Le.POW:
            n = t ? qB : jB;
            break;

          default:
            continue;
        }
        let a, r, s;
        return t ? (a = "isnanVec4", r = "vec4<f32>", s = "vec4<bool>") : (a = "isnan", 
        r = "f32", s = "bool"), `
      let aIsNaN = ${a}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${a}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${s}(isNaN) | aIsNaN | bIsNaN);
      }
    `;
    } while (0);
    switch (e) {
      case Le.ADD:
        n = kB;
        break;

      case Le.COMPLEX_MULTIPLY_IMAG:
        n = NB;
        break;

      case Le.COMPLEX_MULTIPLY_REAL:
        n = SB;
        break;

      case Le.DIV:
        n = CB;
        break;

      case Le.ELU_DER:
        n = TB;
        break;

      case Le.EQUAL:
        n = RB;
        break;

      case Le.FLOOR_DIV:
        n = EB;
        break;

      case Le.GREATER:
        n = $B;
        break;

      case Le.GREATER_EQUAL:
        n = MB;
        break;

      case Le.LESS:
        n = FB;
        break;

      case Le.LESS_EQUAL:
        n = _B;
        break;

      case Le.LOGICAL_AND:
        return t ? PB : OB;

      case Le.LOGICAL_OR:
        return t ? zB : DB;

      case Le.MUL:
        n = UB;
        break;

      case Le.PRELU:
        return t ? KB : XB;

      case Le.SQUARED_DIFFERENCE:
        n = ZB;
        break;

      case Le.SUB:
        n = YB;
    }
    return `
    ${n}
    return resultTemp;
  `;
}

(function(e) {
    e[e.ABS = 0] = "ABS", e[e.ACOS = 1] = "ACOS", e[e.ACOSH = 2] = "ACOSH", e[e.ASIN = 3] = "ASIN", 
    e[e.ASINH = 4] = "ASINH", e[e.ATAN = 5] = "ATAN", e[e.ATANH = 6] = "ATANH", 
    e[e.CEIL = 7] = "CEIL", e[e.COS = 8] = "COS", e[e.COSH = 9] = "COSH", e[e.ELU = 10] = "ELU", 
    e[e.ERF = 11] = "ERF", e[e.EXP = 12] = "EXP", e[e.EXPM1 = 13] = "EXPM1", e[e.FLOOR = 14] = "FLOOR", 
    e[e.IS_FINITE = 15] = "IS_FINITE", e[e.IS_INF = 16] = "IS_INF", e[e.IS_NAN = 17] = "IS_NAN", 
    e[e.LINEAR = 18] = "LINEAR", e[e.LOG = 19] = "LOG", e[e.LOG1P = 20] = "LOG1P", 
    e[e.LOGICAL_NOT = 21] = "LOGICAL_NOT", e[e.NEG = 22] = "NEG", e[e.RELU = 23] = "RELU", 
    e[e.RELU6 = 24] = "RELU6", e[e.LEAKYRELU = 25] = "LEAKYRELU", e[e.RECIPROCAL = 26] = "RECIPROCAL", 
    e[e.ROUND = 27] = "ROUND", e[e.RSQRT = 28] = "RSQRT", e[e.SELU = 29] = "SELU", 
    e[e.SIGMOID = 30] = "SIGMOID", e[e.SIGN = 31] = "SIGN", e[e.SIN = 32] = "SIN", 
    e[e.SINH = 33] = "SINH", e[e.SOFTPLUS = 34] = "SOFTPLUS", e[e.SQRT = 35] = "SQRT", 
    e[e.SQUARE = 36] = "SQUARE", e[e.STEP = 37] = "STEP", e[e.TAN = 38] = "TAN", 
    e[e.TANH = 39] = "TANH", e[e.TO_INT = 40] = "TO_INT";
})(oe || (oe = {}));

var JB = "return abs(a);", QB = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`, eV = `
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`, tV = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`, nV = "return asinh(a);", aV = `
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`, rV = `
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`, sV = "return ceil(a);", iV = "return cos(a);", oV = `
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`, lV = "return exp(a) - 1.0;", uV = "if (a >= 0.0) { return a; }  return (exp(a) - 1.0);", dV = `
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`, pV = `
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${C.ERF_P};
  let a1 = ${C.ERF_A1};
  let a2 = ${C.ERF_A2};
  let a3 = ${C.ERF_A3};
  let a4 = ${C.ERF_A4};
  let a5 = ${C.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`, cV = "return exp(a);", hV = "return floor(a);", fV = "return f32(!isnan(a) && !isinf(a));", mV = "return f32(isinf(a));", gV = "return f32(isnan(a));", yV = "return a;", AV = `if (a < 0.0) { return uniforms.NAN; }
  return log(a);`, xV = `
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`, bV = "return f32(!(a >= 1.0));", vV = "return -a;", wV = "if (a < 0.0) { return uniforms.alpha * a; } return a;", kV = `
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`, IV = "return 1.0 / a;", SV = "return select(a, 0.0, a < 0.0);", NV = "return clamp(a, 0.0, 6.0);", CV = "return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));", TV = `
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`, RV = "return round(a);", EV = "return inverseSqrt(a);", $V = `
  if (a >= 0.0) {
    return ${C.SELU_SCALE} * a;
  } else {
    return ${C.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`, MV = "return 1.0 / (1.0 + exp(-1.0 * a));", FV = "return sign(a);", _V = "return sin(a);", OV = `
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`, PV = `
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`, DV = "return sqrt(a);", zV = "return a * a;", LV = `
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`, WV = "return tan(a);", BV = `
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`, VV = "return f32(i32((a)));";

function Oo(e, t) {
    switch (e) {
      case oe.ABS:
        return JB;

      case oe.ACOS:
        return QB;

      case oe.ACOSH:
        return eV;

      case oe.ASIN:
        return tV;

      case oe.ASINH:
        return nV;

      case oe.ATAN:
        return aV;

      case oe.ATANH:
        return rV;

      case oe.COS:
        return iV;

      case oe.COSH:
        return oV;

      case oe.CEIL:
        return sV;

      case oe.ELU:
        return t ? dV : uV;

      case oe.ERF:
        return pV;

      case oe.EXP:
        return cV;

      case oe.EXPM1:
        return lV;

      case oe.FLOOR:
        return hV;

      case oe.IS_FINITE:
        return fV;

      case oe.IS_INF:
        return mV;

      case oe.IS_NAN:
        return gV;

      case oe.LINEAR:
        return yV;

      case oe.LOG:
        return AV;

      case oe.LOG1P:
        return xV;

      case oe.LOGICAL_NOT:
        return bV;

      case oe.NEG:
        return vV;

      case oe.LEAKYRELU:
        return t ? kV : wV;

      case oe.RECIPROCAL:
        return IV;

      case oe.RELU:
        return t ? TV : SV;

      case oe.RELU6:
        return t ? CV : NV;

      case oe.ROUND:
        return RV;

      case oe.RSQRT:
        return EV;

      case oe.SELU:
        return $V;

      case oe.SIGMOID:
        return MV;

      case oe.SIGN:
        return FV;

      case oe.SIN:
        return _V;

      case oe.SINH:
        return OV;

      case oe.SOFTPLUS:
        return PV;

      case oe.SQRT:
        return DV;

      case oe.SQUARE:
        return zV;

      case oe.STEP:
        return LV;

      case oe.TAN:
        return WV;

      case oe.TANH:
        return BV;

      case oe.TO_INT:
        return VV;

      default:
        throw new Error(`BinaryType ${e} is not implemented!`);
    }
}

function ir(e, t = !1, n = !1, a = 3) {
    if (e === null) return "";
    let r = "";
    if (e === "linear") r = Oo(oe.LINEAR); else if (e === "relu") r = Oo(oe.RELU, n); else if (e === "elu") r = Oo(oe.ELU, n); else if (e === "relu6") r = Oo(oe.RELU6, n); else if (e === "prelu") r = F1(Le.PRELU, n); else if (e === "sigmoid") r = Oo(oe.SIGMOID, n); else {
        if (e !== "leakyrelu") throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);
        r = Oo(oe.LEAKYRELU, n);
    }
    let s = Je(n ? 4 : 1), i = "";
    return i = t ? `
      fn activation(a : ${s}, coords : vec${a}<i32>) -> ${s} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }` : `
      fn activation(a : ${s}, coords : vec${a}<i32>) -> ${s} {
        ${r}
      }`, i;
}

function Po(e, t) {
    return `
      ${e ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${t ? "value = activation(value, coords);" : ""}
      `;
}

function Iw(e, t, n = !1, a = !1, r = !1, s = 1) {
    k.assert(e && s === 1 || !e, () => `transposeA ${e} is not compatible with component size ${s}`);
    let i = `
      ${e ? "value = getA(batch, col, row);" : "value = getA(batch, row, col);"}

    `, l = t ? "value = getB(batch, col, row);" : "value = getB(batch, row, col);";
    return `
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${Je(s)} {
    var value = ${Je(s)}(0.0);
    ${n && r ? i : `
    ${e ? "if(row < uniforms.dimAOuter && col < uniforms.dimInner)" : "if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${Je(s)} {
    var value = ${Je(s)}(0.0);
    ${l}
    return value;
  }
  `;
}

function _1(e, t, n, a, r = !1, s = !1, i = !1, l = 1) {
    return `
  ${Iw(n, a, r, s, i, l)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${Je(l)}) {
    ${r && s ? "" : "if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Po(e, t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `;
}

function Yc(e, t, n = !1, a = 32, r = !1, s = 32, i = !1) {
    let l = t[1] * e[1], o = t[0] * e[0], p = n ? l : a, u = n ? a : l, c = p / t[0], d = a / t[1], h = e[1], f = e[0];
    return k.assert((n && c === 4 && e[1] === 4 || !n && (c === 3 || c === 4)) && p % t[0] == 0 && a % t[1] == 0 && e[0] === 4, () => `If transposeA ${n} is true, innerElementSize ${c} and workPerThread[1] ${e[1]} must be 4.
          Otherwise, innerElementSize ${c} must be 3 or 4.
      tileAWidth ${p} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`), 
    `
  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${p / c}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${o / e[0]}>, ${a}>;

  ${le()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${h};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${h};
    let globalCol = i32(globalId.x) * ${f};
    let batch = ${r ? "0" : "i32(globalId.z)"};
    let batchA = ${r || !i ? "batch" : "batch % uniforms.aShape[0]"};
    let batchB = ${r || !i ? "batch" : "batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${l};

    let numTiles = ${r ? `${Math.ceil(s / a)}` : `(uniforms.dimInner - 1) / ${a} + 1`};
    var kStart = ${r ? `i32(globalId.z) * ${s}` : "0"};

    var acc: array<vec4<f32>, ${h}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${h}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${((m, g) => m ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${g});
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${g});
        `)(n, c)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${a};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${((m, g, y, A) => {
        if (m) return `
      for (var k = 0; k < ${A}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${y}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;
        {
            let x = "", b = "";
            for (let v = 0; v < g; v++) x += `let BCached${v} = mm_Bsub[k * ${g} + ${v}][tileCol];`, 
            b += `acc[i] = fma(BCached${v}, vec4<f32>(ACached[${v}]), acc[i]);`;
            return `
      for (var k = 0; k < ${A / g}; k++) {
        ${x}
        for (var i = 0; i < ${y}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${b}
        }
      }`;
        }
    })(n, c, h, a)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${h}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`;
}

var Sw = e => e ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `;

function Jc(e, t, n = !1, a = 32, r = !1, s = 32, i = !1, l = !1) {
    let o = e[1] * t[1], p = e[0] * t[0], u = n ? o : a, c = n ? a : o;
    k.assert(c % t[1] == 0 && u % t[0] == 0 && a % t[1] == 0, () => `tileAHight ${c} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);
    let d = c / t[1], h = u / t[0], f = a / t[1], m = e[1], g = e[0], y = i ? `
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${o};
      let globalColStart = i32(workgroupId.x) * ${p};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {
            ${Sw(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${a};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${g}>;
        for (var k = 0; k < ${a}; k++) {
          for (var inner = 0; inner < ${g}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${m}; innerRow++) {
            let ACached = ${n ? `mm_Asub[k][localRow + innerRow * ${t[1]}];` : `mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${g}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      ` : `
  let tileRow = i32(localId.y) * ${m};
  let tileCol = i32(localId.x) * ${g};

  let globalRow = i32(globalId.y) * ${m};
  let globalCol = i32(globalId.x) * ${g};
  let globalRowStart = i32(workgroupId.y) * ${o};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${h};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${h}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${Sw(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
      for (var innerCol = 0; innerCol < ${g}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${a};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${g}>;
    for (var k = 0; k < ${a}; k++) {
      for (var inner = 0; inner < ${g}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        ${(A => A ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];")(n)}
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${m}; innerRow++) {
    for (var innerCol = 0; innerCol < ${g}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;
    return `
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${c}>;
    var<workgroup> mm_Bsub : array<array<f32, ${p}>, ${a}>;

    ${le()} {
      let batch = ${r ? "0" : "i32(globalId.z)"};
      let batchA = ${r || !l ? "batch" : "batch % uniforms.aShape[0]"};
      let batchB = ${r || !l ? "batch" : "batch % uniforms.bShape[0]"};
      let numTiles = ${r ? `${Math.ceil(s / a)}` : `(uniforms.dimInner - 1) / ${a} + 1`};
      var kStart = ${r ? `i32(globalId.z) * ${s}` : "0"};

      var acc : array<array<f32, ${g}>, ${m}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${m}; innerRow++) {
        for (var innerCol = 0; innerCol < ${g}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${y}
    }
  `;
}

var UV = class {
    constructor(e, t, n = !1, a = !1, r = null, s = null, i = null, l = !1) {
        this.variableNames = [ "A", "B" ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", 
        this.outputShape = t, this.dispatchLayout = {
            x: [ 2 ],
            y: [ 1 ],
            z: [ 0 ]
        };
        let o = n ? e[1] : e[2];
        if (this.isVec4 = (o % 4 == 0 && !n || t[1] % 4 == 0 && n) && t[2] % 4 == 0 && !a, 
        this.outputComponent = this.isVec4 ? 4 : 1, this.isVectorA = t[1] === 1 && !n, 
        !this.isVec4 && this.isVectorA) this.elementsPerThread = [ 1, 1, 1 ], this.workgroupSize = [ 32, 1, 1 ]; else {
            let c = kw(t[1], o, t[2], n);
            this.workgroupSize = c.workgroupSize, this.elementsPerThread = c.elementsPerThread;
        }
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread);
        let p = r != null, u = i != null;
        p && this.variableNames.push("bias"), u && this.variableNames.push("preluActivationWeights"), 
        this.sequentialAccessByThreads = l, this.transposeA = n, this.transposeB = a, 
        this.addBias = p, this.activation = s, this.hasPreluActivationWeights = u, 
        [ this.fitAOuter, this.fitBOuter, this.fitInner ] = this.getShapeFit(t[1], t[2], o), 
        this.shaderKey = `matMulPacked_${this.elementsPerThread}_${n}_${a}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`;
    }
    getShapeFit(e, t, n) {
        let a = this.workgroupSize[1] * this.elementsPerThread[1], r = this.workgroupSize[0] * this.elementsPerThread[0];
        return !this.isVec4 && this.isVectorA ? this.tileInner = 4 * this.workgroupSize[0] : this.tileInner = r, 
        [ e % a == 0, t % r == 0, n % this.tileInner == 0 ];
    }
    getUserCode() {
        return `
      ${ir(this.activation, this.hasPreluActivationWeights, this.isVec4)}
      ${_1(this.addBias, this.activation, !1, this.transposeB, this.fitAOuter, this.fitBOuter, this.fitInner, this.isVec4 ? 4 : 1)}
      ${this.isVec4 ? Yc(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, !1, null, !0) : this.isVectorA ? function(e, t = !1) {
            k.assert(e[1] === 1 && e[2] === 1, () => `A linear work group size is required. But got ${e}.`);
            let n = 4 * e[0];
            return `
    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;

    ${le()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${(a => a ? `
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  ` : `
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `)(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n / 4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `;
        }(this.workgroupSize, this.transposeA) : Jc(this.elementsPerThread, this.workgroupSize, this.transposeA, this.tileInner, !1, null, this.sequentialAccessByThreads, !0)}
    `;
    }
}, GV = class {
    constructor(e, t = !1, n = !1, a = null, r = null, s = null) {
        this.variableNames = [ "A", "B" ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", 
        this.workgroupSize = [ 256, 1, 1 ], this.outputShape = e, this.dispatchLayout = {
            x: [],
            y: [ 1, 2 ],
            z: [ 0 ]
        }, this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize);
        let i = a != null, l = s != null;
        i && this.variableNames.push("bias"), l && this.variableNames.push("preluActivationWeights"), 
        this.transposeA = t, this.transposeB = n, this.addBias = i, this.activation = r, 
        this.hasPreluActivationWeights = l, this.shaderKey = `matMulReduce_${this.activation}_${t}_${n}`;
    }
    getUserCode() {
        return `
      ${ir(this.activation, this.hasPreluActivationWeights)}
      ${_1(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${function(e) {
            return `
    var<workgroup> sumValues : array<f32, ${e}>;
    ${le()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${e}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${e / 2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `;
        }(this.workgroupSize[0])}
    `;
    }
}, HV = class {
    constructor(e, t, n, a = !1, r = !1, s = null, i = null, l = null) {
        this.variableNames = [ "A", "B" ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", 
        this.workgroupSize = [ 16, 8, 1 ], this.outputShape = n, this.dispatchLayout = {
            x: [ 2 ],
            y: [ 1 ],
            z: [ 0 ]
        }, this.dispatch = [ Math.ceil(n[2] / this.workgroupSize[0]), Math.ceil(n[1] / this.workgroupSize[1]), n[0] ];
        let o = s != null;
        o && this.variableNames.push("bias");
        let p = l != null;
        p && this.variableNames.push("preluActivationWeights"), this.transposeA = a, 
        this.transposeB = r, this.addBias = o, this.activation = i, this.hasPreluActivationWeights = p, 
        this.shaderKey = `matMulSmallOutputSize_${this.activation}_${a}_${r}`;
    }
    getUserCode() {
        return `
      ${ir(this.activation, this.hasPreluActivationWeights)}
      ${_1(this.addBias, this.activation, this.transposeA, this.transposeB)}
      ${function(e) {
            let t = e[1], n = e[0], a = t > n ? t : n;
            return `
  var<workgroup> mm_Asub : array<array<f32, ${a}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${a}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${le()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${a} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${a};
    globalRowB = globalRowB + ${a};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${a};
      globalRowB = globalRowB + ${a};

      for (var k = 0; k < ${a}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `;
        }(this.workgroupSize)}
    `;
    }
}, jV = class {
    constructor(e, t, n = !1, a = !1) {
        this.variableNames = [ "A", "B" ], this.uniforms = "dimAOuter : i32, dimBOuter : i32, dimInner : i32,", 
        this.workgroupSize = [ 8, 8, 1 ], this.atomic = !0, this.splitedDimInner = 128, 
        k.assert(e[0] === 1, () => "MatMulSplitKProgram only supports batch = 1."), 
        this.outputShape = e, this.dispatchLayout = {
            x: [ 2 ],
            y: [ 1 ],
            z: [ 0, 3 ]
        };
        let r = (n && this.outputShape[1] % 4 == 0 || !n && t % 4 == 0) && this.outputShape[2] % 4 == 0;
        this.elementsPerThread = [ 4, 4, this.splitedDimInner ], this.outputComponent = r ? 4 : 1, 
        r || (this.outputShape[1] < 16 && (this.elementsPerThread[1] = 1), this.outputShape[2] < 16 && (this.elementsPerThread[0] = 1)), 
        this.dispatch = de(this.dispatchLayout, [ this.outputShape[0], this.outputShape[1], this.outputShape[2], t ], this.workgroupSize, this.elementsPerThread), 
        this.transposeA = n, this.transposeB = a, this.shaderKey = `matMulSplitK_${n}_${a}_${this.elementsPerThread}_${this.outputComponent}`;
    }
    getUserCode() {
        let e = this.outputComponent;
        return `
      ${Iw(!1, this.transposeB, !1, !1, !1, e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${Je(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Kr("&result[flatIndex + i]", e > 1 ? "value[i]" : "value", "float32")}
          }
        }
      }
      ${e === 4 ? Yc(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, !0, this.splitedDimInner) : Jc(this.elementsPerThread, this.workgroupSize, this.transposeA, 32, !0, this.splitedDimInner)}
    `;
    }
}, qV = class {
    constructor(e, t = null, n = null, a = null) {
        this.uniforms = "", this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.addBias = t != null, this.hasPreluActivationWeights = a != null, this.activation = n, 
        this.addBias && this.variableNames.push("bias"), this.hasPreluActivationWeights && this.variableNames.push("preluActivationWeights"), 
        this.shaderKey = `biasActivation_${n}`;
    }
    getUserCode() {
        return `
    ${ir(this.activation, this.hasPreluActivationWeights)}
    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Po(this.addBias, this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `;
    }
}, XV = class {
    constructor(e) {
        this.variableNames = [], this.outputShape = [], this.uniforms = "value : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "fill";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;
    }
};

function Sn(e) {
    let {
        backend: t,
        attrs: n
    } = e, {
        shape: a,
        value: r
    } = n, {
        dtype: s
    } = n;
    if (s = s || k.inferDtype(r), s === "string") {
        let i = k.getArrayFromDType(s, k.sizeFromShape(a));
        return i.fill(r), t.makeTensorInfo(a, s, i);
    }
    {
        let i = new XV(a), l = [ {
            type: "float32",
            data: [ r ]
        } ];
        return t.runWebGPUProgram(i, [], s, l);
    }
}

var KV = {
    kernelName: wl,
    backendName: "webgpu",
    kernelFunc: Sn
};

function Ne(e) {
    let {
        inputs: t,
        attrs: n
    } = e, {
        x: a
    } = t, {
        shape: r
    } = n, s = k.sizeFromShape(a.shape), i = k.inferFromImplicitShape(r, s), l = k.sizeFromShape(i);
    return k.assert(s === l, () => `The new shape (${i}) has ${l} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`), 
    e.backend.incRef(a.dataId), {
        dataId: a.dataId,
        shape: i,
        dtype: a.dtype
    };
}

var ZV = {
    kernelName: Ml,
    backendName: "webgpu",
    kernelFunc: Ne
};

function Qc({
    a: e,
    b: t,
    transposeA: n,
    transposeB: a,
    backend: r,
    bias: s = null,
    preluActivationWeights: i = null,
    leakyreluAlpha: l = 0,
    activation: o = null
}) {
    let p = e.shape.length, u = t.shape.length, c = n ? e.shape[p - 2] : e.shape[p - 1], d = a ? t.shape[u - 1] : t.shape[u - 2], h = n ? e.shape[p - 1] : e.shape[p - 2], f = a ? t.shape[u - 2] : t.shape[u - 1], m = e.shape.slice(0, -2), g = t.shape.slice(0, -2), y = k.sizeFromShape(m), A = k.sizeFromShape(g), x = mo.assertAndGetBroadcastShape(e.shape.slice(0, -2), t.shape.slice(0, -2)).concat([ h, f ]);
    k.assert(c === d, () => `Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${a} must match.`);
    let b, v, I = n ? [ y, c, h ] : [ y, h, c ], N = a ? [ A, f, d ] : [ A, d, f ], T = Ne({
        inputs: {
            x: e
        },
        backend: r,
        attrs: {
            shape: I
        }
    }), R = Ne({
        inputs: {
            x: t
        },
        backend: r,
        attrs: {
            shape: N
        }
    }), w = [ T, R ], E = Math.max(y, A), $ = [ T, R ], M = [ {
        type: "int32",
        data: [ h ]
    }, {
        type: "int32",
        data: [ f ]
    }, {
        type: "int32",
        data: [ c ]
    } ], F = [ E, h, f ], P = H().get("WEBGPU_MATMUL_PROGRAM_TYPE");
    if (P < 0) {
        let O = H().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), B = O > 0 ? O : r.thresholdToIncreaseWorkgroups, G = E * Math.ceil(h / 32) * Math.ceil(f / 32);
        P = G <= B || h <= 8 && G <= 2 * B ? E * h * f <= 128 ? Na.MatMulReduceProgram : E === 1 && d >= 2e3 ? Na.MatMulSplitKProgram : Na.MatMulSmallOutputSizeProgram : Na.MatMulPackedProgram;
    }
    switch (P) {
      case Na.MatMulReduceProgram:
        b = new GV(F, n, a, s, o, i);
        break;

      case Na.MatMulSplitKProgram:
        if (v = Sn({
            backend: r,
            attrs: {
                shape: F,
                value: 0,
                dtype: e.dtype
            }
        }), b = new jV(F, d, n, a), s || o) {
            v = r.runWebGPUProgram(b, $, e.dtype, M, v);
            let B = new qV(v.shape, s, o, i), G = null, W = [ v ];
            s && W.push(s), i && W.push(i), o === "leakyrelu" && (G = [ {
                type: "float32",
                data: [ l ]
            } ], B.uniforms += " alpha : f32,");
            let z = r.runWebGPUProgram(B, W, v.dtype, G);
            w.push(v);
            let X = Ne({
                inputs: {
                    x: z
                },
                backend: r,
                attrs: {
                    shape: x
                }
            });
            w.push(z);
            for (let q of w) r.disposeData(q.dataId);
            return X;
        }
        break;

      case Na.MatMulSmallOutputSizeProgram:
        b = new HV(I, N, F, n, a, s, o, i);
        break;

      case Na.MatMulPackedProgram:
        let O = r.adapterInfo.isIntel();
        b = new UV(I, F, n, a, s, o, i, O);
        break;

      default:
        throw new Error(`Unsupported MatMulProgramType ${P}.`);
    }
    s && $.push(s), i && $.push(i), o === "leakyrelu" && (M.push({
        type: "float32",
        data: [ l ]
    }), b.uniforms += " alpha : f32,"), v = r.runWebGPUProgram(b, $, e.dtype, M, v);
    let L = Ne({
        inputs: {
            x: v
        },
        backend: r,
        attrs: {
            shape: x
        }
    });
    w.push(v);
    for (let O of w) r.disposeData(O.dataId);
    return L;
}

var YV = {
    kernelName: wr,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            a: r,
            b: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            transposeA: o,
            transposeB: p,
            activation: u,
            leakyreluAlpha: c
        } = a;
        return Qc({
            a: r,
            b: s,
            transposeA: o,
            transposeB: p,
            backend: n,
            bias: i,
            preluActivationWeights: l,
            leakyreluAlpha: c,
            activation: u
        });
    }
}, Nw = class {
    constructor(e, t, n) {
        this.variableNames = [ "AReal", "AImag", "BReal", "BImag" ], this.workgroupSize = [ 128, 1, 1 ], 
        this.size = !0, this.outputShape = C.assertAndGetBroadcastShape(t, n), this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = `binaryOpComplex_${e}`, this.op = e;
    }
    getUserCode() {
        return `
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${F1(this.op, !1)}
      }

      ${le("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;
    }
}, eh = class {
    constructor(e, t, n) {
        if (this.size = !0, this.variableNames = [ "A", "B" ], this.outputShape = C.assertAndGetBroadcastShape(t, n), 
        this.dispatchLayout = xe(this.outputShape), this.op = e, this.useSharedMemoryWithA = t.length <= 1 && n.length > 1 && t[0] < 128, 
        this.useSharedMemoryWithB = n.length <= 1 && t.length > 1 && n[0] < 128, 
        this.useSharedMemoryWithA || this.useSharedMemoryWithB) this.outputComponent = 1, 
        this.variableComponents = [ 1, 1 ], this.lastDimensionSize = this.useSharedMemoryWithB ? n[0] : t[0], 
        this.shaderKey = `binary_${e}_${this.lastDimensionSize}`, this.type = "shared", 
        this.workgroupSize = [ 256, 1, 1 ]; else {
            let a = t.length > 0 && t[t.length - 1] % 4 == 0, r = n.length > 0 && n[n.length - 1] % 4 == 0;
            a && r ? (this.outputComponent = 4, this.variableComponents = [ 4, 4 ]) : a && (k.isScalarShape(n) || n[n.length - 1] === 1) || r && (k.isScalarShape(t) || t[t.length - 1] === 1) ? (this.outputComponent = 4, 
            this.variableComponents = a ? [ 4, 1 ] : [ 1, 4 ]) : (this.outputComponent = 1, 
            this.variableComponents = [ 1, 1 ]), this.type = "nonshared", this.shaderKey = `binary_${e}_${this.variableComponents}`, 
            this.workgroupSize = [ 128, 1, 1 ];
        }
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.outputComponent, 1, 1 ]);
    }
    getUserCode() {
        let e, t = this.outputComponent === 4 ? "vec4<f32>" : "f32", n = `
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${F1(this.op, this.outputComponent === 4)}
    };
    `;
        if (this.type === "shared") {
            let a = this.lastDimensionSize > 1 ? `coords[${this.outputShape.length - 1}]` : "0", r = this.useSharedMemoryWithB ? `let a = getAByOutputIndex(index);
          let b = sharedBuf[${a}];` : `let a = sharedBuf[${a}];
          let b = getBByOutputIndex(index);`;
            e = `
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${le("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB ? "B" : "A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${r}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `;
        } else e = `
       ${n}
       ${le("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;
        return e;
    }
};

function jn(e) {
    let {
        inputs: t
    } = e, {
        x: n
    } = t;
    return e.backend.incRef(n.dataId), {
        dataId: n.dataId,
        shape: n.shape,
        dtype: n.dtype
    };
}

var JV = {
    kernelName: Js,
    backendName: "webgpu",
    kernelFunc: jn
};

function Do(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        real: a,
        imag: r
    } = t, s = n.makeTensorInfo(a.shape, "complex64"), i = n.tensorMap.get(s.dataId), l = jn({
        inputs: {
            x: a
        },
        backend: n
    }), o = jn({
        inputs: {
            x: r
        },
        backend: n
    });
    return i.complexTensorInfos = {
        real: l,
        imag: o
    }, s;
}

var QV = {
    kernelName: qu,
    backendName: "webgpu",
    kernelFunc: Do
}, bu = class {
    constructor(e, t, n = "") {
        this.variableNames = [ "A" ], this.size = !0, this.workgroupSize = [ 128, 1, 1 ], 
        this.outputShape = e, this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.op = t, n !== "" && (this.uniforms = n), this.shaderKey = `unary_${t}`;
    }
    getUserCode() {
        return `
      fn unaryOperation(a : f32) -> f32 {
        ${Oo(this.op, !1)}
      }
      ${le("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `;
    }
};

function st({
    opType: e,
    cpuKernelImpl: t,
    dtype: n
}) {
    return ({
        inputs: a,
        backend: r
    }) => {
        let {
            x: s
        } = a, i = r, l = n || s.dtype;
        if (i.shouldExecuteOnCPU([ s ]) && t != null) {
            let p = i.tensorMap.get(s.dataId), u = t(p.values, l);
            return i.makeTensorInfo(s.shape, l, u);
        }
        let o = new bu(s.shape, e);
        return i.runWebGPUProgram(o, [ s ], l);
    };
}

function jt({
    opType: e,
    cpuKernelImpl: t,
    supportsComplex: n = !1,
    dtype: a
}) {
    return ({
        inputs: r,
        backend: s
    }) => {
        let {
            a: i,
            b: l
        } = r, o = s;
        if (n && i.dtype === "complex64") {
            let c, d, h = o.tensorMap.get(i.dataId), f = o.tensorMap.get(l.dataId);
            if (e !== Le.MUL) [ c, d ] = [ [ h.complexTensorInfos.real, f.complexTensorInfos.real ], [ h.complexTensorInfos.imag, f.complexTensorInfos.imag ] ].map(g => {
                let [ y, A ] = g, x = {
                    dataId: y.dataId,
                    dtype: y.dtype,
                    shape: i.shape
                }, b = {
                    dataId: A.dataId,
                    dtype: A.dtype,
                    shape: l.shape
                }, v = new eh(e, i.shape, l.shape);
                return o.runWebGPUProgram(v, [ x, b ], Zt(y.dtype, A.dtype));
            }); else {
                let g = new Nw(Le.COMPLEX_MULTIPLY_REAL, i.shape, l.shape), y = new Nw(Le.COMPLEX_MULTIPLY_IMAG, i.shape, l.shape), A = [ {
                    dataId: h.complexTensorInfos.real.dataId,
                    dtype: h.complexTensorInfos.real.dtype,
                    shape: i.shape
                }, {
                    dataId: h.complexTensorInfos.imag.dataId,
                    dtype: h.complexTensorInfos.imag.dtype,
                    shape: i.shape
                }, {
                    dataId: f.complexTensorInfos.real.dataId,
                    dtype: f.complexTensorInfos.real.dtype,
                    shape: l.shape
                }, {
                    dataId: f.complexTensorInfos.imag.dataId,
                    dtype: f.complexTensorInfos.imag.dtype,
                    shape: l.shape
                } ];
                c = o.runWebGPUProgram(g, A, "float32"), d = o.runWebGPUProgram(y, A, "float32");
            }
            let m = Do({
                inputs: {
                    real: c,
                    imag: d
                },
                backend: o
            });
            return o.disposeData(c.dataId), o.disposeData(d.dataId), m;
        }
        let p = a || Zt(i.dtype, l.dtype);
        if ((i.dtype === "string" || l.dtype === "string" || o.shouldExecuteOnCPU([ i, l ])) && t != null) {
            let c = o.tensorMap.get(i.dataId).values, d = o.tensorMap.get(l.dataId).values, h = i.dtype === "string" ? C.fromUint8ToStringArray(c) : c, f = i.dtype === "string" ? C.fromUint8ToStringArray(d) : d, [ m, g ] = t(i.shape, l.shape, h, f, p);
            return o.makeTensorInfo(g, p, m);
        }
        let u = new eh(e, i.shape, l.shape);
        return o.runWebGPUProgram(u, [ i, l ], p);
    };
}

var {
    addImpl: eU,
    castImpl: tU,
    ceilImpl: nU,
    concatImpl: aU,
    equalImpl: rU,
    expImpl: sU,
    expm1Impl: iU,
    floorImpl: oU,
    floorDivImpl: lU,
    gatherNdImpl: uU,
    gatherV2Impl: dU,
    greaterEqualImpl: pU,
    greaterImpl: cU,
    lessEqualImpl: hU,
    lessImpl: fU,
    logImpl: mU,
    maxImpl: gU,
    maximumImpl: yU,
    minimumImpl: AU,
    multiplyImpl: xU,
    negImpl: bU,
    notEqualImpl: vU,
    prodImpl: wU,
    rangeImpl: kU,
    rsqrtImpl: IU,
    scatterImpl: SU,
    simpleAbsImpl: NU,
    sliceImpl: CU,
    stridedSliceImpl: TU,
    stringNGramsImpl: RU,
    subImpl: EU,
    tileImpl: $U,
    topKImpl: MU,
    transposeImpl: FU,
    uniqueImpl: CZ
} = Sc, _U = st({
    opType: oe.ABS,
    cpuKernelImpl: NU
}), OU = {
    kernelName: ol,
    backendName: "webgpu",
    kernelFunc: _U
}, PU = st({
    opType: oe.ACOS
}), DU = {
    kernelName: cs,
    backendName: "webgpu",
    kernelFunc: PU
}, zU = st({
    opType: oe.ACOSH
}), LU = {
    kernelName: hs,
    backendName: "webgpu",
    kernelFunc: zU
}, WU = jt({
    opType: Le.ADD,
    cpuKernelImpl: eU,
    supportsComplex: !0
}), BU = {
    kernelName: Ar,
    backendName: "webgpu",
    kernelFunc: WU
}, VU = class {
    constructor(e) {
        this.workPerThread = 1, this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.outputShape = e[0], this.variableNames = e.map((t, n) => `T${n}`), 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.workPerThread, 1, 1 ]), 
        this.shaderKey = "addN";
    }
    getUserCode() {
        let e = [];
        this.variableNames.forEach(n => {
            e.push(`let v${n} = get${n}ByOutputCoords(coords);`);
        });
        let t = this.variableNames.map(n => `v${n}`).join(" + ");
        return `
      ${le("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `;
    }
}, UU = {
    kernelName: fs,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, a = t;
        if (a.length === 1) return jn({
            inputs: {
                x: a[0]
            },
            backend: n
        });
        let r = a.map(l => l.dtype).reduce((l, o) => Zt(l, o)), s = a.map(l => l.shape), i = new VU(s);
        return n.runWebGPUProgram(i, a, r);
    }
}, GU = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.workgroupSize = [ 16, 16, 1 ];
        let n = new Array(e.length);
        for (let a = 0; a < n.length; a++) n[a] = e[t[a]];
        this.outputShape = n, this.dispatchLayout = {
            x: [ 0 ],
            y: [ 1 ]
        }, this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ 1, 1, 1 ]), 
        this.shaderKey = "transposeShared";
    }
    getUserCode() {
        k.assert(this.workgroupSize[0] === this.workgroupSize[1], () => `Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);
        let e = this.workgroupSize[0];
        return `
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0] + 1}>, ${this.workgroupSize[0]}>;
      ${le()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;
    }
}, HU = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.workPerThread = 1, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0;
        let n = new Array(e.length);
        for (let a = 0; a < n.length; a++) n[a] = e[t[a]];
        this.outputShape = n, this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.workPerThread, 1, 1 ]), 
        this.newDim = t, this.shaderKey = `transpose_${t}`;
    }
    getUserCode() {
        let e = Tt(this.outputShape.length), t = Cw(this.newDim);
        return `
      ${le("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `;
    }
};

function Cw(e) {
    let t = e.length;
    if (t > 6) throw Error(`Transpose for rank ${t} is not yet supported`);
    let n = new Array(t);
    for (let a = 0; a < e.length; a++) n[e[a]] = `coords.${sr(a)}`;
    return n.join();
}

function Va(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        perm: s
    } = a, i = n, l = r.shape.length, o = new Array(l);
    for (let u = 0; u < o.length; u++) o[u] = r.shape[s[u]];
    if (n.shouldExecuteOnCPU([ r ])) {
        let u = i.tensorMap.get(r.dataId).values, c = FU(u, r.shape, r.dtype, s, o);
        return n.makeTensorInfo(o, r.dtype, c);
    }
    if (r.shape.length === 2 && k.arraysEqual(s, [ 1, 0 ])) {
        let u = new GU(r.shape, s);
        return i.runWebGPUProgram(u, [ r ], r.dtype);
    }
    let p = new HU(r.shape, s);
    return i.runWebGPUProgram(p, [ r ], r.dtype);
}

var jU = {
    kernelName: Xa,
    backendName: "webgpu",
    kernelFunc: Va
}, qU = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.uniforms = "reduceSize : i32,", this.size = !0, 
        this.inputShape = [ e.batchSize, e.inSize ];
        let [ a ] = C.computeOutAndReduceShapes(this.inputShape, [ 1 ]);
        this.outputShape = a.length === 0 ? [ 1 ] : a, e.inSize >= 32768 && n >= 512 ? this.workgroupSize = [ 512, 1, 1 ] : e.inSize >= 4096 ? this.workgroupSize = [ 256, 1, 1 ] : this.workgroupSize = [ 64, 1, 1 ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, [ 1, 1, 1 ]), 
        this.reduceType = t, this.shaderKey = `reduce_${t}`;
    }
    getUserCode() {
        let e = "", t = "0.0", n = this.workgroupSize[0];
        this.reduceType === "min" || this.reduceType === "max" ? (e = `
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType === "min" ? "<" : ">"} bestValue)
           {  bestValue = candidate; }`, t = "f32(x[offset])") : this.reduceType === "sum" || this.reduceType === "mean" ? e = " bestValue = bestValue + candidate; " : this.reduceType === "prod" ? (e = " bestValue = bestValue * candidate; ", 
        t = "1.0") : this.reduceType === "all" ? (e = " bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ", 
        t = "1.0") : this.reduceType === "any" && (e = " bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ", 
        t = "0.0");
        let a = this.reduceType === "mean" ? "setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));" : "setOutputAtIndex(outputIndex, bestValue);";
        return `
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       
         var<workgroup> xBestValues : array<f32, ${n}>;
       
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length === 1 ? "outputCoords" : "outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${le("index")} {
         let outputIndex = index / ${n};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${n}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${n}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${a}
        }
       }
     `;
    }
}, XU = {
    mean: "float32",
    all: "bool",
    any: "bool"
};

function zo(e, t, n, a, r) {
    let s = e.shape.length, i = [], l = k.parseAxisParam(t, e.shape), o = l, p = C.getAxesPermutation(o, s), u = e;
    p != null && (u = Va({
        inputs: {
            x: e
        },
        attrs: {
            perm: p
        },
        backend: r
    }), o = C.getInnerMostAxes(o.length, s), i.push(u)), C.assertAxesAreInnerMostDims(a, o, s);
    let c, [ d, h ] = C.computeOutAndReduceShapes(u.shape, o), f = d;
    if (n && (f = C.expandShapeToKeepDim(d, l)), a !== "max" && a !== "prod" || !r.shouldExecuteOnCPU([ u ])) {
        let m = k.sizeFromShape(h), g = {
            windowSize: m,
            inSize: m,
            batchSize: k.sizeFromShape(u.shape) / m,
            outSize: 1
        }, y = XU[a] || kd(e.dtype), A = [ {
            type: "int32",
            data: [ m ]
        } ], x = new qU(g, a, r.device.limits.maxComputeWorkgroupSizeX), b = r.runWebGPUProgram(x, [ u ], y, A);
        i.push(b), c = Ne({
            inputs: {
                x: b
            },
            attrs: {
                shape: f
            },
            backend: r
        });
    } else {
        let m = r.tensorMap.get(u.dataId).values;
        switch (a) {
          case "max":
            let g = gU(m, k.sizeFromShape(h), f, e.dtype);
            c = r.makeTensorInfo(f, e.dtype, g);
            break;

          case "prod":
            let {
                outVals: y,
                outShape: A,
                outDtype: x
            } = wU(u.shape, u.dtype, m, o);
            c = r.makeTensorInfo(A, x, y);
            break;

          default:
            throw new Error(`${a} CPU implementation is not yet supported.`);
        }
    }
    return i.forEach(m => r.disposeData(m.dataId)), c;
}

var KU = {
    kernelName: ms,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            keepDims: s,
            axis: i
        } = a;
        return zo(r, i, s, "all", n);
    }
}, ZU = {
    kernelName: gs,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            keepDims: s,
            axis: i
        } = a;
        return zo(r, i, s, "any", n);
    }
}, Tw = class {
    constructor(e, t, n) {
        this.workgroupSize = [ 64, 1, 1 ], this.variableNames = [ "x" ], this.uniforms = "infinityValue : f32,", 
        this.size = !0;
        let a = [ t ];
        this.op = n === "min" ? "<" : ">";
        let [ r, s ] = C.computeOutAndReduceShapes(e, a);
        this.outputShape = r.length === 0 ? [ 1 ] : r, this.dispatchLayout = xe(this.outputShape), 
        k.sizeFromShape(s) < 32 ? (this.type = "plain", this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize)) : (this.type = "shared", 
        this.dispatch = de(this.dispatchLayout, this.outputShape, [ 1, 1, 1 ])), 
        this.inputShape = e, this.shaderKey = `argMinMax_${this.op}_${this.type}`;
    }
    getUserCode() {
        let e = this.workgroupSize[0], t = () => this.inputShape.length === 1 ? "uniforms.xShape" : `uniforms.xShape.${sr(this.inputShape.length - 1)}`, n = () => {
            let a = "";
            if (this.outputShape.length === 1) this.inputShape.length !== 1 && (a += "outputCoords,"); else for (let r = 0; r < this.outputShape.length; r++) a += `outputCoords.${sr(r)},`;
            return a;
        };
        return this.type === "shared" ? `
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    

      ${le("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${n()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    ` : `
      ${le("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${n()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${n()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;
    }
}, YU = {
    kernelName: ll,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s
        } = a, i = k.parseAxisParam(s, r.shape), l = C.getAxesPermutation(i, r.shape.length), o = r, p = [];
        l != null && (o = Va({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: l
            }
        }), p.push(o), i = C.getInnerMostAxes(i.length, o.shape.length)), C.assertAxesAreInnerMostDims("argMax", [ i[0] ], o.shape.length);
        let u = new Tw(o.shape, i[0], "max"), c = [ {
            type: "float32",
            data: [ Number.NEGATIVE_INFINITY ]
        } ], d = n.runWebGPUProgram(u, [ o ], "int32", c);
        return p.forEach(h => n.disposeData(h.dataId)), d;
    }
}, JU = {
    kernelName: ul,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s
        } = a, i = k.parseAxisParam(s, r.shape), l = C.getAxesPermutation(i, r.shape.length), o = r, p = [];
        l != null && (o = Va({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: l
            }
        }), p.push(o), i = C.getInnerMostAxes(i.length, o.shape.length)), C.assertAxesAreInnerMostDims("argMin", [ i[0] ], o.shape.length);
        let u = new Tw(o.shape, i[0], "min"), c = [ {
            type: "float32",
            data: [ Number.POSITIVE_INFINITY ]
        } ], d = n.runWebGPUProgram(u, [ o ], "int32", c);
        return p.forEach(h => n.disposeData(h.dataId)), d;
    }
}, QU = st({
    opType: oe.ASIN
}), eG = {
    kernelName: ys,
    backendName: "webgpu",
    kernelFunc: QU
}, tG = st({
    opType: oe.ASINH
}), nG = {
    kernelName: As,
    backendName: "webgpu",
    kernelFunc: tG
}, aG = st({
    opType: oe.ATAN
}), rG = {
    kernelName: xs,
    backendName: "webgpu",
    kernelFunc: aG
}, sG = jt({
    opType: Le.ATAN2
}), iG = {
    kernelName: vs,
    backendName: "webgpu",
    kernelFunc: sG
}, oG = st({
    opType: oe.ATANH
}), lG = {
    kernelName: bs,
    backendName: "webgpu",
    kernelFunc: oG
}, uG = class {
    constructor(e) {
        this.variableNames = [ "x" ], this.uniforms = "strides : vec2<i32>,", this.workgroupSize = [ 256, 1, 1 ], 
        this.size = !0, this.outputShape = e.outShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "poolWithFilterSizeEqualsOne";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
}, dp = class {
    constructor(e, t, n = !1, a = !1, r = !1) {
        if (this.variableNames = [ "x" ], this.uniforms = "strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,", 
        this.workgroupSize = [ 128, 1, 1 ], this.size = !0, t === "avg" && n) throw new Error("Cannot compute positions for average pool.");
        this.outputShape = e.outShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.poolType = t, this.computePositions = n, this.flattenPositions = a, 
        this.includeBatchIndex = r, this.shaderKey = `pool2D_${t}_${n}_${a}_${r}`;
    }
    getUserCode() {
        let e;
        e = this.poolType === "avg" ? "resultValue = resultValue + value; count = count + 1.0;" : this.computePositions ? `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d" : "wR * uniforms.filterDims.y + wC"};
      }` : "resultValue = max(value, resultValue);";
        let t = "resultValue";
        return this.poolType === "avg" && (t = "resultValue / max(count, 1.0)"), 
        `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t});`}
        }
      }
    `;
    }
}, O1 = class {
    constructor(e, t, n = !1, a = !1, r = !1) {
        if (this.variableNames = [ "x" ], this.uniforms = "strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,", 
        this.workgroupSize = [ 128, 1, 1 ], this.size = !0, t === "avg" && n) throw new Error("Cannot compute positions for average pool.");
        this.outputShape = e.outShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.poolType = t, this.computePositions = n, this.flattenPositions = a, 
        this.includeBatchIndex = r, this.shaderKey = `pool3D_${t}_${n}_${a}_${r}`;
    }
    getUserCode() {
        let e;
        e = this.poolType === "avg" ? "resultValue += value; count += 1.0;" : this.computePositions ? `let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions ? this.includeBatchIndex ? "(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch" : "wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }` : "resultValue = max(value, resultValue);";
        let t = "resultValue";
        return this.poolType === "avg" && (t = "resultValue / max(count, 1.0)"), 
        `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions ? `var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;` : `var resultValue = ${this.poolType === "avg" ? "0.0" : "-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions ? "setOutputAtIndexI32(index, maxPosition);" : `setOutputAtIndex(index, ${t});`}
        }
      }
    `;
    }
};

function Rw(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        reductionIndices: s,
        keepDims: i
    } = a;
    return zo(r, s, i, "max", n);
}

var dG = {
    kernelName: ci,
    backendName: "webgpu",
    kernelFunc: Rw
};

function Ew(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        keepDims: s,
        axis: i
    } = a;
    return zo(r, i, s, "mean", n);
}

var pG = {
    kernelName: mi,
    backendName: "webgpu",
    kernelFunc: Ew
};

function $w(e, t, n, a) {
    if (t.filterWidth === 1 && t.filterHeight === 1 && k.arraysEqual(t.inShape, t.outShape)) return jn({
        inputs: {
            x: e
        },
        backend: a
    });
    if (t.filterWidth === t.inWidth && t.filterHeight === t.inHeight && t.batchSize === 1 && t.padInfo.type === "VALID") {
        let i, l = e.shape.length, o = Ne({
            inputs: {
                x: e
            },
            backend: a,
            attrs: {
                shape: [ e.shape[l - 3] * e.shape[l - 2], e.shape[l - 1] ]
            }
        });
        n === "avg" ? i = Ew({
            inputs: {
                x: o
            },
            backend: a,
            attrs: {
                axis: 0,
                keepDims: !1
            }
        }) : (k.assert(n === "max", () => `Invalid pool type ${n}`), i = Rw({
            inputs: {
                x: o
            },
            backend: a,
            attrs: {
                reductionIndices: 0,
                keepDims: !1
            }
        }));
        let p = Ne({
            inputs: {
                x: i
            },
            backend: a,
            attrs: {
                shape: t.outShape
            }
        });
        return a.disposeData(o.dataId), a.disposeData(i.dataId), p;
    }
    let r, s = [ {
        type: "int32",
        data: [ t.strideHeight, t.strideWidth ]
    } ];
    return t.filterHeight === 1 && t.filterWidth === 1 ? r = new uG(t) : (n === "avg" ? r = new dp(t, "avg") : (k.assert(n === "max", () => `Invalid pool type ${n}`), 
    r = new dp(t, "max")), s.push({
        type: "int32",
        data: [ t.padInfo.top, t.padInfo.left ]
    }, {
        type: "int32",
        data: [ t.dilationHeight, t.dilationWidth ]
    }, {
        type: "int32",
        data: [ t.inHeight, t.inWidth ]
    }, {
        type: "int32",
        data: [ t.effectiveFilterHeight, t.effectiveFilterWidth ]
    })), a.runWebGPUProgram(r, [ e ], e.dtype, s);
}

var cG = {
    kernelName: ws,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o
        } = a;
        return $w(r, C.computePool2DInfo(r.shape, s, i, 1, l, o), "avg", n);
    }
}, hG = {
    kernelName: dl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p
        } = a, u = C.computePool3DInfo(r.shape, s, i, [ 1, 1, 1 ], l, p, o), c = new O1(u, "avg"), d = [ {
            type: "int32",
            data: [ u.strideDepth, u.strideHeight, u.strideWidth ]
        }, {
            type: "int32",
            data: [ u.padInfo.front, u.padInfo.top, u.padInfo.left ]
        }, {
            type: "int32",
            data: [ u.inDepth, u.inHeight, u.inWidth ]
        }, {
            type: "int32",
            data: [ u.effectiveFilterDepth, u.effectiveFilterHeight, u.effectiveFilterWidth ]
        } ];
        return n.runWebGPUProgram(c, [ r ], r.dtype, d);
    }
}, fG = class {
    constructor(e) {
        this.variableNames = [ "dy" ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e.inShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "avgPool2DBackprop";
    }
    getUserCode() {
        return `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
}, mG = class {
    constructor(e) {
        this.variableNames = [ "dy" ], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e.inShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "avgPool3DBackprop";
    }
    getUserCode() {
        return `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
}, gG = {
    kernelName: ju,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s, {
            filterSize: l,
            strides: o,
            pad: p,
            dimRoundingMode: u
        } = a, c = C.computePool3DInfo(i.shape, l, o, 1, p, u), d = new mG(c), h = 1 / (c.filterDepth * c.filterHeight * c.filterWidth), f = [ {
            type: "int32",
            data: [ c.strideDepth, c.strideHeight, c.strideWidth ]
        }, {
            type: "int32",
            data: [ c.effectiveFilterDepth - 1 - c.padInfo.front, c.effectiveFilterHeight - 1 - c.padInfo.top, c.effectiveFilterWidth - 1 - c.padInfo.left ]
        }, {
            type: "int32",
            data: [ c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth ]
        }, {
            type: "int32",
            data: [ c.outDepth ]
        }, {
            type: "int32",
            data: [ c.outHeight ]
        }, {
            type: "int32",
            data: [ c.outWidth ]
        }, {
            type: "float32",
            data: [ h ]
        } ];
        return n.runWebGPUProgram(d, [ r ], i.dtype, f);
    }
}, yG = {
    kernelName: Hu,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s;
        $1([ r, s ], "avgPoolGrad");
        let {
            filterSize: l,
            strides: o,
            pad: p
        } = a, u = C.computePool2DInfo(i.shape, l, o, 1, p), c = new fG(u), d = 1 / (u.filterHeight * u.filterWidth), h = [ {
            type: "int32",
            data: [ u.strideHeight, u.strideWidth ]
        }, {
            type: "int32",
            data: [ u.effectiveFilterHeight - 1 - u.padInfo.top, u.effectiveFilterWidth - 1 - u.padInfo.left ]
        }, {
            type: "int32",
            data: [ u.dilationHeight, u.dilationWidth ]
        }, {
            type: "int32",
            data: [ u.effectiveFilterHeight, u.effectiveFilterWidth ]
        }, {
            type: "int32",
            data: [ u.outHeight ]
        }, {
            type: "int32",
            data: [ u.outWidth ]
        }, {
            type: "float32",
            data: [ d ]
        } ];
        return n.runWebGPUProgram(c, [ r ], i.dtype, h);
    }
}, AG = {
    kernelName: ks,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            a: r,
            b: s
        } = t, {
            transposeA: i,
            transposeB: l
        } = a;
        return Qc({
            a: r,
            b: s,
            transposeA: i,
            transposeB: l,
            backend: n
        });
    }
}, xG = class {
    constructor(e, t) {
        this.variableNames = [ "source" ], this.workPerThread = 1, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = t, this.rank = t.length, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.workPerThread, 1, 1 ]), 
        this.start = e, this.uniforms = `start : ${Tt(e.length)}, `, this.shaderKey = "slice";
    }
    getUserCode() {
        let e, t = Tt(this.rank), n = function(a) {
            if (a === 1) return "sourceLoc";
            if (a <= 6) return P1.slice(0, a).map(r => `sourceLoc.${r}`).join(",");
            throw Error(`Slicing for rank ${a} is not yet supported`);
        }(this.rank);
        return e = this.start.length === 1 ? this.outputShape.map((a, r) => "sourceLoc = uniforms.start + coords;") : this.outputShape.map((a, r) => `sourceLoc.${P1[r]} = uniforms.start.${sr(r)} + coords.${P1[r]};`), 
        `
      ${le("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${e.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `;
    }
}, P1 = [ "x", "y", "z", "w", "u", "v" ];

function vu(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        begin: s,
        size: i
    } = a, [ l, o ] = St.parseSliceParams(r, s, i);
    if (St.assertParamsValid(r, l, o), n.shouldExecuteOnCPU([ r ]) || r.dtype === "string") {
        let c = n.tensorMap.get(r.dataId), d = CU(c.values, l, o, r.shape, r.dtype);
        return n.makeTensorInfo(o, r.dtype, d);
    }
    if (k.sizeFromShape(o) === 0) return n.makeTensorInfo(o, r.dtype, []);
    let p = new xG(l, o), u = [ {
        type: "int32",
        data: l
    } ];
    return n.runWebGPUProgram(p, [ r ], r.dtype, u);
}

var bG = {
    kernelName: Pl,
    backendName: "webgpu",
    kernelFunc: vu
}, vG = {
    kernelName: pl,
    backendName: "webgpu",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            crops: i
        } = a;
        k.assert(r.shape.length <= 4, () => "batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");
        let l = s.reduce((A, x) => A * x), o = C.getReshaped(r.shape, s, l), p = C.getPermuted(o.length, s.length), u = C.getReshapedPermuted(r.shape, s, l), c = C.getSliceBeginCoords(i, s.length), d = C.getSliceSize(u, i, s.length), h = [], f = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: o
            }
        }), m = Va({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                perm: p
            }
        }), g = Ne({
            inputs: {
                x: m
            },
            backend: n,
            attrs: {
                shape: u
            }
        }), y = vu({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                begin: c,
                size: d
            }
        });
        return h.push(f), h.push(m), h.push(g), h.forEach(A => n.disposeData(A.dataId)), 
        y;
    }
}, wG = `
  fn bincount_write(index: i32, value: f32) {
    ${Kr("&result[index]", "value", "float32")}
  }
`, Mw = class {
    constructor(e, t, n = !1) {
        this.outputShape = [], this.variableNames = [ "x" ], this.uniforms = "binCountSize : i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.atomic = !0, this.hasWeights = !0, 
        this.binaryOutput = !1, this.outputShape = e, this.rank = e.length, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.binaryOutput = n, n && (this.atomic = !1), this.hasWeights = t, this.hasWeights && this.variableNames.push("w"), 
        this.shaderKey = `bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`;
    }
    getUserCode() {
        return `
    ${this.binaryOutput ? `
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
` : wG}
  ${le("index")} {
    ${this.rank === 1 ? `if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(index)" : "1."};
        bincount_write(indexVal, value);
      }
    }` : `let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput ? 1 : this.hasWeights ? "getW(coord[0], coord[1])" : "1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;
    }
}, kG = {
    kernelName: Is,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = t, {
            size: i
        } = a, l = k.sizeFromShape(r.shape), o = k.sizeFromShape(s.shape) > 0, p = [ i ], u = s.dtype, c = Sn({
            backend: n,
            attrs: {
                shape: p,
                value: 0,
                dtype: u
            }
        }), d = new Mw([ l ], o), h = [ {
            type: "int32",
            data: [ i ]
        } ], f = o ? [ r, s ] : [ r ];
        return n.runWebGPUProgram(d, f, u, h, c);
    }
}, IG = class {
    constructor(e) {
        this.outputShape = [], this.variableNames = [ "s0", "s1" ], this.uniforms = "s0Size : i32, s1Size : i32, ", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = [ e ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "broadcastArgs";
    }
    getUserCode() {
        return `
  ${le("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;
    }
}, SG = {
    kernelName: hl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            s0: a,
            s1: r
        } = t;
        if (n.shouldExecuteOnCPU([ a, r ])) {
            let u = n.tensorMap.get(a.dataId), c = n.tensorMap.get(r.dataId), d = u.values, h = c.values, f = C.assertAndGetBroadcastShape(Array.from(d), Array.from(h));
            return n.makeTensorInfo([ f.length ], "int32", Int32Array.from(f));
        }
        let s = k.sizeFromShape(a.shape), i = k.sizeFromShape(r.shape), l = Math.max(s, i), o = new IG(l), p = [ {
            type: "int32",
            data: [ s ]
        }, {
            type: "int32",
            data: [ i ]
        } ];
        return n.runWebGPUProgram(o, [ a, r ], "int32", p);
    }
}, Fw = jt({
    opType: Le.NOT_EQUAL,
    dtype: "bool",
    cpuKernelImpl: vU
}), NG = {
    kernelName: wi,
    backendName: "webgpu",
    kernelFunc: Fw
};

function pp(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        input: a
    } = t;
    return jn({
        inputs: {
            x: n.tensorMap.get(a.dataId).complexTensorInfos.real
        },
        backend: n
    });
}

var CG = {
    kernelName: sd,
    backendName: "webgpu",
    kernelFunc: pp
}, TG = {
    kernelName: Ss,
    backendName: "webgpu",
    kernelFunc: function e(t) {
        let {
            inputs: n,
            backend: a,
            attrs: r
        } = t, {
            x: s
        } = n, {
            dtype: i
        } = r;
        if (i === "complex64") {
            if (s.dtype === "complex64") return jn({
                inputs: {
                    x: s
                },
                backend: a
            });
            let l = ka(s.shape), o = e({
                inputs: {
                    x: s
                },
                backend: a,
                attrs: {
                    dtype: "float32"
                }
            }), p = Do({
                inputs: {
                    real: o,
                    imag: l
                },
                backend: a
            });
            return l.dispose(), a.disposeData(o.dataId), p;
        }
        if (s.dtype === "complex64") {
            let l = pp({
                inputs: {
                    input: s
                },
                backend: a
            }), o = e({
                inputs: {
                    x: l
                },
                backend: a,
                attrs: {
                    dtype: i
                }
            });
            return a.disposeData(l.dataId), o;
        }
        if (!k.hasEncodingLoss(s.dtype, i)) {
            let l = jn({
                inputs: {
                    x: s
                },
                backend: a
            });
            return {
                dataId: l.dataId,
                shape: l.shape,
                dtype: i
            };
        }
        if (a.shouldExecuteOnCPU([ s ])) {
            let l = a.tensorMap.get(s.dataId).values, [ o, p, u ] = tU(l, s.shape, s.dtype, i);
            return a.makeTensorInfo(o, p, u);
        }
        if (i === "int32") return function(l, o) {
            let p = new bu(l.shape, oe.TO_INT), u = o.runWebGPUProgram(p, [ l ], "int32");
            return {
                dataId: u.dataId,
                shape: u.shape,
                dtype: u.dtype
            };
        }(s, a);
        if (i === "bool") {
            let l = a.makeTensorInfo([], "bool", k.getTypedArrayFromDType("bool", 1)), o = Fw({
                inputs: {
                    a: s,
                    b: l
                },
                backend: a
            });
            return a.disposeData(l.dataId), o;
        }
        throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`);
    }
}, RG = st({
    opType: oe.CEIL,
    cpuKernelImpl: nU
}), EG = {
    kernelName: Ns,
    backendName: "webgpu",
    kernelFunc: RG
}, $G = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.uniforms = "minVal : f32, maxVal : f32,", 
        this.workPerThread = 4, this.workgroupSize = [ 64, 1, 1 ], this.outputComponent = 4, 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.workPerThread, 1, 1 ]), 
        this.shaderKey = "clipVec4";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;
    }
}, MG = class {
    constructor(e) {
        this.variableNames = [ "A" ], this.uniforms = "minVal : f32, maxVal : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "clip";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;
    }
}, FG = {
    kernelName: xr,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s
        } = n, {
            clipValueMin: i,
            clipValueMax: l
        } = r, o = [ {
            type: "float32",
            data: [ i ]
        }, {
            type: "float32",
            data: [ l ]
        } ];
        return t = k.sizeFromShape(s.shape) % 4 == 0 ? new $G(s.shape) : new MG(s.shape), 
        a.runWebGPUProgram(t, [ s ], s.dtype, o);
    }
}, _G = class {
    constructor(e) {
        this.outputShape = [], this.variableNames = [ "real", "imag" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "complexAbs";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;
    }
};

function _w(e, t) {
    return {
        dataId: t.dataId,
        dtype: t.dtype,
        shape: e.shape
    };
}

var OG = {
    kernelName: Xu,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t, r = n.tensorMap.get(a.dataId), s = new _G(a.shape), i = [ _w(a, r.complexTensorInfos.real), _w(a, r.complexTensorInfos.imag) ];
        return n.runWebGPUProgram(s, i, i[0].dtype);
    }
}, PG = class {
    constructor(e) {
        this.uniforms = "", this.workPerThread = 1, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = C.computeOutShape(e, 1), this.variableNames = e.map((t, n) => `T${n}`), 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.workPerThread, 1, 1 ]), 
        this.offsetLength = e.length - 1;
        for (let t = 0; t < this.offsetLength; t++) this.uniforms += `offset${t} : i32,`;
        this.shaderKey = "concat";
    }
    getUserCode() {
        let e = [];
        if (this.offsetLength > 0) {
            e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");
            for (let a = 1; a < this.offsetLength; a++) e.push(`else if (yC < uniforms.offset${[ a ]}){ setOutputAtCoords(coords.x, coords.y, getT${a}(yR, yC - uniforms.offset${a - 1})); }`);
            let t = this.offsetLength, n = this.offsetLength - 1;
            e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`);
        } else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");
        return `
      ${le("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `;
    }
};

function th(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        input: a
    } = t;
    return jn({
        inputs: {
            x: n.tensorMap.get(a.dataId).complexTensorInfos.imag
        },
        backend: n
    });
}

var DG = {
    kernelName: nd,
    backendName: "webgpu",
    kernelFunc: th
};

function cp(e, t, n) {
    let a = e[0].dtype;
    if (a === "complex64") {
        let f = e.map(x => pp({
            inputs: {
                input: x
            },
            backend: n
        })), m = e.map(x => th({
            inputs: {
                input: x
            },
            backend: n
        })), g = cp(f, t, n), y = cp(m, t, n), A = Do({
            inputs: {
                real: g,
                imag: y
            },
            backend: n
        });
        return f.forEach(x => n.disposeData(x.dataId)), m.forEach(x => n.disposeData(x.dataId)), 
        n.disposeData(g.dataId), n.disposeData(y.dataId), A;
    }
    let r = n.shouldExecuteOnCPU(e);
    if (a === "string" && (r = !0), r) {
        let f = e.map(v => {
            let I = [ -1, k.sizeFromShape(v.shape.slice(t)) ];
            return Ne({
                inputs: {
                    x: v
                },
                backend: n,
                attrs: {
                    shape: I
                }
            });
        }), m = f.map(v => ({
            vals: n.readSync(v.dataId),
            shape: v.shape
        })), g = C.computeOutShape(f.map(v => v.shape), 1), y = f[0].shape[0] === 1, A = aU(m, g, a, y), x = C.computeOutShape(e.map(v => v.shape), t), b = n.makeTensorInfo(x, a, A);
        return f.forEach(v => n.disposeData(v.dataId)), b;
    }
    let s = n.device.limits.maxStorageBuffersPerShaderStage - 1;
    if (e.length > s) {
        let f = [];
        for (let g = 0; g < e.length; g += s) {
            let y = e.slice(g, g + s);
            f.push(cp(y, t, n));
        }
        let m = cp(f, t, n);
        for (let g of f) n.disposeData(g.dataId);
        return m;
    }
    let {
        tensors2D: i,
        outShape: l
    } = function(f, m, g) {
        let y = C.computeOutShape(f.map(A => A.shape), m);
        return {
            tensors2D: f.map(A => Ne({
                inputs: {
                    x: A
                },
                backend: g,
                attrs: {
                    shape: [ k.sizeFromShape(A.shape.slice(0, m)), k.sizeFromShape(A.shape.slice(m)) ]
                }
            })),
            outShape: y
        };
    }(e, t, n), o = i.map(f => f.shape), p = new PG(o), u = [], c = new Array(o.length - 1);
    if (c.length > 0) {
        c[0] = o[0][1], u.push({
            type: "int32",
            data: [ c[0] ]
        });
        for (let f = 1; f < c.length; f++) c[f] = c[f - 1] + o[f][1], u.push({
            type: "int32",
            data: [ c[f] ]
        });
    }
    let d = n.runWebGPUProgram(p, i, i[0].dtype, u);
    i.forEach(f => n.disposeData(f.dataId));
    let h = Ne({
        inputs: {
            x: d
        },
        backend: n,
        attrs: {
            shape: l
        }
    });
    return n.disposeData(d.dataId), h;
}

function Ow(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        axis: r
    } = a, s = k.parseAxisParam(r, t[0].shape)[0], i = t.map(p => p.shape);
    C.assertParamsConsistent(i, s);
    let l = C.computeOutShape(t.map(p => p.shape), s);
    if (k.sizeFromShape(l) === 0) return n.makeTensorInfo(l, t[0].dtype, []);
    let o = t.filter(p => k.sizeFromShape(p.shape) > 0);
    return o.length === 1 ? jn({
        inputs: {
            x: o[0]
        },
        backend: n
    }) : cp(o, s, n);
}

var zG = {
    kernelName: fl,
    backendName: "webgpu",
    kernelFunc: Ow
}, LG = class {
    constructor(e, t, n, a, r = !1, s = null, i = !1, l = !1) {
        this.variableNames = [ "x", "W" ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", 
        this.outputShape = e.outShape, this.isChannelsLast = e.dataFormat === "channelsLast", 
        this.isVec4 = ((e.inChannels % 4 == 0 || e.inChannels % 3 == 0) && this.isChannelsLast || e.outWidth % 4 == 0 && !this.isChannelsLast) && e.outChannels % 4 == 0, 
        this.dispatchLayout = this.isChannelsLast ? {
            x: [ 3 ],
            y: [ 1, 2 ],
            z: [ 0 ]
        } : {
            x: [ 2, 3 ],
            y: [ 1 ],
            z: [ 0 ]
        }, this.workgroupSize = C1(this.dispatchLayout, this.outputShape, this.isVec4), 
        this.elementsPerThread = T1(this.dispatchLayout, this.outputShape, this.isVec4), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), 
        this.isVec4 ? (this.outputComponent = 4, this.isChannelsLast && e.inChannels % 4 != 0 ? (this.innerElementSize = 3, 
        this.variableComponents = [ 1, 4 ]) : (this.innerElementSize = 4, this.variableComponents = [ 4, 4 ]), 
        r && (this.variableNames.push("bias"), this.variableComponents.push(4)), 
        i && (this.variableNames.push("preluActivationWeights"), this.variableComponents.push(4))) : (this.innerElementSize = this.elementsPerThread[0], 
        r && this.variableNames.push("bias"), i && this.variableNames.push("preluActivationWeights")), 
        this.sequentialAccessByThreads = l, this.addBias = r, this.activation = s, 
        this.hasPreluActivationWeights = i, this.tileAOuter = this.workgroupSize[1] * this.elementsPerThread[1], 
        this.tileBOuter = this.workgroupSize[0] * this.elementsPerThread[0], this.tileInner = Math.max(this.workgroupSize[0] * this.innerElementSize, this.workgroupSize[1]), 
        this.fitAOuter = t % this.tileAOuter == 0, this.fitBOuter = n % this.tileBOuter == 0, 
        this.fitInner = a % this.tileInner == 0, this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`;
    }
    getUserCode() {
        let e = this.isVec4 ? Yc(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner) : Jc(this.elementsPerThread, this.workgroupSize, !this.isChannelsLast, this.tileInner, !1, null, this.sequentialAccessByThreads), t = this.isVec4 ? [ this.innerElementSize, 4, 4 ] : [ 1, 1, 1 ];
        return `
    ${function(n, a, r, s, i = !1, l = null, o = !1, p = 4, u = 4, c = 4) {
            let d = n ? `
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `, h = n ? `
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      ` : `
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `, f = n ? "uniforms.xShape[1]" : "uniforms.xShape[2]", m = n ? "uniforms.xShape[2]" : "uniforms.xShape[3]", g = n ? "row" : "col", y = n ? "col" : "row", A = `
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${y} % inChannels;
      var resData = ${Je(p)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${m}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${(T => {
                switch (T) {
                  case 1:
                    return "resData = f32(x[xIndex]);";

                  case 3:
                    return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";

                  case 4:
                    return "resData = vec4<f32>(x[xIndex / 4]);";

                  default:
                    throw new Error(`innerElementSize ${T} is not supported.`);
                }
            })(p)}
      }
      return resData;`, x = n ? a && s ? `
      ${A}` : `
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${A}
      }
      return ${Je(p)}(0.0);` : s && r ? `
      ${A}` : `
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${A}
      }
      return ${Je(p)}(0.0);`, b = `${(T => {
                switch (T) {
                  case 1:
                    return "return f32(W[row * uniforms.wShape[3] + col]);";

                  case 4:
                    return "return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";

                  default:
                    throw new Error(`innerElementSize ${T} is not supported.`);
                }
            })(u)}`, v = Je(c), I = Je(n ? p : u), N = Je(n ? u : p);
            return `
      ${ir(l, o, c === 4, 4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${I} {
        ${n ? x : b}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${N} {
        ${n ? b : x}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${v}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n ? "uniforms.outShape[2]" : "uniforms.outShape[3]"};
        ${h}
        ${Po(i, l)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;
        }(this.isChannelsLast, this.fitAOuter, this.fitBOuter, this.fitInner, this.addBias, this.activation, this.hasPreluActivationWeights, t[0], t[1], t[2])}
    ${e}
  `;
    }
}, WG = class {
    constructor(e, t = !1, n = null, a = !1) {
        this.variableNames = [ "x", "W" ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,", 
        this.workgroupSize = [ 4, 4, 8 ], this.outputShape = e.outShape, this.isChannelsLast = e.dataFormat === "channelsLast", 
        this.dispatchLayout = this.isChannelsLast ? {
            x: [ 2 ],
            y: [ 1 ],
            z: [ 0, 3 ]
        } : {
            x: [ 3 ],
            y: [ 2 ],
            z: [ 0, 1 ]
        }, this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.addBias = t, this.activation = n, this.hasPreluActivationWeights = a, 
        t && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), 
        this.shaderKey = `conv2dnaive_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
        return `
       ${ir(this.activation, this.hasPreluActivationWeights, !1, 4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast ? "vec4<i32>(batch, row, col, chan);" : "vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Po(this.addBias, this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${le("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast ? "coords[3];" : "coords[1];"}
         let outRow = ${this.isChannelsLast ? "coords[1];" : "coords[2];"}
         let outCol = ${this.isChannelsLast ? "coords[2];" : "coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast ? "uniforms.xShape[3];" : "uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast ? "let v = readInp(batch, xRow, xCol, xChannel);" : "let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;
    }
}, BG = class {
    constructor(e, t) {
        this.variableNames = [ "x" ], this.uniforms = `pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`, this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.isChannelsLast = t, this.shaderKey = `im2col_${this.isChannelsLast}`;
    }
    getUserCode() {
        let e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, n = this.isChannelsLast ? "coords[1]" : "coords[2]", a = this.isChannelsLast ? "coords[2]" : "coords[1]", r = this.isChannelsLast ? "getX(batch, xRow, xCol, ch)" : "getX(batch, ch, xRow, xCol)";
        return `
    ${le("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n};
        let col = ${a};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${r};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;
    }
};

function nh(e, t) {
    let n = e.length;
    return n >= 3 ? t ? [ ...e.slice(0, -3), e[n - 3] * e[n - 2], e[n - 1] ] : [ ...e.slice(0, -3), e[n - 3], e[n - 2] * e[n - 1] ] : !t && n === 1 && e[0] > 1 ? [ e[0], 1 ] : null;
}

function Pw({
    x: e,
    filter: t,
    convInfo: n,
    backend: a,
    bias: r = null,
    preluActivationWeights: s = null,
    leakyreluAlpha: i = 0,
    activation: l = null
}) {
    let o = r != null, p = s != null, u = n.dataFormat === "channelsLast", c = u && n.filterHeight === n.inHeight && n.filterWidth === n.inWidth && n.padInfo.type === "VALID", d = H().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");
    if (!d && (c || n.filterHeight === 1 && n.filterWidth === 1 && n.dilationHeight === 1 && n.dilationWidth === 1 && n.strideHeight === 1 && n.strideWidth === 1 && (n.padInfo.type === "SAME" || n.padInfo.type === "VALID"))) return function({
        x: I,
        filter: N,
        convInfo: T,
        backend: R,
        bias: w = null,
        preluActivationWeights: E = null,
        leakyreluAlpha: $ = 0,
        activation: M = null
    }) {
        let F, P, L = T.dataFormat === "channelsLast", O = !L, B = [];
        if (L && T.filterHeight === T.inHeight && T.filterWidth === T.inWidth && T.padInfo.type === "VALID") {
            let z = T.inHeight * T.inWidth * T.inChannels;
            F = Ne({
                inputs: {
                    x: I
                },
                backend: R,
                attrs: {
                    shape: [ 1, T.batchSize, z ]
                }
            }), P = Ne({
                inputs: {
                    x: N
                },
                backend: R,
                attrs: {
                    shape: [ 1, z, T.outChannels ]
                }
            });
        } else F = Ne({
            inputs: {
                x: I
            },
            backend: R,
            attrs: {
                shape: L ? [ T.batchSize, T.inHeight * T.inWidth, T.inChannels ] : [ T.batchSize, T.inChannels, T.inHeight * T.inWidth ]
            }
        }), P = Ne({
            inputs: {
                x: N
            },
            backend: R,
            attrs: {
                shape: [ 1, T.inChannels, T.outChannels ]
            }
        });
        if (B.push(F), B.push(P), E != null) {
            let z = nh(E.shape, L);
            z != null && (E = Ne({
                inputs: {
                    x: E
                },
                backend: R,
                attrs: {
                    shape: z
                }
            }), B.push(E));
        }
        if (w != null) {
            let z = nh(w.shape, L);
            z != null && (w = Ne({
                inputs: {
                    x: w
                },
                backend: R,
                attrs: {
                    shape: z
                }
            }), B.push(w));
        }
        let G = Qc({
            a: L ? F : P,
            b: L ? P : F,
            transposeA: O,
            transposeB: !1,
            backend: R,
            bias: w,
            activation: M,
            preluActivationWeights: E,
            leakyreluAlpha: $
        }), W = Ne({
            inputs: {
                x: G
            },
            backend: R,
            attrs: {
                shape: T.outShape
            }
        });
        B.push(G);
        for (let z of B) R.disposeData(z.dataId);
        return W;
    }({
        x: e,
        filter: t,
        convInfo: n,
        backend: a,
        bias: r,
        activation: l,
        preluActivationWeights: s,
        leakyreluAlpha: i
    });
    let h = H().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"), f = h > -1 ? h : a.thresholdToIncreaseWorkgroups, m = n.batchSize * Math.ceil(n.outHeight * n.outWidth / 32) * Math.ceil(n.outChannels / 32);
    if (H().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER") || m <= f) return function({
        x: I,
        filter: N,
        convInfo: T,
        backend: R,
        bias: w = null,
        preluActivationWeights: E = null,
        leakyreluAlpha: $ = 0,
        activation: M = null
    }) {
        let {
            filterWidth: F,
            filterHeight: P,
            inChannels: L,
            strideWidth: O,
            strideHeight: B,
            padInfo: G,
            outWidth: W,
            outHeight: z,
            dilationWidth: X,
            dilationHeight: q,
            dataFormat: Z
        } = T, Y = Z === "channelsLast", te = F * P * L, re = z * W, pe = Y ? [ T.batchSize, re, te ] : [ T.batchSize, te, re ], ge = new BG(pe, Y), Re = [ {
            type: "int32",
            data: [ G.top, G.left ]
        }, {
            type: "int32",
            data: [ B, O ]
        }, {
            type: "int32",
            data: [ q, X ]
        }, {
            type: "int32",
            data: [ W ]
        }, {
            type: "int32",
            data: [ L * F ]
        }, {
            type: "int32",
            data: [ L ]
        } ], ye = R.runWebGPUProgram(ge, [ I ], I.dtype, Re), Me = [];
        Me.push(ye);
        let Ee = Ne({
            inputs: {
                x: N
            },
            backend: R,
            attrs: {
                shape: [ 1, te, -1 ]
            }
        });
        if (Me.push(Ee), E != null) {
            let we = nh(E.shape, Y);
            we != null && (E = Ne({
                inputs: {
                    x: E
                },
                backend: R,
                attrs: {
                    shape: we
                }
            }), Me.push(E));
        }
        if (w != null) {
            let we = nh(w.shape, Y);
            we != null && (w = Ne({
                inputs: {
                    x: w
                },
                backend: R,
                attrs: {
                    shape: we
                }
            }), Me.push(w));
        }
        let me = Qc({
            a: Y ? ye : Ee,
            b: Y ? Ee : ye,
            transposeA: !Y,
            transposeB: !1,
            backend: R,
            bias: w,
            activation: M,
            preluActivationWeights: E,
            leakyreluAlpha: $
        }), Oe = Ne({
            inputs: {
                x: me
            },
            backend: R,
            attrs: {
                shape: T.outShape
            }
        });
        Me.push(me);
        for (let we of Me) R.disposeData(we.dataId);
        return Oe;
    }({
        x: e,
        filter: t,
        convInfo: n,
        backend: a,
        bias: r,
        preluActivationWeights: s,
        leakyreluAlpha: i,
        activation: l
    });
    let g, y = [ n.padInfo.top, n.padInfo.left ], A = [ {
        type: "int32",
        data: [ n.filterHeight, n.filterWidth ]
    }, {
        type: "int32",
        data: [ ...y ]
    }, {
        type: "int32",
        data: [ n.strideHeight, n.strideWidth ]
    }, {
        type: "int32",
        data: [ n.dilationHeight, n.dilationWidth ]
    } ];
    if (d) g = new WG(n, o, l, p); else {
        let I = u ? n.outHeight * n.outWidth : n.outChannels, N = u ? n.outChannels : n.outHeight * n.outWidth, T = n.filterHeight * n.filterWidth * n.inChannels;
        A.push({
            type: "int32",
            data: [ I ]
        }, {
            type: "int32",
            data: [ N ]
        }, {
            type: "int32",
            data: [ T ]
        });
        let R = a.adapterInfo.isIntel();
        g = new LG(n, I, N, T, o, l, p, R);
    }
    let x = [], b = [ e, t ];
    o && (!u && r.shape.length === 1 && (r = Ne({
        inputs: {
            x: r
        },
        backend: a,
        attrs: {
            shape: [ r.shape[0], 1, 1 ]
        }
    }), x.push(r)), b.push(r)), p && (!u && s.shape.length === 1 && (s = Ne({
        inputs: {
            x: s
        },
        backend: a,
        attrs: {
            shape: [ s.shape[0], 1, 1 ]
        }
    }), x.push(s)), b.push(s)), l === "leakyrelu" && (A.push({
        type: "float32",
        data: [ i ]
    }), g.uniforms += " alpha : f32,");
    let v = a.runWebGPUProgram(g, b, e.dtype, A);
    for (let I of x) a.disposeData(I.dataId);
    return v;
}

var VG = {
    kernelName: Cs,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            attrs: n,
            backend: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dataFormat: o,
            dilations: p,
            dimRoundingMode: u
        } = n, c = C.convertConv2DDataFormat(o);
        return Pw({
            x: r,
            filter: s,
            convInfo: C.computeConv2DInfo(r.shape, s.shape, i, p, l, u, !1, c),
            backend: a
        });
    }
}, UG = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !1, this.isVec4 = !1, this.workPerThread = 1, 
        this.outputShape = e.inShape, this.isChannelsLast = e.dataFormat === "channelsLast", 
        this.isVec4 = this.isChannelsLast && e.outChannels % 4 == 0 && e.inChannels % 4 == 0, 
        this.isVec4 ? (this.workPerThread = 2, this.outputComponent = 4, this.workgroupSize = [ 4, 4, 4 ], 
        this.dispatchLayout = {
            x: [ 3 ],
            y: [ 2 ],
            z: [ 0, 1 ]
        }, this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ 4, this.workPerThread, 1 ])) : (this.size = !0, 
        this.workPerThread = 1, this.workgroupSize = [ 64, 1, 1 ], this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize)), 
        this.shaderKey = `conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`;
    }
    getUserCode() {
        let e = this.isChannelsLast ? 1 : 2, t = this.isChannelsLast ? 2 : 3, n = this.isChannelsLast ? 3 : 1, a = `
    ${le()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;
        return this.isVec4 ? `
    ${a}
    ` : `
    ${le("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast ? "getDy(batch, idyR, idyC, d2)" : "getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
}, GG = class {
    constructor(e) {
        this.variableNames = [ "x", "dy" ], this.uniforms = "pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e.filterShape, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.isChannelsLast = e.dataFormat === "channelsLast", this.shaderKey = `conv2DDerFilter_${this.isChannelsLast}`;
    }
    getUserCode() {
        return `
    ${le("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
}, HG = class {
    constructor(e) {
        this.variableNames = [ "x", "dy" ], this.uniforms = `pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`, 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e.filterShape, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "conv3DDerFilter";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
}, jG = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.uniforms = `filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e.inShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "conv3DDerInput";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `;
    }
}, qG = {
    kernelName: Ku,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p,
            filterShape: u
        } = a, c = C.convertConv2DDataFormat(o), d = C.computeConv2DInfo(r.shape, u, i, 1, l, p, !1, c), h = new GG(d), f = [ {
            type: "int32",
            data: [ d.padInfo.top, d.padInfo.left ]
        }, {
            type: "int32",
            data: [ d.strideHeight, d.strideWidth ]
        }, {
            type: "int32",
            data: [ d.batchSize ]
        }, {
            type: "int32",
            data: [ d.outHeight ]
        }, {
            type: "int32",
            data: [ d.outWidth ]
        }, {
            type: "int32",
            data: [ d.inHeight ]
        }, {
            type: "int32",
            data: [ d.inWidth ]
        } ];
        return n.runWebGPUProgram(h, [ r, s ], r.dtype, f);
    }
}, XG = class {
    constructor(e) {
        this.variableNames = [ "x", "W" ], this.uniforms = "filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,", 
        this.outputShape = e.inShape, k.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), 
        this.isVec4 = e.inChannels % 4 == 0 && e.outChannels % 4 == 0, this.dispatchLayout = {
            x: [ 3 ],
            y: [ 1, 2 ],
            z: [ 0 ]
        }, this.workgroupSize = C1(this.dispatchLayout, this.outputShape, this.isVec4), 
        this.elementsPerThread = T1(this.dispatchLayout, this.outputShape, this.isVec4), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, this.elementsPerThread), 
        this.isVec4 && (this.outputComponent = 4, this.variableComponents = [ 4, 1 ]), 
        this.shaderKey = `conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`;
    }
    getUserCode() {
        let e = this.isVec4 ? Yc(this.elementsPerThread, this.workgroupSize) : Jc(this.elementsPerThread, this.workgroupSize);
        return `
    ${function(t = 4) {
            let n = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${Je(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${Je(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];
      }
      return ${Je(t)}(0.0);`;
            return `
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${Je(t)} {
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${Je(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${(a => {
                switch (a) {
                  case 1:
                    return "return W[getIndexFromCoords4D(coord, uniforms.wShape)];";

                  case 4:
                    return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;

                  default:
                    throw new Error(`innerElementSize ${a} is not supported.`);
                }
            })(t)}
    }
    return ${Je(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${Je(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`;
        }(this.isVec4 ? 4 : 1)}
    ${e}
    `;
    }
}, KG = {
    kernelName: Ts,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            dy: s,
            filter: i
        } = n, {
            inputShape: l,
            strides: o,
            pad: p,
            dataFormat: u,
            dimRoundingMode: c
        } = r, d = C.convertConv2DDataFormat(u), h = C.computeConv2DInfo(l, i.shape, o, 1, p, c, !1, d), f = [ {
            type: "int32",
            data: [ h.filterHeight, h.filterWidth ]
        }, {
            type: "int32",
            data: [ h.filterHeight - 1 - h.padInfo.top, h.filterWidth - 1 - h.padInfo.left ]
        }, {
            type: "int32",
            data: [ h.strideHeight, h.strideWidth ]
        }, {
            type: "int32",
            data: [ h.batchSize, h.outHeight, h.outWidth, h.outChannels ]
        } ];
        if (H().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE") || h.dataFormat !== "channelsLast") t = new UG(h); else {
            t = new XG(h);
            let m = h.inHeight * h.inWidth, g = h.inChannels, y = h.filterHeight * h.filterWidth * h.outChannels;
            f.push({
                type: "uint32",
                data: [ m ]
            }, {
                type: "uint32",
                data: [ g ]
            }, {
                type: "uint32",
                data: [ y ]
            });
        }
        return a.runWebGPUProgram(t, [ s, i ], "float32", f);
    }
}, ZG = class {
    constructor(e) {
        this.variableNames = [ "x", "W" ], this.uniforms = "filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e.outShape, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "conv3dnaive";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;
    }
}, YG = {
    kernelName: Rs,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o
        } = a, p = C.computeConv3DInfo(r.shape, s.shape, i, o, l), u = [ p.padInfo.front, p.padInfo.top, p.padInfo.left ], c = [ {
            type: "int32",
            data: [ p.filterDepth, p.filterHeight, p.filterWidth ]
        }, {
            type: "int32",
            data: [ ...u ]
        }, {
            type: "int32",
            data: [ p.strideDepth, p.strideHeight, p.strideWidth ]
        }, {
            type: "int32",
            data: [ p.dilationDepth, p.dilationHeight, p.dilationWidth ]
        } ], d = new ZG(p), h = Zt(r.dtype, s.dtype);
        return n.runWebGPUProgram(d, [ r, s ], h, c);
    }
}, JG = {
    kernelName: ml,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            pad: l,
            filterShape: o
        } = a, p = C.computeConv3DInfo(r.shape, o, i, 1, l), u = new HG(p), c = [ {
            type: "int32",
            data: [ p.padInfo.front, p.padInfo.top, p.padInfo.left ]
        }, {
            type: "int32",
            data: [ p.strideDepth, p.strideHeight, p.strideWidth ]
        }, {
            type: "int32",
            data: [ p.batchSize ]
        }, {
            type: "int32",
            data: [ p.outDepth ]
        }, {
            type: "int32",
            data: [ p.outHeight ]
        }, {
            type: "int32",
            data: [ p.outWidth ]
        }, {
            type: "int32",
            data: [ p.inDepth ]
        }, {
            type: "int32",
            data: [ p.inHeight ]
        }, {
            type: "int32",
            data: [ p.inWidth ]
        } ];
        return n.runWebGPUProgram(u, [ r, s ], s.dtype, c);
    }
}, hp, QG = {
    kernelName: Es,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            inputShape: o
        } = a, p = C.computeConv3DInfo(o, s.shape, i, 1, l), u = new jG(p), c = [ {
            type: "int32",
            data: [ p.filterDepth, p.filterHeight, p.filterWidth ]
        }, {
            type: "int32",
            data: [ p.filterDepth - 1 - p.padInfo.front, p.filterHeight - 1 - p.padInfo.top, p.filterWidth - 1 - p.padInfo.left ]
        }, {
            type: "int32",
            data: [ p.strideDepth, p.strideHeight, p.strideWidth ]
        }, {
            type: "int32",
            data: [ p.outDepth ]
        }, {
            type: "int32",
            data: [ p.outHeight ]
        }, {
            type: "int32",
            data: [ p.outWidth ]
        }, {
            type: "int32",
            data: [ p.outChannels ]
        } ];
        return n.runWebGPUProgram(u, [ r, s ], r.dtype, c);
    }
}, eH = st({
    opType: oe.COS
}), tH = {
    kernelName: $s,
    backendName: "webgpu",
    kernelFunc: eH
}, nH = st({
    opType: oe.COSH
}), aH = {
    kernelName: Ms,
    backendName: "webgpu",
    kernelFunc: nH
}, rH = class {
    constructor(e, t, n, a) {
        this.variableNames = [ "Image", "Boxes", "BoxInd" ], this.uniforms = "extrapolationValue : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0;
        let [ r ] = t;
        this.outputShape = [ r, n[0], n[1], e ], this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.methodId = a === "bilinear" ? 1 : 0, this.cropHeightBiggerThan1 = this.outputShape[1] > 1, 
        this.cropWidthBiggerThan1 = this.outputShape[2] > 1, this.shaderKey = `cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;
    }
    getUserCode() {
        let [ e, t ] = [ "f32(uniforms.imageShape[1] - 1)", "f32(uniforms.imageShape[2] - 1)" ], [ n, a, r ] = this.cropHeightBiggerThan1 ? [ `(${e} / f32(uniforms.outShape[1] - 1))`, "(y2-y1) * height_ratio", `y1*${e} + f32(y)*(height_scale)` ] : [ "0.0", "0.0", `0.5 * (y1+y2) * ${e}` ], [ s, i, l ] = this.cropWidthBiggerThan1 ? [ `(${t} / f32(uniforms.outShape[2] - 1))`, "(x2-x1) * width_ratio", `x1*${t} + f32(x)*(width_scale)` ] : [ "0.0", "0.0", `0.5 * (x1+x2) * ${t}` ];
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${s});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${a};
        let width_scale = ${i};
        let in_y = ${r};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;
    }
}, sH = {
    kernelName: Os,
    backendName: "webgpu",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r,
            boxes: s,
            boxInd: i
        } = t, {
            cropSize: l,
            method: o,
            extrapolationValue: p
        } = a, u = new rH(r.shape[3], s.shape, l, o), c = [ {
            type: "float32",
            data: [ p ]
        } ];
        return n.runWebGPUProgram(u, [ r, s, i ], "float32", c);
    }
};

(function(e) {
    e.Prod = "*", e.Sum = "+";
})(hp || (hp = {}));

var Dw = class {
    constructor(e, t, n, a) {
        this.variableNames = [ "x" ], this.uniforms = "index : f32,", this.size = !0, 
        this.workgroupSize = [ 128, 1, 1 ], this.outputShape = t, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.exclusive = n, this.reverse = a, this.op = e, this.shaderKey = `cum_${this.op}_${this.exclusive}_${this.reverse}`;
    }
    getUserCode() {
        let e = this.outputShape.length, t = this.op === hp.Prod ? "1.0" : "0.0", n = this.exclusive ? t : `getX(${zw(e, "coords", this.op)})`, a = this.outputShape[this.outputShape.length - 1], r = "", s = "";
        return this.exclusive ? (r = this.reverse ? "end != " + (a - 1) : "end != 0", 
        s = this.reverse ? "end + 1" : "end - 1") : (r = this.reverse ? `end + pow2 < ${a}` : "end >= pow2", 
        s = this.reverse ? "end + pow2" : "end - pow2"), `
      ${le("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${Lw(e, "coords", this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${r}) {
           let idx = ${s};
           ${Lw(e, "coords", this.op)} = idx;
           val ${this.op}= getX(${zw(e, "coords", this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `;
    }
};

function zw(e, t, n) {
    if (e === 1) return `${t}`;
    if (e === 2) return `${t}.x, ${t}.y`;
    if (e === 3) return `${t}.x, ${t}.y, ${t}.z`;
    if (e === 4) return `${t}.x, ${t}.y, ${t}.z, ${t}.w`;
    throw Error(`Cumulative ${n} for rank ${e} is not yet supported`);
}

function Lw(e, t, n) {
    if (e === 1) return `${t}`;
    if (e === 2) return `${t}.y`;
    if (e === 3) return `${t}.z`;
    if (e === 4) return `${t}.w`;
    throw Error(`Cumulative ${n} for rank ${e} is not yet supported`);
}

function Ww(e, t, n, a, r, s) {
    let i = t.shape.length, l = C.getAxesPermutation([ a ], i), o = t;
    l != null && (o = Va({
        inputs: {
            x: t
        },
        backend: n,
        attrs: {
            perm: l
        }
    }));
    let p = C.getInnerMostAxes(1, i)[0];
    if (p !== i - 1) throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length - 1} but got axis=${a}`);
    let u = o.shape[p], c = jn({
        inputs: {
            x: o
        },
        backend: n
    });
    for (let d = 0; d <= Math.ceil(Math.log2(u)) - 1; d++) {
        let h = new Dw(e, o.shape, !1, s), f = c, m = [ {
            type: "float32",
            data: [ d ]
        } ];
        c = n.runWebGPUProgram(h, [ c ], c.dtype, m), n.disposeData(f.dataId);
    }
    if (r) {
        let d = new Dw(e, o.shape, r, s), h = c, f = [ {
            type: "float32",
            data: [ 0 ]
        } ];
        c = n.runWebGPUProgram(d, [ c ], c.dtype, f), n.disposeData(h.dataId);
    }
    if (l != null) {
        let d = Va({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                perm: C.getUndoAxesPermutation(l)
            }
        });
        return n.disposeData(c.dataId), n.disposeData(o.dataId), d;
    }
    return c;
}

var iH = {
    kernelName: Fs,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a;
        return Ww(hp.Prod, r, n, s, i, l);
    }
}, oH = {
    kernelName: _s,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            exclusive: i,
            reverse: l
        } = a;
        return Ww(hp.Sum, r, n, s, i, l);
    }
}, lH = {
    kernelName: gl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            weights: s
        } = t, {
            size: i,
            binaryOutput: l
        } = a, o = r.shape.length === 1, p = k.sizeFromShape(s.shape) > 0, u = s.dtype, c = o ? [ r.shape[0] ] : [ r.shape[0], r.shape[1] ], d = Sn({
            backend: n,
            attrs: {
                shape: o ? [ i ] : [ r.shape[0], i ],
                value: 0,
                dtype: u
            }
        }), h = new Mw(c, p, l), f = [ {
            type: "int32",
            data: [ i ]
        } ], m = p ? [ r, s ] : [ r ];
        return n.runWebGPUProgram(h, m, u, f, d);
    }
}, uH = class {
    constructor(e, t) {
        this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.uniforms = "blockSize : i32,", this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = `depthToSpace_${t}`, this.dataFormat = t;
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;
    }
    getHeightCoordString() {
        return this.dataFormat === "NHWC" ? "coords[1]" : "coords[2]";
    }
    getWidthCoordString() {
        return this.dataFormat === "NHWC" ? "coords[2]" : "coords[3]";
    }
    getDepthCoordString() {
        return this.dataFormat === "NHWC" ? "coords[3]" : "coords[1]";
    }
    getOutputDepthSize() {
        return this.dataFormat === "NHWC" ? "uniforms.outShape[3]" : "uniforms.outShape[1]";
    }
    getInputSamplingString() {
        return this.dataFormat === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
    }
}, dH = {
    kernelName: Ps,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockSize: s,
            dataFormat: i
        } = a, l = r.shape[0], o = (i === "NHWC" ? r.shape[1] : r.shape[2]) * s, p = (i === "NHWC" ? r.shape[2] : r.shape[3]) * s, u = (i === "NHWC" ? r.shape[3] : r.shape[1]) / (s * s), c = [ {
            type: "int32",
            data: [ s ]
        } ], d = new uH(i === "NHWC" ? [ l, o, p, u ] : [ l, u, o, p ], i);
        return n.runWebGPUProgram(d, [ r ], r.dtype, c);
    }
}, pH = class {
    constructor(e, t, n, a = !1, r = null, s = !1) {
        this.variableNames = [ "x", "W" ], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>,", 
        this.workgroupSize = [ 16, 16, 1 ], this.outputShape = e, this.dispatchLayout = {
            x: [ 3 ],
            y: [ 2 ],
            z: [ 0, 1 ]
        }, this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        a && this.variableNames.push("bias"), s && this.variableNames.push("preluActivationWeights"), 
        this.addBias = a, this.activation = r, this.hasPreluActivation = s, this.filterHeight = t, 
        this.filterWidth = n, this.shaderKey = `depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`;
    }
    getUserCode() {
        let e = this.filterWidth * this.filterHeight, t = this.workgroupSize[0] * this.workgroupSize[1] * this.workgroupSize[2], n = this.workgroupSize[1] + this.filterHeight - 1, a = this.workgroupSize[0] + this.filterWidth - 1;
        return `
      ${ir(this.activation, this.hasPreluActivation, !1, 4)}

      var<workgroup> mm_Asub : array<array<f32, ${a}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${le()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${a}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e < t ? `if (wIndex < ${e})` : `for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Po(this.addBias, this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
}, Bw = class {
    constructor(e, t = !1, n = null, a = !1) {
        this.variableNames = [ "x", "W" ], this.uniforms = "pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.workPerThread = 4, this.outputComponent = 4, 
        this.outputShape = e.outShape, this.virtualWidth = Math.ceil(this.outputShape[2] / this.workPerThread) * this.workPerThread;
        let r = [ this.outputShape[0], this.outputShape[1], this.virtualWidth, this.outputShape[3] ];
        this.dispatchLayout = xe(r), this.dispatch = de(this.dispatchLayout, r, this.workgroupSize, [ this.outputComponent * this.workPerThread, 1, 1 ]), 
        k.assert(e.dataFormat === "channelsLast", () => "TODO: NCHW is unimplemented"), 
        t && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), 
        this.convInfo = e, this.addBias = t, this.activation = n, this.hasPreluActivation = a, 
        this.shaderKey = `depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`;
    }
    getUserCode() {
        let e = (this.workPerThread - 1) * this.convInfo.strideWidth + this.convInfo.filterWidth, t = this.convInfo.strideHeight, n = this.convInfo.strideWidth;
        return `
      ${ir(this.activation, this.hasPreluActivation, !0, 4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${le("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Po(this.addBias, this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;
    }
}, Vw = class {
    constructor(e, t = !1, n = null, a = !1) {
        this.variableNames = [ "x", "W" ], this.uniforms = `pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`, this.workgroupSize = [ 256, 1, 1 ], 
        this.size = !0, this.outputShape = e.outShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.isChannelsLast = e.dataFormat === "channelsLast", t && this.variableNames.push("bias"), 
        a && this.variableNames.push("preluActivationWeights"), this.convInfo = e, 
        this.addBias = t, this.activation = n, this.hasPreluActivation = a, this.shaderKey = `depthwise_${this.activation}_${this.isChannelsLast}`;
    }
    getUserCode() {
        let e = this.isChannelsLast ? "getX(batch, xR, xC, d1);" : "getX(batch, d1, xR, xC);";
        return `
      ${ir(this.activation, this.hasPreluActivation, !1, 4)}

      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast ? "yz" : "zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast ? 3 : 1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Po(this.addBias, this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;
    }
}, cH = {
    kernelName: Ds,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dataFormat: o,
            dilations: p,
            dimRoundingMode: u
        } = a, c = C.convertConv2DDataFormat(o), d = p;
        d == null && (d = [ 1, 1 ]);
        let h, f = C.computeConv2DInfo(r.shape, s.shape, i, d, l, u, !0, c), m = [ {
            type: "int32",
            data: [ f.padInfo.top, f.padInfo.left ]
        }, {
            type: "int32",
            data: [ f.inHeight, f.inWidth ]
        } ], g = f.dataFormat === "channelsLast";
        return !g && f.inHeight > 16 && f.inWidth > 16 && f.strideHeight === 1 && f.strideWidth === 1 && f.dilationWidth === 1 && f.dilationHeight === 1 && f.inChannels === f.outChannels ? h = new pH(f.outShape, f.filterHeight, f.filterWidth) : g && f.outHeight > 4 && f.outWidth > 4 && f.strideWidth <= 2 && f.inChannels === f.outChannels && f.dilationHeight === 1 && f.dilationWidth === 1 && f.inChannels % 4 == 0 ? (h = new Bw(f), 
        m.push({
            type: "int32",
            data: [ h.virtualWidth ]
        })) : (h = new Vw(f), m.push({
            type: "int32",
            data: [ f.filterHeight ]
        }, {
            type: "int32",
            data: [ f.filterWidth ]
        }, {
            type: "int32",
            data: [ f.strideHeight, f.strideWidth ]
        }, {
            type: "int32",
            data: [ f.dilationHeight, f.dilationWidth ]
        })), n.runWebGPUProgram(h, [ r, s ], r.dtype, m);
    }
}, hH = class {
    constructor(e) {
        this.variableNames = [ "x", "dy" ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`, 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e.filterShape, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "depthwise_conv2d_backprop_filter";
    }
    getUserCode() {
        return `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
}, fH = class {
    constructor(e) {
        this.variableNames = [ "dy", "W" ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e.inShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "depthwise_conv2d_backprop_input";
    }
    getUserCode() {
        return `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
}, mH = {
    kernelName: Zu,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            dy: s
        } = t, {
            strides: i,
            dilations: l,
            pad: o,
            dimRoundingMode: p,
            filterShape: u
        } = a, c = C.computeConv2DInfo(r.shape, u, i, l, o, p, !0), d = new hH(c), h = [ {
            type: "int32",
            data: [ c.strideHeight, c.strideWidth ]
        }, {
            type: "int32",
            data: [ c.padInfo.top, c.padInfo.left ]
        }, {
            type: "int32",
            data: [ c.filterHeight, c.filterWidth ]
        }, {
            type: "int32",
            data: [ c.outHeight ]
        }, {
            type: "int32",
            data: [ c.outWidth ]
        }, {
            type: "int32",
            data: [ c.inHeight ]
        }, {
            type: "int32",
            data: [ c.inWidth ]
        }, {
            type: "int32",
            data: [ c.batchSize ]
        }, {
            type: "int32",
            data: [ c.outChannels / c.inChannels ]
        } ];
        return n.runWebGPUProgram(d, [ r, s ], "float32", h);
    }
}, gH = {
    kernelName: Yu,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            filter: s
        } = t, {
            strides: i,
            dilations: l,
            pad: o,
            dimRoundingMode: p,
            inputShape: u
        } = a, c = C.computeConv2DInfo(u, s.shape, i, l, o, p, !0), d = new fH(c), h = [ {
            type: "int32",
            data: [ c.strideHeight, c.strideWidth ]
        }, {
            type: "int32",
            data: [ c.filterHeight - 1 - c.padInfo.top, c.filterWidth - 1 - c.padInfo.left ]
        }, {
            type: "int32",
            data: [ c.filterHeight, c.filterWidth ]
        }, {
            type: "int32",
            data: [ c.outHeight ]
        }, {
            type: "int32",
            data: [ c.outWidth ]
        }, {
            type: "int32",
            data: [ c.outChannels / c.inChannels ]
        } ];
        return n.runWebGPUProgram(d, [ r, s ], r.dtype, h);
    }
}, yH = class {
    constructor(e) {
        this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.outputShape = [ e, e ], this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "diag";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;
    }
}, AH = {
    kernelName: yl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t, r = [ ...a.shape, ...a.shape ], s = k.sizeFromShape(a.shape), i = Ne({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: [ s ]
            }
        }), l = new yH(s), o = n.runWebGPUProgram(l, [ i ], i.dtype), p = Ne({
            inputs: {
                x: o
            },
            backend: n,
            attrs: {
                shape: r
            }
        });
        return n.disposeData(i.dataId), n.disposeData(o.dataId), p;
    }
}, xH = class {
    constructor(e) {
        this.variableNames = [ "x", "w" ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e.outShape, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "dilation2d";
    }
    getUserCode() {
        return `
       ${le("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;
    }
}, bH = {
    kernelName: zs,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s
        } = t, {
            strides: i,
            pad: l,
            dilations: o
        } = a, p = C.computeDilation2DInfo(r.shape, s.shape, i, l, "NHWC", o), u = [ p.padInfo.top, p.padInfo.left ], c = [ {
            type: "int32",
            data: [ p.filterHeight, p.filterWidth ]
        }, {
            type: "int32",
            data: [ ...u ]
        }, {
            type: "int32",
            data: [ p.strideHeight, p.strideWidth ]
        }, {
            type: "int32",
            data: [ p.dilationHeight, p.dilationWidth ]
        } ], d = new xH(p);
        return n.runWebGPUProgram(d, [ r, s ], r.dtype, c);
    }
}, vH = class {
    constructor(e, t) {
        if (this.variableNames = [ "x", "w", "dy" ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.atomic = !0, this.outputShape = e.inShape, 
        this.dispatchLayout = xe(e.outShape), this.dispatch = de(this.dispatchLayout, e.outShape, this.workgroupSize), 
        t !== "float32" && t !== "int32") throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);
        this.type = t, this.shaderKey = "dilation2DBackpropInput";
    }
    getUserCode() {
        return `
       ${le("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Kr("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
}, wH = class {
    constructor(e, t, n) {
        if (this.variableNames = [ "x", "w", "dy" ], this.uniforms = "filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.atomic = !0, this.outputShape = e.filterShape, 
        this.dispatchLayout = xe(e.outShape), this.dispatch = de(this.dispatchLayout, e.outShape, this.workgroupSize), 
        n !== "float32" && n !== "int32") throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${n} type.`);
        this.type = n, this.shaderKey = "dilation2DBackpropFilter";
    }
    getUserCode() {
        return `
       ${le("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Kr("&result[flatIndexIn]", "value", this.type)}
         }
       }
     `;
    }
}, kH = {
    kernelName: xl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            dy: i
        } = t, {
            strides: l,
            pad: o,
            dilations: p
        } = a, u = C.computeDilation2DInfo(r.shape, s.shape, l, o, "NHWC", p), c = s.dtype, d = new wH(u, s.shape, c), h = [ {
            type: "int32",
            data: [ u.filterHeight, u.filterWidth ]
        }, {
            type: "int32",
            data: [ u.padInfo.top, u.padInfo.left ]
        }, {
            type: "int32",
            data: [ u.strideHeight, u.strideWidth ]
        }, {
            type: "int32",
            data: [ u.dilationHeight, u.dilationWidth ]
        }, {
            type: "int32",
            data: [ k.sizeFromShape(u.outShape) ]
        } ], f = Sn({
            backend: n,
            attrs: {
                shape: s.shape,
                value: 0,
                dtype: c
            }
        });
        return n.runWebGPUProgram(d, [ r, s, i ], c, h, f);
    }
}, IH = {
    kernelName: Al,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            dy: i
        } = t, {
            strides: l,
            pad: o,
            dilations: p
        } = a, u = C.computeDilation2DInfo(r.shape, s.shape, l, o, "NHWC", p), c = r.dtype, d = new vH(u, c), h = [ {
            type: "int32",
            data: [ u.filterHeight, u.filterWidth ]
        }, {
            type: "int32",
            data: [ u.padInfo.top, u.padInfo.left ]
        }, {
            type: "int32",
            data: [ u.strideHeight, u.strideWidth ]
        }, {
            type: "int32",
            data: [ u.dilationHeight, u.dilationWidth ]
        }, {
            type: "int32",
            data: [ k.sizeFromShape(u.outShape) ]
        } ], f = Sn({
            backend: n,
            attrs: {
                shape: u.inShape,
                value: 0,
                dtype: c
            }
        });
        return n.runWebGPUProgram(d, [ r, s, i ], c, h, f);
    }
}, SH = class {
    constructor(e, t, n) {
        this.variableNames = [ "Image" ], this.uniforms = "alpha: f32,", this.workgroupSize = [ 64, 1, 1 ], 
        this.pixelsOpType = xu.DRAW, this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.type = t, this.textureFormat = n, this.shaderKey = `draw_${t}_${n}`;
    }
    getUserCode() {
        let e, t = this.type === "float32" ? "value" : "value / 255.0";
        return e = `
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`, `
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${le("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `;
    }
}, NH = {
    kernelName: Ju,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            image: r
        } = t, {
            canvas: s,
            options: i
        } = a, [ l, o ] = r.shape.slice(0, 2), {
            imageOptions: p
        } = i || {}, u = (p == null ? void 0 : p.alpha) || 1, c = n.device.features.has("bgra8unorm-storage") ? "bgra8unorm" : "rgba8unorm", d = [ l, o ], h = new SH(d, r.dtype, c);
        s.width = o, s.height = l;
        let f, m = "webgpu", g = s.getContext(m);
        g || (f = new OffscreenCanvas(o, l), g = f.getContext(m));
        let y = r.shape.length === 3 ? r.shape[2] : 1;
        g.configure({
            device: n.device,
            format: c,
            usage: GPUTextureUsage.STORAGE_BINDING,
            alphaMode: "premultiplied"
        });
        let A = "int32", x = n.makeTensorInfo(d, A), b = n.tensorMap.get(x.dataId);
        b.resource = g.getCurrentTexture(), b.external = !0;
        let v = [ {
            type: "uint32",
            data: [ y ]
        }, {
            type: "float32",
            data: [ u ]
        } ];
        if (n.runWebGPUProgram(h, [ r ], A, v, x), f) {
            let I = s.getContext("2d");
            if (!I) throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");
            I.drawImage(f, 0, 0);
        }
        return n.disposeData(x.dataId), r;
    }
}, Uw = jt({
    opType: Le.MUL,
    cpuKernelImpl: xU,
    supportsComplex: !0
}), CH = {
    kernelName: vi,
    backendName: "webgpu",
    kernelFunc: Uw
};

function Gw(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        axis: s,
        keepDims: i
    } = a;
    return zo(r, s, i, "sum", n);
}

var TH = {
    kernelName: Xi,
    backendName: "webgpu",
    kernelFunc: Gw
}, RH = {
    kernelName: Qu,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            equation: r
        } = a, s = t, {
            allDims: i,
            summedDims: l,
            idDims: o
        } = C.decodeEinsumEquation(r, s.length);
        C.checkEinsumDimSizes(i.length, o, s);
        let {
            path: p,
            steps: u
        } = C.getEinsumComputePath(l, o), c = u.length, d = null, h = i.length, f = [];
        for (let m = 0; m < c; ++m) {
            for (let g of u[m]) {
                let y, {
                    permutationIndices: A,
                    expandDims: x
                } = C.getEinsumPermutation(h, o[g]);
                C.isIdentityPermutation(A) ? y = s[g] : (y = Va({
                    inputs: {
                        x: s[g]
                    },
                    backend: n,
                    attrs: {
                        perm: A
                    }
                }), f.push(y));
                let b = y.shape.slice();
                for (let v = 0; v < x.length; ++v) b.splice(x[v], 0, 1);
                k.arraysEqual(y.shape, b) || (y = Ne({
                    inputs: {
                        x: y
                    },
                    backend: n,
                    attrs: {
                        shape: b
                    }
                }), f.push(y)), d === null ? d = y : (d = Uw({
                    inputs: {
                        a: y,
                        b: d
                    },
                    backend: n
                }), f.push(d));
            }
            m < c - 1 && (p[m] >= 0 && (d = Gw({
                inputs: {
                    x: d
                },
                backend: n,
                attrs: {
                    axis: p[m] - (i.length - h),
                    keepDims: !1
                }
            }), f.push(d)), h--);
        }
        for (let m of f) m !== d && n.disposeData(m.dataId);
        return d;
    }
}, EH = st({
    opType: oe.ELU
}), $H = {
    kernelName: Ws,
    backendName: "webgpu",
    kernelFunc: EH
}, MH = {
    kernelName: bl,
    backendName: "webgpu",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n
        } = e, {
            dy: a,
            y: r
        } = t, s = new eh(Le.ELU_DER, a.shape, r.shape);
        return n.runWebGPUProgram(s, [ a, r ], a.dtype);
    }
}, FH = jt({
    opType: Le.EQUAL,
    dtype: "bool",
    cpuKernelImpl: rU
}), _H = {
    kernelName: Vs,
    backendName: "webgpu",
    kernelFunc: FH
}, OH = st({
    opType: oe.ERF
}), PH = {
    kernelName: Bs,
    backendName: "webgpu",
    kernelFunc: OH
}, DH = st({
    opType: oe.EXP,
    cpuKernelImpl: sU,
    dtype: "float32"
}), zH = {
    kernelName: Us,
    backendName: "webgpu",
    kernelFunc: DH
};

function D1(e) {
    let {
        inputs: t,
        attrs: n,
        backend: a
    } = e, {
        dim: r
    } = n, {
        input: s
    } = t, i = s.shape.length, l = s.shape.slice(), o = r;
    return r < 0 && (k.assert(-(i + 1) <= r, () => `Axis must be in the interval [${-(i + 1)}, ${i}]`), 
    o = i + r + 1), l.splice(o, 0, 1), Ne({
        inputs: {
            x: s
        },
        backend: a,
        attrs: {
            shape: l
        }
    });
}

var LH = {
    kernelName: vl,
    backendName: "webgpu",
    kernelFunc: D1
}, WH = st({
    opType: oe.EXPM1,
    cpuKernelImpl: iU
}), BH = {
    kernelName: Gs,
    backendName: "webgpu",
    kernelFunc: WH
}, Hw = class {
    constructor(e, t) {
        this.variableNames = [ "real", "imag" ], this.outputShape = [], this.uniforms = "exponentMultiplier : f32, denominator: f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = t, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.component = e, this.shaderKey = `fft_${e}`;
    }
    getUserCode() {
        return `
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component === "real" ? "return real * expR - imag * expI;" : "return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;
    }
};

function jw(e, t, n) {
    let a = n.tensorMap.get(e.dataId), r = k.sizeFromShape(e.shape), s = e.shape[e.shape.length - 1], i = [], l = Ne({
        inputs: {
            x: e
        },
        backend: n,
        attrs: {
            shape: [ r / s, s ]
        }
    });
    i.push(l);
    let o = l.shape, p = new Hw("real", o), u = new Hw("imag", o), c = [ {
        dataId: a.complexTensorInfos.real.dataId,
        dtype: a.complexTensorInfos.real.dtype,
        shape: o
    }, {
        dataId: a.complexTensorInfos.imag.dataId,
        dtype: a.complexTensorInfos.imag.dtype,
        shape: o
    } ], d = [ {
        type: "float32",
        data: [ t ? 2 * Math.PI : -2 * Math.PI ]
    }, {
        type: "float32",
        data: [ t ? o[1] : 1 ]
    } ], h = n.runWebGPUProgram(p, c, "float32", d);
    i.push(h);
    let f = n.runWebGPUProgram(u, c, "float32", d);
    i.push(f);
    let m = Do({
        inputs: {
            real: h,
            imag: f
        },
        backend: n
    });
    i.push(m);
    let g = Ne({
        inputs: {
            x: m
        },
        backend: n,
        attrs: {
            shape: e.shape
        }
    });
    return i.forEach(y => n.disposeData(y.dataId)), g;
}

var wu, VH = {
    kernelName: ed,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            input: a
        } = t;
        return jw(a, !1, n);
    }
}, UH = class {
    constructor(e) {
        this.outputShape = [], this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "flipLeftRight";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;
    }
}, GH = {
    kernelName: Hs,
    backendName: "webgpu",
    kernelFunc: ({
        inputs: e,
        backend: t
    }) => {
        let {
            image: n
        } = e, a = t, r = new UH(n.shape);
        return a.runWebGPUProgram(r, [ n ], n.dtype);
    }
}, HH = st({
    opType: oe.FLOOR,
    cpuKernelImpl: oU
}), jH = {
    kernelName: js,
    backendName: "webgpu",
    kernelFunc: HH
}, qH = jt({
    opType: Le.FLOOR_DIV,
    cpuKernelImpl: lU,
    dtype: "int32"
}), XH = {
    kernelName: qs,
    backendName: "webgpu",
    kernelFunc: qH
}, KH = class {
    constructor(e, t, n = !1) {
        this.pixelsOpType = xu.FROM_PIXELS, this.outputShape = [ 0 ], this.variableNames = [], 
        this.workgroupSize = [ 256, 1, 1 ], this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ t, 1, 1 ]), 
        this.importVideo = n, this.shaderKey = `fromPixels_${this.importVideo}`;
    }
    getUserCode() {
        let e = this.importVideo ? "textureLoad(src, vec2<i32>(coords.yx));" : "textureLoad(src, vec2<i32>(coords.yx), 0)";
        return `
      @binding(1) @group(0) var src: ${this.importVideo ? "texture_external" : "texture_2d<f32>"};
      ${le("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `;
    }
}, ZH = {
    kernelName: hd,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            pixels: r
        } = t, {
            numChannels: s
        } = a;
        if (r == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        let i = typeof HTMLVideoElement < "u" && r instanceof HTMLVideoElement, l = typeof HTMLImageElement < "u" && r instanceof HTMLImageElement, o = typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas, p = typeof ImageBitmap < "u" && r instanceof ImageBitmap, [ u, c ] = i ? [ r.videoWidth, r.videoHeight ] : [ r.width, r.height ], d = [ c, u, s ], h = H().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE") && i, f = i || l;
        if (p || o || f) {
            let A;
            if (h) A = n.device.importExternalTexture({
                source: r
            }); else {
                if (f) {
                    let E = H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
                    (wu == null || E !== z1) && (z1 = E, wu = document.createElement("canvas").getContext("2d", {
                        willReadFrequently: z1
                    })), wu.canvas.width = u, wu.canvas.height = c, wu.drawImage(r, 0, 0, u, c), 
                    r = wu.canvas;
                }
                let R = GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING, w = n.textureManager.acquireTexture(d[1], d[0], "rgba8unorm", R);
                n.queue.copyExternalImageToTexture({
                    source: r
                }, {
                    texture: w
                }, [ d[1], d[0] ]), A = w;
            }
            let x = k.sizeFromShape(d), b = k.computeStrides(d), v = new KH(d, s, h), I = [ {
                type: "uint32",
                data: [ x ]
            }, {
                type: "uint32",
                data: [ s ]
            }, {
                type: "uint32",
                data: [ ...b ]
            } ], N = n.makeTensorInfo([ c, u ], "int32");
            n.tensorMap.get(N.dataId).resource = A;
            let T = n.runWebGPUProgram(v, [ N ], "int32", I);
            return n.disposeData(N.dataId), T;
        }
        let m = r.data, g = m;
        if (s != null && s !== 4) {
            g = new Uint8Array(r.width * r.height * s);
            let A = m.length, x = 0;
            for (let b = 0; b < A; b++) b % 4 < s && (g[x++] = m[b]);
        }
        let y = n.makeTensorInfo(d, "int32", new Int32Array(g));
        return n.uploadToGPU(y.dataId), y;
    }
}, z1 = H().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"), YH = class {
    constructor(e, t, n, a, r) {
        this.uniforms = "varianceEpsilon : f32,", this.workgroupSize = [ 128, 1, 1 ], 
        this.size = !0, this.variableNames = [ "x", "mean", "variance" ], C.assertAndGetBroadcastShape(e, t), 
        C.assertAndGetBroadcastShape(e, n), this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        a != null && (C.assertAndGetBroadcastShape(e, a), this.variableNames.push("offset")), 
        r != null && (C.assertAndGetBroadcastShape(e, r), this.variableNames.push("scale")), 
        this.offsetShape = a, this.scaleShape = r, this.shaderKey = "batchNorm";
    }
    getUserCode() {
        let e = "0.0";
        this.offsetShape != null && (e = "getOffsetByOutputIndex(index)");
        let t = "1.0";
        return this.scaleShape != null && (t = "getScaleByOutputIndex(index)"), 
        `
      ${le("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;
    }
}, JH = {
    kernelName: Xs,
    backendName: "webgpu",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            x: a,
            scale: r,
            offset: s,
            mean: i,
            variance: l
        } = e, {
            varianceEpsilon: o
        } = t, p = n, u = [ a, i, l ], c = null;
        s != null && (c = s.shape, u.push(s));
        let d = null;
        r != null && (d = r.shape, u.push(r));
        let h = new YH(a.shape, i.shape, l.shape, c, d), f = [ {
            type: "float32",
            data: [ o ]
        } ];
        return p.runWebGPUProgram(h, u, a.dtype, f);
    }
}, QH = {
    kernelName: kr,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dataFormat: u,
            dilations: c,
            dimRoundingMode: d,
            activation: h,
            leakyreluAlpha: f
        } = a, m = C.convertConv2DDataFormat(u);
        return Pw({
            x: r,
            filter: s,
            convInfo: C.computeConv2DInfo(r.shape, s.shape, o, c, p, d, !1, m),
            backend: n,
            bias: i,
            preluActivationWeights: l,
            leakyreluAlpha: f,
            activation: h
        });
    }
}, ej = {
    kernelName: Ir,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            filter: s,
            bias: i,
            preluActivationWeights: l
        } = t, {
            strides: o,
            pad: p,
            dilations: u,
            dimRoundingMode: c,
            activation: d,
            leakyreluAlpha: h
        } = a, f = u;
        f == null && (f = [ 1, 1 ]), k.assert(C.eitherStridesOrDilationsAreOne(o, f), () => `Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);
        let m = C.computeConv2DInfo(r.shape, s.shape, o, f, p, c, !0), g = [ r, s ], y = i != null, A = l != null;
        y && g.push(i), A && g.push(l);
        let x, b = [ {
            type: "int32",
            data: [ m.padInfo.top, m.padInfo.left ]
        }, {
            type: "int32",
            data: [ m.inHeight, m.inWidth ]
        } ];
        return m.outHeight > 4 && m.outWidth > 4 && m.strideWidth <= 2 && m.inChannels === m.outChannels && m.dilationHeight === 1 && m.dilationWidth === 1 && m.inChannels % 4 == 0 ? (x = new Bw(m, y, d, A), 
        b.push({
            type: "int32",
            data: [ x.virtualWidth ]
        })) : (x = new Vw(m, y, d, A), b.push({
            type: "int32",
            data: [ m.filterHeight ]
        }, {
            type: "int32",
            data: [ m.filterWidth ]
        }, {
            type: "int32",
            data: [ m.strideHeight, m.strideWidth ]
        }, {
            type: "int32",
            data: [ m.dilationHeight, m.dilationWidth ]
        })), d === "leakyrelu" && (b.push({
            type: "float32",
            data: [ h ]
        }), x.uniforms += " alpha : f32,"), n.runWebGPUProgram(x, g, "float32", b);
    }
}, tj = class {
    constructor(e, t) {
        this.variableNames = [ "A", "indices" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = t, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = `gathernd_${e}`, this.sliceDim = e, this.uniforms = `sliceDim : i32, strides : ${Tt(e)},`;
    }
    getUserCode() {
        let e;
        return e = this.sliceDim > 1 ? "uniforms.strides[j]" : "uniforms.strides", 
        `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;
    }
}, nj = {
    kernelName: Ks,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            params: a,
            indices: r
        } = t, s = r.shape, i = s[s.length - 1], l = k.sizeFromShape(a.shape), [ o, p, u, c ] = C.prepareAndValidate(a, r), d = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ p, i ]
            }
        }), h = Ne({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: [ k.sizeFromShape(a.shape) / u, u ]
            }
        });
        if (n.shouldExecuteOnCPU([ a, r ]) || a.dtype === "string") {
            let A = n.readSync(r.dataId), x = n.bufferSync(a), b = uU(A, x, a.dtype, p, i, u, c, a.shape, l);
            return n.makeTensorInfo(o, a.dtype, b.values);
        }
        let f = new tj(i, [ p, u ]), m = [ {
            type: "int32",
            data: [ i ]
        }, {
            type: "int32",
            data: c
        } ], g = n.runWebGPUProgram(f, [ h, d ], h.dtype, m), y = Ne({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: o
            }
        });
        return n.disposeData(d.dataId), n.disposeData(h.dataId), n.disposeData(g.dataId), 
        y;
    }
}, aj = class {
    constructor(e, t) {
        this.variableNames = [ "A", "indices" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e.slice(), this.aShape = e, this.outputShape = t, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "gather";
    }
    getUserCode() {
        let e = function(t) {
            let n = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w" ], a = [];
            for (let r = 0; r < t.length; r++) r === 2 ? a.push("indexZ") : a.push(`${n[r]}`);
            return a.join();
        }(this.aShape);
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `;
    }
};

function qw(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r,
        indices: s
    } = t, {
        axis: i,
        batchDims: l
    } = a, o = k.parseAxisParam(i, r.shape)[0], p = C.segment_util.collectGatherOpShapeInfo(r, s, o, l), u = k.sizeFromShape(s.shape), c = [], d = Ne({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            shape: [ p.batchSize, p.outerSize, p.dimSize, p.sliceSize ]
        }
    }), h = Ne({
        inputs: {
            x: s
        },
        backend: n,
        attrs: {
            shape: [ p.batchSize, u / p.batchSize ]
        }
    });
    c.push(d), c.push(h);
    let f = [ p.batchSize, p.outerSize, u / p.batchSize, p.sliceSize ];
    if (n.shouldExecuteOnCPU([ r, s ])) {
        let A = n.tensorMap.get(h.dataId).values, x = We(h.shape, h.dtype, A), b = n.tensorMap.get(d.dataId).values, v = We(d.shape, d.dtype, b), I = dU(v, x, f);
        return c.forEach(N => n.disposeData(N.dataId)), n.makeTensorInfo(p.outputShape, I.dtype, I.values);
    }
    let m = new aj(d.shape, f), g = n.runWebGPUProgram(m, [ d, h ], d.dtype);
    c.push(g);
    let y = Ne({
        inputs: {
            x: g
        },
        backend: n,
        attrs: {
            shape: p.outputShape
        }
    });
    return c.forEach(A => n.disposeData(A.dataId)), y;
}

var rj = {
    kernelName: kl,
    backendName: "webgpu",
    kernelFunc: qw
}, sj = jt({
    opType: Le.GREATER,
    cpuKernelImpl: cU,
    dtype: "bool"
}), ij = {
    kernelName: Zs,
    backendName: "webgpu",
    kernelFunc: sj
}, oj = jt({
    opType: Le.GREATER_EQUAL,
    dtype: "bool",
    cpuKernelImpl: pU
}), lj = {
    kernelName: Ys,
    backendName: "webgpu",
    kernelFunc: oj
}, uj = {
    kernelName: td,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            input: a
        } = t;
        return jw(a, !0, n);
    }
}, dj = st({
    opType: oe.IS_FINITE,
    dtype: "bool"
}), pj = {
    kernelName: Qs,
    backendName: "webgpu",
    kernelFunc: dj
}, cj = st({
    opType: oe.IS_INF,
    dtype: "bool"
}), hj = {
    kernelName: ei,
    backendName: "webgpu",
    kernelFunc: cj
}, fj = st({
    opType: oe.IS_NAN,
    dtype: "bool"
}), mj = {
    kernelName: ti,
    backendName: "webgpu",
    kernelFunc: fj
}, gj = {
    kernelName: ni,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            alpha: s
        } = a, i = [ {
            type: "float32",
            data: [ s ]
        } ], l = new bu(r.shape, oe.LEAKYRELU, "alpha : f32,");
        return n.runWebGPUProgram(l, [ r ], "float32", i);
    }
}, yj = jt({
    opType: Le.LESS,
    dtype: "bool",
    cpuKernelImpl: fU
}), Aj = {
    kernelName: ai,
    backendName: "webgpu",
    kernelFunc: yj
}, xj = jt({
    opType: Le.LESS_EQUAL,
    dtype: "bool",
    cpuKernelImpl: hU
}), bj = {
    kernelName: ri,
    backendName: "webgpu",
    kernelFunc: xj
}, vj = class {
    constructor(e) {
        this.variableNames = [], this.outputShape = [], this.uniforms = "start : f32, step : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = [ e ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "linSpace";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;
    }
}, wj = {
    kernelName: si,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            backend: t,
            attrs: n
        } = e, {
            start: a,
            stop: r,
            num: s
        } = n, i = (r - a) / (s - 1), l = new vj(s), o = [ {
            type: "float32",
            data: [ a ]
        }, {
            type: "float32",
            data: [ i ]
        } ];
        return t.runWebGPUProgram(l, [], "float32", o);
    }
}, kj = st({
    opType: oe.LOG,
    cpuKernelImpl: mU
}), Ij = {
    kernelName: ii,
    backendName: "webgpu",
    kernelFunc: kj
}, Sj = st({
    opType: oe.LOG1P
}), Nj = {
    kernelName: oi,
    backendName: "webgpu",
    kernelFunc: Sj
}, Cj = jt({
    opType: Le.LOGICAL_AND,
    dtype: "bool"
}), Tj = {
    kernelName: li,
    backendName: "webgpu",
    kernelFunc: Cj
}, Rj = st({
    opType: oe.LOGICAL_NOT
}), Ej = {
    kernelName: ui,
    backendName: "webgpu",
    kernelFunc: Rj
}, $j = jt({
    opType: Le.LOGICAL_OR
}), Mj = {
    kernelName: di,
    backendName: "webgpu",
    kernelFunc: $j
}, Xw = `
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`, Fj = class {
    constructor(e) {
        this.outputShape = [], this.variableNames = [ "x" ], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "lrn";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${Xw}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;
    }
}, _j = class {
    constructor(e, t) {
        this.outputShape = [], this.variableNames = [ "x" ], this.uniforms = "radius : i32, bias : f32, alpha : f32, beta : f32,", 
        this.workgroupSize = [ 256, 1, 1 ], this.maxAllowRadius = 16, k.assert(t <= this.maxAllowRadius, () => `Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`), 
        this.outputShape = e, this.elementsPerWorkgroup = this.workgroupSize[0] - 2 * this.maxAllowRadius, 
        this.dispatchLayout = {
            x: [ 3 ],
            y: [ 2 ],
            z: [ 0, 1 ]
        }, this.dispatch = de(this.dispatchLayout, this.outputShape, [ this.elementsPerWorkgroup, this.workgroupSize[1], this.workgroupSize[2] ]), 
        this.shaderKey = "lrn_shared";
    }
    getUserCode() {
        return `
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${le()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${Xw}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;
    }
}, Oj = {
    kernelName: pi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s
        } = n, {
            depthRadius: i,
            bias: l,
            alpha: o,
            beta: p
        } = r;
        t = i > 16 ? new Fj(s.shape) : new _j(s.shape, i);
        let u = [ {
            type: "int32",
            data: [ i ]
        }, {
            type: "float32",
            data: [ l ]
        }, {
            type: "float32",
            data: [ o ]
        }, {
            type: "float32",
            data: [ p ]
        } ];
        return a.runWebGPUProgram(t, [ s ], s.dtype, u);
    }
}, Pj = class {
    constructor(e) {
        this.outputShape = [], this.variableNames = [ "inputImage", "outputImage", "dy" ], 
        this.uniforms = "depthRadius : i32, bias : f32, alpha : f32, beta : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "lrn_grad";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;
    }
}, Dj = {
    kernelName: Il,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            y: s,
            dy: i
        } = t, {
            depthRadius: l,
            bias: o,
            alpha: p,
            beta: u
        } = a, c = new Pj(r.shape), d = [ {
            type: "int32",
            data: [ l ]
        }, {
            type: "float32",
            data: [ o ]
        }, {
            type: "float32",
            data: [ p ]
        }, {
            type: "float32",
            data: [ u ]
        } ];
        return n.runWebGPUProgram(c, [ r, s, i ], r.dtype, d);
    }
}, zj = jt({
    opType: Le.MAX,
    cpuKernelImpl: yU
}), Lj = {
    kernelName: hi,
    backendName: "webgpu",
    kernelFunc: zj
}, Wj = {
    kernelName: fi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dimRoundingMode: o
        } = a;
        return $w(r, C.computePool2DInfo(r.shape, s, i, 1, l, o), "max", n);
    }
}, Bj = {
    kernelName: Sl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            filterSize: s,
            strides: i,
            pad: l,
            dataFormat: o,
            dimRoundingMode: p
        } = a, u = C.computePool3DInfo(r.shape, s, i, [ 1, 1, 1 ], l, p, o), c = new O1(u, "max"), d = [ {
            type: "int32",
            data: [ u.strideDepth, u.strideHeight, u.strideWidth ]
        }, {
            type: "int32",
            data: [ u.padInfo.front, u.padInfo.top, u.padInfo.left ]
        }, {
            type: "int32",
            data: [ u.inDepth, u.inHeight, u.inWidth ]
        }, {
            type: "int32",
            data: [ u.effectiveFilterDepth, u.effectiveFilterHeight, u.effectiveFilterWidth ]
        } ];
        return n.runWebGPUProgram(c, [ r ], r.dtype, d);
    }
}, Vj = class {
    constructor(e) {
        this.variableNames = [ "dy", "maxPos" ], this.uniforms = `strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`, this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.outputShape = e.inShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "maxPool2DBackprop";
    }
    getUserCode() {
        return `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
}, Uj = class {
    constructor(e) {
        this.variableNames = [ "dy", "maxPos" ], this.uniforms = `strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e.inShape, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "maxPool3DBackprop";
    }
    getUserCode() {
        return `
      ${le("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;
    }
}, Gj = {
    kernelName: rd,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s
        } = t, i = s, {
            filterSize: l,
            strides: o,
            pad: p,
            dimRoundingMode: u
        } = a, c = C.computePool3DInfo(i.shape, l, o, [ 1, 1, 1 ], p, u), d = new O1(c, "max", !0), h = [ {
            type: "int32",
            data: [ c.strideDepth, c.strideHeight, c.strideWidth ]
        }, {
            type: "int32",
            data: [ c.padInfo.front, c.padInfo.top, c.padInfo.left ]
        }, {
            type: "int32",
            data: [ c.inDepth, c.inHeight, c.inWidth ]
        }, {
            type: "int32",
            data: [ c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth ]
        } ], f = n.runWebGPUProgram(d, [ i ], "int32", h), m = new Uj(c);
        h = [ {
            type: "int32",
            data: [ c.strideDepth, c.strideHeight, c.strideWidth ]
        }, {
            type: "int32",
            data: [ c.effectiveFilterDepth - 1 - c.padInfo.front, c.effectiveFilterHeight - 1 - c.padInfo.top, c.effectiveFilterWidth - 1 - c.padInfo.left ]
        }, {
            type: "int32",
            data: [ c.effectiveFilterDepth, c.effectiveFilterHeight, c.effectiveFilterWidth ]
        }, {
            type: "int32",
            data: [ c.outDepth ]
        }, {
            type: "int32",
            data: [ c.outHeight ]
        }, {
            type: "int32",
            data: [ c.outWidth ]
        } ];
        let g = n.runWebGPUProgram(m, [ r, f ], i.dtype, h);
        return n.disposeData(f.dataId), g;
    }
}, Hj = {
    kernelName: ad,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            dy: r,
            input: s,
            output: i
        } = t, l = s;
        $1([ s, i ], "maxPoolGrad");
        let {
            filterSize: o,
            strides: p,
            pad: u,
            dimRoundingMode: c
        } = a, d = C.computePool2DInfo(l.shape, o, p, 1, u, c), h = new dp(d, "max", !0), f = [ {
            type: "int32",
            data: [ d.strideHeight, d.strideWidth ]
        }, {
            type: "int32",
            data: [ d.padInfo.top, d.padInfo.left ]
        }, {
            type: "int32",
            data: [ d.dilationHeight, d.dilationWidth ]
        }, {
            type: "int32",
            data: [ d.inHeight, d.inWidth ]
        }, {
            type: "int32",
            data: [ d.effectiveFilterHeight, d.effectiveFilterWidth ]
        } ], m = n.runWebGPUProgram(h, [ l ], "int32", f), g = new Vj(d);
        f = [ {
            type: "int32",
            data: [ d.strideHeight, d.strideWidth ]
        }, {
            type: "int32",
            data: [ d.effectiveFilterHeight - 1 - d.padInfo.top, d.effectiveFilterWidth - 1 - d.padInfo.left ]
        }, {
            type: "int32",
            data: [ d.dilationHeight, d.dilationWidth ]
        }, {
            type: "int32",
            data: [ d.effectiveFilterHeight, d.effectiveFilterWidth ]
        }, {
            type: "int32",
            data: [ d.outHeight ]
        }, {
            type: "int32",
            data: [ d.outWidth ]
        } ];
        let y = n.runWebGPUProgram(g, [ r, m ], l.dtype, f);
        return n.disposeData(m.dataId), y;
    }
}, jj = {
    kernelName: Nl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            filterSize: r,
            strides: s,
            pad: i,
            includeBatchInIndex: l
        } = a, {
            x: o
        } = t;
        k.assert(o.shape.length === 4, () => `Error in maxPool: input must be rank 4 but got rank ${o.shape.length}.`);
        let p = [ 1, 1 ];
        k.assert(C.eitherStridesOrDilationsAreOne(s, p), () => `Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);
        let u = C.computePool2DInfo(o.shape, r, s, p, i), c = [ {
            type: "int32",
            data: [ u.strideHeight, u.strideWidth ]
        }, {
            type: "int32",
            data: [ u.padInfo.top, u.padInfo.left ]
        }, {
            type: "int32",
            data: [ u.dilationHeight, u.dilationWidth ]
        }, {
            type: "int32",
            data: [ u.inHeight, u.inWidth ]
        }, {
            type: "int32",
            data: [ u.effectiveFilterHeight, u.effectiveFilterWidth ]
        } ], d = new dp(u, "max", !1), h = n.runWebGPUProgram(d, [ o ], o.dtype, c);
        return d = new dp(u, "max", !0, !0, l), [ h, n.runWebGPUProgram(d, [ o ], "int32", c) ];
    }
}, qj = {
    kernelName: gi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a;
        return zo(r, s, i, "min", n);
    }
}, Xj = jt({
    opType: Le.MIN,
    cpuKernelImpl: AU
}), Kj = {
    kernelName: yi,
    backendName: "webgpu",
    kernelFunc: Xj
}, Zj = class {
    constructor(e, t, n) {
        this.uniforms = "", this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = t.map((a, r) => a[0] + e[r] + a[1]), 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.xShape = e, t.map((a, r) => {
            this.uniforms += ` pad${r} : vec2<i32>,`;
        }), this.offset = n === "reflect" ? 0 : 1, this.shaderKey = `mirrorPad_${n}`;
    }
    getUserCode() {
        let e = this.xShape.length, t = this.xShape.map((o, p) => `uniforms.pad${p}[0]`).join(","), n = this.xShape.map((o, p) => `uniforms.pad${p}[0] + uniforms.xShape${e > 1 ? `[${p}]` : ""}`).join(","), a = e === 1 ? "start" : "start[i]", r = e === 1 ? "end" : "end[i]", s = e === 1 ? "outC" : "outC[i]", i = Tt(e), l = e > 1 ? [ "coords[0]", "coords[1]", "coords[2]", "coords[3]" ].slice(0, e) : "coords";
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let start = ${i}(${t});
          let end = ${i}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${s} < ${a}) {
              ${s} = ${a} * 2 - ${s} - ${this.offset};
            } else if(${s} >= ${r}) {
              ${s} = (${r} - 1) * 2 - ${s} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `;
    }
}, Yj = {
    kernelName: Ai,
    backendName: "webgpu",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            x: a
        } = e, {
            paddings: r,
            mode: s
        } = t, i = n, l = r.map(p => ({
            type: "int32",
            data: [ p[0], p[1] ]
        })), o = new Zj(a.shape, r, s);
        return i.runWebGPUProgram(o, [ a ], a.dtype, l);
    }
}, Jj = jt({
    opType: Le.MOD
}), Qj = {
    kernelName: xi,
    backendName: "webgpu",
    kernelFunc: Jj
}, eq = class {
    constructor(e, t) {
        this.variableNames = [ "probs" ], this.outputShape = [], this.uniforms = "seed : f32, numOutcomes: i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = [ e, t ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "multinomial";
    }
    getUserCode() {
        return `
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${le("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;
    }
}, tq = class {
    constructor(e) {
        this.variableNames = [ "logits" ], this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = [ this.outputShape[0], 1, 1 ], this.outputShape[1] >= 4096 ? this.workgroupSize = [ 256, 1, 1 ] : this.workgroupSize = [ 64, 1, 1 ], 
        this.shaderKey = "softmax";
    }
    getUserCode() {
        return `
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${le("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;
    }
};

function Kw(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        logits: r
    } = t, {
        dim: s
    } = a, i = Ne({
        inputs: {
            x: r
        },
        backend: n,
        attrs: {
            shape: [ k.sizeFromShape(r.shape) / r.shape[s], r.shape[s] ]
        }
    }), l = new tq(i.shape), o = n.runWebGPUProgram(l, [ i ], r.dtype), p = Ne({
        inputs: {
            x: o
        },
        backend: n,
        attrs: {
            shape: r.shape
        }
    });
    return n.disposeData(i.dataId), n.disposeData(o.dataId), p;
}

var nq = {
    kernelName: Ki,
    backendName: "webgpu",
    kernelFunc: Kw
}, aq = {
    kernelName: bi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            logits: r
        } = t, {
            numSamples: s,
            seed: i,
            normalized: l
        } = a, o = l ? r : Kw({
            inputs: {
                logits: r
            },
            backend: n,
            attrs: {
                dim: r.shape.length - 1
            }
        }), p = o.shape[0], u = o.shape[1], c = new eq(p, s), d = [ {
            type: "float32",
            data: [ i ]
        }, {
            type: "int32",
            data: [ u ]
        } ], h = n.runWebGPUProgram(c, [ o ], "int32", d);
        return l || n.disposeData(o.dataId), h;
    }
}, rq = {
    kernelName: Cl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a
        } = t;
        if (n.shouldExecuteOnCPU([ a ])) {
            let s = n.tensorMap.get(a.dataId), [ i, l ] = bU(s.values, a.shape, a.dtype);
            return n.makeTensorInfo(l, a.dtype, i);
        }
        let r = new bu(a.shape, oe.NEG);
        return n.runWebGPUProgram(r, [ a ], a.dtype);
    }
}, sq = {
    kernelName: ki,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o
        } = a, p = n.readSync(r.dataId), u = n.readSync(s.dataId), {
            selectedIndices: c
        } = ua.nonMaxSuppressionV3Impl(p, u, i, l, o);
        return n.makeTensorInfo([ c.length ], "int32", new Int32Array(c));
    }
}, iq = {
    kernelName: Ii,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            boxes: r,
            scores: s
        } = t, {
            maxOutputSize: i,
            iouThreshold: l,
            scoreThreshold: o,
            softNmsSigma: p
        } = a, u = n.readSync(r.dataId), c = n.readSync(s.dataId), d = i, h = l, f = o, m = p, {
            selectedIndices: g,
            selectedScores: y
        } = ua.nonMaxSuppressionV5Impl(u, c, d, h, f, m);
        return [ n.makeTensorInfo([ g.length ], "int32", new Int32Array(g)), n.makeTensorInfo([ y.length ], "float32", new Float32Array(y)) ];
    }
}, oq = class {
    constructor(e, t) {
        this.variableNames = [ "x" ], this.uniforms = "onValue : f32, offValue : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = [ e, t ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "onehot";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;
    }
}, lq = {
    kernelName: Si,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r
        } = t, {
            dtype: s,
            depth: i,
            onValue: l,
            offValue: o
        } = a, p = k.sizeFromShape(r.shape), u = new oq(p, i), c = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ p ]
            }
        }), d = [ {
            type: "float32",
            data: [ l ]
        }, {
            type: "float32",
            data: [ o ]
        } ], h = n.runWebGPUProgram(u, [ c ], s, d);
        n.disposeData(c.dataId);
        let f = Ne({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                shape: [ ...r.shape, i ]
            }
        });
        return n.disposeData(h.dataId), f;
    }
};

function ah(e) {
    let {
        inputs: t,
        backend: n
    } = e, {
        x: a
    } = t;
    if (a.dtype === "complex64") {
        let r = pp({
            inputs: {
                input: a
            },
            backend: n
        }), s = ah({
            inputs: {
                x: r
            },
            backend: n
        }), i = th({
            inputs: {
                input: a
            },
            backend: n
        }), l = ah({
            inputs: {
                x: i
            },
            backend: n
        }), o = Do({
            inputs: {
                real: s,
                imag: l
            },
            backend: n
        });
        return n.disposeData(r.dataId), n.disposeData(s.dataId), n.disposeData(i.dataId), 
        n.disposeData(l.dataId), o;
    }
    return Sn({
        attrs: {
            shape: a.shape,
            dtype: a.dtype,
            value: a.dtype === "string" ? "" : 0
        },
        backend: n
    });
}

var uq = {
    kernelName: Gl,
    backendName: "webgpu",
    kernelFunc: ah
}, dq = {
    kernelName: Rl,
    backendName: "webgpu",
    kernelFunc: function e(t) {
        let {
            inputs: n,
            backend: a
        } = t, {
            x: r
        } = n;
        if (r.dtype === "string") throw new Error("onesLike is not supported under string dtype");
        if (r.dtype === "complex64") {
            let s = pp({
                inputs: {
                    input: r
                },
                backend: a
            }), i = e({
                inputs: {
                    x: s
                },
                backend: a
            }), l = th({
                inputs: {
                    input: r
                },
                backend: a
            }), o = ah({
                inputs: {
                    x: l
                },
                backend: a
            }), p = Do({
                inputs: {
                    real: i,
                    imag: o
                },
                backend: a
            });
            return a.disposeData(s.dataId), a.disposeData(i.dataId), a.disposeData(l.dataId), 
            a.disposeData(o.dataId), p;
        }
        return Sn({
            attrs: {
                shape: r.shape,
                dtype: r.dtype,
                value: 1
            },
            backend: a
        });
    }
}, pq = {
    kernelName: El,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            axis: r
        } = a;
        if (t.length === 1) return D1({
            inputs: {
                input: t[0]
            },
            backend: n,
            attrs: {
                dim: r
            }
        });
        let s = t[0].shape, i = t[0].dtype;
        t.forEach(p => {
            k.assertShapesMatch(s, p.shape, "All tensors passed to stack must have matching shapes"), 
            k.assert(i === p.dtype, () => "All tensors passed to stack must have matching dtypes");
        });
        let l = [], o = Ow({
            inputs: t.map(p => {
                let u = D1({
                    inputs: {
                        input: p
                    },
                    backend: n,
                    attrs: {
                        dim: r
                    }
                });
                return l.push(u), u;
            }),
            backend: n,
            attrs: {
                axis: r
            }
        });
        return l.forEach(p => n.disposeData(p.dataId)), o;
    }
};

function Zw(e, t = !1) {
    let n = e.length, a = Tt(n), r = e.map((i, l) => `uniforms.pad${l}[0]`).join(","), s = e.map((i, l) => `uniforms.pad${l}[0] + uniforms.xShape${n > 1 ? `[${l}]` : ""}`).join(",");
    return `
        let start = ${n > 1 ? `${a}(${r})` : `${r}`};
        let end = ${n > 1 ? `${a}(${s})` : `${s}`};
        if (${n > 1 ? "any(paddedCoords < start)" : "paddedCoords < start"} || ${n > 1 ? "any(paddedCoords >= end)" : "paddedCoords >= end"}) {
          setOutputAtIndex(index, ${t ? 0 : "uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${n > 1 ? [ "coords[0]", "coords[1]", "coords[2]", "coords[3]" ].slice(0, n) : "coords"}));
        }
  `;
}

var cq = class {
    constructor(e, t) {
        this.variableNames = [ "x" ], this.uniforms = "constantValue : f32,", this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = t.map((n, a) => n[0] + e[a] + n[1]), 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        t.map((n, a) => {
            this.uniforms += ` pad${a} : vec2<i32>,`;
        }), this.xShape = e, this.shaderKey = "pad";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Zw(this.xShape)}
        }
      }
    `;
    }
}, hq = {
    kernelName: Ni,
    backendName: "webgpu",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            paddings: s,
            constantValue: i
        } = a;
        if (s.every(p => k.arraysEqual(p, [ 0, 0 ]))) return jn({
            inputs: {
                x: r
            },
            backend: n
        });
        if (k.sizeFromShape(r.shape) === 0) return Sn({
            backend: n,
            attrs: {
                shape: s.map((p, u) => p[0] + r.shape[u] + p[1]),
                value: i,
                dtype: r.dtype
            }
        });
        let l = [ {
            type: "float32",
            data: [ i ]
        } ];
        s.map(p => l.push({
            type: "int32",
            data: [ p[0], p[1] ]
        }));
        let o = new cq(r.shape, s);
        return n.runWebGPUProgram(o, [ r ], r.dtype, l);
    }
}, fq = jt({
    opType: Le.POW
}), mq = {
    kernelName: Ci,
    backendName: "webgpu",
    kernelFunc: fq
}, gq = {
    kernelName: Ti,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            x: a,
            alpha: r
        } = t, s = new eh(Le.PRELU, a.shape, r.shape);
        return n.runWebGPUProgram(s, [ a, r ], "float32");
    }
}, yq = {
    kernelName: Ri,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            axis: s,
            keepDims: i
        } = a;
        return zo(r, s, i, "prod", n);
    }
}, Aq = {
    kernelName: $l,
    backendName: "webgpu",
    kernelFunc: e => {
        let {
            backend: t,
            attrs: n
        } = e, {
            start: a,
            stop: r,
            step: s,
            dtype: i
        } = n, l = kU(a, r, s, i);
        return t.makeTensorInfo([ l.length ], i, l);
    }
}, xq = jt({
    opType: Le.DIV
}), bq = {
    kernelName: Ls,
    backendName: "webgpu",
    kernelFunc: xq
}, vq = st({
    opType: oe.RECIPROCAL
}), wq = {
    kernelName: Ei,
    backendName: "webgpu",
    kernelFunc: vq
}, kq = st({
    opType: oe.RELU
}), Iq = {
    kernelName: $i,
    backendName: "webgpu",
    kernelFunc: kq
}, Sq = st({
    opType: oe.RELU6
}), Nq = {
    kernelName: _i,
    backendName: "webgpu",
    kernelFunc: Sq
}, Cq = class {
    constructor(e, t, n) {
        this.variableNames = [ "x" ], this.uniforms = "adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = [ e[0], t, n, e[3] ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "resizeBilinear";
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
}, Tq = {
    kernelName: Fi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r
        } = t, {
            alignCorners: s,
            size: i,
            halfPixelCenters: l
        } = a, [ o, p ] = i, u = [ {
            type: "float32",
            data: [ s && o > 1 ? 1 : 0, s && p > 1 ? 1 : 0 ]
        }, {
            type: "float32",
            data: [ l ? .5 : 0 ]
        } ], c = new Cq(r.shape, o, p);
        return n.runWebGPUProgram(c, [ r ], "float32", u);
    }
}, Rq = class {
    constructor(e, t) {
        this.variableNames = [ "dy" ], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`, 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.alignCorners = t, this.shaderKey = `resizeBilinearBackprop_${t}`;
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
}, Eq = {
    kernelName: _l,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r,
            dy: s
        } = t, {
            alignCorners: i
        } = a, [ , l, o ] = r.shape, [ , p, u ] = s.shape, c = [ i && p > 1 ? l - 1 : l, i && u > 1 ? o - 1 : o ], d = [ i && p > 1 ? p - 1 : p, i && u > 1 ? u - 1 : u ], h = c[0] / d[0], f = c[1] / d[1], m = 1 / h, g = 1 / f, y = 2 * Math.ceil(m) + 2, A = 2 * Math.ceil(g) + 2, x = new Rq(r.shape, i), b = [ {
            type: "int32",
            data: c
        }, {
            type: "int32",
            data: d
        }, {
            type: "float32",
            data: [ h ]
        }, {
            type: "float32",
            data: [ f ]
        }, {
            type: "float32",
            data: [ m ]
        }, {
            type: "float32",
            data: [ g ]
        }, {
            type: "int32",
            data: [ y ]
        }, {
            type: "int32",
            data: [ A ]
        } ];
        return n.runWebGPUProgram(x, [ s ], s.dtype, b);
    }
}, $q = class {
    constructor(e, t, n, a) {
        this.variableNames = [ "x" ], this.uniforms = "adjustHeightWidth : vec2<f32>, roundBase : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = [ e[0], t, n, e[3] ], 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.halfPixelCenters = a, this.shaderKey = `resizeNearest_${a}`;
    }
    getUserCode() {
        let e;
        return e = this.halfPixelCenters ? "max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))" : "vec2<f32>(rc) * effectiveInputOverOutputRatioRC", 
        `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;
    }
}, Mq = {
    kernelName: Mi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r
        } = t, {
            alignCorners: s,
            halfPixelCenters: i,
            size: l
        } = a, [ o, p ] = l, u = [ {
            type: "float32",
            data: [ s && o > 1 ? 1 : 0, s && p > 1 ? 1 : 0 ]
        }, {
            type: "float32",
            data: [ s ? .5 : 0 ]
        } ], c = new $q(r.shape, o, p, i);
        return n.runWebGPUProgram(c, [ r ], r.dtype, u);
    }
}, Fq = class {
    constructor(e, t) {
        this.variableNames = [ "dy" ], this.uniforms = `effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`, this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.outputShape = e, this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.alignCorners = t, this.shaderKey = `resizeNearestNeigborBackprop_${t}`;
    }
    getUserCode() {
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners ? "floor(sourceFracRow + 0.5)" : "floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners ? "floor(sourceFracCol + 0.5)" : "floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;
    }
}, _q = {
    kernelName: Fl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            images: r,
            dy: s
        } = t, {
            alignCorners: i
        } = a, [ , l, o ] = r.shape, [ , p, u ] = s.shape, c = [ i && p > 1 ? l - 1 : l, i && u > 1 ? o - 1 : o ], d = [ i && p > 1 ? p - 1 : p, i && u > 1 ? u - 1 : u ], h = 1 / (c[0] / d[0]), f = 1 / (c[1] / d[1]), m = 2 * Math.ceil(h) + 2, g = 2 * Math.ceil(f) + 2, y = new Fq(r.shape, i), A = [ {
            type: "int32",
            data: c
        }, {
            type: "int32",
            data: d
        }, {
            type: "float32",
            data: [ h ]
        }, {
            type: "float32",
            data: [ f ]
        }, {
            type: "int32",
            data: [ m ]
        }, {
            type: "int32",
            data: [ g ]
        } ];
        return n.runWebGPUProgram(y, [ s ], s.dtype, A);
    }
}, Oq = class {
    constructor(e) {
        this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.outputShape = e, this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.uniforms = " axis : vec4<i32>,", this.shaderKey = "reverse";
    }
    getUserCode() {
        return `
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;
    }
}, Pq = {
    kernelName: Oi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            dims: s
        } = a, i = r.shape.length;
        if (i === 0) return jn({
            inputs: {
                x: r
            },
            backend: n
        });
        let l = r.shape, o = [ 1, 1, 1, 1 ];
        l.forEach((g, y) => {
            o[y + 4 - i] = g;
        });
        let p = k.parseAxisParam(s, r.shape), u = [ 0, 0, 0, 0 ];
        p.forEach(g => {
            u[g + 4 - i] = 1;
        });
        let c = [ {
            type: "int32",
            data: u
        } ], d = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: o
            }
        }), h = new Oq(o), f = n.runWebGPUProgram(h, [ d ], d.dtype, c);
        n.disposeData(d.dataId);
        let m = Ne({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: l
            }
        });
        return n.disposeData(f.dataId), m;
    }
}, Dq = class {
    constructor(e, t) {
        this.outputShape = [], this.variableNames = [ "x" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.uniforms = `centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`, this.shaderKey = "rotate", this.outputShape = e, typeof t == "number" ? (this.uniforms += " fillValue : f32,", 
        this.fillSnippet = "var outputValue = uniforms.fillValue;", this.shaderKey += "_float") : (this.uniforms += " fillValue : vec3<f32>,", 
        this.fillSnippet = "var outputValue = uniforms.fillValue[coords[3]];", this.shaderKey += "_vec3");
    }
    getUserCode() {
        return `
        ${le("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;
    }
}, zq = {
    kernelName: ro,
    backendName: "webgpu",
    kernelFunc: ({
        inputs: e,
        attrs: t,
        backend: n
    }) => {
        let {
            image: a
        } = e, {
            radians: r,
            fillValue: s,
            center: i
        } = t, l = n, o = new Dq(a.shape, s), [ p, u ] = C.getImageCenter(i, a.shape[1], a.shape[2]), c = [ {
            type: "float32",
            data: [ p ]
        }, {
            type: "float32",
            data: [ u ]
        }, {
            type: "float32",
            data: [ Math.sin(r) ]
        }, {
            type: "float32",
            data: [ Math.cos(r) ]
        } ];
        return typeof s == "number" ? c.push({
            type: "float32",
            data: [ Number.parseFloat(s.toFixed(2)) ]
        }) : c.push({
            type: "float32",
            data: s
        }), l.runWebGPUProgram(o, [ a ], a.dtype, c);
    }
}, Lq = st({
    opType: oe.ROUND
}), Wq = {
    kernelName: Pi,
    backendName: "webgpu",
    kernelFunc: Lq
}, Bq = st({
    opType: oe.RSQRT,
    cpuKernelImpl: IU
}), Vq = {
    kernelName: Di,
    backendName: "webgpu",
    kernelFunc: Bq
}, fp = class {
    constructor(e, t, n, a, r, s, i, l = !0) {
        this.variableNames = [ "updates", "indices" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.atomic = !0, this.outputShape = s, this.type = i, this.sumDupeIndices = l, 
        this.dispatchLayout = xe(e), this.dispatch = de(this.dispatchLayout, e, this.workgroupSize), 
        this.sliceDimGreaterThanOne = t > 1, this.shaderKey = `scatter_${n}_${a}_${this.sliceDimGreaterThanOne}_${i}_${l}_${r.length}`;
        let o = Tt(r.length);
        this.uniforms = `sliceDim : i32, strides: ${o}, updatesSize: i32,`, this.updatesRank = a, 
        this.indicesRank = n;
    }
    getUserCode() {
        let e = "";
        this.indicesRank === 1 ? e = "coords[0]" : this.indicesRank === 2 && (e = "coords[0], j");
        let t = `getIndices(${e})`, n = this.sliceDimGreaterThanOne ? "uniforms.strides[j]" : "uniforms.strides", a = "", r = "";
        this.dispatchLayout.x.length === 1 ? (a = "flattenedIndex", r = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `) : this.dispatchLayout.x.length === 2 && (a = "vec2<i32>(flattenedIndex, coords[1])", 
        r = `
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);
        let s = `getUpdates(${Array.from({
            length: this.updatesRank
        }, (i, l) => `coords[${l}]`).join(", ")})`;
        return `
    ${r}
      ${le("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${Fo(this.type)}(${s});
          let flatIndex = getOutputIndexFromCoords(${a});

          ${this.sumDupeIndices ? Kr("&result[flatIndex]", "updateValue", this.type) : "atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`;
    }
}, Uq = {
    kernelName: zi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            indices: r,
            updates: s
        } = t, {
            shape: i
        } = a, {
            sliceRank: l,
            numUpdates: o,
            sliceSize: p,
            strides: u,
            outputSize: c
        } = C.calculateShapes(s, r, i), d = [ c / p, p ];
        if (c === 0) return n.makeTensorInfo(i, r.dtype);
        let h = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ o, l ]
            }
        }), f = Ne({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: [ o, p ]
            }
        }), m = f.dtype, g = Sn({
            backend: n,
            attrs: {
                shape: d,
                value: 0,
                dtype: m
            }
        }), y = [ {
            type: "int32",
            data: [ l ]
        }, {
            type: "int32",
            data: u
        }, {
            type: "int32",
            data: [ k.sizeFromShape(f.shape) ]
        } ], A = new fp(f.shape, l, h.shape.length, f.shape.length, u, d, m), x = n.runWebGPUProgram(A, [ f, h ], m, y, g), b = Ne({
            inputs: {
                x: x
            },
            backend: n,
            attrs: {
                shape: i
            }
        });
        return n.disposeData(h.dataId), n.disposeData(f.dataId), n.disposeData(x.dataId), 
        b;
    }
}, Gq = class {
    constructor(e, t) {
        this.outputShape = [], this.variableNames = [ "sortedSequence", "values" ], 
        this.uniforms = "numInputs : i32,", this.workgroupSize = [ 64, 1, 1 ], this.size = !0, 
        this.outputShape = e, this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.side = t, this.shaderKey = `search_sorted_${t}`;
    }
    getUserCode() {
        return `
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side === "left" ? "<" : "<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${le("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;
    }
}, Hq = {
    kernelName: Wi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            sortedSequence: r,
            values: s
        } = t, {
            side: i
        } = a, l = new Gq([ s.shape[0], s.shape[1] ], i), o = [ {
            type: "int32",
            data: [ r.shape[1] ]
        } ];
        return n.runWebGPUProgram(l, [ r, s ], "int32", o);
    }
}, jq = class {
    constructor(e, t, n) {
        this.variableNames = [ "c", "a", "b" ], this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = t, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.cRank = e, this.rank = n, this.shaderKey = "select";
    }
    getUserCode() {
        let e, t;
        if (this.rank > 4) throw Error(`Where for rank ${this.rank} is not yet supported`);
        if (this.rank === 1) t = "resRC", e = "resRC"; else {
            let n = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w" ], a = [], r = [];
            for (let s = 0; s < this.outputShape.length; s++) r.push(`${n[s]}`), 
            s < this.cRank && a.push(`${n[s]}`);
            e = a.join(), t = r.join();
        }
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `;
    }
}, qq = {
    kernelName: Ol,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            condition: a,
            t: r,
            e: s
        } = t, i = new jq(a.shape.length, r.shape, r.shape.length);
        return n.runWebGPUProgram(i, [ a, r, s ], Zt(r.dtype, s.dtype));
    }
}, Xq = st({
    opType: oe.SELU
}), Kq = {
    kernelName: Bi,
    backendName: "webgpu",
    kernelFunc: Xq
}, Zq = st({
    opType: oe.SIGMOID
}), Yq = {
    kernelName: Hi,
    backendName: "webgpu",
    kernelFunc: Zq
}, Jq = st({
    opType: oe.SIGN
}), Qq = {
    kernelName: Gi,
    backendName: "webgpu",
    kernelFunc: Jq
}, eX = st({
    opType: oe.SIN
}), tX = {
    kernelName: Vi,
    backendName: "webgpu",
    kernelFunc: eX
}, nX = st({
    opType: oe.SINH
}), aX = {
    kernelName: Ui,
    backendName: "webgpu",
    kernelFunc: nX
}, rX = st({
    opType: oe.SOFTPLUS
}), sX = {
    kernelName: ji,
    backendName: "webgpu",
    kernelFunc: rX
}, iX = class {
    constructor(e, t, n, a, r, s) {
        this.variableNames = [ "x" ], this.outputShape = [], this.uniforms = "", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0;
        let i = new Array(a.length);
        for (let l = 0; l < i.length; l++) i[l] = a[r[l]];
        this.outputShape = i, this.newDim = r, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.xShape = e, this.paddedXShape = t, this.uniforms += `reshapedPaddedXShape : ${Tt(a.length)}, paddedXShapeStrides : ${Tt(s)}, `, 
        n.map((l, o) => {
            this.uniforms += ` pad${o} : vec2<i32>,`;
        }), this.shaderKey = `spaceToBatchND_${r}`;
    }
    getUserCode() {
        let e = Tt(this.outputShape.length), t = Cw(this.newDim);
        return `
      ${Zc(this.paddedXShape, "PaddedX")}
      ${le("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Zw(this.xShape, !0)}
        }
      }
    `;
    }
}, oX = {
    kernelName: Dl,
    backendName: "webgpu",
    kernelFunc: e => {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            blockShape: s,
            paddings: i
        } = a;
        k.assert(r.shape.length <= 4, () => "spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");
        let l = s.reduce((A, x) => A * x), o = [ [ 0, 0 ] ];
        o.push(...i);
        for (let A = 1 + s.length; A < r.shape.length; ++A) o.push([ 0, 0 ]);
        let p = o.map((A, x) => A[0] + r.shape[x] + A[1]), u = C.getReshaped(p, s, l, !1), c = C.getPermuted(u.length, s.length, !1), d = C.getReshapedPermuted(p, s, l, !1), h = k.computeStrides(p), f = new iX(r.shape, p, o, u, c, h.length), m = [ {
            type: "int32",
            data: u
        }, {
            type: "int32",
            data: h
        } ];
        o.map(A => m.push({
            type: "int32",
            data: [ A[0], A[1] ]
        }));
        let g = n.runWebGPUProgram(f, [ r ], r.dtype, m), y = Ne({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                shape: d
            }
        });
        return n.disposeData(g.dataId), y;
    }
}, lX = class {
    constructor(e, t, n) {
        this.variableNames = [ "input", "indices", "segmentIds" ], this.outputShape = [], 
        this.uniforms = "segmentSize : i32, sparseSize : i32,", this.workgroupSize = [ 64, 1, 1 ], 
        this.atomic = !0, this.outputShape = e, this.type = n, this.dispatchLayout = xe([ t ]), 
        this.dispatch = de(this.dispatchLayout, [ t ], this.workgroupSize), this.shaderKey = "sparseSegmentSum";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Kr("&result[outIndex]", "value", this.type)}
      }
    }
  `;
    }
}, uX = class {
    constructor(e, t) {
        this.variableNames = [ "segmentIds" ], this.outputShape = [], this.workgroupSize = [ 64, 1, 1 ], 
        this.atomic = !0, this.outputShape = [ e ], this.dispatchLayout = xe(t), 
        this.dispatch = de(this.dispatchLayout, t, this.workgroupSize), this.shaderKey = "sparseSegmentIdCountProgram";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Kr("&result[segmentId]", "1", "int32")}
      }
    }
  `;
    }
}, dX = class {
    constructor(e, t) {
        this.variableNames = [ "segmentSum", "sameSegmentIdCount" ], this.outputShape = [], 
        this.uniforms = "segmentSize : i32", this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.type = t, this.dispatchLayout = xe(e), 
        this.dispatch = de(this.dispatchLayout, e, this.workgroupSize), this.shaderKey = "sparseSegmentMean";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type === "float32" ? "setOutputAtIndex(index, segmentSum[index] / f32(count));" : "setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `;
    }
};

function Yw(e, t, n, a = !1, r) {
    let s, i = k.sizeFromShape(e.shape) / e.shape[0], l = e.dtype, o = k.sizeFromShape(t.shape), p = r.readSync(n.dataId), u = o > 0 ? p[o - 1] + 1 : 0, c = e.shape.slice();
    c[0] = u;
    let d = o * i, h = Sn({
        backend: r,
        attrs: {
            shape: c,
            value: 0,
            dtype: l
        }
    });
    s = new lX(c, d, l);
    let f = [ {
        type: "int32",
        data: [ i ]
    }, {
        type: "int32",
        data: [ d ]
    } ], m = r.runWebGPUProgram(s, [ e, t, n ], l, f, h);
    if (a) return m;
    let g = Sn({
        backend: r,
        attrs: {
            shape: [ u ],
            value: 0,
            dtype: "int32"
        }
    });
    s = new uX(u, n.shape);
    let y = r.runWebGPUProgram(s, [ n ], "int32", null, g), A = Sn({
        backend: r,
        attrs: {
            shape: c,
            value: 0,
            dtype: l
        }
    });
    s = new dX(c, l), f = [ {
        type: "int32",
        data: [ i ]
    } ];
    let x = r.runWebGPUProgram(s, [ m, y ], l, f, A);
    return r.disposeData(m.dataId), r.disposeData(y.dataId), x;
}

var pX = {
    kernelName: Wl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            data: a,
            indices: r,
            segmentIds: s
        } = t;
        return Yw(a, r, s, !1, n);
    }
}, cX = {
    kernelName: Bl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n
        } = e, {
            data: a,
            indices: r,
            segmentIds: s
        } = t;
        return Yw(a, r, s, !0, n);
    }
}, hX = class {
    constructor(e, t) {
        this.variableNames = [ "A" ], this.workgroupSize = [ 64, 1, 1 ], this.size = !0;
        let n = new Array(e.length);
        for (let a = 0; a < n.length; a++) n[a] = e[a] * t[a];
        this.outputShape = n, this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.rank = this.outputShape.length, this.shaderKey = "tile";
    }
    getUserCode() {
        let e = function(t, n = "") {
            if (t >= 5) throw Error(`Tile for rank ${t} is not yet supported`);
            if (t === 1) return `(resRC % ${n}aShape)`;
            let a = [ "resRC.x", "resRC.y", "resRC.z", "resRC.w" ], r = [];
            for (let s = 0; s < t; s++) r.push(`(${a[s]} % ${n}aShape[${s}])`);
            return r.join();
        }(this.rank, "uniforms.");
        return `
      ${le("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `;
    }
};

function L1(e) {
    let {
        inputs: t,
        backend: n,
        attrs: a
    } = e, {
        x: r
    } = t, {
        reps: s
    } = a;
    if (n.shouldExecuteOnCPU([ r ]) || r.dtype === "string" || r.shape.length >= 5) {
        let l = n.readSync(r.dataId), o = r.dtype === "string" ? l.map(c => k.decodeString(c)) : l, p = We(r.shape, r.dtype, o), u = $U(p, s);
        return n.makeTensorInfo(u.shape, u.dtype, u.values);
    }
    let i = new hX(r.shape, s);
    return n.runWebGPUProgram(i, [ r ], r.dtype);
}

var fX = {
    kernelName: br,
    backendName: "webgpu",
    kernelFunc: L1
}, mX = {
    kernelName: Zi,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            sparseIndices: r,
            sparseValues: s,
            defaultValue: i
        } = t, {
            outputShape: l
        } = a, {
            sliceRank: o,
            numUpdates: p,
            sliceSize: u,
            strides: c,
            outputSize: d
        } = C.calculateShapes(s, r, l), h = !1;
        if (s.dtype === "string") {
            let N = n.bufferSync(r), T = n.bufferSync(s), R = k.decodeString(n.readSync(i.dataId)[0]), w = SU(N, T, l, d, u, p, o, c, R, h);
            return n.makeTensorInfo(l, w.dtype, w.values);
        }
        let f = [ d / u, u ], m = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: [ p, o ]
            }
        }), g = s.shape.length ? Ne({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: [ p, u ]
            }
        }) : jn({
            inputs: {
                x: s
            },
            backend: n
        }), y = g.dtype, A = n.makeTensorInfo([], y, k.makeZerosTypedArray(1, y)), x = Ne({
            inputs: {
                x: i
            },
            backend: n,
            attrs: {
                shape: Array(f.length).fill(1)
            }
        }), b = L1({
            inputs: {
                x: x
            },
            backend: n,
            attrs: {
                reps: f
            }
        }), v = [ {
            type: "int32",
            data: [ o ]
        }, {
            type: "int32",
            data: c
        }, {
            type: "int32",
            data: [ k.sizeFromShape([ p, u ]) ]
        } ];
        switch (p) {
          case 0:
            break;

          case 1:
            {
                let N = new fp([ p, u ], o, m.shape.length, g.shape.length, c, f, y, h);
                n.runWebGPUProgram(N, [ g, m ], y, v, b);
            }
            break;

          default:
            {
                let N = new fp([ p, u ], o, m.shape.length, A.shape.length, c, f, y, h);
                n.runWebGPUProgram(N, [ A, m ], y, v, b);
            }
            {
                let N = new fp([ p, u ], o, m.shape.length, g.shape.length, c, f, y);
                n.runWebGPUProgram(N, [ g, m ], y, v, b);
            }
        }
        let I = Ne({
            inputs: {
                x: b
            },
            backend: n,
            attrs: {
                shape: l
            }
        });
        return n.disposeData(m.dataId), n.disposeData(g.dataId), n.disposeData(x.dataId), 
        n.disposeData(A.dataId), n.disposeData(b.dataId), I;
    }
}, gX = {
    kernelName: zl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            numOrSizeSplits: s,
            axis: i
        } = a, l = k.parseAxisParam(i, r.shape)[0], o = C.prepareSplitSize(r, s, l), p = r.shape.length, u = new Array(p).fill(0), c = r.shape.slice();
        return o.map(d => {
            let h = [ ...c ];
            h[l] = d;
            let f = vu({
                inputs: {
                    x: r
                },
                backend: n,
                attrs: {
                    begin: u,
                    size: h
                }
            });
            return u[l] += d, f;
        });
    }
}, yX = st({
    opType: oe.SQRT
}), AX = {
    kernelName: qi,
    backendName: "webgpu",
    kernelFunc: yX
}, xX = {
    kernelName: od,
    backendName: "webgpu",
    kernelFunc: ({
        inputs: e,
        backend: t
    }) => {
        let {
            x: n
        } = e, a = t, r = new bu(n.shape, oe.SQUARE);
        return a.runWebGPUProgram(r, [ n ], n.dtype);
    }
}, bX = jt({
    opType: Le.SQUARED_DIFFERENCE
}), vX = {
    kernelName: Yi,
    backendName: "webgpu",
    kernelFunc: bX
}, wX = {
    kernelName: vr,
    backendName: "webgpu",
    kernelFunc: function({
        inputs: e,
        attrs: t,
        backend: n
    }) {
        let {
            x: a
        } = e, r = new bu(a.shape, oe.STEP, "stepAlpha : f32,"), s = [ {
            type: "float32",
            data: [ t.alpha ]
        } ];
        return n.runWebGPUProgram(r, [ a ], a.dtype, s);
    }
}, kX = class {
    constructor(e) {
        this.variableNames = [ "x" ], this.workPerThread = 1, this.workgroupSize = [ 64, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize, [ this.workPerThread, 1, 1 ]);
        let t = Tt(this.outputShape.length);
        this.uniforms = `begin : ${t},  strides : ${t}, `, this.shaderKey = "stridedSlice";
    }
    getUserCode() {
        let e = "";
        if (this.outputShape.length === 1) e = "coords * uniforms.strides + uniforms.begin"; else {
            let t = 0;
            e = this.outputShape.map((n, a) => (t++, this.outputShape.length === 1 ? `coords * uniforms.strides[${a}] + uniforms.begin[${a}]` : `coords[${t - 1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",");
        }
        return `
       ${le("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `;
    }
}, IX = {
    kernelName: Ji,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            x: s
        } = n, {
            begin: i,
            end: l,
            strides: o,
            beginMask: p,
            endMask: u,
            ellipsisMask: c,
            newAxisMask: d,
            shrinkAxisMask: h
        } = r, {
            finalShapeSparse: f,
            finalShape: m,
            isIdentity: g,
            sliceDim0: y,
            isSimpleSlice: A,
            begin: x,
            end: b,
            strides: v
        } = St.sliceInfo(s.shape, i, l, o, p, u, c, d, h);
        if (g) t = Ne({
            inputs: {
                x: s
            },
            backend: a,
            attrs: {
                shape: m
            }
        }); else if (y || A) {
            k.assert(s.shape.length >= 1, () => `Input must have rank at least 1, got: ${s.shape.length}`);
            let I = St.computeOutShape(x, b, v), N = vu({
                inputs: {
                    x: s
                },
                backend: a,
                attrs: {
                    begin: x,
                    size: I
                }
            });
            t = Ne({
                inputs: {
                    x: N
                },
                backend: a,
                attrs: {
                    shape: m
                }
            }), a.disposeData(N.dataId);
        } else if (a.shouldExecuteOnCPU([ s ])) {
            let I = a.readSync(s.dataId), N = We(s.shape, s.dtype, I), T = TU(f, N, v, x);
            t = a.makeTensorInfo(m, s.dtype, T.values);
        } else {
            let I = new kX(f), N = [ {
                type: "int32",
                data: x
            }, {
                type: "int32",
                data: v
            } ], T = a.runWebGPUProgram(I, [ s ], s.dtype, N);
            t = Ne({
                inputs: {
                    x: T
                },
                backend: a,
                attrs: {
                    shape: m
                }
            }), a.disposeData(T.dataId);
        }
        return t;
    }
}, SX = {
    kernelName: Vl,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            separator: r,
            nGramWidths: s,
            leftPad: i,
            rightPad: l,
            padWidth: o,
            preserveShortSequences: p
        } = a, {
            data: u,
            dataSplits: c
        } = t, d = n.readSync(u.dataId), h = n.readSync(c.dataId), [ f, m ] = RU(d, h, r, s, i, l, o, p);
        return [ n.makeTensorInfo([ f.length ], "string", f), n.makeTensorInfo(c.shape, "int32", m) ];
    }
}, NX = jt({
    opType: Le.SUB,
    cpuKernelImpl: EU,
    supportsComplex: !0
}), CX = {
    kernelName: Qi,
    backendName: "webgpu",
    kernelFunc: NX
}, TX = st({
    opType: oe.TAN
}), RX = {
    kernelName: eo,
    backendName: "webgpu",
    kernelFunc: TX
}, EX = st({
    opType: oe.TANH
}), $X = {
    kernelName: to,
    backendName: "webgpu",
    kernelFunc: EX
}, MX = {
    kernelName: Li,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            tensor: r,
            indices: s,
            updates: i
        } = t, {
            sliceRank: l,
            numUpdates: o,
            sliceSize: p,
            strides: u,
            outputSize: c
        } = C.calculateShapes(i, s, r.shape), d = [ c / p, p ];
        if (c === 0) return n.makeTensorInfo(r.shape, s.dtype);
        let h = [], f = Ne({
            inputs: {
                x: s
            },
            backend: n,
            attrs: {
                shape: [ o, l ]
            }
        });
        h.push(f);
        let m = Ne({
            inputs: {
                x: i
            },
            backend: n,
            attrs: {
                shape: [ o, p ]
            }
        });
        h.push(m);
        let g = Ne({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                shape: d
            }
        });
        h.push(g);
        let y = L1({
            inputs: {
                x: g
            },
            backend: n,
            attrs: {
                reps: Array(d.length).fill(1)
            }
        }), A = new fp([ o, p ], l, f.shape.length, m.shape.length, u, d, r.dtype, !1), x = [ {
            type: "int32",
            data: [ l ]
        }, {
            type: "int32",
            data: u
        }, {
            type: "int32",
            data: [ k.sizeFromShape([ o, p ]) ]
        } ], b = n.runWebGPUProgram(A, [ m, f ], g.dtype, x, y);
        h.push(b);
        let v = Ne({
            inputs: {
                x: b
            },
            backend: n,
            attrs: {
                shape: r.shape
            }
        });
        return h.forEach(I => n.disposeData(I.dataId)), v;
    }
}, FX = class {
    constructor(e) {
        this.variableNames = [ "x", "indices" ], this.workgroupSize = [ 256, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.uniforms = `inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`, this.shaderKey = "swap";
    }
    getUserCode() {
        return `
        ${le("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
}, _X = class {
    constructor(e) {
        this.variableNames = [ "x", "indices" ], this.workgroupSize = [ 256, 1, 1 ], 
        this.size = !0, this.outputShape = e, this.dispatchLayout = xe(this.outputShape), 
        this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.uniforms = "inputSize : i32, firstPass : i32, k : i32,", this.shaderKey = "merge";
    }
    getUserCode() {
        return `
        ${le("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;
    }
};

function ku(e, t) {
    t !== null && e.disposeData(t.dataId);
}

function Jw(e) {
    let t = 1;
    for (;t < e; ) t *= 2;
    return t;
}

var OX = {
    kernelName: no,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r
        } = t, {
            k: s,
            sorted: i
        } = a, l = r.shape, o = l[l.length - 1];
        if (n.shouldExecuteOnCPU([ r ])) {
            let b = n.readSync(r.dataId), [ v, I ] = MU(b, l, r.dtype, s, i);
            return [ n.makeTensorInfo(v.shape, v.dtype, v.values), n.makeTensorInfo(I.shape, I.dtype, I.values) ];
        }
        if (s === 0) return l[l.length - 1] = 0, [ n.makeTensorInfo(l, r.dtype, []), n.makeTensorInfo(l, "int32", []) ];
        if (o === 1) return [ r, Sn({
            attrs: {
                shape: l,
                dtype: "int32",
                value: 0
            },
            backend: n
        }) ];
        let p = k.sizeFromShape(l) / o, u = Ne({
            inputs: {
                x: r
            },
            attrs: {
                shape: [ p, o ]
            },
            backend: n
        }), c = Jw(s), d = Jw(o), h = null, f = () => h === null ? [ u, u ] : [ u, h ], m = (b, v, I) => {
            let N = f(), T = new FX(I), R = [ {
                type: "int32",
                data: [ o ]
            }, {
                type: "int32",
                data: [ h === null ? 1 : 0 ]
            }, {
                type: "float32",
                data: [ Number.NEGATIVE_INFINITY ]
            }, {
                type: "int32",
                data: [ b ]
            }, {
                type: "int32",
                data: [ v ]
            } ], w = h;
            h = n.runWebGPUProgram(T, N, "int32", R), ku(n, w);
        };
        for (let b = 1; b < c; b *= 2) {
            let v = 2 * b;
            for (let I = b; I >= 1; I /= 2) m(v, I, [ p, d ]);
        }
        for (let b = d; b > c; b /= 2) {
            let v = f(), I = new _X([ p, b / 2 ]), N = [ {
                type: "int32",
                data: [ o ]
            }, {
                type: "int32",
                data: [ h === null ? 1 : 0 ]
            }, {
                type: "int32",
                data: [ c ]
            } ], T = h;
            h = n.runWebGPUProgram(I, v, "int32", N), ku(n, T);
            let R = c / 2, w = 2 * R;
            for (let E = R; E >= 1; E /= 2) m(w, E, h.shape);
        }
        let g = h;
        h = vu({
            inputs: {
                x: h
            },
            backend: n,
            attrs: {
                begin: 0,
                size: [ p, s ]
            }
        }), ku(n, g);
        let y = qw({
            inputs: {
                x: u,
                indices: h
            },
            backend: n,
            attrs: {
                axis: 1,
                batchDims: 1
            }
        });
        ku(n, u);
        let A = l.slice(0, -1);
        A.push(s), g = h, h = Ne({
            inputs: {
                x: h
            },
            attrs: {
                shape: A
            },
            backend: n
        }), ku(n, g);
        let x = y;
        return y = Ne({
            inputs: {
                x: y
            },
            attrs: {
                shape: A
            },
            backend: n
        }), ku(n, x), [ y, h ];
    }
}, PX = class {
    constructor(e) {
        this.variableNames = [ "Image", "Transforms" ], this.uniforms = "interpolationModeId : i32, fillModeId : i32, fillValue : f32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.size = !0, this.outputShape = e, 
        this.dispatchLayout = xe(this.outputShape), this.dispatch = de(this.dispatchLayout, this.outputShape, this.workgroupSize), 
        this.shaderKey = "transform";
    }
    getUserCode() {
        return `
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${le("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;
    }
}, DX = {
    kernelName: ao,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let t, {
            inputs: n,
            backend: a,
            attrs: r
        } = e, {
            image: s,
            transforms: i
        } = n, {
            interpolation: l,
            fillMode: o,
            fillValue: p,
            outputShape: u
        } = r, [ c, d, h, f ] = s.shape, [ m, g ] = u ?? [ d, h ], y = new PX([ c, m, g, f ]), A = l === "nearest" ? 1 : 2;
        switch (o) {
          case "constant":
          default:
            t = 1;
            break;

          case "reflect":
            t = 2;
            break;

          case "wrap":
            t = 3;
            break;

          case "nearest":
            t = 4;
        }
        let x = [ {
            type: "int32",
            data: [ A ]
        }, {
            type: "int32",
            data: [ t ]
        }, {
            type: "float32",
            data: [ p ]
        } ];
        return a.runWebGPUProgram(y, [ s, i ], "float32", x);
    }
}, zX = {
    kernelName: Ul,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            value: r
        } = t, {
            axis: s
        } = a;
        s < 0 && (s += r.shape.length);
        let i = r, l = i.shape.length, o = r.shape[s], p = new Array(l - 1), u = 0;
        for (let m = 0; m < l; m++) m !== s && (p[u++] = i.shape[m]);
        let c = [], d = new Array(l).fill(0), h = i.shape.slice();
        h[s] = 1;
        let f = new Array(o);
        for (let m = 0; m < f.length; m++) {
            d[s] = m;
            let g = vu({
                inputs: {
                    x: i
                },
                backend: n,
                attrs: {
                    begin: d,
                    size: h
                }
            }), y = Ne({
                inputs: {
                    x: g
                },
                backend: n,
                attrs: {
                    shape: p
                }
            });
            f[m] = y, c.push(g);
        }
        return c.forEach(m => n.disposeData(m.dataId)), f;
    }
}, LX = class {
    constructor(e, t, n) {
        if (this.outputShape = [], this.variableNames = [ "x", "segmentIds" ], this.uniforms = "numSegments : i32, xSize: i32,", 
        this.workgroupSize = [ 64, 1, 1 ], this.atomic = !0, this.outputShape = t, 
        this.dispatchLayout = xe(e), this.dispatch = de(this.dispatchLayout, e, this.workgroupSize), 
        n !== "float32" && n !== "int32") throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${n} type.`);
        this.type = n, this.shaderKey = "unsortedSegmentSum";
    }
    getUserCode() {
        return `
    ${le("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Kr("&result[flatIndex]", "value", this.type)}
        }
      }
    }
  `;
    }
}, WX = {
    kernelName: cd,
    backendName: "webgpu",
    kernelFunc: function(e) {
        let {
            inputs: t,
            backend: n,
            attrs: a
        } = e, {
            x: r,
            segmentIds: s
        } = t, {
            numSegments: i
        } = a, l = r.shape.length, o = [], p = 0, u = C.getAxesPermutation([ p ], l), c = r;
        u != null && (c = Va({
            inputs: {
                x: r
            },
            backend: n,
            attrs: {
                perm: u
            }
        }), o.push(c), p = C.getInnerMostAxes(1, l)[0]);
        let d = C.segment_util.computeOutShape(c.shape, p, i), h = k.sizeFromShape([ c.shape[p] ]), f = Ne({
            inputs: {
                x: c
            },
            backend: n,
            attrs: {
                shape: [ -1, h ]
            }
        });
        o.push(f);
        let m = r.dtype, g = [ f.shape[0], i ], y = Sn({
            backend: n,
            attrs: {
                shape: g,
                value: 0,
                dtype: m
            }
        }), A = new LX(f.shape, g, m), x = [ {
            type: "int32",
            data: [ i ]
        }, {
            type: "int32",
            data: [ k.sizeFromShape(f.shape) ]
        } ], b = n.runWebGPUProgram(A, [ f, s ], m, x, y), v = Ne({
            inputs: {
                x: b
            },
            backend: n,
            attrs: {
                shape: d
            }
        });
        o.push(b);
        let I = v;
        if (u != null) {
            o.push(v);
            let N = C.getUndoAxesPermutation(u);
            I = Va({
                inputs: {
                    x: I
                },
                backend: n,
                attrs: {
                    perm: N
                }
            });
        }
        return o.forEach(N => n.disposeData(N.dataId)), I;
    }
}, BX = [ YV, OU, DU, LU, BU, UU, KU, ZU, YU, JU, eG, nG, rG, iG, lG, cG, hG, gG, yG, AG, vG, kG, SG, TG, EG, FG, QV, OG, zG, VG, qG, KG, YG, JG, QG, tH, aH, sH, iH, oH, lH, dH, mH, gH, cH, AH, bH, kH, IH, NH, RH, $H, MH, _H, PH, zH, LH, BH, VH, KV, GH, ZH, jH, XH, JH, QH, ej, nj, rj, ij, lj, JV, uj, DG, pj, hj, mj, gj, Aj, bj, wj, Nj, Ij, Tj, Ej, Mj, Oj, Dj, dG, Lj, Wj, Hj, Bj, Gj, jj, pG, qj, Kj, Yj, Qj, aq, CH, rq, sq, iq, NG, lq, dq, pq, hq, mq, gq, yq, Aq, CG, bq, wq, Iq, Nq, ZV, Tq, Eq, Mq, _q, Pq, zq, Wq, Vq, Uq, Hq, qq, Kq, Yq, Qq, tX, aX, bG, wX, IX, SX, nq, sX, oX, pX, cX, mX, gX, AX, xX, vX, CX, TH, RX, $X, MX, fX, OX, DX, jU, zX, WX, uq ];

for (let e of BX) Aa(e);

var Qw = "4.17.0", W1 = {
    tfjs: Qw,
    "tfjs-core": Qw,
    "tfjs-converter": "4.17.0",
    "tfjs-backend-cpu": "4.17.0",
    "tfjs-backend-webgl": "4.17.0",
    "tfjs-backend-wasm": "4.17.0",
    "tfjs-backend-webgpu": "4.17.0"
}, e7 = void 0;

function ee(...e) {
    const t = new Date();
    t.getHours().toString().padStart(2, "0"), t.getMinutes().toString().padStart(2, "0"), 
    t.getSeconds().toString().padStart(2, "0"), t.getMilliseconds().toString().padStart(3, "0");
}

var se = () => typeof performance < "u" ? performance.now() : parseInt((Number(process.hrtime.bigint()) / 1e3 / 1e3).toString());

function t7(e, t, n = "config", a = []) {
    for (const r of Object.keys(t)) if (typeof t[r] == "object") t7(e[r], t[r], r, a); else {
        const s = e && e[r] !== void 0;
        s || a.push({
            reason: "unknown property",
            where: `${n}.${r} = ${t[r]}`
        });
        const i = e && typeof e[r] == typeof t[r];
        s && !i && a.push({
            reason: "property type mismatch",
            where: `${n}.${r} = ${t[r]}`,
            expected: typeof e[r]
        });
    }
    return t.debug && n === "config" && a.length > 0 && ee(), a;
}

function gn(...e) {
    const t = n => n && typeof n == "object";
    return e.reduce((n, a) => (Object.keys(a || {}).forEach(r => {
        const s = n[r], i = a[r];
        Array.isArray(s) && Array.isArray(i) ? n[r] = s.concat(...i) : t(s) && t(i) ? n[r] = gn(s, i) : n[r] = i;
    }), n), {});
}

var mp = {
    backend: "",
    modelBasePath: "",
    cacheModels: !0,
    validateModels: !0,
    wasmPath: "",
    wasmPlatformFetch: !1,
    debug: !1,
    async: !0,
    warmup: "full",
    cacheSensitivity: .7,
    skipAllowed: !1,
    deallocate: !1,
    flags: {},
    softwareKernels: !1,
    filter: {
        enabled: !0,
        equalization: !1,
        width: 0,
        height: 0,
        flip: !1,
        return: !0,
        autoBrightness: !0,
        brightness: 0,
        contrast: 0,
        sharpness: 0,
        blur: 0,
        saturation: 0,
        hue: 0,
        negative: !1,
        sepia: !1,
        vintage: !1,
        kodachrome: !1,
        technicolor: !1,
        polaroid: !1,
        pixelate: 0
    },
    gesture: {
        enabled: !0
    },
    face: {
        enabled: !0,
        detector: {
            modelPath: "blazeface.json",
            rotation: !1,
            maxDetected: 1,
            skipFrames: 99,
            skipTime: 2500,
            minConfidence: .2,
            minSize: 0,
            iouThreshold: .1,
            scale: 1.4,
            mask: !1,
            return: !1
        },
        mesh: {
            enabled: !0,
            modelPath: "facemesh.json",
            keepInvalid: !1
        },
        attention: {
            enabled: !1,
            modelPath: "facemesh-attention.json"
        },
        iris: {
            enabled: !0,
            scale: 2.3,
            modelPath: "iris.json"
        },
        emotion: {
            enabled: !0,
            minConfidence: .1,
            skipFrames: 99,
            skipTime: 1500,
            modelPath: "emotion.json"
        },
        description: {
            enabled: !0,
            modelPath: "faceres.json",
            skipFrames: 99,
            skipTime: 3e3,
            minConfidence: .1
        },
        antispoof: {
            enabled: !1,
            skipFrames: 99,
            skipTime: 4e3,
            modelPath: "antispoof.json"
        },
        liveness: {
            enabled: !1,
            skipFrames: 99,
            skipTime: 4e3,
            modelPath: "liveness.json"
        }
    },
    body: {
        enabled: !0,
        modelPath: "movenet-lightning.json",
        maxDetected: -1,
        minConfidence: .3,
        skipFrames: 1,
        skipTime: 200
    },
    hand: {
        enabled: !0,
        rotation: !0,
        skipFrames: 99,
        skipTime: 1e3,
        minConfidence: .5,
        iouThreshold: .2,
        maxDetected: -1,
        landmarks: !0,
        detector: {
            modelPath: "handtrack.json"
        },
        skeleton: {
            modelPath: "handlandmark-lite.json"
        }
    },
    object: {
        enabled: !1,
        modelPath: "centernet.json",
        minConfidence: .2,
        iouThreshold: .4,
        maxDetected: 10,
        skipFrames: 99,
        skipTime: 2e3
    },
    segmentation: {
        enabled: !1,
        modelPath: "rvm.json",
        ratio: .5,
        mode: "default"
    }
}, VX = `
  precision highp float;
  attribute vec2 pos;
  attribute vec2 uv;
  varying vec2 vUv;
  uniform float flipY;
  void main(void) {
    vUv = uv;
    gl_Position = vec4(pos.x, pos.y*flipY, 0.0, 1.);
  }
`, UX = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[3] * c.a + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[8] * c.a + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[13] * c.a + m[14];
    gl_FragColor.a = m[15] * c.r + m[16] * c.g + m[17] * c.b + m[18] * c.a + m[19];
  }
`, GX = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform float m[20];
  void main(void) {
    vec4 c = texture2D(texture, vUv);
    gl_FragColor.r = m[0] * c.r + m[1] * c.g + m[2] * c.b + m[4];
    gl_FragColor.g = m[5] * c.r + m[6] * c.g + m[7] * c.b + m[9];
    gl_FragColor.b = m[10] * c.r + m[11] * c.g + m[12] * c.b + m[14];
    gl_FragColor.a = c.a;
  }
`, HX = `
  precision highp float;
  varying vec2 vUv;
  uniform vec2 size;
  uniform sampler2D texture;
  vec2 pixelate(vec2 coord, vec2 size) {
    return floor( coord / size ) * size;
  }
  void main(void) {
    gl_FragColor = vec4(0.0);
    vec2 coord = pixelate(vUv, size);
    gl_FragColor += texture2D(texture, coord);
  }
`, jX = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  void main(void) {
    gl_FragColor = vec4(0.0);
    gl_FragColor += texture2D(texture, vUv + vec2(-7.0*px.x, -7.0*px.y))*0.0044299121055113265;
    gl_FragColor += texture2D(texture, vUv + vec2(-6.0*px.x, -6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2(-5.0*px.x, -5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2(-4.0*px.x, -4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2(-3.0*px.x, -3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2(-2.0*px.x, -2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2(-1.0*px.x, -1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv                             )*0.159576912161;
    gl_FragColor += texture2D(texture, vUv + vec2( 1.0*px.x,  1.0*px.y))*0.147308056121;
    gl_FragColor += texture2D(texture, vUv + vec2( 2.0*px.x,  2.0*px.y))*0.115876621105;
    gl_FragColor += texture2D(texture, vUv + vec2( 3.0*px.x,  3.0*px.y))*0.0776744219933;
    gl_FragColor += texture2D(texture, vUv + vec2( 4.0*px.x,  4.0*px.y))*0.0443683338718;
    gl_FragColor += texture2D(texture, vUv + vec2( 5.0*px.x,  5.0*px.y))*0.0215963866053;
    gl_FragColor += texture2D(texture, vUv + vec2( 6.0*px.x,  6.0*px.y))*0.00895781211794;
    gl_FragColor += texture2D(texture, vUv + vec2( 7.0*px.x,  7.0*px.y))*0.0044299121055113265;
  }
`, qX = `
  precision highp float;
  varying vec2 vUv;
  uniform sampler2D texture;
  uniform vec2 px;
  uniform float m[9];
  void main(void) {
    vec4 c11 = texture2D(texture, vUv - px); // top left
    vec4 c12 = texture2D(texture, vec2(vUv.x, vUv.y - px.y)); // top center
    vec4 c13 = texture2D(texture, vec2(vUv.x + px.x, vUv.y - px.y)); // top right
    vec4 c21 = texture2D(texture, vec2(vUv.x - px.x, vUv.y) ); // mid left
    vec4 c22 = texture2D(texture, vUv); // mid center
    vec4 c23 = texture2D(texture, vec2(vUv.x + px.x, vUv.y) ); // mid right
    vec4 c31 = texture2D(texture, vec2(vUv.x - px.x, vUv.y + px.y) ); // bottom left
    vec4 c32 = texture2D(texture, vec2(vUv.x, vUv.y + px.y) ); // bottom center
    vec4 c33 = texture2D(texture, vUv + px ); // bottom right
    gl_FragColor = 
    c11 * m[0] + c12 * m[1] + c22 * m[2] +
    c21 * m[3] + c22 * m[4] + c23 * m[5] +
    c31 * m[6] + c32 * m[7] + c33 * m[8];
    gl_FragColor.a = c22.a;
  }
`, B1 = (e, t, n) => {
    const a = new RegExp("\\b" + t + " \\w+ (\\w+)", "ig");
    e.replace(a, (r, s) => (n[s] = 0, r));
}, XX = class {
    constructor(e, t, n) {
        ve(this, "uniform", {}), ve(this, "attribute", {}), ve(this, "gl"), ve(this, "id"), 
        ve(this, "compile", (s, i) => {
            const l = this.gl.createShader(i);
            return l ? (this.gl.shaderSource(l, s), this.gl.compileShader(l), this.gl.getShaderParameter(l, this.gl.COMPILE_STATUS) ? l : (ee(this.gl.getShaderInfoLog(l)), 
            null)) : (ee(), null);
        }), this.gl = e;
        const a = this.compile(t, this.gl.VERTEX_SHADER), r = this.compile(n, this.gl.FRAGMENT_SHADER);
        if (this.id = this.gl.createProgram(), a && r) if (this.id) if (this.gl.attachShader(this.id, a), 
        this.gl.attachShader(this.id, r), this.gl.linkProgram(this.id), this.gl.getProgramParameter(this.id, this.gl.LINK_STATUS)) {
            this.gl.useProgram(this.id), B1(t, "attribute", this.attribute);
            for (const s in this.attribute) this.attribute[s] = this.gl.getAttribLocation(this.id, s);
            B1(t, "uniform", this.uniform), B1(n, "uniform", this.uniform);
            for (const s in this.uniform) this.uniform[s] = this.gl.getUniformLocation(this.id, s);
        } else ee(this.gl.getProgramInfoLog(this.id)); else ee();
    }
};

function KX() {
    let e = 0, t = null, n = !1, a = -1, r = [ null, null ], s = [], i = null, l = null;
    const o = Zr(100, 100), p = {}, u = 1, c = o.getContext("webgl");
    if (!c) return void ee();
    function d(g) {
        return r[g] = r[g] || function(y, A) {
            const x = c.createFramebuffer();
            c.bindFramebuffer(c.FRAMEBUFFER, x);
            const b = c.createRenderbuffer();
            c.bindRenderbuffer(c.RENDERBUFFER, b);
            const v = c.createTexture();
            return c.bindTexture(c.TEXTURE_2D, v), c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, y, A, 0, c.RGBA, c.UNSIGNED_BYTE, null), 
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR), 
            c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), 
            c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, v, 0), 
            c.bindTexture(c.TEXTURE_2D, null), c.bindFramebuffer(c.FRAMEBUFFER, null), 
            {
                fbo: x,
                texture: v
            };
        }(o.width, o.height), r[g];
    }
    function h(g = 0) {
        if (!l) return;
        let y = null, A = null, x = !1;
        y = e === 0 ? t : d(a).texture || null, e++, !n || g & u ? (a = (a + 1) % 2, 
        A = d(a).fbo || null) : (A = null, x = e % 2 == 0), c.bindTexture(c.TEXTURE_2D, y), 
        c.bindFramebuffer(c.FRAMEBUFFER, A), c.uniform1f(l.uniform.flipY, x ? -1 : 1), 
        c.drawArrays(c.TRIANGLES, 0, 6);
    }
    function f(g) {
        if (p[g]) return l = p[g], c.useProgram((l ? l.id : null) || null), l;
        if (l = new XX(c, VX, g), !l) return ee(), null;
        const y = Float32Array.BYTES_PER_ELEMENT, A = 4 * y;
        return c.enableVertexAttribArray(l.attribute.pos), c.vertexAttribPointer(l.attribute.pos, 2, c.FLOAT, !1, A, 0 * y), 
        c.enableVertexAttribArray(l.attribute.uv), c.vertexAttribPointer(l.attribute.uv, 2, c.FLOAT, !1, A, 2 * y), 
        p[g] = l, l;
    }
    this.gl = c;
    const m = {
        colorMatrix: g => {
            const y = new Float32Array(g);
            y[4] /= 255, y[9] /= 255, y[14] /= 255, y[19] /= 255;
            const A = f(y[18] === 1 && y[3] === 0 && y[8] === 0 && y[13] === 0 && y[15] === 0 && y[16] === 0 && y[17] === 0 && y[19] === 0 ? GX : UX);
            A && (c.uniform1fv(A.uniform.m, y), h());
        },
        brightness: g => {
            const y = (g || 0) + 1;
            m.colorMatrix([ y, 0, 0, 0, 0, 0, y, 0, 0, 0, 0, 0, y, 0, 0, 0, 0, 0, 1, 0 ]);
        },
        saturation: g => {
            const y = 2 * (g || 0) / 3 + 1, A = -.5 * (y - 1);
            m.colorMatrix([ y, A, A, 0, 0, A, y, A, 0, 0, A, A, y, 0, 0, 0, 0, 0, 1, 0 ]);
        },
        desaturate: () => {
            m.saturation(-1);
        },
        contrast: g => {
            const y = (g || 0) + 1, A = -128 * (y - 1);
            m.colorMatrix([ y, 0, 0, 0, A, 0, y, 0, 0, A, 0, 0, y, 0, A, 0, 0, 0, 1, 0 ]);
        },
        negative: () => {
            m.contrast(-2);
        },
        hue: g => {
            g = (g || 0) / 180 * Math.PI;
            const y = Math.cos(g), A = Math.sin(g), x = .213, b = .715, v = .072;
            m.colorMatrix([ x + .787 * y + A * -x, b + y * -b + A * -b, v + y * -v + .928 * A, 0, 0, x + y * -x + .143 * A, b + y * (1 - b) + .14 * A, v + y * -v + -.283 * A, 0, 0, x + y * -x + -.787 * A, b + y * -b + A * b, v + .928 * y + A * v, 0, 0, 0, 0, 0, 1, 0 ]);
        },
        desaturateLuminance: () => {
            m.colorMatrix([ .2764723, .929708, .0938197, 0, -37.1, .2764723, .929708, .0938197, 0, -37.1, .2764723, .929708, .0938197, 0, -37.1, 0, 0, 0, 1, 0 ]);
        },
        sepia: () => {
            m.colorMatrix([ .393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0 ]);
        },
        brownie: () => {
            m.colorMatrix([ .5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0 ]);
        },
        vintagePinhole: () => {
            m.colorMatrix([ .6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0 ]);
        },
        kodachrome: () => {
            m.colorMatrix([ 1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0 ]);
        },
        technicolor: () => {
            m.colorMatrix([ 1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0 ]);
        },
        polaroid: () => {
            m.colorMatrix([ 1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0 ]);
        },
        shiftToBGR: () => {
            m.colorMatrix([ 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0 ]);
        },
        convolution: g => {
            const y = new Float32Array(g), A = 1 / o.width, x = 1 / o.height, b = f(qX);
            b && (c.uniform1fv(b.uniform.m, y), c.uniform2f(b.uniform.px, A, x), 
            h());
        },
        detectEdges: () => {
            m.convolution.call(this, [ 0, 1, 0, 1, -4, 1, 0, 1, 0 ]);
        },
        sobelX: () => {
            m.convolution.call(this, [ -1, 0, 1, -2, 0, 2, -1, 0, 1 ]);
        },
        sobelY: () => {
            m.convolution.call(this, [ -1, -2, -1, 0, 0, 0, 1, 2, 1 ]);
        },
        sharpen: g => {
            const y = g || 1;
            m.convolution.call(this, [ 0, -1 * y, 0, -1 * y, 1 + 4 * y, -1 * y, 0, -1 * y, 0 ]);
        },
        emboss: g => {
            const y = g || 1;
            m.convolution.call(this, [ -2 * y, -1 * y, 0, -1 * y, 1, 1 * y, 0, 1 * y, 2 * y ]);
        },
        blur: g => {
            const y = g / 7 / o.width, A = g / 7 / o.height, x = f(jX);
            x && (c.uniform2f(x.uniform.px, 0, A), h(u), c.uniform2f(x.uniform.px, y, 0), 
            h());
        },
        pixelate: g => {
            const y = g / o.width, A = g / o.height, x = f(HX);
            x && (c.uniform2f(x.uniform.size, y, A), h());
        }
    };
    this.add = function(g) {
        const y = Array.prototype.slice.call(arguments, 1), A = m[g];
        s.push({
            func: A,
            args: y
        });
    }, this.reset = function() {
        s = [];
    }, this.get = function() {
        return s;
    }, this.apply = function(g) {
        (function(y, A) {
            if (y !== o.width || A !== o.height) {
                if (o.width = y, o.height = A, !i) {
                    const x = new Float32Array([ -1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 1, 1, 1, 1, 1, 0 ]);
                    i = c.createBuffer(), c.bindBuffer(c.ARRAY_BUFFER, i), c.bufferData(c.ARRAY_BUFFER, x, c.STATIC_DRAW), 
                    c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
                }
                c.viewport(0, 0, o.width, o.height), r = [ null, null ];
            }
        })(g.width, g.height), e = 0, t || (t = c.createTexture()), c.bindTexture(c.TEXTURE_2D, t), 
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), 
        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), 
        c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, c.RGBA, c.UNSIGNED_BYTE, g);
        for (let y = 0; y < s.length; y++) {
            n = y === s.length - 1;
            const A = s[y];
            A.func.apply(this, A.args || []);
        }
        return o;
    }, this.draw = function(g) {
        return this.add("brightness", 0), this.apply(g);
    };
}

async function n7(e) {
    const t = e.shape.length === 4 ? at(e) : e, n = Ia(t, 3, 2), a = [ yo(n[0]), yo(n[1]), yo(n[2]) ], r = [ Jn(n[0]), Jn(n[1]), Jn(n[2]) ], s = await Promise.all(r.map(p => p.data())), i = Math.max(s[0][0], s[1][0], s[2][0]), l = (i > 1 ? 255 : 1) / i;
    let o;
    if (l > 1) {
        const p = [ $e(n[0], a[0]), $e(n[1], a[1]), $e(n[2], a[2]) ], u = [ $e(r[0], a[0]), $e(r[1], a[1]), $e(r[2], a[2]) ], c = [ ne(p[0], l), ne(p[1], l), ne(p[2], l) ], d = Bn([ c[0], c[1], c[2] ], 2);
        o = Q(d, [ 1, t.shape[0] || 0, t.shape[1] || 0, 3 ]), ae([ ...p, ...u, ...c, d ]);
    } else o = pn(t, 0);
    return ae([ ...n, ...a, ...r, n, t, e ]), o;
}

var wt, rh, sh, ih, oh = 3840, qt = null, tn = null, Iu = null, na = {
    inputSum: 0,
    cacheDiff: 1,
    sumMethod: 0,
    inputTensor: void 0
};

function a7() {
    na.inputSum = 0, na.cacheDiff = 1, na.sumMethod = 0, na.inputTensor = void 0;
}

function Zr(e, t) {
    let n;
    if (ce.browser) if (ce.worker) {
        if (typeof OffscreenCanvas > "u") throw new Error("canvas error: attempted to run in web worker but OffscreenCanvas is not supported");
        n = new OffscreenCanvas(e, t);
    } else if (typeof document < "u") n = document.createElement("canvas"), n.width = e, 
    n.height = t; else {
        if (typeof navigator > "u" || navigator.product !== "ReactNative") throw new Error("canvas error: attempted to run in browser but DOM is not defined");
        if (ce.Canvas !== void 0) n = new ce.Canvas(e, t); else {
            if (globalThis.Canvas === void 0) throw new Error("canvas error: attempted to use canvas in react-native without canvas support installed");
            n = new globalThis.Canvas(e, t);
        }
    } else ce.Canvas !== void 0 ? n = new ce.Canvas(e, t) : globalThis.Canvas !== void 0 && (n = new globalThis.Canvas(e, t));
    return n;
}

function lh(e, t) {
    const n = t || Zr(e.width, e.height);
    return n.getContext("2d").drawImage(e, 0, 0), n;
}

async function V1(e, t, n = !0) {
    var a, r, s;
    if (!e) return t.debug && ee(), {
        tensor: null,
        canvas: null
    };
    if (!(e instanceof vt || typeof Image < "u" && e instanceof Image || globalThis.Canvas !== void 0 && e instanceof globalThis.Canvas || typeof ImageData < "u" && e instanceof ImageData || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLMediaElement < "u" && e instanceof HTMLMediaElement || typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas)) throw new Error("input error: type not recognized");
    if (e instanceof vt) {
        let m = null;
        if (e.isDisposedInternal) throw new Error("input error: attempted to use tensor but it is disposed");
        if (!e.shape) throw new Error("input error: attempted to use tensor without a shape");
        if (e.shape.length === 3) {
            if (e.shape[2] === 3) m = pn(e, 0); else if (e.shape[2] === 4) {
                const g = lc(e, [ 0, 0, 0 ], [ -1, -1, 3 ]);
                m = pn(g, 0), ae(g);
            }
        } else e.shape.length === 4 && (e.shape[3] === 3 ? m = wn(e) : e.shape[3] === 4 && (m = jf(e, [ 0, 0, 0, 0 ], [ -1, -1, -1, 3 ])));
        if (m == null || m.shape.length !== 4 || m.shape[0] !== 1 || m.shape[3] !== 3) throw new Error(`input error: attempted to use tensor with unrecognized shape: ${e.shape.toString()}`);
        if (m.dtype === "int32") {
            const g = Qe(m, "float32");
            ae(m), m = g;
        }
        return {
            tensor: m,
            canvas: t.filter.return ? tn : null
        };
    }
    if (e.readyState !== void 0 && e.readyState <= 2) return t.debug && ee(), {
        tensor: null,
        canvas: qt
    };
    const i = e.naturalWidth || e.videoWidth || e.width || e.shape && e.shape[1] > 0, l = e.naturalHeight || e.videoHeight || e.height || e.shape && e.shape[2] > 0;
    if (!i || !l) return t.debug && ee(), {
        tensor: null,
        canvas: qt
    };
    let o = i, p = l;
    if (o > oh && (o = oh, p = Math.trunc(o * l / i)), p > oh && (p = oh, o = Math.trunc(p * i / l)), 
    (((a = t.filter) == null ? void 0 : a.width) || 0) > 0 ? o = t.filter.width : (((r = t.filter) == null ? void 0 : r.height) || 0) > 0 && (o = i * ((t.filter.height || 0) / l)), 
    (t.filter.height || 0) > 0 ? p = t.filter.height : (t.filter.width || 0) > 0 && (p = l * ((t.filter.width || 0) / i)), 
    !o || !p) throw new Error("input error: cannot determine dimension");
    qt && qt.width === o && qt.height === p || (qt = Zr(o, p));
    const u = qt.getContext("2d");
    if (typeof ImageData < "u" && e instanceof ImageData ? u.putImageData(e, 0, 0) : t.filter.flip && u.translate !== void 0 ? (u.translate(i, 0), 
    u.scale(-1, 1), u.drawImage(e, 0, 0, i, l, 0, 0, qt.width, qt.height), u.setTransform(1, 0, 0, 1, 0, 0)) : u.drawImage(e, 0, 0, i, l, 0, 0, qt.width, qt.height), 
    tn && qt.width === tn.width && qt.height === tn.height || (tn = Zr(qt.width, qt.height)), 
    t.filter.enabled && ce.webgl.supported ? (wt || (wt = ce.browser ? new KX() : null), 
    ce.filter = !!wt, wt != null && wt.add ? (wt.reset(), t.filter.brightness !== 0 && wt.add("brightness", t.filter.brightness), 
    t.filter.contrast !== 0 && wt.add("contrast", t.filter.contrast), t.filter.sharpness !== 0 && wt.add("sharpen", t.filter.sharpness), 
    t.filter.blur !== 0 && wt.add("blur", t.filter.blur), t.filter.saturation !== 0 && wt.add("saturation", t.filter.saturation), 
    t.filter.hue !== 0 && wt.add("hue", t.filter.hue), t.filter.negative && wt.add("negative"), 
    t.filter.sepia && wt.add("sepia"), t.filter.vintage && wt.add("brownie"), t.filter.sepia && wt.add("sepia"), 
    t.filter.kodachrome && wt.add("kodachrome"), t.filter.technicolor && wt.add("technicolor"), 
    t.filter.polaroid && wt.add("polaroid"), t.filter.pixelate !== 0 && wt.add("pixelate", t.filter.pixelate), 
    tn = ((s = wt.get()) == null ? void 0 : s.length) > 1 ? wt.apply(qt) : wt.draw(qt)) : (t.debug && ee(), 
    ce.webgl.supported = !1, t.filter.enabled = !1, lh(qt, tn))) : (lh(qt, tn), 
    wt && (wt = null), ce.filter = !!wt), !n) return {
        tensor: null,
        canvas: tn
    };
    if (!tn) throw new Error("canvas error: cannot create output");
    let c, d = 3;
    if (typeof ImageData < "u" && e instanceof ImageData || e.data && e.width && e.height) ce.browser && Lr ? c = Lr ? Lr.fromPixels(e) : null : (d = e.data.length / e.height / e.width, 
    c = Ye(new Uint8Array(e.data.buffer), [ e.height, e.width, d ], "int32")); else if (Iu && tn.width === Iu.width && tn.height === Iu.height || (Iu = Zr(tn.width, tn.height)), 
    Lr && ce.browser) t.backend === "webgl" || t.backend === "humangl" || t.backend === "webgpu" ? c = Lr.fromPixels(tn) : (Iu = lh(tn), 
    c = Lr.fromPixels(Iu)); else {
        const m = lh(tn).getContext("2d").getImageData(0, 0, o, p);
        d = m.data.length / o / p, c = Ye(new Uint8Array(m.data.buffer), [ o, p, d ]);
    }
    if (d === 4) {
        const m = lc(c, [ 0, 0, 0 ], [ -1, -1, 3 ]);
        ae(c), c = m;
    }
    if (!c) throw new Error("input error: cannot create tensor");
    const h = Qe(c, "float32"), f = t.filter.equalization ? await n7(h) : pn(h, 0);
    if (ae([ c, h ]), t.filter.autoBrightness) {
        const m = Jn(f), g = await m.data();
        t.filter.brightness = g[0] > 1 ? 1 - g[0] / 255 : 1 - g[0], ae(m);
    }
    return {
        tensor: f,
        canvas: t.filter.return ? tn : null
    };
}

rh = new WeakMap(), sh = new WeakMap(), ih = new WeakMap();

var ce = new class {
    constructor() {
        if (ve(this, "browser"), ve(this, "node"), ve(this, "worker"), ve(this, "platform", ""), 
        ve(this, "agent", ""), ve(this, "backends", []), ve(this, "initial"), ve(this, "filter"), 
        ve(this, "tfjs"), ve(this, "offscreen"), ve(this, "perfadd", !1), ve(this, "tensorflow", {
            version: void 0,
            gpu: void 0
        }), ve(this, "wasm", {
            supported: void 0,
            backend: void 0,
            simd: void 0,
            multithread: void 0
        }), ve(this, "webgl", {
            supported: void 0,
            backend: void 0,
            version: void 0,
            renderer: void 0,
            shader: void 0,
            vendor: void 0
        }), ve(this, "webgpu", {
            supported: void 0,
            backend: void 0,
            adapter: void 0
        }), ve(this, "cpu", {
            model: void 0,
            flags: []
        }), ve(this, "kernels", []), mr(this, rh, void 0), mr(this, sh, void 0), 
        mr(this, ih, void 0), this.browser = typeof navigator < "u" && navigator.appVersion !== void 0, 
        this.node = typeof process < "u" && process.versions !== void 0 && process.versions.node !== void 0, 
        this.tfjs = {
            version: W1["tfjs-core"]
        }, this.offscreen = typeof OffscreenCanvas < "u", this.initial = !0, this.worker = this.browser && this.offscreen ? typeof WorkerGlobalScope < "u" : void 0, 
        typeof navigator < "u" && navigator.userAgent !== void 0) {
            const e = navigator.userAgent || "", t = e.match(/\(([^()]+)\)/g);
            if (t != null && t[0]) {
                const n = t[0].match(/\(([^()]+)\)/g);
                this.platform = n != null && n[0] ? n[0].replace(/\(|\)/g, "") : "", 
                this.agent = e.replace(t[0], ""), this.platform[1] && (this.agent = this.agent.replace(t[1], "")), 
                this.agent = this.agent.replace(/  /g, " ");
            }
        } else typeof process < "u" && (this.platform = `${process.platform} ${process.arch}`, 
        this.agent = `NodeJS ${process.version}`);
    }
    get Canvas() {
        return sa(this, rh);
    }
    set Canvas(e) {
        ds(this, rh, e), globalThis.Canvas = e;
    }
    get Image() {
        return sa(this, sh);
    }
    set Image(e) {
        ds(this, sh, e), globalThis.Image = e;
    }
    get ImageData() {
        return sa(this, ih);
    }
    set ImageData(e) {
        ds(this, ih, e), globalThis.ImageData = e;
    }
    async updateBackend() {
        this.backends = Object.keys(Mt().registryFactory);
        try {
            this.tensorflow = {
                version: Rr().binding ? Rr().binding.TF_Version : void 0,
                gpu: Rr().binding ? Rr().binding.isUsingGpuDevice() : void 0
            };
        } catch {}
        this.wasm.supported = typeof WebAssembly < "u", this.wasm.backend = this.backends.includes("wasm"), 
        this.wasm.supported && this.wasm.backend && (this.wasm.simd = await H().getAsync("WASM_HAS_SIMD_SUPPORT"), 
        this.wasm.multithread = await H().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"));
        const e = Zr(100, 100), t = e ? e.getContext("webgl2") : void 0;
        this.webgl.supported = t !== void 0, this.webgl.backend = this.backends.includes("webgl"), 
        this.webgl.supported && this.webgl.backend && t && (this.webgl.version = t.getParameter(t.VERSION), 
        this.webgl.vendor = t.getParameter(t.VENDOR), this.webgl.renderer = t.getParameter(t.RENDERER), 
        this.webgl.shader = t.getParameter(t.SHADING_LANGUAGE_VERSION)), this.webgpu.supported = this.browser && typeof navigator < "u" && navigator.gpu !== void 0, 
        this.webgpu.backend = this.backends.includes("webgpu");
        try {
            if (this.webgpu.supported) {
                const n = await navigator.gpu.requestAdapter();
                this.webgpu.adapter = await (n == null ? void 0 : n.requestAdapterInfo());
            }
        } catch {
            this.webgpu.supported = !1;
        }
        try {
            this.kernels = so(dn()).map(n => n.kernelName.toLowerCase());
        } catch {}
    }
    updateCPU() {
        const e = {
            model: "",
            flags: []
        };
        this.node && this.platform.startsWith("linux"), this.cpu ? this.cpu = e : Object.defineProperty(this, "cpu", {
            value: e
        });
    }
}(), ZX = class {
    constructor() {
        ve(this, "config"), ve(this, "element"), ve(this, "stream"), ve(this, "devices", []), 
        ve(this, "enumerate", async () => {
            try {
                const e = await navigator.mediaDevices.enumerateDevices();
                this.devices = e.filter(t => t.kind === "videoinput");
            } catch {
                this.devices = [];
            }
            return this.devices;
        }), ve(this, "start", async e => {
            var t, n;
            if (e != null && e.debug && (this.config.debug = e == null ? void 0 : e.debug), 
            e != null && e.crop && (this.config.crop = e == null ? void 0 : e.crop), 
            e != null && e.mode && (this.config.mode = e == null ? void 0 : e.mode), 
            e != null && e.width && (this.config.width = e == null ? void 0 : e.width), 
            e != null && e.height && (this.config.height = e == null ? void 0 : e.height), 
            e != null && e.id && (this.config.id = e == null ? void 0 : e.id), e == null ? void 0 : e.element) if (typeof e.element == "string") {
                const s = document.getElementById(e.element);
                if (!(s && s instanceof HTMLVideoElement)) return this.config.debug && ee(e.element), 
                `webcam error: cannot get dom element: ${e.element}`;
                this.element = s;
            } else {
                if (!(e.element instanceof HTMLVideoElement)) return this.config.debug && ee(e.element), 
                `webcam error: unknown dom element: ${e.element}`;
                this.element = e.element;
            } else this.element = document.createElement("video");
            const a = {
                audio: !1,
                video: {
                    facingMode: this.config.mode === "front" ? "user" : "environment",
                    resizeMode: this.config.crop ? "crop-and-scale" : "none"
                }
            };
            if (((t = this.config) == null ? void 0 : t.width) > 0 && (a.video.width = {
                ideal: this.config.width
            }), ((n = this.config) == null ? void 0 : n.height) > 0 && (a.video.height = {
                ideal: this.config.height
            }), this.config.id && (a.video.deviceId = this.config.id), this.element.addEventListener("play", () => {
                this.config.debug && ee();
            }), this.element.addEventListener("pause", () => {
                this.config.debug && ee();
            }), this.element.addEventListener("click", async () => {
                this.element && this.stream && (this.element.paused ? await this.element.play() : this.element.pause());
            }), !(navigator != null && navigator.mediaDevices)) return this.config.debug && ee(), 
            "webcam error: no devices";
            try {
                this.stream = await navigator.mediaDevices.getUserMedia(a);
            } catch (s) {
                return ee(), `webcam error: ${s}`;
            }
            return this.stream ? (this.element.srcObject = this.stream, await new Promise(s => {
                this.element ? this.element.onloadeddata = () => s(!0) : s(!1);
            }), await this.element.play(), this.config.debug && ee((this.width, 
            this.height, this.label, this.stream, this.track, this.settings, this.constraints, 
            this.capabilities)), `webcam: ${this.label}`) : (this.config.debug && ee(), 
            "webcam error no stream");
        }), ve(this, "pause", () => {
            this.element && this.element.pause();
        }), ve(this, "play", async () => {
            this.element && await this.element.play();
        }), ve(this, "stop", () => {
            this.config.debug && ee(), this.track && this.track.stop();
        }), this.config = {
            element: void 0,
            debug: !0,
            mode: "front",
            crop: !1,
            width: 0,
            height: 0
        };
    }
    get track() {
        if (this.stream) return this.stream.getVideoTracks()[0];
    }
    get capabilities() {
        if (this.track) return this.track.getCapabilities ? this.track.getCapabilities() : void 0;
    }
    get constraints() {
        if (this.track) return this.track.getConstraints ? this.track.getConstraints() : void 0;
    }
    get settings() {
        if (!this.stream) return;
        const e = this.stream.getVideoTracks()[0];
        return e.getSettings ? e.getSettings() : void 0;
    }
    get label() {
        return this.track ? this.track.label : "";
    }
    get paused() {
        var e;
        return ((e = this.element) == null ? void 0 : e.paused) || !1;
    }
    get width() {
        var e;
        return ((e = this.element) == null ? void 0 : e.videoWidth) || 0;
    }
    get height() {
        var e;
        return ((e = this.element) == null ? void 0 : e.videoHeight) || 0;
    }
}, r7 = {};

fr(r7, {
    "affectnet-mobilenet": () => y7,
    age: () => A7,
    "anti-spoofing": () => Z7,
    antispoof: () => s7,
    blazeface: () => i7,
    "blazeface-back": () => x7,
    "blazeface-front": () => b7,
    "blazepose-detector": () => v7,
    "blazepose-full": () => w7,
    "blazepose-heavy": () => k7,
    "blazepose-lite": () => I7,
    centernet: () => o7,
    default: () => YX,
    efficientpose: () => S7,
    "efficientpose-i-lite": () => Y7,
    "efficientpose-ii-lite": () => J7,
    "efficientpose-iv": () => Q7,
    emotion: () => l7,
    faceboxes: () => N7,
    facemesh: () => u7,
    "facemesh-attention": () => T7,
    "facemesh-attention-pinto": () => C7,
    "facemesh-detection-full": () => R7,
    "facemesh-detection-short": () => E7,
    faceres: () => d7,
    "faceres-deep": () => $7,
    gear: () => _7,
    "gear-e1": () => M7,
    "gear-e2": () => F7,
    gender: () => P7,
    "gender-ssrnet-imdb": () => O7,
    handdetect: () => D7,
    "handlandmark-full": () => z7,
    "handlandmark-lite": () => p7,
    "handlandmark-sparse": () => L7,
    handskeleton: () => W7,
    handtrack: () => c7,
    "insightface-efficientnet-b0": () => ek,
    "insightface-ghostnet-strides1": () => tk,
    "insightface-ghostnet-strides2": () => nk,
    "insightface-mobilenet-emore": () => ak,
    "insightface-mobilenet-swish": () => rk,
    iris: () => h7,
    liveness: () => f7,
    meet: () => B7,
    mobileface: () => V7,
    mobilefacenet: () => U7,
    models: () => m7,
    "movenet-lightning": () => g7,
    "movenet-multipose": () => G7,
    "movenet-thunder": () => H7,
    nanodet: () => j7,
    "nanodet-e": () => sk,
    "nanodet-g": () => ik,
    "nanodet-m": () => ok,
    "nanodet-t": () => lk,
    posenet: () => q7,
    rvm: () => X7,
    selfie: () => K7
});

var s7 = 853098, i7 = 538928, o7 = 4030290, l7 = 820516, u7 = 1477958, d7 = 6978814, p7 = 2023432, c7 = 2964837, h7 = 2599092, f7 = 592976, m7 = 0, g7 = 4650216, y7 = 6920630, A7 = 161240, x7 = 538928, b7 = 402048, v7 = 5928856, w7 = 6339202, k7 = 27502466, I7 = 2726402, S7 = 5651240, N7 = 2013002, C7 = 2387598, T7 = 2382414, R7 = 1026192, E7 = 201268, $7 = 13957620, M7 = 112438, F7 = 112438, _7 = 1498916, O7 = 161236, P7 = 201808, D7 = 3515612, z7 = 5431368, L7 = 5286322, W7 = 5502280, B7 = 372228, V7 = 2183192, U7 = 5171976, G7 = 9448838, H7 = 12477112, j7 = 7574558, q7 = 5032780, X7 = 3739355, K7 = 212886, Z7 = 853098, Y7 = 2269064, J7 = 5651240, Q7 = 25643252, ek = 13013224, tk = 8093408, nk = 8049584, ak = 6938536, rk = 12168584, sk = 12319156, ik = 7574558, ok = 1887474, lk = 5294216, YX = {
    antispoof: s7,
    blazeface: i7,
    centernet: o7,
    emotion: l7,
    facemesh: u7,
    faceres: d7,
    "handlandmark-lite": p7,
    handtrack: c7,
    iris: h7,
    liveness: f7,
    models: m7,
    "movenet-lightning": g7,
    "affectnet-mobilenet": y7,
    age: A7,
    "blazeface-back": x7,
    "blazeface-front": b7,
    "blazepose-detector": v7,
    "blazepose-full": w7,
    "blazepose-heavy": k7,
    "blazepose-lite": I7,
    efficientpose: S7,
    faceboxes: N7,
    "facemesh-attention-pinto": C7,
    "facemesh-attention": T7,
    "facemesh-detection-full": R7,
    "facemesh-detection-short": E7,
    "faceres-deep": $7,
    "gear-e1": M7,
    "gear-e2": F7,
    gear: _7,
    "gender-ssrnet-imdb": O7,
    gender: P7,
    handdetect: D7,
    "handlandmark-full": z7,
    "handlandmark-sparse": L7,
    handskeleton: W7,
    meet: B7,
    mobileface: V7,
    mobilefacenet: U7,
    "movenet-multipose": G7,
    "movenet-thunder": H7,
    nanodet: j7,
    posenet: q7,
    rvm: X7,
    selfie: K7,
    "anti-spoofing": Z7,
    "efficientpose-i-lite": Y7,
    "efficientpose-ii-lite": J7,
    "efficientpose-iv": Q7,
    "insightface-efficientnet-b0": ek,
    "insightface-ghostnet-strides1": tk,
    "insightface-ghostnet-strides2": nk,
    "insightface-mobilenet-emore": ak,
    "insightface-mobilenet-swish": rk,
    "nanodet-e": sk,
    "nanodet-g": ik,
    "nanodet-m": ok,
    "nanodet-t": lk
}, Nn = {
    cacheModels: !0,
    cacheSupported: !0,
    verbose: !0,
    debug: !1,
    modelBasePath: ""
}, yn = {};

async function xt(e) {
    var t, n, a, r;
    let s = function(h, f) {
        const m = h.endsWith("/") ? "" : "/", g = f.startsWith(".") || f.startsWith("/") || f.startsWith("http:") || f.startsWith("https:") || f.startsWith("file:") ? `${f}` : `${h}${m}${f}`;
        if (!g.toLocaleLowerCase().includes(".json")) throw new Error(`modelpath error: expecting json file: ${g}`);
        return g;
    }(Nn.modelBasePath, e || "");
    s.toLowerCase().endsWith(".json") || (s += ".json");
    const i = s.includes("/") ? s.split("/") : s.split("\\"), l = i[i.length - 1].replace(".json", ""), o = "indexeddb://" + l;
    yn[l] = {
        name: l,
        sizeFromManifest: 0,
        sizeLoadedWeights: 0,
        sizeDesired: r7[l],
        inCache: !1,
        url: ""
    }, Nn.cacheSupported = typeof indexedDB < "u";
    let p = {};
    try {
        p = Nn.cacheSupported && Nn.cacheModels ? await nr.listModels() : {};
    } catch {
        Nn.cacheSupported = !1;
    }
    yn[l].inCache = Nn.cacheSupported && Nn.cacheModels && Object.keys(p).includes(o), 
    yn[l].url = yn[l].inCache ? o : s;
    const u = typeof fetch > "u" ? {} : {
        fetchFunc: (h, f) => async function(m, g) {
            return fetch(m, g);
        }(h, f)
    };
    let c = new Ic(yn[l].url, u), d = !1;
    try {
        c.findIOHandler(), Nn.debug;
    } catch {
        ee();
    }
    try {
        const h = await ((t = c.handler) == null ? void 0 : t.load()) || null;
        yn[l].sizeFromManifest = ((n = h == null ? void 0 : h.weightData) == null ? void 0 : n.byteLength) || 0, 
        h ? c.loadSync(h) : c = await Cx(yn[l].inCache ? o : s, u), yn[l].sizeLoadedWeights = ((r = (a = c.artifacts) == null ? void 0 : a.weightData) == null ? void 0 : r.byteLength) || 0, 
        Nn.verbose && ee((c.modelUrl, yn[l].sizeLoadedWeights)), d = !0;
    } catch {
        ee();
    }
    if (d && Nn.cacheModels && Nn.cacheSupported && !yn[l].inCache) try {
        await c.save(o), Nn.debug;
    } catch {
        ee();
    }
    return c;
}

var uk = "3.2.2", Nt = {
    name: "humangl",
    priority: 999,
    canvas: null,
    gl: null,
    extensions: [],
    webGLattr: {
        alpha: !1,
        antialias: !1,
        premultipliedAlpha: !1,
        preserveDrawingBuffer: !1,
        depth: !1,
        stencil: !1,
        failIfMajorPerformanceCaveat: !1,
        desynchronized: !0
    }
};

function JX(e) {
    var t;
    if (e.config.backend === "humangl" && (Nt.name in Mt().registry && !((t = Nt == null ? void 0 : Nt.gl) != null && t.getParameter(Nt.gl.VERSION)) && (ee(), 
    e.models.reset()), !O0(Nt.name))) {
        try {
            Nt.canvas = Zr(100, 100);
        } catch {
            return void ee();
        }
        try {
            if (Nt.gl = Nt.canvas.getContext("webgl2", Nt.webGLattr), !Nt.gl) return void ee();
            if (!Nt.gl.getParameter(Nt.gl.VERSION).includes("2.0")) return ee(), 
            void (e.config.backend = "webgl");
            Nt.canvas && (Nt.canvas.addEventListener("webglcontextlost", r => {
                throw ee(r.type), ee(), e.emit("error"), new Error("backend error: webgl context lost");
            }), Nt.canvas.addEventListener("webglcontextrestored", r => {
                ee();
            }), Nt.canvas.addEventListener("webglcontextcreationerror", r => {
                ee();
            }));
        } catch {
            return void ee();
        }
        try {
            Zm(2, Nt.gl);
        } catch {
            return void ee();
        }
        try {
            const r = new Qd(Nt.gl);
            ql(Nt.name, () => new Wc(r), Nt.priority);
        } catch {
            return void ee();
        }
        try {
            so("webgl").forEach(r => {
                Aa({
                    ...r,
                    backendName: Nt.name
                });
            });
        } catch {
            return void ee();
        }
        try {
            H().flagRegistry.WEBGL_VERSION && H().set("WEBGL_VERSION", 2);
        } catch {
            return void ee();
        }
        (function() {
            const r = Nt.gl;
            r && (Nt.extensions = r.getSupportedExtensions());
        })();
        const n = Rr(), a = n.gpgpu !== void 0 ? n.getGPGPUContext().gl : null;
        a ? e.config.debug && ee((a.getParameter(a.VERSION), a.getParameter(a.RENDERER))) : ee(Nt.gl);
    }
}

var lt = {
    tf255: 255,
    tf1: 1,
    tf2: 2,
    tf05: .5,
    tf127: 127.5,
    rgb: [ .2989, .587, .114 ]
}, dk = {};

async function U1(e, t = !1) {
    var n, a;
    if (e.state = "backend", ((n = e.config.backend) == null ? void 0 : n.length) === 0 && (e.config.backend = await async function() {
        var r;
        return await ce.updateBackend(), (r = ce.tensorflow) != null && r.version ? "tensorflow" : ce.webgpu.supported && ce.webgpu.backend ? "webgpu" : ce.webgl.supported && ce.webgl.backend ? "webgl" : ce.wasm.supported && ce.wasm.backend ? "wasm" : "cpu";
    }()), t || ce.initial || e.config.backend && e.config.backend.length > 0 && dn() !== e.config.backend) {
        const r = se();
        if (e.config.backend && e.config.backend.length > 0) {
            typeof window > "u" && typeof WorkerGlobalScope < "u" && e.config.debug && e.config.debug && ee(), 
            typeof navigator < "u" && ((a = navigator == null ? void 0 : navigator.userAgent) != null && a.toLowerCase().includes("electron")) && e.config.debug && ee();
            let s = Object.keys(Mt().registryFactory);
            if (e.config.backend !== "humangl" || s.includes("humangl") || (JX(e), 
            s = Object.keys(Mt().registryFactory)), e.config.debug && ee(), ce.browser && !ce.node && e.config.backend === "tensorflow" && s.includes("webgl") && (e.config.debug && ee(), 
            e.config.backend = "webgl"), !ce.node || ce.browser || e.config.backend !== "webgl" && e.config.backend !== "humangl" || !s.includes("tensorflow") || (e.config.debug && ee(e.config.backend), 
            e.config.backend = "tensorflow"), ce.browser && e.config.backend === "webgpu") if (typeof navigator > "u" || navigator.gpu === void 0) ee(), 
            e.config.backend = "webgl"; else {
                const i = await navigator.gpu.requestAdapter();
                e.config.debug && ee(), i ? ("requestAdapterInfo" in i && await i.requestAdapterInfo(), 
                ee()) : (ee(), e.config.backend = "webgl");
            }
            if (s.includes(e.config.backend) || (ee(e.config.backend), e.config.backend = ce.node ? "tensorflow" : "webgl", 
            e.config.debug && ee(e.config.backend)), e.config.debug && ee(e.config.backend), 
            e.config.backend === "wasm") {
                if (H().flagRegistry.CANVAS2D_WILL_READ_FREQUENTLY && H().set("CANVAS2D_WILL_READ_FREQUENTLY", !0), 
                e.config.debug && ee(e.config.wasmPath), S1 === void 0) throw new Error("backend error: attempting to use wasm backend but wasm path is not set");
                S1(e.config.wasmPath, e.config.wasmPlatformFetch);
                let i = !1, l = !1;
                try {
                    i = await H().getAsync("WASM_HAS_MULTITHREAD_SUPPORT"), l = await H().getAsync("WASM_HAS_SIMD_SUPPORT"), 
                    e.config.debug && ee(), e.config.debug && !l && ee();
                } catch {
                    ee();
                }
            }
            try {
                await Xp(e.config.backend), await rf();
            } catch {
                return ee(e.config.backend), !1;
            }
            e.config.debug && (dk = JSON.parse(JSON.stringify(H().flags)));
        }
        if (dn() !== "humangl" && dn() !== "webgl" || (H().flagRegistry.WEBGL_USE_SHAPES_UNIFORMS && H().set("WEBGL_USE_SHAPES_UNIFORMS", !0), 
        H().flagRegistry.WEBGL_EXP_CONV && H().set("WEBGL_EXP_CONV", !0), e.config.debug && e.config.deallocate !== void 0 && e.config.deallocate && (ee(), 
        H().set("WEBGL_DELETE_TEXTURE_THRESHOLD", 0))), dn(), e.config.debug) {
            const s = H().flags, i = {};
            for (const l of Object.keys(s)) dk[l] !== s[l] && (i[l] = s[l]);
            e.config.debug && Object.keys(i).length > 0 && ee(dn());
        }
        if (e.config.flags && Object.keys(e.config.flags).length > 0) {
            e.config.debug && ee(e.config.flags);
            for (const [ s, i ] of Object.entries(e.config.flags)) H().set(s, i);
        }
        F0(), lt.tf255 = je(255, "float32"), lt.tf1 = je(1, "float32"), lt.tf2 = je(2, "float32"), 
        lt.tf05 = je(.5, "float32"), lt.tf127 = je(127.5, "float32"), lt.rgb = Yt([ .2989, .587, .114 ], "float32"), 
        e.performance.initBackend = Math.trunc(se() - r), e.config.backend = dn(), 
        await ce.updateBackend(), function(s) {
            const i = [];
            ce.kernels.includes("mod") || (Aa({
                kernelName: "Mod",
                backendName: dn(),
                kernelFunc: l => qe(() => $e(l.inputs.a, ne(ze(l.inputs.a, l.inputs.b), l.inputs.b)))
            }), ce.kernels.push("mod"), i.push("mod")), ce.kernels.includes("floormod") || (Aa({
                kernelName: "FloorMod",
                backendName: dn(),
                kernelFunc: l => qe(() => _e(ne(Zp(l.inputs.a, l.inputs.b), l.inputs.b), sc(l.inputs.a, l.inputs.b)))
            }), ce.kernels.push("floormod"), i.push("floormod")), !ce.kernels.includes("rotatewithoffset") && s.softwareKernels && (Aa({
                kernelName: "RotateWithOffset",
                backendName: dn(),
                kernelFunc: l => qe(() => {
                    const o = dn();
                    Xp("cpu");
                    const p = Ue.rotateWithOffset(l.inputs.image, l.attrs.radians, l.attrs.fillValue, l.attrs.center);
                    return Xp(o), p;
                })
            }), ce.kernels.push("rotatewithoffset"), i.push("rotatewithoffset")), 
            i.length > 0 && s.debug && ee();
        }(e.config);
    }
    return !0;
}

function pk(e, t) {
    for (const n of e) Aa({
        kernelName: n,
        backendName: t.backend,
        kernelFunc: a => {
            var r;
            return t.debug && ee(t.backend), (r = a == null ? void 0 : a.inputs) == null ? void 0 : r.info;
        }
    });
    ce.kernels = so(dn()).map(n => n.kernelName.toLowerCase());
}

var ck = {};

fr(ck, {
    all: () => dK,
    body: () => Ak,
    canvas: () => uK,
    face: () => yk,
    gesture: () => vk,
    hand: () => xk,
    init: () => wk,
    object: () => bk,
    options: () => Cn,
    person: () => lK
});

var Lo = e => {
    if (e) if (e.getContext) {
        const t = e.getContext("2d", {
            willReadFrequently: !0
        });
        if (t) return t;
        ee();
    } else ee(); else ee();
    return null;
}, Su = e => Math.round(180 * e / Math.PI), bt = (e, t, n) => e.replace(t, typeof n == "number" ? n.toFixed(1) : n), gp = (e, t) => {
    if (!t.useDepth || e === void 0) return t.color;
    const n = Uint8ClampedArray.from([ 127 + 2 * e, 127 - 2 * e, 255 ]);
    return `rgba(${n[0]}, ${n[1]}, ${n[2]}, ${t.alpha})`;
};

function Yr(e, t, n, a, r) {
    const s = t.replace(/\[.*\]/g, "").split(`
`).map(l => l.trim()), i = Math.max(0, n);
    for (let l = s.length - 1; l >= 0; l--) {
        const o = l * r.lineHeight + a;
        r.shadowColor && r.shadowColor !== "" && (e.fillStyle = r.shadowColor, e.fillText(s[l], i + 5, o + 16)), 
        e.fillStyle = r.labelColor, e.fillText(s[l], i + 4, o + 15);
    }
}

function Wo(e, t, n, a, r) {
    e.fillStyle = gp(a, r), e.beginPath(), e.arc(t, n, r.pointSize, 0, 2 * Math.PI), 
    e.fill();
}

function yp(e, t, n, a, r, s) {
    if (e.beginPath(), e.lineWidth = s.lineWidth, s.useCurves) {
        const i = (t + t + a) / 2, l = (n + n + r) / 2;
        e.ellipse(i, l, a / 2, r / 2, 0, 0, 2 * Math.PI);
    } else e.moveTo(t + s.roundRect, n), e.lineTo(t + a - s.roundRect, n), e.quadraticCurveTo(t + a, n, t + a, n + s.roundRect), 
    e.lineTo(t + a, n + r - s.roundRect), e.quadraticCurveTo(t + a, n + r, t + a - s.roundRect, n + r), 
    e.lineTo(t + s.roundRect, n + r), e.quadraticCurveTo(t, n + r, t, n + r - s.roundRect), 
    e.lineTo(t, n + s.roundRect), e.quadraticCurveTo(t, n, t + s.roundRect, n), 
    e.closePath();
    e.stroke();
}

function hk(e, t, n) {
    if (!(t.length < 2)) {
        e.beginPath(), e.moveTo(t[0][0], t[0][1]);
        for (const a of t) e.strokeStyle = gp(a[2] || 0, n), e.lineTo(Math.trunc(a[0]), Math.trunc(a[1]));
        e.stroke(), n.fillPolygons && (e.closePath(), e.fill());
    }
}

function QX(e, t, n) {
    if (!(t.length < 2)) if (e.lineWidth = n.lineWidth, !n.useCurves || t.length <= 2) hk(e, t, n); else {
        e.moveTo(t[0][0], t[0][1]);
        for (let a = 0; a < t.length - 2; a++) {
            const r = (t[a][0] + t[a + 1][0]) / 2, s = (t[a][1] + t[a + 1][1]) / 2;
            e.quadraticCurveTo(t[a][0], t[a][1], r, s);
        }
        e.quadraticCurveTo(t[t.length - 2][0], t[t.length - 2][1], t[t.length - 1][0], t[t.length - 1][1]), 
        e.stroke(), n.fillPolygons && (e.closePath(), e.fill());
    }
}

function fk(e, t, n, a = 5) {
    let r, s, i;
    e.beginPath(), e.moveTo(t[0], t[1]), e.lineTo(n[0], n[1]), r = Math.atan2(n[1] - t[1], n[0] - t[0]), 
    s = a * Math.cos(r) + n[0], i = a * Math.sin(r) + n[1], e.moveTo(s, i), r += 1 / 3 * (2 * Math.PI), 
    s = a * Math.cos(r) + n[0], i = a * Math.sin(r) + n[1], e.lineTo(s, i), r += 1 / 3 * (2 * Math.PI), 
    s = a * Math.cos(r) + n[0], i = a * Math.sin(r) + n[1], e.lineTo(s, i), e.closePath(), 
    e.stroke(), e.fill();
}

var Cn = {
    color: "rgba(173, 216, 230, 0.6)",
    labelColor: "rgba(173, 216, 230, 1)",
    shadowColor: "black",
    alpha: .5,
    font: 'small-caps 16px "Segoe UI"',
    lineHeight: 18,
    lineWidth: 4,
    pointSize: 2,
    roundRect: 8,
    drawPoints: !1,
    drawLabels: !0,
    drawBoxes: !0,
    drawAttention: !0,
    drawGestures: !0,
    drawPolygons: !0,
    drawGaze: !0,
    fillPolygons: !1,
    useDepth: !0,
    useCurves: !1,
    faceLabels: "",
    bodyLabels: "",
    bodyPartLabels: "",
    objectLabels: "",
    handLabels: "",
    fingerLabels: "",
    gestureLabels: ""
}, or = {
    silhouette: [ 10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109 ],
    lipsUpperOuter: [ 185, 40, 39, 37, 0, 267, 269, 270, 409 ],
    lipsLowerOuter: [ 61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291 ],
    lipsUpperInner: [ 191, 80, 81, 82, 13, 312, 311, 310, 415 ],
    lipsLowerInner: [ 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308 ],
    lipsLowerSemiOuter: [ 76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306 ],
    lipsUpperSemiOuter: [ 184, 74, 73, 72, 11, 302, 303, 304, 408 ],
    lipsLowerSemiInner: [ 62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292 ],
    lipsUpperSemiInner: [ 183, 42, 41, 38, 12, 268, 271, 272, 407 ],
    rightEyeUpper0: [ 246, 161, 160, 159, 158, 157, 173 ],
    rightEyeLower0: [ 33, 7, 163, 144, 145, 153, 154, 155, 133 ],
    rightEyeUpper1: [ 247, 30, 29, 27, 28, 56, 190 ],
    rightEyeLower1: [ 130, 25, 110, 24, 23, 22, 26, 112, 243 ],
    rightEyeUpper2: [ 113, 225, 224, 223, 222, 221, 189 ],
    rightEyeLower2: [ 226, 31, 228, 229, 230, 231, 232, 233, 244 ],
    rightEyeLower3: [ 143, 111, 117, 118, 119, 120, 121, 128, 245 ],
    rightEyebrowUpper: [ 156, 70, 63, 105, 66, 107, 55, 193 ],
    rightEyebrowLower: [ 35, 124, 46, 53, 52, 65 ],
    rightEyeIris: [ 473, 474, 475, 476, 477 ],
    leftEyeUpper0: [ 466, 388, 387, 386, 385, 384, 398 ],
    leftEyeLower0: [ 263, 249, 390, 373, 374, 380, 381, 382, 362 ],
    leftEyeUpper1: [ 467, 260, 259, 257, 258, 286, 414 ],
    leftEyeLower1: [ 359, 255, 339, 254, 253, 252, 256, 341, 463 ],
    leftEyeUpper2: [ 342, 445, 444, 443, 442, 441, 413 ],
    leftEyeLower2: [ 446, 261, 448, 449, 450, 451, 452, 453, 464 ],
    leftEyeLower3: [ 372, 340, 346, 347, 348, 349, 350, 357, 465 ],
    leftEyebrowUpper: [ 383, 300, 293, 334, 296, 336, 285, 417 ],
    leftEyebrowLower: [ 265, 353, 276, 283, 282, 295 ],
    leftEyeIris: [ 468, 469, 470, 471, 472 ],
    midwayBetweenEyes: [ 168 ],
    noseTip: [ 1 ],
    noseBottom: [ 2 ],
    noseRightCorner: [ 98 ],
    noseLeftCorner: [ 327 ],
    rightCheek: [ 205 ],
    leftCheek: [ 425 ]
}, mk = {
    count: 468,
    mouth: 13,
    symmetryLine: [ 13, or.midwayBetweenEyes[0] ]
}, Ap = {
    leftEye: 0,
    rightEye: 1,
    nose: 2,
    mouth: 3,
    leftEar: 4,
    rightEar: 5,
    symmetryLine: [ 3, 2 ]
}, gk = [ {
    key: "EyeUpper0",
    indices: [ 9, 10, 11, 12, 13, 14, 15 ]
}, {
    key: "EyeUpper1",
    indices: [ 25, 26, 27, 28, 29, 30, 31 ]
}, {
    key: "EyeUpper2",
    indices: [ 41, 42, 43, 44, 45, 46, 47 ]
}, {
    key: "EyeLower0",
    indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ]
}, {
    key: "EyeLower1",
    indices: [ 16, 17, 18, 19, 20, 21, 22, 23, 24 ]
}, {
    key: "EyeLower2",
    indices: [ 32, 33, 34, 35, 36, 37, 38, 39, 40 ]
}, {
    key: "EyeLower3",
    indices: [ 54, 55, 56, 57, 58, 59, 60, 61, 62 ]
}, {
    key: "EyebrowUpper",
    indices: [ 63, 64, 65, 66, 67, 68, 69, 70 ]
}, {
    key: "EyebrowLower",
    indices: [ 48, 49, 50, 51, 52, 53 ]
} ], uh = [ [ .499976992607117, .652534008026123 ], [ .500025987625122, .547487020492554 ], [ .499974012374878, .602371990680695 ], [ .482113003730774, .471979022026062 ], [ .500150978565216, .527155995368958 ], [ .499909996986389, .498252987861633 ], [ .499523013830185, .40106201171875 ], [ .289712011814117, .380764007568359 ], [ .499954998493195, .312398016452789 ], [ .499987006187439, .269918978214264 ], [ .500023007392883, .107050001621246 ], [ .500023007392883, .666234016418457 ], [ .5000159740448, .679224014282227 ], [ .500023007392883, .692348003387451 ], [ .499976992607117, .695277988910675 ], [ .499976992607117, .70593398809433 ], [ .499976992607117, .719385027885437 ], [ .499976992607117, .737019002437592 ], [ .499967992305756, .781370997428894 ], [ .499816000461578, .562981009483337 ], [ .473773002624512, .573909997940063 ], [ .104906998574734, .254140973091125 ], [ .365929991006851, .409575998783112 ], [ .338757991790771, .41302502155304 ], [ .311120003461838, .409460008144379 ], [ .274657994508743, .389131009578705 ], [ .393361985683441, .403706014156342 ], [ .345234006643295, .344011008739471 ], [ .370094001293182, .346076011657715 ], [ .319321990013123, .347265005111694 ], [ .297903001308441, .353591024875641 ], [ .24779200553894, .410809993743896 ], [ .396889001131058, .842755019664764 ], [ .280097991228104, .375599980354309 ], [ .106310002505779, .399955987930298 ], [ .2099249958992, .391353011131287 ], [ .355807989835739, .534406006336212 ], [ .471751004457474, .65040397644043 ], [ .474155008792877, .680191993713379 ], [ .439785003662109, .657229006290436 ], [ .414617002010345, .66654098033905 ], [ .450374007225037, .680860996246338 ], [ .428770989179611, .682690978050232 ], [ .374971002340317, .727805018424988 ], [ .486716985702515, .547628998756409 ], [ .485300987958908, .527395009994507 ], [ .257764995098114, .314490020275116 ], [ .401223003864288, .455172002315521 ], [ .429818987846375, .548614978790283 ], [ .421351999044418, .533740997314453 ], [ .276895999908447, .532056987285614 ], [ .483370006084442, .499586999416351 ], [ .33721199631691, .282882988452911 ], [ .296391993761063, .293242990970612 ], [ .169294998049736, .193813979625702 ], [ .447580009698868, .302609980106354 ], [ .392390012741089, .353887975215912 ], [ .354490011930466, .696784019470215 ], [ .067304998636246, .730105042457581 ], [ .442739009857178, .572826027870178 ], [ .457098007202148, .584792017936707 ], [ .381974011659622, .694710969924927 ], [ .392388999462128, .694203019142151 ], [ .277076005935669, .271932005882263 ], [ .422551989555359, .563233017921448 ], [ .385919004678726, .281364023685455 ], [ .383103013038635, .255840003490448 ], [ .331431001424789, .119714021682739 ], [ .229923993349075, .232002973556519 ], [ .364500999450684, .189113974571228 ], [ .229622006416321, .299540996551514 ], [ .173287004232407, .278747975826263 ], [ .472878992557526, .666198015213013 ], [ .446828007698059, .668527007102966 ], [ .422762006521225, .673889994621277 ], [ .445307999849319, .580065965652466 ], [ .388103008270264, .693961024284363 ], [ .403039008378983, .706539988517761 ], [ .403629004955292, .693953037261963 ], [ .460041999816895, .557139039039612 ], [ .431158006191254, .692366003990173 ], [ .452181994915009, .692366003990173 ], [ .475387006998062, .692366003990173 ], [ .465828001499176, .779190003871918 ], [ .472328990697861, .736225962638855 ], [ .473087012767792, .717857003211975 ], [ .473122000694275, .704625964164734 ], [ .473033010959625, .695277988910675 ], [ .427942007780075, .695277988910675 ], [ .426479011774063, .703539967536926 ], [ .423162013292313, .711845993995667 ], [ .4183090031147, .720062971115112 ], [ .390094995498657, .639572978019714 ], [ .013953999616206, .560034036636353 ], [ .499913990497589, .58014702796936 ], [ .413199990987778, .69539999961853 ], [ .409626007080078, .701822996139526 ], [ .468080013990402, .601534962654114 ], [ .422728985548019, .585985004901886 ], [ .463079988956451, .593783974647522 ], [ .37211999297142, .47341400384903 ], [ .334562003612518, .496073007583618 ], [ .411671012639999, .546965003013611 ], [ .242175996303558, .14767599105835 ], [ .290776997804642, .201445996761322 ], [ .327338010072708, .256527006626129 ], [ .399509996175766, .748921036720276 ], [ .441727995872498, .261676013469696 ], [ .429764986038208, .187834024429321 ], [ .412198007106781, .108901023864746 ], [ .288955003023148, .398952007293701 ], [ .218936994671822, .435410976409912 ], [ .41278201341629, .398970007896423 ], [ .257135003805161, .355440020561218 ], [ .427684992551804, .437960982322693 ], [ .448339998722076, .536936044692993 ], [ .178560003638268, .45755398273468 ], [ .247308000922203, .457193970680237 ], [ .286267012357712, .467674970626831 ], [ .332827985286713, .460712015628815 ], [ .368755996227264, .447206974029541 ], [ .398963987827301, .432654976844788 ], [ .476410001516342, .405806005001068 ], [ .189241006970406, .523923993110657 ], [ .228962004184723, .348950982093811 ], [ .490725994110107, .562400996685028 ], [ .404670000076294, .485132992267609 ], [ .019469000399113, .401564002037048 ], [ .426243007183075, .420431017875671 ], [ .396993011236191, .548797011375427 ], [ .266469985246658, .376977026462555 ], [ .439121007919312, .51895797252655 ], [ .032313998788595, .644356966018677 ], [ .419054001569748, .387154996395111 ], [ .462783008813858, .505746960639954 ], [ .238978996872902, .779744982719421 ], [ .198220998048782, .831938028335571 ], [ .107550002634525, .540755033493042 ], [ .183610007166862, .740257024765015 ], [ .134409993886948, .333683013916016 ], [ .385764002799988, .883153975009918 ], [ .490967005491257, .579378008842468 ], [ .382384985685349, .508572995662689 ], [ .174399003386497, .397670984268188 ], [ .318785011768341, .39623498916626 ], [ .343364000320435, .400596976280212 ], [ .396100014448166, .710216999053955 ], [ .187885001301765, .588537991046906 ], [ .430987000465393, .944064974784851 ], [ .318993002176285, .898285031318665 ], [ .266247987747192, .869701027870178 ], [ .500023007392883, .190576016902924 ], [ .499976992607117, .954452991485596 ], [ .366169989109039, .398822009563446 ], [ .393207013607025, .39553701877594 ], [ .410373002290726, .391080021858215 ], [ .194993004202843, .342101991176605 ], [ .388664990663528, .362284004688263 ], [ .365961998701096, .355970978736877 ], [ .343364000320435, .355356991291046 ], [ .318785011768341, .35834002494812 ], [ .301414996385574, .363156020641327 ], [ .058132998645306, .319076001644135 ], [ .301414996385574, .387449026107788 ], [ .499987989664078, .618434011936188 ], [ .415838003158569, .624195992946625 ], [ .445681989192963, .566076993942261 ], [ .465844005346298, .620640993118286 ], [ .49992299079895, .351523995399475 ], [ .288718998432159, .819945991039276 ], [ .335278987884521, .852819979190826 ], [ .440512001514435, .902418971061707 ], [ .128294005990028, .791940987110138 ], [ .408771991729736, .373893976211548 ], [ .455606997013092, .451801002025604 ], [ .499877005815506, .908990025520325 ], [ .375436991453171, .924192011356354 ], [ .11421000212431, .615022003650665 ], [ .448662012815475, .695277988910675 ], [ .4480200111866, .704632043838501 ], [ .447111994028091, .715808033943176 ], [ .444831997156143, .730794012546539 ], [ .430011987686157, .766808986663818 ], [ .406787008047104, .685672998428345 ], [ .400738000869751, .681069016456604 ], [ .392399996519089, .677703022956848 ], [ .367855995893478, .663918972015381 ], [ .247923001646996, .601333022117615 ], [ .452769994735718, .420849978923798 ], [ .43639200925827, .359887003898621 ], [ .416164010763168, .368713974952698 ], [ .413385987281799, .692366003990173 ], [ .228018000721931, .683571994304657 ], [ .468268007040024, .352671027183533 ], [ .411361992359161, .804327011108398 ], [ .499989002943039, .469825029373169 ], [ .479153990745544, .442654013633728 ], [ .499974012374878, .439637005329132 ], [ .432112008333206, .493588984012604 ], [ .499886006116867, .866917014122009 ], [ .49991300702095, .821729004383087 ], [ .456548988819122, .819200992584229 ], [ .344549000263214, .745438992977142 ], [ .37890899181366, .574010014533997 ], [ .374292999505997, .780184984207153 ], [ .319687992334366, .570737957954407 ], [ .357154995203018, .604269981384277 ], [ .295284003019333, .621580958366394 ], [ .447750002145767, .862477004528046 ], [ .410986006259918, .508723020553589 ], [ .31395098567009, .775308012962341 ], [ .354128003120422, .812552988529205 ], [ .324548006057739, .703992962837219 ], [ .189096003770828, .646299958229065 ], [ .279776990413666, .71465802192688 ], [ .1338230073452, .682700991630554 ], [ .336768001317978, .644733011722565 ], [ .429883986711502, .466521978378296 ], [ .455527991056442, .548622965812683 ], [ .437114000320435, .558896005153656 ], [ .467287987470627, .529924988746643 ], [ .414712011814117, .335219979286194 ], [ .37704598903656, .322777986526489 ], [ .344107985496521, .320150971412659 ], [ .312875986099243, .32233202457428 ], [ .283526003360748, .333190023899078 ], [ .241245999932289, .382785975933075 ], [ .102986000478268, .468762993812561 ], [ .267612010240555, .424560010433197 ], [ .297879010438919, .433175981044769 ], [ .333433985710144, .433878004550934 ], [ .366427004337311, .426115989685059 ], [ .396012008190155, .416696012020111 ], [ .420121014118195, .41022801399231 ], [ .007561000064015, .480777025222778 ], [ .432949006557465, .569517970085144 ], [ .458638995885849, .479089021682739 ], [ .473466008901596, .545744001865387 ], [ .476087987422943, .563830018043518 ], [ .468472003936768, .555056989192963 ], [ .433990985155106, .582361996173859 ], [ .483518004417419, .562983989715576 ], [ .482482999563217, .57784903049469 ], [ .42645001411438, .389798998832703 ], [ .438998997211456, .39649498462677 ], [ .450067013502121, .400434017181396 ], [ .289712011814117, .368252992630005 ], [ .276670008897781, .363372981548309 ], [ .517862021923065, .471948027610779 ], [ .710287988185883, .380764007568359 ], [ .526226997375488, .573909997940063 ], [ .895093023777008, .254140973091125 ], [ .634069979190826, .409575998783112 ], [ .661242008209229, .41302502155304 ], [ .688880026340485, .409460008144379 ], [ .725341975688934, .389131009578705 ], [ .606630027294159, .40370500087738 ], [ .654766023159027, .344011008739471 ], [ .629905998706818, .346076011657715 ], [ .680678009986877, .347265005111694 ], [ .702096998691559, .353591024875641 ], [ .75221198797226, .410804986953735 ], [ .602918028831482, .842862963676453 ], [ .719901978969574, .375599980354309 ], [ .893692970275879, .399959981441498 ], [ .790081977844238, .391354024410248 ], [ .643998026847839, .534487962722778 ], [ .528249025344849, .65040397644043 ], [ .525849997997284, .680191040039062 ], [ .560214996337891, .657229006290436 ], [ .585384011268616, .66654098033905 ], [ .549625992774963, .680860996246338 ], [ .57122802734375, .682691991329193 ], [ .624852001667023, .72809898853302 ], [ .513050019741058, .547281980514526 ], [ .51509702205658, .527251958847046 ], [ .742246985435486, .314507007598877 ], [ .598631024360657, .454979002475739 ], [ .570338010787964, .548575043678284 ], [ .578631997108459, .533622980117798 ], [ .723087012767792, .532054007053375 ], [ .516445994377136, .499638974666595 ], [ .662801027297974, .282917976379395 ], [ .70362401008606, .293271005153656 ], [ .830704987049103, .193813979625702 ], [ .552385985851288, .302568018436432 ], [ .607609987258911, .353887975215912 ], [ .645429015159607, .696707010269165 ], [ .932694971561432, .730105042457581 ], [ .557260990142822, .572826027870178 ], [ .542901992797852, .584792017936707 ], [ .6180260181427, .694710969924927 ], [ .607590973377228, .694203019142151 ], [ .722943007946014, .271963000297546 ], [ .577413976192474, .563166975975037 ], [ .614082992076874, .281386971473694 ], [ .616907000541687, .255886018276215 ], [ .668509006500244, .119913995265961 ], [ .770092010498047, .232020974159241 ], [ .635536015033722, .189248979091644 ], [ .77039098739624, .299556016921997 ], [ .826722025871277, .278755009174347 ], [ .527121007442474, .666198015213013 ], [ .553171992301941, .668527007102966 ], [ .577238023281097, .673889994621277 ], [ .554691970348358, .580065965652466 ], [ .611896991729736, .693961024284363 ], [ .59696102142334, .706539988517761 ], [ .596370995044708, .693953037261963 ], [ .539958000183105, .557139039039612 ], [ .568841993808746, .692366003990173 ], [ .547818005084991, .692366003990173 ], [ .52461302280426, .692366003990173 ], [ .534089982509613, .779141008853912 ], [ .527670979499817, .736225962638855 ], [ .526912987232208, .717857003211975 ], [ .526877999305725, .704625964164734 ], [ .526966989040375, .695277988910675 ], [ .572058022022247, .695277988910675 ], [ .573521018028259, .703539967536926 ], [ .57683801651001, .711845993995667 ], [ .581691026687622, .720062971115112 ], [ .609944999217987, .639909982681274 ], [ .986046016216278, .560034036636353 ], [ .5867999792099, .69539999961853 ], [ .590372025966644, .701822996139526 ], [ .531915009021759, .601536989212036 ], [ .577268004417419, .585934996604919 ], [ .536915004253387, .593786001205444 ], [ .627542972564697, .473352015018463 ], [ .665585994720459, .495950996875763 ], [ .588353991508484, .546862006187439 ], [ .757824003696442, .14767599105835 ], [ .709249973297119, .201507985591888 ], [ .672684013843536, .256581008434296 ], [ .600408971309662, .74900496006012 ], [ .55826598405838, .261672019958496 ], [ .570303976535797, .187870979309082 ], [ .588165998458862, .109044015407562 ], [ .711045026779175, .398952007293701 ], [ .781069993972778, .435405015945435 ], [ .587247014045715, .398931980133057 ], [ .742869973182678, .355445981025696 ], [ .572156012058258, .437651991844177 ], [ .55186802148819, .536570012569427 ], [ .821442008018494, .457556009292603 ], [ .752701997756958, .457181990146637 ], [ .71375697851181, .467626988887787 ], [ .66711300611496, .460672974586487 ], [ .631101012229919, .447153985500336 ], [ .6008620262146, .432473003864288 ], [ .523481011390686, .405627012252808 ], [ .810747981071472, .523926019668579 ], [ .771045982837677, .348959028720856 ], [ .509127020835876, .562718033790588 ], [ .595292985439301, .485023975372314 ], [ .980530977249146, .401564002037048 ], [ .573499977588654, .420000016689301 ], [ .602994978427887, .548687994480133 ], [ .733529984951019, .376977026462555 ], [ .560611009597778, .519016981124878 ], [ .967685997486115, .644356966018677 ], [ .580985009670258, .387160003185272 ], [ .537728011608124, .505385041236877 ], [ .760966002941132, .779752969741821 ], [ .801778972148895, .831938028335571 ], [ .892440974712372, .54076099395752 ], [ .816350996494293, .740260004997253 ], [ .865594983100891, .333687007427216 ], [ .614073991775513, .883246004581451 ], [ .508952975273132, .579437971115112 ], [ .617941975593567, .508316040039062 ], [ .825608015060425, .397674977779388 ], [ .681214988231659, .39623498916626 ], [ .656635999679565, .400596976280212 ], [ .603900015354156, .710216999053955 ], [ .81208598613739, .588539004325867 ], [ .56801301240921, .944564998149872 ], [ .681007981300354, .898285031318665 ], [ .733752012252808, .869701027870178 ], [ .633830010890961, .398822009563446 ], [ .606792986392975, .39553701877594 ], [ .589659988880157, .391062021255493 ], [ .805015981197357, .342108011245728 ], [ .611334979534149, .362284004688263 ], [ .634037971496582, .355970978736877 ], [ .656635999679565, .355356991291046 ], [ .681214988231659, .35834002494812 ], [ .698584973812103, .363156020641327 ], [ .941866993904114, .319076001644135 ], [ .698584973812103, .387449026107788 ], [ .584177017211914, .624107003211975 ], [ .554318010807037, .566076993942261 ], [ .534153997898102, .62064003944397 ], [ .711217999458313, .819975018501282 ], [ .664629995822906, .852871000766754 ], [ .559099972248077, .902631998062134 ], [ .871706008911133, .791940987110138 ], [ .591234028339386, .373893976211548 ], [ .544341027736664, .451583981513977 ], [ .624562978744507, .924192011356354 ], [ .88577002286911, .615028977394104 ], [ .551338016986847, .695277988910675 ], [ .551980018615723, .704632043838501 ], [ .552887976169586, .715808033943176 ], [ .555167973041534, .730794012546539 ], [ .569944024085999, .767035007476807 ], [ .593203008174896, .685675978660583 ], [ .599261999130249, .681069016456604 ], [ .607599973678589, .677703022956848 ], [ .631937980651855, .663500010967255 ], [ .752032995223999, .601315021514893 ], [ .547226011753082, .420395016670227 ], [ .563543975353241, .359827995300293 ], [ .583841025829315, .368713974952698 ], [ .586614012718201, .692366003990173 ], [ .771915018558502, .683578014373779 ], [ .531597018241882, .352482974529266 ], [ .588370978832245, .804440975189209 ], [ .52079701423645, .442565023899078 ], [ .567984998226166, .493479013442993 ], [ .543282985687256, .819254994392395 ], [ .655317008495331, .745514988899231 ], [ .621008992195129, .574018001556396 ], [ .625559985637665, .78031200170517 ], [ .680198013782501, .570719003677368 ], [ .64276397228241, .604337990283966 ], [ .704662978649139, .621529996395111 ], [ .552012026309967, .862591981887817 ], [ .589071989059448, .508637011051178 ], [ .685944974422455, .775357007980347 ], [ .645735025405884, .812640011310577 ], [ .675342977046967, .703978002071381 ], [ .810858011245728, .646304965019226 ], [ .72012197971344, .714666962623596 ], [ .866151988506317, .682704985141754 ], [ .663187026977539, .644596993923187 ], [ .570082008838654, .466325998306274 ], [ .544561982154846, .548375964164734 ], [ .562758982181549, .558784961700439 ], [ .531987011432648, .530140042304993 ], [ .585271000862122, .335177004337311 ], [ .622952997684479, .32277899980545 ], [ .655896008014679, .320163011550903 ], [ .687132000923157, .322345972061157 ], [ .716481983661652, .333200991153717 ], [ .758756995201111, .382786989212036 ], [ .897013008594513, .468769013881683 ], [ .732392013072968, .424547016620636 ], [ .70211398601532, .433162987232208 ], [ .66652500629425, .433866024017334 ], [ .633504986763, .426087975502014 ], [ .603875994682312, .416586995124817 ], [ .579657971858978, .409945011138916 ], [ .992439985275269, .480777025222778 ], [ .567192018032074, .569419980049133 ], [ .54136598110199, .478899002075195 ], [ .526564002037048, .546118021011353 ], [ .523913025856018, .563830018043518 ], [ .531529009342194, .555056989192963 ], [ .566035985946655, .582329034805298 ], [ .51631098985672, .563053965568542 ], [ .5174720287323, .577877044677734 ], [ .573594987392426, .389806985855103 ], [ .560697972774506, .395331978797913 ], [ .549755990505219, .399751007556915 ], [ .710287988185883, .368252992630005 ], [ .723330020904541, .363372981548309 ] ], xp = [ 127, 34, 139, 11, 0, 37, 232, 231, 120, 72, 37, 39, 128, 121, 47, 232, 121, 128, 104, 69, 67, 175, 171, 148, 157, 154, 155, 118, 50, 101, 73, 39, 40, 9, 151, 108, 48, 115, 131, 194, 204, 211, 74, 40, 185, 80, 42, 183, 40, 92, 186, 230, 229, 118, 202, 212, 214, 83, 18, 17, 76, 61, 146, 160, 29, 30, 56, 157, 173, 106, 204, 194, 135, 214, 192, 203, 165, 98, 21, 71, 68, 51, 45, 4, 144, 24, 23, 77, 146, 91, 205, 50, 187, 201, 200, 18, 91, 106, 182, 90, 91, 181, 85, 84, 17, 206, 203, 36, 148, 171, 140, 92, 40, 39, 193, 189, 244, 159, 158, 28, 247, 246, 161, 236, 3, 196, 54, 68, 104, 193, 168, 8, 117, 228, 31, 189, 193, 55, 98, 97, 99, 126, 47, 100, 166, 79, 218, 155, 154, 26, 209, 49, 131, 135, 136, 150, 47, 126, 217, 223, 52, 53, 45, 51, 134, 211, 170, 140, 67, 69, 108, 43, 106, 91, 230, 119, 120, 226, 130, 247, 63, 53, 52, 238, 20, 242, 46, 70, 156, 78, 62, 96, 46, 53, 63, 143, 34, 227, 173, 155, 133, 123, 117, 111, 44, 125, 19, 236, 134, 51, 216, 206, 205, 154, 153, 22, 39, 37, 167, 200, 201, 208, 36, 142, 100, 57, 212, 202, 20, 60, 99, 28, 158, 157, 35, 226, 113, 160, 159, 27, 204, 202, 210, 113, 225, 46, 43, 202, 204, 62, 76, 77, 137, 123, 116, 41, 38, 72, 203, 129, 142, 64, 98, 240, 49, 102, 64, 41, 73, 74, 212, 216, 207, 42, 74, 184, 169, 170, 211, 170, 149, 176, 105, 66, 69, 122, 6, 168, 123, 147, 187, 96, 77, 90, 65, 55, 107, 89, 90, 180, 101, 100, 120, 63, 105, 104, 93, 137, 227, 15, 86, 85, 129, 102, 49, 14, 87, 86, 55, 8, 9, 100, 47, 121, 145, 23, 22, 88, 89, 179, 6, 122, 196, 88, 95, 96, 138, 172, 136, 215, 58, 172, 115, 48, 219, 42, 80, 81, 195, 3, 51, 43, 146, 61, 171, 175, 199, 81, 82, 38, 53, 46, 225, 144, 163, 110, 246, 33, 7, 52, 65, 66, 229, 228, 117, 34, 127, 234, 107, 108, 69, 109, 108, 151, 48, 64, 235, 62, 78, 191, 129, 209, 126, 111, 35, 143, 163, 161, 246, 117, 123, 50, 222, 65, 52, 19, 125, 141, 221, 55, 65, 3, 195, 197, 25, 7, 33, 220, 237, 44, 70, 71, 139, 122, 193, 245, 247, 130, 33, 71, 21, 162, 153, 158, 159, 170, 169, 150, 188, 174, 196, 216, 186, 92, 144, 160, 161, 2, 97, 167, 141, 125, 241, 164, 167, 37, 72, 38, 12, 145, 159, 160, 38, 82, 13, 63, 68, 71, 226, 35, 111, 158, 153, 154, 101, 50, 205, 206, 92, 165, 209, 198, 217, 165, 167, 97, 220, 115, 218, 133, 112, 243, 239, 238, 241, 214, 135, 169, 190, 173, 133, 171, 208, 32, 125, 44, 237, 86, 87, 178, 85, 86, 179, 84, 85, 180, 83, 84, 181, 201, 83, 182, 137, 93, 132, 76, 62, 183, 61, 76, 184, 57, 61, 185, 212, 57, 186, 214, 207, 187, 34, 143, 156, 79, 239, 237, 123, 137, 177, 44, 1, 4, 201, 194, 32, 64, 102, 129, 213, 215, 138, 59, 166, 219, 242, 99, 97, 2, 94, 141, 75, 59, 235, 24, 110, 228, 25, 130, 226, 23, 24, 229, 22, 23, 230, 26, 22, 231, 112, 26, 232, 189, 190, 243, 221, 56, 190, 28, 56, 221, 27, 28, 222, 29, 27, 223, 30, 29, 224, 247, 30, 225, 238, 79, 20, 166, 59, 75, 60, 75, 240, 147, 177, 215, 20, 79, 166, 187, 147, 213, 112, 233, 244, 233, 128, 245, 128, 114, 188, 114, 217, 174, 131, 115, 220, 217, 198, 236, 198, 131, 134, 177, 132, 58, 143, 35, 124, 110, 163, 7, 228, 110, 25, 356, 389, 368, 11, 302, 267, 452, 350, 349, 302, 303, 269, 357, 343, 277, 452, 453, 357, 333, 332, 297, 175, 152, 377, 384, 398, 382, 347, 348, 330, 303, 304, 270, 9, 336, 337, 278, 279, 360, 418, 262, 431, 304, 408, 409, 310, 415, 407, 270, 409, 410, 450, 348, 347, 422, 430, 434, 313, 314, 17, 306, 307, 375, 387, 388, 260, 286, 414, 398, 335, 406, 418, 364, 367, 416, 423, 358, 327, 251, 284, 298, 281, 5, 4, 373, 374, 253, 307, 320, 321, 425, 427, 411, 421, 313, 18, 321, 405, 406, 320, 404, 405, 315, 16, 17, 426, 425, 266, 377, 400, 369, 322, 391, 269, 417, 465, 464, 386, 257, 258, 466, 260, 388, 456, 399, 419, 284, 332, 333, 417, 285, 8, 346, 340, 261, 413, 441, 285, 327, 460, 328, 355, 371, 329, 392, 439, 438, 382, 341, 256, 429, 420, 360, 364, 394, 379, 277, 343, 437, 443, 444, 283, 275, 440, 363, 431, 262, 369, 297, 338, 337, 273, 375, 321, 450, 451, 349, 446, 342, 467, 293, 334, 282, 458, 461, 462, 276, 353, 383, 308, 324, 325, 276, 300, 293, 372, 345, 447, 382, 398, 362, 352, 345, 340, 274, 1, 19, 456, 248, 281, 436, 427, 425, 381, 256, 252, 269, 391, 393, 200, 199, 428, 266, 330, 329, 287, 273, 422, 250, 462, 328, 258, 286, 384, 265, 353, 342, 387, 259, 257, 424, 431, 430, 342, 353, 276, 273, 335, 424, 292, 325, 307, 366, 447, 345, 271, 303, 302, 423, 266, 371, 294, 455, 460, 279, 278, 294, 271, 272, 304, 432, 434, 427, 272, 407, 408, 394, 430, 431, 395, 369, 400, 334, 333, 299, 351, 417, 168, 352, 280, 411, 325, 319, 320, 295, 296, 336, 319, 403, 404, 330, 348, 349, 293, 298, 333, 323, 454, 447, 15, 16, 315, 358, 429, 279, 14, 15, 316, 285, 336, 9, 329, 349, 350, 374, 380, 252, 318, 402, 403, 6, 197, 419, 318, 319, 325, 367, 364, 365, 435, 367, 397, 344, 438, 439, 272, 271, 311, 195, 5, 281, 273, 287, 291, 396, 428, 199, 311, 271, 268, 283, 444, 445, 373, 254, 339, 263, 466, 249, 282, 334, 296, 449, 347, 346, 264, 447, 454, 336, 296, 299, 338, 10, 151, 278, 439, 455, 292, 407, 415, 358, 371, 355, 340, 345, 372, 390, 249, 466, 346, 347, 280, 442, 443, 282, 19, 94, 370, 441, 442, 295, 248, 419, 197, 263, 255, 359, 440, 275, 274, 300, 383, 368, 351, 412, 465, 263, 467, 466, 301, 368, 389, 380, 374, 386, 395, 378, 379, 412, 351, 419, 436, 426, 322, 373, 390, 388, 2, 164, 393, 370, 462, 461, 164, 0, 267, 302, 11, 12, 374, 373, 387, 268, 12, 13, 293, 300, 301, 446, 261, 340, 385, 384, 381, 330, 266, 425, 426, 423, 391, 429, 355, 437, 391, 327, 326, 440, 457, 438, 341, 382, 362, 459, 457, 461, 434, 430, 394, 414, 463, 362, 396, 369, 262, 354, 461, 457, 316, 403, 402, 315, 404, 403, 314, 405, 404, 313, 406, 405, 421, 418, 406, 366, 401, 361, 306, 408, 407, 291, 409, 408, 287, 410, 409, 432, 436, 410, 434, 416, 411, 264, 368, 383, 309, 438, 457, 352, 376, 401, 274, 275, 4, 421, 428, 262, 294, 327, 358, 433, 416, 367, 289, 455, 439, 462, 370, 326, 2, 326, 370, 305, 460, 455, 254, 449, 448, 255, 261, 446, 253, 450, 449, 252, 451, 450, 256, 452, 451, 341, 453, 452, 413, 464, 463, 441, 413, 414, 258, 442, 441, 257, 443, 442, 259, 444, 443, 260, 445, 444, 467, 342, 445, 459, 458, 250, 289, 392, 290, 290, 328, 460, 376, 433, 435, 250, 290, 392, 411, 416, 433, 341, 463, 464, 453, 464, 465, 357, 465, 412, 343, 412, 399, 360, 363, 440, 437, 399, 456, 420, 456, 363, 401, 435, 288, 372, 383, 353, 339, 255, 249, 448, 261, 255, 133, 243, 190, 133, 155, 112, 33, 246, 247, 33, 130, 25, 398, 384, 286, 362, 398, 414, 362, 463, 341, 263, 359, 467, 263, 249, 255, 466, 467, 260, 75, 60, 166, 238, 239, 79, 162, 127, 139, 72, 11, 37, 121, 232, 120, 73, 72, 39, 114, 128, 47, 233, 232, 128, 103, 104, 67, 152, 175, 148, 173, 157, 155, 119, 118, 101, 74, 73, 40, 107, 9, 108, 49, 48, 131, 32, 194, 211, 184, 74, 185, 191, 80, 183, 185, 40, 186, 119, 230, 118, 210, 202, 214, 84, 83, 17, 77, 76, 146, 161, 160, 30, 190, 56, 173, 182, 106, 194, 138, 135, 192, 129, 203, 98, 54, 21, 68, 5, 51, 4, 145, 144, 23, 90, 77, 91, 207, 205, 187, 83, 201, 18, 181, 91, 182, 180, 90, 181, 16, 85, 17, 205, 206, 36, 176, 148, 140, 165, 92, 39, 245, 193, 244, 27, 159, 28, 30, 247, 161, 174, 236, 196, 103, 54, 104, 55, 193, 8, 111, 117, 31, 221, 189, 55, 240, 98, 99, 142, 126, 100, 219, 166, 218, 112, 155, 26, 198, 209, 131, 169, 135, 150, 114, 47, 217, 224, 223, 53, 220, 45, 134, 32, 211, 140, 109, 67, 108, 146, 43, 91, 231, 230, 120, 113, 226, 247, 105, 63, 52, 241, 238, 242, 124, 46, 156, 95, 78, 96, 70, 46, 63, 116, 143, 227, 116, 123, 111, 1, 44, 19, 3, 236, 51, 207, 216, 205, 26, 154, 22, 165, 39, 167, 199, 200, 208, 101, 36, 100, 43, 57, 202, 242, 20, 99, 56, 28, 157, 124, 35, 113, 29, 160, 27, 211, 204, 210, 124, 113, 46, 106, 43, 204, 96, 62, 77, 227, 137, 116, 73, 41, 72, 36, 203, 142, 235, 64, 240, 48, 49, 64, 42, 41, 74, 214, 212, 207, 183, 42, 184, 210, 169, 211, 140, 170, 176, 104, 105, 69, 193, 122, 168, 50, 123, 187, 89, 96, 90, 66, 65, 107, 179, 89, 180, 119, 101, 120, 68, 63, 104, 234, 93, 227, 16, 15, 85, 209, 129, 49, 15, 14, 86, 107, 55, 9, 120, 100, 121, 153, 145, 22, 178, 88, 179, 197, 6, 196, 89, 88, 96, 135, 138, 136, 138, 215, 172, 218, 115, 219, 41, 42, 81, 5, 195, 51, 57, 43, 61, 208, 171, 199, 41, 81, 38, 224, 53, 225, 24, 144, 110, 105, 52, 66, 118, 229, 117, 227, 34, 234, 66, 107, 69, 10, 109, 151, 219, 48, 235, 183, 62, 191, 142, 129, 126, 116, 111, 143, 7, 163, 246, 118, 117, 50, 223, 222, 52, 94, 19, 141, 222, 221, 65, 196, 3, 197, 45, 220, 44, 156, 70, 139, 188, 122, 245, 139, 71, 162, 145, 153, 159, 149, 170, 150, 122, 188, 196, 206, 216, 92, 163, 144, 161, 164, 2, 167, 242, 141, 241, 0, 164, 37, 11, 72, 12, 144, 145, 160, 12, 38, 13, 70, 63, 71, 31, 226, 111, 157, 158, 154, 36, 101, 205, 203, 206, 165, 126, 209, 217, 98, 165, 97, 237, 220, 218, 237, 239, 241, 210, 214, 169, 140, 171, 32, 241, 125, 237, 179, 86, 178, 180, 85, 179, 181, 84, 180, 182, 83, 181, 194, 201, 182, 177, 137, 132, 184, 76, 183, 185, 61, 184, 186, 57, 185, 216, 212, 186, 192, 214, 187, 139, 34, 156, 218, 79, 237, 147, 123, 177, 45, 44, 4, 208, 201, 32, 98, 64, 129, 192, 213, 138, 235, 59, 219, 141, 242, 97, 97, 2, 141, 240, 75, 235, 229, 24, 228, 31, 25, 226, 230, 23, 229, 231, 22, 230, 232, 26, 231, 233, 112, 232, 244, 189, 243, 189, 221, 190, 222, 28, 221, 223, 27, 222, 224, 29, 223, 225, 30, 224, 113, 247, 225, 99, 60, 240, 213, 147, 215, 60, 20, 166, 192, 187, 213, 243, 112, 244, 244, 233, 245, 245, 128, 188, 188, 114, 174, 134, 131, 220, 174, 217, 236, 236, 198, 134, 215, 177, 58, 156, 143, 124, 25, 110, 7, 31, 228, 25, 264, 356, 368, 0, 11, 267, 451, 452, 349, 267, 302, 269, 350, 357, 277, 350, 452, 357, 299, 333, 297, 396, 175, 377, 381, 384, 382, 280, 347, 330, 269, 303, 270, 151, 9, 337, 344, 278, 360, 424, 418, 431, 270, 304, 409, 272, 310, 407, 322, 270, 410, 449, 450, 347, 432, 422, 434, 18, 313, 17, 291, 306, 375, 259, 387, 260, 424, 335, 418, 434, 364, 416, 391, 423, 327, 301, 251, 298, 275, 281, 4, 254, 373, 253, 375, 307, 321, 280, 425, 411, 200, 421, 18, 335, 321, 406, 321, 320, 405, 314, 315, 17, 423, 426, 266, 396, 377, 369, 270, 322, 269, 413, 417, 464, 385, 386, 258, 248, 456, 419, 298, 284, 333, 168, 417, 8, 448, 346, 261, 417, 413, 285, 326, 327, 328, 277, 355, 329, 309, 392, 438, 381, 382, 256, 279, 429, 360, 365, 364, 379, 355, 277, 437, 282, 443, 283, 281, 275, 363, 395, 431, 369, 299, 297, 337, 335, 273, 321, 348, 450, 349, 359, 446, 467, 283, 293, 282, 250, 458, 462, 300, 276, 383, 292, 308, 325, 283, 276, 293, 264, 372, 447, 346, 352, 340, 354, 274, 19, 363, 456, 281, 426, 436, 425, 380, 381, 252, 267, 269, 393, 421, 200, 428, 371, 266, 329, 432, 287, 422, 290, 250, 328, 385, 258, 384, 446, 265, 342, 386, 387, 257, 422, 424, 430, 445, 342, 276, 422, 273, 424, 306, 292, 307, 352, 366, 345, 268, 271, 302, 358, 423, 371, 327, 294, 460, 331, 279, 294, 303, 271, 304, 436, 432, 427, 304, 272, 408, 395, 394, 431, 378, 395, 400, 296, 334, 299, 6, 351, 168, 376, 352, 411, 307, 325, 320, 285, 295, 336, 320, 319, 404, 329, 330, 349, 334, 293, 333, 366, 323, 447, 316, 15, 315, 331, 358, 279, 317, 14, 316, 8, 285, 9, 277, 329, 350, 253, 374, 252, 319, 318, 403, 351, 6, 419, 324, 318, 325, 397, 367, 365, 288, 435, 397, 278, 344, 439, 310, 272, 311, 248, 195, 281, 375, 273, 291, 175, 396, 199, 312, 311, 268, 276, 283, 445, 390, 373, 339, 295, 282, 296, 448, 449, 346, 356, 264, 454, 337, 336, 299, 337, 338, 151, 294, 278, 455, 308, 292, 415, 429, 358, 355, 265, 340, 372, 388, 390, 466, 352, 346, 280, 295, 442, 282, 354, 19, 370, 285, 441, 295, 195, 248, 197, 457, 440, 274, 301, 300, 368, 417, 351, 465, 251, 301, 389, 385, 380, 386, 394, 395, 379, 399, 412, 419, 410, 436, 322, 387, 373, 388, 326, 2, 393, 354, 370, 461, 393, 164, 267, 268, 302, 12, 386, 374, 387, 312, 268, 13, 298, 293, 301, 265, 446, 340, 380, 385, 381, 280, 330, 425, 322, 426, 391, 420, 429, 437, 393, 391, 326, 344, 440, 438, 458, 459, 461, 364, 434, 394, 428, 396, 262, 274, 354, 457, 317, 316, 402, 316, 315, 403, 315, 314, 404, 314, 313, 405, 313, 421, 406, 323, 366, 361, 292, 306, 407, 306, 291, 408, 291, 287, 409, 287, 432, 410, 427, 434, 411, 372, 264, 383, 459, 309, 457, 366, 352, 401, 1, 274, 4, 418, 421, 262, 331, 294, 358, 435, 433, 367, 392, 289, 439, 328, 462, 326, 94, 2, 370, 289, 305, 455, 339, 254, 448, 359, 255, 446, 254, 253, 449, 253, 252, 450, 252, 256, 451, 256, 341, 452, 414, 413, 463, 286, 441, 414, 286, 258, 441, 258, 257, 442, 257, 259, 443, 259, 260, 444, 260, 467, 445, 309, 459, 250, 305, 289, 290, 305, 290, 460, 401, 376, 435, 309, 250, 392, 376, 411, 433, 453, 341, 464, 357, 453, 465, 343, 357, 412, 437, 343, 399, 344, 360, 440, 420, 437, 456, 360, 420, 363, 361, 401, 288, 265, 372, 353, 390, 339, 249, 339, 448, 255 ];

function Jr(e) {
    const t = e.map(n => n[0]);
    return t.push(e[e.length - 1][1]), t;
}

[ 127, 234, 132, 58, 172, 150, 149, 148, 152, 377, 378, 379, 397, 288, 361, 454, 356, 70, 63, 105, 66, 107, 336, 296, 334, 293, 300, 168, 6, 195, 4, 98, 97, 2, 326, 327, 33, 160, 158, 133, 153, 144, 362, 385, 387, 263, 373, 380, 57, 40, 37, 0, 267, 270, 287, 321, 314, 17, 84, 91, 78, 81, 13, 311, 308, 402, 14, 178 ].map(e => uh[e]), 
[ 33, 133, 362, 263, 1, 62, 308, 159, 145, 386, 374, 6, 102, 331, 2, 13, 14, 70, 105, 107, 336, 334, 300, 54, 10, 284, 50, 280, 234, 454, 58, 288, 152 ].map(e => uh[e]), 
[ 33, 133, 362, 263, 1, 78, 308 ].map(e => uh[e]), Jr([ [ 61, 146 ], [ 146, 91 ], [ 91, 181 ], [ 181, 84 ], [ 84, 17 ], [ 17, 314 ], [ 314, 405 ], [ 405, 321 ], [ 321, 375 ], [ 375, 291 ], [ 61, 185 ], [ 185, 40 ], [ 40, 39 ], [ 39, 37 ], [ 37, 0 ], [ 0, 267 ], [ 267, 269 ], [ 269, 270 ], [ 270, 409 ], [ 409, 291 ], [ 78, 95 ], [ 95, 88 ], [ 88, 178 ], [ 178, 87 ], [ 87, 14 ], [ 14, 317 ], [ 317, 402 ], [ 402, 318 ], [ 318, 324 ], [ 324, 308 ], [ 78, 191 ], [ 191, 80 ], [ 80, 81 ], [ 81, 82 ], [ 82, 13 ], [ 13, 312 ], [ 312, 311 ], [ 311, 310 ], [ 310, 415 ], [ 415, 308 ] ]), 
Jr([ [ 263, 249 ], [ 249, 390 ], [ 390, 373 ], [ 373, 374 ], [ 374, 380 ], [ 380, 381 ], [ 381, 382 ], [ 382, 362 ], [ 263, 466 ], [ 466, 388 ], [ 388, 387 ], [ 387, 386 ], [ 386, 385 ], [ 385, 384 ], [ 384, 398 ], [ 398, 362 ] ]), 
Jr([ [ 276, 283 ], [ 283, 282 ], [ 282, 295 ], [ 295, 285 ], [ 300, 293 ], [ 293, 334 ], [ 334, 296 ], [ 296, 336 ] ]), 
Jr([ [ 474, 475 ], [ 475, 476 ], [ 476, 477 ], [ 477, 474 ] ]), Jr([ [ 33, 7 ], [ 7, 163 ], [ 163, 144 ], [ 144, 145 ], [ 145, 153 ], [ 153, 154 ], [ 154, 155 ], [ 155, 133 ], [ 33, 246 ], [ 246, 161 ], [ 161, 160 ], [ 160, 159 ], [ 159, 158 ], [ 158, 157 ], [ 157, 173 ], [ 173, 133 ] ]), 
Jr([ [ 46, 53 ], [ 53, 52 ], [ 52, 65 ], [ 65, 55 ], [ 70, 63 ], [ 63, 105 ], [ 105, 66 ], [ 66, 107 ] ]), 
Jr([ [ 469, 470 ], [ 470, 471 ], [ 471, 472 ], [ 472, 469 ] ]), Jr([ [ 10, 338 ], [ 338, 297 ], [ 297, 332 ], [ 332, 284 ], [ 284, 251 ], [ 251, 389 ], [ 389, 356 ], [ 356, 454 ], [ 454, 323 ], [ 323, 361 ], [ 361, 288 ], [ 288, 397 ], [ 397, 365 ], [ 365, 379 ], [ 379, 378 ], [ 378, 400 ], [ 400, 377 ], [ 377, 152 ], [ 152, 148 ], [ 148, 176 ], [ 176, 149 ], [ 149, 150 ], [ 150, 136 ], [ 136, 172 ], [ 172, 58 ], [ 58, 132 ], [ 132, 93 ], [ 93, 234 ], [ 234, 127 ], [ 127, 162 ], [ 162, 21 ], [ 21, 54 ], [ 54, 103 ], [ 103, 67 ], [ 67, 109 ], [ 109, 10 ] ]);

function Qr(e) {
    const t = e.map(n => n[0]);
    return t.push(e[e.length - 1][1]), t;
}

var eK = {
    lips: Qr([ [ 61, 146 ], [ 146, 91 ], [ 91, 181 ], [ 181, 84 ], [ 84, 17 ], [ 17, 314 ], [ 314, 405 ], [ 405, 321 ], [ 321, 375 ], [ 375, 291 ], [ 61, 185 ], [ 185, 40 ], [ 40, 39 ], [ 39, 37 ], [ 37, 0 ], [ 0, 267 ], [ 267, 269 ], [ 269, 270 ], [ 270, 409 ], [ 409, 291 ], [ 78, 95 ], [ 95, 88 ], [ 88, 178 ], [ 178, 87 ], [ 87, 14 ], [ 14, 317 ], [ 317, 402 ], [ 402, 318 ], [ 318, 324 ], [ 324, 308 ], [ 78, 191 ], [ 191, 80 ], [ 80, 81 ], [ 81, 82 ], [ 82, 13 ], [ 13, 312 ], [ 312, 311 ], [ 311, 310 ], [ 310, 415 ], [ 415, 308 ] ]),
    leftEye: Qr([ [ 263, 249 ], [ 249, 390 ], [ 390, 373 ], [ 373, 374 ], [ 374, 380 ], [ 380, 381 ], [ 381, 382 ], [ 382, 362 ], [ 263, 466 ], [ 466, 388 ], [ 388, 387 ], [ 387, 386 ], [ 386, 385 ], [ 385, 384 ], [ 384, 398 ], [ 398, 362 ] ]),
    leftEyebrow: Qr([ [ 276, 283 ], [ 283, 282 ], [ 282, 295 ], [ 295, 285 ], [ 300, 293 ], [ 293, 334 ], [ 334, 296 ], [ 296, 336 ] ]),
    leftIris: Qr([ [ 474, 475 ], [ 475, 476 ], [ 476, 477 ], [ 477, 474 ] ]),
    rightEye: Qr([ [ 33, 7 ], [ 7, 163 ], [ 163, 144 ], [ 144, 145 ], [ 145, 153 ], [ 153, 154 ], [ 154, 155 ], [ 155, 133 ], [ 33, 246 ], [ 246, 161 ], [ 161, 160 ], [ 160, 159 ], [ 159, 158 ], [ 158, 157 ], [ 157, 173 ], [ 173, 133 ] ]),
    rightEyebrow: Qr([ [ 46, 53 ], [ 53, 52 ], [ 52, 65 ], [ 65, 55 ], [ 70, 63 ], [ 63, 105 ], [ 105, 66 ], [ 66, 107 ] ]),
    rightIris: Qr([ [ 469, 470 ], [ 470, 471 ], [ 471, 472 ], [ 472, 469 ] ]),
    faceOval: Qr([ [ 10, 338 ], [ 338, 297 ], [ 297, 332 ], [ 332, 284 ], [ 284, 251 ], [ 251, 389 ], [ 389, 356 ], [ 356, 454 ], [ 454, 323 ], [ 323, 361 ], [ 361, 288 ], [ 288, 397 ], [ 397, 365 ], [ 365, 379 ], [ 379, 378 ], [ 378, 400 ], [ 400, 377 ], [ 377, 152 ], [ 152, 148 ], [ 148, 176 ], [ 176, 149 ], [ 149, 150 ], [ 150, 136 ], [ 136, 172 ], [ 172, 58 ], [ 58, 132 ], [ 132, 93 ], [ 93, 234 ], [ 234, 127 ], [ 127, 162 ], [ 162, 21 ], [ 21, 54 ], [ 54, 103 ], [ 103, 67 ], [ 67, 109 ], [ 109, 10 ] ])
}, tK = Object.entries(eK).map(([ e, t ]) => t.map(n => [ n, e ])).flat();

new Map(tK);

var ot, G1 = [ 61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 185, 40, 39, 37, 0, 267, 269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 191, 80, 81, 82, 13, 312, 311, 310, 415, 76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306, 184, 74, 73, 72, 11, 302, 303, 304, 408, 62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292, 183, 42, 41, 38, 12, 268, 271, 272, 407 ], bp = [ 33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173, 130, 25, 110, 24, 23, 22, 26, 112, 243, 247, 30, 29, 27, 28, 56, 190, 226, 31, 228, 229, 230, 231, 232, 233, 244, 113, 225, 224, 223, 222, 221, 189, 35, 124, 46, 53, 52, 65, 143, 111, 117, 118, 119, 120, 121, 128, 245, 156, 70, 63, 105, 66, 107, 55, 193 ], vp = [ 263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398, 359, 255, 339, 254, 253, 252, 256, 341, 463, 467, 260, 259, 257, 258, 286, 414, 446, 261, 448, 449, 450, 451, 452, 453, 464, 342, 445, 444, 443, 442, 441, 413, 265, 353, 276, 283, 282, 295, 372, 340, 346, 347, 348, 349, 350, 357, 465, 383, 300, 293, 334, 296, 336, 285, 417 ];

function nK(e, t) {
    var n, a, r, s, i, l, o, p, u;
    if (!ot.drawLabels || ((n = ot.faceLabels) == null ? void 0 : n.length) === 0) return;
    let c = ot.faceLabels.slice();
    if (c = bt(c, "[id]", e.id.toFixed(0)), e.score && (c = bt(c, "[score]", 100 * e.score)), 
    e.gender && (c = bt(c, "[gender]", e.gender)), e.genderScore && (c = bt(c, "[genderScore]", 100 * e.genderScore)), 
    e.age && (c = bt(c, "[age]", e.age)), e.distance && (c = bt(c, "[distance]", 100 * e.distance)), 
    e.real && (c = bt(c, "[real]", 100 * e.real)), e.live && (c = bt(c, "[live]", 100 * e.live)), 
    e.emotion && e.emotion.length > 0) {
        const d = e.emotion.map(h => `${Math.trunc(100 * h.score)}% ${h.emotion}`);
        d.length > 3 && (d.length = 3), c = bt(c, "[emotions]", d.join(" "));
    }
    (r = (a = e.rotation) == null ? void 0 : a.angle) != null && r.roll && (c = bt(c, "[roll]", Su(e.rotation.angle.roll))), 
    (i = (s = e.rotation) == null ? void 0 : s.angle) != null && i.yaw && (c = bt(c, "[yaw]", Su(e.rotation.angle.yaw))), 
    (o = (l = e.rotation) == null ? void 0 : l.angle) != null && o.pitch && (c = bt(c, "[pitch]", Su(e.rotation.angle.pitch))), 
    (u = (p = e.rotation) == null ? void 0 : p.gaze) != null && u.bearing && (c = bt(c, "[gaze]", Su(e.rotation.gaze.bearing))), 
    Yr(t, c, e.box[0], e.box[1], ot);
}

function aK(e, t) {
    var n;
    if (ot.drawGaze && ((n = e.rotation) != null && n.angle) && typeof Path2D < "u") {
        t.strokeStyle = "pink";
        const a = e.box[0] + e.box[2] / 2 - e.box[3] * Su(e.rotation.angle.yaw) / 90, r = e.box[1] + e.box[3] / 2 + e.box[2] * Su(e.rotation.angle.pitch) / 90, s = new Path2D(`
      M ${e.box[0] + e.box[2] / 2} ${e.box[1]}
      C
        ${a} ${e.box[1]},
        ${a} ${e.box[1] + e.box[3]},
        ${e.box[0] + e.box[2] / 2} ${e.box[1] + e.box[3]}
    `), i = new Path2D(`
      M ${e.box[0]} ${e.box[1] + e.box[3] / 2}
      C 
        ${e.box[0]} ${r},
        ${e.box[0] + e.box[2]} ${r},
        ${e.box[0] + e.box[2]} ${e.box[1] + e.box[3] / 2}
    `);
        t.stroke(i), t.stroke(s);
    }
}

function rK(e, t) {
    var n;
    if (ot.drawGaze && ((n = e.rotation) != null && n.gaze.strength) && e.rotation.gaze.bearing && e.annotations.leftEyeIris && e.annotations.rightEyeIris && e.annotations.leftEyeIris[0] && e.annotations.rightEyeIris[0]) {
        t.strokeStyle = "pink", t.fillStyle = "pink";
        const a = [ e.annotations.leftEyeIris[0][0] + Math.sin(e.rotation.gaze.bearing) * e.rotation.gaze.strength * e.box[3], e.annotations.leftEyeIris[0][1] + Math.cos(e.rotation.gaze.bearing) * e.rotation.gaze.strength * e.box[2] ];
        fk(t, [ e.annotations.leftEyeIris[0][0], e.annotations.leftEyeIris[0][1] ], [ a[0], a[1] ], 4);
        const r = [ e.annotations.rightEyeIris[0][0] + Math.sin(e.rotation.gaze.bearing) * e.rotation.gaze.strength * e.box[3], e.annotations.rightEyeIris[0][1] + Math.cos(e.rotation.gaze.bearing) * e.rotation.gaze.strength * e.box[2] ];
        fk(t, [ e.annotations.rightEyeIris[0][0], e.annotations.rightEyeIris[0][1] ], [ r[0], r[1] ], 4);
    }
}

function sK(e, t) {
    if (ot.drawPolygons && e.mesh.length >= 468) {
        t.lineWidth = 1;
        for (let n = 0; n < xp.length / 3; n++) hk(t, [ xp[3 * n + 0], xp[3 * n + 1], xp[3 * n + 2] ].map(a => e.mesh[a]), ot);
        (function(n, a) {
            var r, s, i, l;
            if ((r = n.annotations) != null && r.leftEyeIris && ((s = n.annotations) != null && s.leftEyeIris[0])) {
                a.strokeStyle = ot.useDepth ? "rgba(255, 200, 255, 0.3)" : ot.color, 
                a.beginPath();
                const o = Math.abs(n.annotations.leftEyeIris[3][0] - n.annotations.leftEyeIris[1][0]) / 2, p = Math.abs(n.annotations.leftEyeIris[4][1] - n.annotations.leftEyeIris[2][1]) / 2;
                a.ellipse(n.annotations.leftEyeIris[0][0], n.annotations.leftEyeIris[0][1], o, p, 0, 0, 2 * Math.PI), 
                a.stroke(), ot.fillPolygons && (a.fillStyle = ot.useDepth ? "rgba(255, 255, 200, 0.3)" : ot.color, 
                a.fill());
            }
            if ((i = n.annotations) != null && i.rightEyeIris && ((l = n.annotations) != null && l.rightEyeIris[0])) {
                a.strokeStyle = ot.useDepth ? "rgba(255, 200, 255, 0.3)" : ot.color, 
                a.beginPath();
                const o = Math.abs(n.annotations.rightEyeIris[3][0] - n.annotations.rightEyeIris[1][0]) / 2, p = Math.abs(n.annotations.rightEyeIris[4][1] - n.annotations.rightEyeIris[2][1]) / 2;
                a.ellipse(n.annotations.rightEyeIris[0][0], n.annotations.rightEyeIris[0][1], o, p, 0, 0, 2 * Math.PI), 
                a.stroke(), ot.fillPolygons && (a.fillStyle = ot.useDepth ? "rgba(255, 255, 200, 0.3)" : ot.color, 
                a.fill());
            }
        })(e, t);
    }
}

function iK(e, t) {
    if (ot.drawPoints) if ((e == null ? void 0 : e.mesh.length) >= 468) for (let n = 0; n < e.mesh.length; n++) Wo(t, e.mesh[n][0], e.mesh[n][1], e.mesh[n][2], ot), 
    ot.drawAttention && (G1.includes(n) && Wo(t, e.mesh[n][0], e.mesh[n][1], e.mesh[n][2] + 127, ot), 
    bp.includes(n) && Wo(t, e.mesh[n][0], e.mesh[n][1], e.mesh[n][2] - 127, ot), 
    vp.includes(n) && Wo(t, e.mesh[n][0], e.mesh[n][1], e.mesh[n][2] - 127, ot)); else for (const [ n, a ] of Object.entries((e == null ? void 0 : e.annotations) || {})) {
        if (!(a != null && a[0])) continue;
        const r = a[0];
        Wo(t, r[0], r[1], 0, ot), ot.drawLabels && Yr(t, n, r[0], r[1], ot);
    }
}

function oK(e, t) {
    ot.drawBoxes && yp(t, e.box[0], e.box[1], e.box[2], e.box[3], ot);
}

function yk(e, t, n) {
    if (ot = gn(Cn, n), !t || !e) return;
    const a = Lo(e);
    if (a) {
        a.font = ot.font, a.strokeStyle = ot.color, a.fillStyle = ot.color;
        for (const r of t) oK(r, a), nK(r, a), r.mesh && r.mesh.length > 0 && (iK(r, a), 
        sK(r, a), aK(r, a), rK(r, a));
    }
}

function Ak(e, t, n) {
    var a, r;
    const s = gn(Cn, n);
    if (!t || !e) return;
    const i = Lo(e);
    if (i) {
        i.lineJoin = "round";
        for (let l = 0; l < t.length; l++) {
            if (i.strokeStyle = s.color, i.fillStyle = s.color, i.lineWidth = s.lineWidth, 
            i.font = s.font, s.drawBoxes && t[l].box && t[l].box.length === 4 && (yp(i, t[l].box[0], t[l].box[1], t[l].box[2], t[l].box[3], s), 
            s.drawLabels && ((a = s.bodyLabels) == null ? void 0 : a.length) > 0)) {
                let o = s.bodyLabels.slice();
                o = bt(o, "[id]", t[l].id.toFixed(0)), o = bt(o, "[score]", 100 * t[l].score), 
                Yr(i, o, t[l].box[0], t[l].box[1], s);
            }
            if (s.drawPoints && t[l].keypoints) for (let o = 0; o < t[l].keypoints.length; o++) t[l].keypoints[o].score && t[l].keypoints[o].score !== 0 && (i.fillStyle = gp(t[l].keypoints[o].position[2], s), 
            Wo(i, t[l].keypoints[o].position[0], t[l].keypoints[o].position[1], 0, s));
            if (s.drawLabels && ((r = s.bodyPartLabels) == null ? void 0 : r.length) > 0 && t[l].keypoints) {
                i.font = s.font;
                for (const o of t[l].keypoints) {
                    if (!o.score || o.score === 0) continue;
                    let p = s.bodyPartLabels.slice();
                    p = bt(p, "[label]", o.part), p = bt(p, "[score]", 100 * o.score), 
                    Yr(i, p, o.position[0], o.position[1], s);
                }
            }
            if (s.drawPolygons && t[l].keypoints && t[l].annotations) for (const o of Object.values(t[l].annotations)) for (const p of o) QX(i, p, s);
        }
    }
}

function xk(e, t, n) {
    var a, r;
    const s = gn(Cn, n);
    if (!t || !e) return;
    const i = Lo(e);
    if (i) {
        i.lineJoin = "round", i.font = s.font;
        for (const l of t) {
            if (s.drawBoxes) {
                if (i.strokeStyle = s.color, i.fillStyle = s.color, yp(i, l.box[0], l.box[1], l.box[2], l.box[3], s), 
                s.drawLabels && ((a = s.handLabels) == null ? void 0 : a.length) > 0) {
                    let o = s.handLabels.slice();
                    o = bt(o, "[id]", l.id.toFixed(0)), o = bt(o, "[label]", l.label), 
                    o = bt(o, "[score]", 100 * l.score), Yr(i, o, l.box[0], l.box[1], s);
                }
                i.stroke();
            }
            if (s.drawPoints && l.keypoints && l.keypoints.length > 0) for (const o of l.keypoints) i.fillStyle = gp(o[2], s), 
            Wo(i, o[0], o[1], 0, s);
            if (s.drawLabels && l.annotations && ((r = s.fingerLabels) == null ? void 0 : r.length) > 0) for (const [ o, p ] of Object.entries(l.annotations)) {
                let u = s.fingerLabels.slice();
                u = bt(u, "[label]", o), Yr(i, u, p[p.length - 1][0], p[p.length - 1][1], s);
            }
            if (s.drawPolygons && l.annotations) {
                const o = p => {
                    if (p && p.length !== 0 && p[0]) for (let u = 0; u < p.length; u++) {
                        i.beginPath();
                        const c = p[u][2] || 0;
                        i.strokeStyle = gp(u * c, s), i.moveTo(p[u > 0 ? u - 1 : 0][0], p[u > 0 ? u - 1 : 0][1]), 
                        i.lineTo(p[u][0], p[u][1]), i.stroke();
                    }
                };
                i.lineWidth = s.lineWidth, o(l.annotations.index), o(l.annotations.middle), 
                o(l.annotations.ring), o(l.annotations.pinky), o(l.annotations.thumb);
            }
        }
    }
}

function bk(e, t, n) {
    var a;
    const r = gn(Cn, n);
    if (!t || !e) return;
    const s = Lo(e);
    if (s) {
        s.lineJoin = "round", s.font = r.font;
        for (const i of t) if (r.drawBoxes) {
            if (s.strokeStyle = r.color, s.fillStyle = r.color, yp(s, i.box[0], i.box[1], i.box[2], i.box[3], r), 
            r.drawLabels && ((a = r.objectLabels) == null ? void 0 : a.length) > 0) {
                let l = r.objectLabels.slice();
                l = bt(l, "[id]", i.id.toFixed(0)), l = bt(l, "[label]", i.label), 
                l = bt(l, "[score]", 100 * i.score), Yr(s, l, i.box[0], i.box[1], r);
            }
            s.stroke();
        }
    }
}

function vk(e, t, n) {
    var a;
    const r = gn(Cn, n);
    if (t && e && r.drawGestures && ((a = r.gestureLabels) == null ? void 0 : a.length) > 0) {
        const s = Lo(e);
        if (!s) return;
        s.font = r.font, s.fillStyle = r.color;
        let i = 1;
        for (let l = 0; l < t.length; l++) {
            const [ o, p ] = Object.entries(t[l]);
            if (p.length > 1 && p[1].length > 0) {
                const u = o[1] > 0 ? `#${o[1]}` : "";
                let c = r.gestureLabels.slice();
                c = bt(c, "[where]", o[0]), c = bt(c, "[who]", u), c = bt(c, "[what]", p[1]), 
                Yr(s, c, 8, 2 + i * r.lineHeight, r), i += 1;
            }
        }
    }
}

var Bo = {
    face: `face
    confidence: [score]%
    [gender] [genderScore]%
    age: [age] years
    distance: [distance]cm
    real: [real]%
    live: [live]%
    [emotions]
    roll: [roll]\xB0 yaw:[yaw]\xB0 pitch:[pitch]\xB0
    gaze: [gaze]\xB0`,
    body: "body [score]%",
    bodyPart: "[label] [score]%",
    object: "[label] [score]%",
    hand: "[label] [score]%",
    finger: "[label]",
    gesture: "[where] [who]: [what]"
}, H1 = 0;

function lK(e, t, n) {
    const a = gn(Cn, n);
    if (!t || !e) return;
    const r = Lo(e);
    if (r) {
        r.lineJoin = "round", r.font = a.font;
        for (let s = 0; s < t.length; s++) if (a.drawBoxes) {
            if (r.strokeStyle = a.color, r.fillStyle = a.color, yp(r, t[s].box[0], t[s].box[1], t[s].box[2], t[s].box[3], a), 
            a.drawLabels) {
                const i = `person #${s}`;
                a.shadowColor && a.shadowColor !== "" && (r.fillStyle = a.shadowColor, 
                r.fillText(i, t[s].box[0] + 3, 1 + t[s].box[1] + a.lineHeight, t[s].box[2])), 
                r.fillStyle = a.labelColor, r.fillText(i, t[s].box[0] + 2, 0 + t[s].box[1] + a.lineHeight, t[s].box[2]);
            }
            r.stroke();
        }
    }
}

function uK(e, t) {
    if (!e || !t) return;
    const n = Lo(t);
    n && n.drawImage(e, 0, 0);
}

async function dK(e, t, n) {
    if (!(t != null && t.performance) || !e) return null;
    const a = se(), r = gn(Cn, n), s = Promise.all([ yk(e, t.face, r), Ak(e, t.body, r), xk(e, t.hand, r), bk(e, t.object, r), vk(e, t.gesture, r) ]);
    return H1 = ce.perfadd ? H1 + Math.round(se() - a) : Math.round(se() - a), t.performance.draw = H1, 
    s;
}

function wk() {
    Cn.faceLabels = Bo.face, Cn.bodyLabels = Bo.body, Cn.bodyPartLabels = Bo.bodyPart, 
    Cn.handLabels = Bo.hand, Cn.fingerLabels = Bo.finger, Cn.objectLabels = Bo.object, 
    Cn.gestureLabels = Bo.gesture;
}

var kk = {};

fr(kk, {
    connected: () => Nk,
    kpt: () => Sk
});

var Ua, Ik, Sk = [ "nose", "leftEyeInside", "leftEye", "leftEyeOutside", "rightEyeInside", "rightEye", "rightEyeOutside", "leftEar", "rightEar", "leftMouth", "rightMouth", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftPinky", "rightPinky", "leftIndex", "rightIndex", "leftThumb", "rightThumb", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle", "leftHeel", "rightHeel", "leftFoot", "rightFoot", "bodyCenter", "bodyTop", "leftPalm", "leftHand", "rightPalm", "rightHand" ], Nk = {
    shoulders: [ "leftShoulder", "rightShoulder" ],
    hips: [ "rightHip", "leftHip" ],
    mouth: [ "leftMouth", "rightMouth" ],
    leftLegUpper: [ "leftHip", "leftKnee" ],
    leftLegLower: [ "leftKnee", "leftAnkle" ],
    leftFoot: [ "leftAnkle", "leftHeel", "leftFoot" ],
    leftTorso: [ "leftShoulder", "leftHip" ],
    leftArmUpper: [ "leftShoulder", "leftElbow" ],
    leftArmLower: [ "leftElbow", "leftWrist" ],
    leftHand: [ "leftWrist", "leftPalm" ],
    leftHandPinky: [ "leftPalm", "leftPinky" ],
    leftHandIndex: [ "leftPalm", "leftIndex" ],
    leftHandThumb: [ "leftPalm", "leftThumb" ],
    leftEyeOutline: [ "leftEyeInside", "leftEyeOutside" ],
    rightLegUpper: [ "rightHip", "rightKnee" ],
    rightLegLower: [ "rightKnee", "rightAnkle" ],
    rightFoot: [ "rightAnkle", "rightHeel", "rightFoot" ],
    rightTorso: [ "rightShoulder", "rightHip" ],
    rightArmUpper: [ "rightShoulder", "rightElbow" ],
    rightArmLower: [ "rightElbow", "rightWrist" ],
    rightHand: [ "rightWrist", "rightPalm" ],
    rightHandPinky: [ "rightPalm", "rightPinky" ],
    rightHandIndex: [ "rightPalm", "rightIndex" ],
    rightHandThumb: [ "rightPalm", "rightThumb" ],
    rightEyeOutline: [ "rightEyeInside", "rightEyeOutside" ]
}, Vo = 224, pK = 5, dh = [ 8, 16, 32, 32, 32 ];

async function cK(e) {
    if (ce.initial && (Ua = null), !Ua && e.body.detector && e.body.detector.modelPath) {
        const t = (Ua = await xt(e.body.detector.modelPath)) != null && Ua.executor ? Object.values(Ua.modelSignature.inputs) : void 0;
        Vo = Array.isArray(t) ? parseInt(t[0].tensorShape.dim[1].size) : 0;
    } else e.debug && Ua && ee(Ua.modelUrl);
    return function() {
        const t = [];
        let n = 0;
        for (;n < pK; ) {
            let a = 0, r = n;
            for (;r < dh.length && dh[r] === dh[n]; ) a += 2, r++;
            const s = dh[n], i = Math.ceil(Vo / s), l = Math.ceil(Vo / s);
            for (let o = 0; o < i; ++o) for (let p = 0; p < l; ++p) for (let u = 0; u < a; ++u) t.push({
                x: (p + .5) / l,
                y: (o + .5) / i
            });
            n = r;
        }
        Ik = {
            x: Yt(t.map(a => a.x)),
            y: Yt(t.map(a => a.y))
        };
    }(), Ua;
}

var Ca, Ck = [ 5, 5 ];

async function hK(e, t, n, a) {
    var r, s;
    const i = [], l = {};
    l.boxes = function(c, d) {
        return qe(() => {
            const h = Ia(c, 12, 1);
            let f = at(h[0]), m = at(h[1]), g = at(h[2]), y = at(h[3]);
            f = _e(ze(f, Vo), d.x), m = _e(ze(m, Vo), d.y), g = ne(ze(g, Vo), Ck[0]), 
            y = ne(ze(y, Vo), Ck[1]);
            const A = $e(f, ze(g, 2)), x = $e(m, ze(y, 2)), b = _e(A, g), v = _e(x, y);
            return Bn([ A, x, b, v ], 1);
        });
    }(e, Ik), l.scores = va(t), l.nms = await Ue.nonMaxSuppressionAsync(l.boxes, l.scores, 1, ((r = n.body.detector) == null ? void 0 : r.minConfidence) || .1, ((s = n.body.detector) == null ? void 0 : s.iouThreshold) || .1);
    const o = await l.nms.data(), p = await l.scores.data(), u = await l.boxes.array();
    for (const c of Array.from(o)) {
        const d = p[c], h = u[c], f = {
            score: d,
            boxRaw: h,
            box: [ Math.round(h[0] * a[0]), Math.round(h[1] * a[1]), Math.round(h[2] * a[0]), Math.round(h[3] * a[1]) ]
        };
        i.push(f);
    }
    return Object.keys(l).forEach(c => ae(l[c])), i;
}

function ph(e, t = [ 1, 1 ]) {
    const n = [ e.map(i => i[0]), e.map(i => i[1]) ], a = [ Math.min(...n[0]), Math.min(...n[1]) ], r = [ Math.max(...n[0]), Math.max(...n[1]) ], s = [ a[0], a[1], r[0] - a[0], r[1] - a[1] ];
    return {
        box: s,
        boxRaw: [ s[0] / t[0], s[1] / t[1], s[2] / t[0], s[3] / t[1] ]
    };
}

function fK(e, t = [ 1, 1 ]) {
    const n = [ e.map(o => o[0]), e.map(o => o[1]) ], a = [ Math.min(...n[0]), Math.min(...n[1]) ], r = [ Math.max(...n[0]), Math.max(...n[1]) ], s = [ (a[0] + r[0]) / 2, (a[1] + r[1]) / 2 ], i = Math.max(s[0] - a[0], s[1] - a[1], -s[0] + r[0], -s[1] + r[1]), l = [ Math.trunc(s[0] - i), Math.trunc(s[1] - i), Math.trunc(2 * i), Math.trunc(2 * i) ];
    return {
        box: l,
        boxRaw: [ l[0] / t[0], l[1] / t[1], l[2] / t[0], l[3] / t[1] ]
    };
}

function j1(e, t) {
    const n = [ e[2] * t, e[3] * t ];
    return [ e[0] - (n[0] - e[2]) / 2, e[1] - (n[1] - e[3]) / 2, n[0], n[1] ];
}

var q1 = 256, X1 = Number.MAX_SAFE_INTEGER, mK = {
    landmarks: [ "ld_3d", "activation_segmentation", "activation_heatmap", "world_3d", "output_poseflag" ],
    detector: []
}, ch = [], es = [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ], Tk = 0, Rk = e => 1 - 1 / (1 + Math.exp(e));

function Ek(e, t, n) {
    var a, r;
    const s = {};
    if (!((a = e == null ? void 0 : e.shape) != null && a[1]) || !((r = e == null ? void 0 : e.shape) != null && r[2])) return e;
    let i;
    if (n && (s.cropped = Ue.cropAndResize(e, [ n ], [ 0 ], [ e.shape[1], e.shape[2] ])), 
    e.shape[1] !== e.shape[2]) {
        const l = [ e.shape[2] > e.shape[1] ? Math.trunc((e.shape[2] - e.shape[1]) / 2) : 0, e.shape[2] > e.shape[1] ? Math.trunc((e.shape[2] - e.shape[1]) / 2) : 0 ], o = [ e.shape[1] > e.shape[2] ? Math.trunc((e.shape[1] - e.shape[2]) / 2) : 0, e.shape[1] > e.shape[2] ? Math.trunc((e.shape[1] - e.shape[2]) / 2) : 0 ];
        es = [ [ 0, 0 ], l, o, [ 0, 0 ] ], s.pad = Or(s.cropped || e, es), s.resize = Ue.resizeBilinear(s.pad, [ t, t ]), 
        i = ze(s.resize, lt.tf255);
    } else e.shape[1] !== t ? (s.resize = Ue.resizeBilinear(s.cropped || e, [ t, t ]), 
    i = ze(s.resize, lt.tf255)) : i = ze(s.cropped || e, lt.tf255);
    return Object.keys(s).forEach(l => ae(s[l])), i;
}

async function gK(e, t, n) {
    if (!(Ca != null && Ca.executor)) return null;
    const a = {};
    [ a.ld, a.segmentation, a.heatmap, a.world, a.poseflag ] = Ca == null ? void 0 : Ca.execute(e, mK.landmarks);
    const r = (await a.poseflag.data())[0], s = await a.ld.data(), i = await a.world.data();
    Object.keys(a).forEach(c => ae(a[c]));
    const l = [];
    for (let c = 0; c < s.length / 5; c++) {
        const d = Rk(s[5 * c + 3]), h = Rk(s[5 * c + 4]), f = Math.trunc(100 * d * h * r) / 100, m = [ s[5 * c + 0] / q1, s[5 * c + 1] / q1, s[5 * c + 2] + 0 ], g = [ Math.trunc(n[0] * m[0]), Math.trunc(n[1] * m[1]), m[2] ], y = [ i[5 * c + 0], i[5 * c + 1], i[5 * c + 2] + 0 ];
        l.push({
            part: Sk[c],
            positionRaw: m,
            position: g,
            distance: y,
            score: f
        });
    }
    if (r < (t.body.minConfidence || 0)) return null;
    (function(c) {
        const d = c.find(A => A.part === "leftPalm"), h = c.find(A => A.part === "leftWrist"), f = c.find(A => A.part === "leftIndex");
        d.position[2] = ((h.position[2] || 0) + (f.position[2] || 0)) / 2;
        const m = c.find(A => A.part === "rightPalm"), g = c.find(A => A.part === "rightWrist"), y = c.find(A => A.part === "rightIndex");
        m.position[2] = ((g.position[2] || 0) + (y.position[2] || 0)) / 2;
    })(l);
    const o = function(c, d, h) {
        for (const f of c) f.position = [ Math.trunc(f.position[0] * (d[0] + es[2][0] + es[2][1]) / d[0] - es[2][0]), Math.trunc(f.position[1] * (d[1] + es[1][0] + es[1][1]) / d[1] - es[1][0]), f.position[2] ], 
        f.positionRaw = [ f.position[0] / d[0], f.position[1] / d[1], 2 * f.position[2] / (d[0] + d[1]) ];
        if (h) {
            const f = h[2] - h[0], m = h[3] - h[1];
            for (const g of c) g.positionRaw = [ g.positionRaw[0] / m + h[1], g.positionRaw[1] / f + h[0], g.positionRaw[2] ], 
            g.position = [ Math.trunc(g.positionRaw[0] * d[0]), Math.trunc(g.positionRaw[1] * d[1]), g.positionRaw[2] ];
        }
        return c;
    }(l, n), p = ph(o.map(c => c.position), [ n[0], n[1] ]), u = {};
    for (const [ c, d ] of Object.entries(Nk)) {
        const h = [];
        for (let f = 0; f < d.length - 1; f++) {
            const m = o.find(y => y.part === d[f]), g = o.find(y => y.part === d[f + 1]);
            m && g && h.push([ m.position, g.position ]);
        }
        u[c] = h;
    }
    return {
        id: 0,
        score: Math.trunc(100 * r) / 100,
        box: p.box,
        boxRaw: p.boxRaw,
        keypoints: o,
        annotations: u
    };
}

async function $k(e, t) {
    var n, a, r;
    const s = [ e.shape[2] || 0, e.shape[1] || 0 ], i = (t.body.skipTime || 0) > se() - Tk, l = X1 < (t.body.skipFrames || 0);
    if (t.skipAllowed && i && l && ch !== null) X1++; else {
        let o = [];
        if ((a = (n = t.body) == null ? void 0 : n.detector) != null && a.enabled) {
            const p = Ek(e, 224);
            o = await async function(u, c, d) {
                const h = {};
                h.res = Ua == null ? void 0 : Ua.execute(u, [ "Identity" ]), h.logitsRaw = He(h.res, [ 0, 0, 0 ], [ 1, -1, 1 ]), 
                h.boxesRaw = He(h.res, [ 0, 0, 1 ], [ 1, -1, -1 ]), h.logits = at(h.logitsRaw), 
                h.boxes = at(h.boxesRaw);
                const f = await hK(h.boxes, h.logits, c, d);
                return Object.keys(h).forEach(m => ae(h[m])), f;
            }(p, t, s), ae(p);
        } else o = [ {
            box: [ 0, 0, 0, 0 ],
            boxRaw: [ 0, 0, 1, 1 ],
            score: 0
        } ];
        for (let p = 0; p < o.length; p++) {
            const u = Ek(e, 256, (r = o[p]) == null ? void 0 : r.boxRaw);
            ch.length = 0;
            const c = await gK(u, t, s);
            ae(u), c && (c.id = p, ch.push(c));
        }
        Tk = se(), X1 = 0;
    }
    return ch;
}

var Ta, hh = [ {
    class: 1,
    label: "person"
}, {
    class: 2,
    label: "bicycle"
}, {
    class: 3,
    label: "car"
}, {
    class: 4,
    label: "motorcycle"
}, {
    class: 5,
    label: "airplane"
}, {
    class: 6,
    label: "bus"
}, {
    class: 7,
    label: "train"
}, {
    class: 8,
    label: "truck"
}, {
    class: 9,
    label: "boat"
}, {
    class: 10,
    label: "traffic light"
}, {
    class: 11,
    label: "fire hydrant"
}, {
    class: 12,
    label: "stop sign"
}, {
    class: 13,
    label: "parking meter"
}, {
    class: 14,
    label: "bench"
}, {
    class: 15,
    label: "bird"
}, {
    class: 16,
    label: "cat"
}, {
    class: 17,
    label: "dog"
}, {
    class: 18,
    label: "horse"
}, {
    class: 19,
    label: "sheep"
}, {
    class: 20,
    label: "cow"
}, {
    class: 21,
    label: "elephant"
}, {
    class: 22,
    label: "bear"
}, {
    class: 23,
    label: "zebra"
}, {
    class: 24,
    label: "giraffe"
}, {
    class: 25,
    label: "backpack"
}, {
    class: 26,
    label: "umbrella"
}, {
    class: 27,
    label: "handbag"
}, {
    class: 28,
    label: "tie"
}, {
    class: 29,
    label: "suitcase"
}, {
    class: 30,
    label: "frisbee"
}, {
    class: 31,
    label: "skis"
}, {
    class: 32,
    label: "snowboard"
}, {
    class: 33,
    label: "sports ball"
}, {
    class: 34,
    label: "kite"
}, {
    class: 35,
    label: "baseball bat"
}, {
    class: 36,
    label: "baseball glove"
}, {
    class: 37,
    label: "skateboard"
}, {
    class: 38,
    label: "surfboard"
}, {
    class: 39,
    label: "tennis racket"
}, {
    class: 40,
    label: "bottle"
}, {
    class: 41,
    label: "wine glass"
}, {
    class: 42,
    label: "cup"
}, {
    class: 43,
    label: "fork"
}, {
    class: 44,
    label: "knife"
}, {
    class: 45,
    label: "spoon"
}, {
    class: 46,
    label: "bowl"
}, {
    class: 47,
    label: "banana"
}, {
    class: 48,
    label: "apple"
}, {
    class: 49,
    label: "sandwich"
}, {
    class: 50,
    label: "orange"
}, {
    class: 51,
    label: "broccoli"
}, {
    class: 52,
    label: "carrot"
}, {
    class: 53,
    label: "hot dog"
}, {
    class: 54,
    label: "pizza"
}, {
    class: 55,
    label: "donut"
}, {
    class: 56,
    label: "cake"
}, {
    class: 57,
    label: "chair"
}, {
    class: 58,
    label: "couch"
}, {
    class: 59,
    label: "potted plant"
}, {
    class: 60,
    label: "bed"
}, {
    class: 61,
    label: "dining table"
}, {
    class: 62,
    label: "toilet"
}, {
    class: 63,
    label: "tv"
}, {
    class: 64,
    label: "laptop"
}, {
    class: 65,
    label: "mouse"
}, {
    class: 66,
    label: "remote"
}, {
    class: 67,
    label: "keyboard"
}, {
    class: 68,
    label: "cell phone"
}, {
    class: 69,
    label: "microwave"
}, {
    class: 70,
    label: "oven"
}, {
    class: 71,
    label: "toaster"
}, {
    class: 72,
    label: "sink"
}, {
    class: 73,
    label: "refrigerator"
}, {
    class: 74,
    label: "book"
}, {
    class: 75,
    label: "clock"
}, {
    class: 76,
    label: "vase"
}, {
    class: 77,
    label: "scissors"
}, {
    class: 78,
    label: "teddy bear"
}, {
    class: 79,
    label: "hair drier"
}, {
    class: 80,
    label: "toothbrush"
} ], Uo = 0, K1 = [], Mk = 0, Z1 = Number.MAX_SAFE_INTEGER;

async function Fk(e, t) {
    if (!(Ta != null && Ta.executor)) return [];
    const n = (t.object.skipTime || 0) > se() - Mk, a = Z1 < (t.object.skipFrames || 0);
    return t.skipAllowed && n && a && K1.length > 0 ? (Z1++, K1) : (Z1 = 0, new Promise(async r => {
        const s = [ e.shape[2] || 0, e.shape[1] || 0 ], i = Ue.resizeBilinear(e, [ Uo, Uo ]), l = t.object.enabled ? Ta == null ? void 0 : Ta.execute(i, [ "tower_0/detections" ]) : null;
        Mk = se(), ae(i);
        const o = await async function(p, u, c) {
            if (!p) return [];
            const d = {}, h = [], f = await p.array();
            d.squeeze = at(p);
            const m = Ia(d.squeeze, 6, 1);
            d.stack = Bn([ m[1], m[0], m[3], m[2] ], 1), d.boxes = at(d.stack), 
            d.scores = at(m[4]), d.classes = at(m[5]), ae([ p, ...m ]), d.nms = await Ue.nonMaxSuppressionAsync(d.boxes, d.scores, c.object.maxDetected || 0, c.object.iouThreshold, c.object.minConfidence || 0);
            const g = await d.nms.data();
            let y = 0;
            for (const A of Array.from(g)) {
                const x = Math.trunc(100 * f[0][A][4]) / 100, b = f[0][A][5];
                if (Number.isNaN(b)) continue;
                const v = hh[b].label, [ I, N ] = [ f[0][A][0] / Uo, f[0][A][1] / Uo ], T = [ I, N, f[0][A][2] / Uo - I, f[0][A][3] / Uo - N ], R = [ Math.trunc(T[0] * u[0]), Math.trunc(T[1] * u[1]), Math.trunc(T[2] * u[0]), Math.trunc(T[3] * u[1]) ];
                h.push({
                    id: y++,
                    score: x,
                    class: b,
                    label: v,
                    box: R,
                    boxRaw: T
                });
            }
            return Object.keys(d).forEach(A => ae(d[A])), h;
        }(l, s, t);
        K1 = o, r(o);
    }));
}

var _k = {};

fr(_k, {
    connected: () => Pk,
    kpt: () => Ok
});

var Xt, Ok = [ "head", "neck", "rightShoulder", "rightElbow", "rightWrist", "chest", "leftShoulder", "leftElbow", "leftWrist", "bodyCenter", "rightHip", "rightKnee", "rightAnkle", "leftHip", "leftKnee", "leftAnkle" ], Pk = {
    leftLeg: [ "leftHip", "leftKnee", "leftAnkle" ],
    rightLeg: [ "rightHip", "rightKnee", "rightAnkle" ],
    torso: [ "leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder" ],
    leftArm: [ "leftShoulder", "leftElbow", "leftWrist" ],
    rightArm: [ "rightShoulder", "rightElbow", "rightWrist" ],
    head: []
}, Dk = 0, An = {
    id: 0,
    keypoints: [],
    box: [ 0, 0, 0, 0 ],
    boxRaw: [ 0, 0, 0, 0 ],
    score: 0,
    annotations: {}
}, Y1 = Number.MAX_SAFE_INTEGER;

async function yK(e, t) {
    const [ n, a ] = e.shape, r = Q(e, [ a * n ]), s = Jn(r, 0), i = (await s.data())[0];
    if (i > t) {
        const l = Zl(r, 0), o = sc(l, n), p = (await o.data())[0], u = ze(l, n), c = (await u.data())[0];
        return ae([ r, s, l, o, u ]), [ p, c, i ];
    }
    return ae([ r, s ]), [ 0, 0, i ];
}

async function zk(e, t) {
    if (!(Xt != null && Xt.executor) || !(Xt != null && Xt.inputs[0].shape)) return [];
    const n = (t.body.skipTime || 0) > se() - Dk, a = Y1 < (t.body.skipFrames || 0);
    return t.skipAllowed && n && a && Object.keys(An.keypoints).length > 0 ? (Y1++, 
    [ An ]) : (Y1 = 0, new Promise(async r => {
        const s = qe(() => {
            var c, d;
            const h = Ue.resizeBilinear(e, [ ((c = Xt == null ? void 0 : Xt.inputs[0].shape) == null ? void 0 : c[2]) || 0, ((d = Xt == null ? void 0 : Xt.inputs[0].shape) == null ? void 0 : d[1]) || 0 ], !1), f = ne(h, lt.tf2);
            return $e(f, lt.tf1);
        });
        let i;
        if (t.body.enabled && (i = Xt == null ? void 0 : Xt.execute(s)), Dk = se(), 
        ae(s), i) {
            An.keypoints.length = 0;
            const c = at(i);
            ae(i);
            const d = la(c, 2);
            ae(c);
            for (let h = 0; h < d.length; h++) {
                const [ f, m, g ] = await yK(d[h], t.body.minConfidence);
                g > (t.body.minConfidence || 0) && An.keypoints.push({
                    score: Math.round(100 * g) / 100,
                    part: Ok[h],
                    positionRaw: [ f / Xt.inputs[0].shape[2], m / Xt.inputs[0].shape[1] ],
                    position: [ Math.round(e.shape[2] * f / Xt.inputs[0].shape[2]), Math.round(e.shape[1] * m / Xt.inputs[0].shape[1]) ]
                });
            }
            d.forEach(h => ae(h));
        }
        An.score = An.keypoints.reduce((c, d) => d.score > c ? d.score : c, 0);
        const l = An.keypoints.map(c => c.position[0]), o = An.keypoints.map(c => c.position[1]);
        An.box = [ Math.min(...l), Math.min(...o), Math.max(...l) - Math.min(...l), Math.max(...o) - Math.min(...o) ];
        const p = An.keypoints.map(c => c.positionRaw[0]), u = An.keypoints.map(c => c.positionRaw[1]);
        An.boxRaw = [ Math.min(...p), Math.min(...u), Math.max(...p) - Math.min(...p), Math.max(...u) - Math.min(...u) ];
        for (const [ c, d ] of Object.entries(Pk)) {
            const h = [];
            for (let f = 0; f < d.length - 1; f++) {
                const m = An.keypoints.find(y => y.part === d[f]), g = An.keypoints.find(y => y.part === d[f + 1]);
                m && g && m.score > (t.body.minConfidence || 0) && g.score > (t.body.minConfidence || 0) && h.push([ m.position, g.position ]);
            }
            An.annotations[c] = h;
        }
        r([ An ]);
    }));
}

var wp = e => [ Math.abs(e.endPoint[0] - e.startPoint[0]), Math.abs(e.endPoint[1] - e.startPoint[1]) ], fh = e => [ e.startPoint[0] + (e.endPoint[0] - e.startPoint[0]) / 2, e.startPoint[1] + (e.endPoint[1] - e.startPoint[1]) / 2, 1 ], J1 = (e, t) => e ? [ Math.trunc(Math.max(0, e.startPoint[0])), Math.trunc(Math.max(0, e.startPoint[1])), Math.trunc(Math.min(t.shape[2] || 0, e.endPoint[0]) - Math.max(0, e.startPoint[0])), Math.trunc(Math.min(t.shape[1] || 0, e.endPoint[1]) - Math.max(0, e.startPoint[1])) ] : [ 0, 0, 0, 0 ], Q1 = (e, t) => e ? [ e.startPoint[0] / (t.shape[2] || 0), e.startPoint[1] / (t.shape[1] || 0), (e.endPoint[0] - e.startPoint[0]) / (t.shape[2] || 0), (e.endPoint[1] - e.startPoint[1]) / (t.shape[1] || 0) ] : [ 0, 0, 0, 0 ], AK = (e, t, n) => ({
    startPoint: [ e.startPoint[0] * t[0], e.startPoint[1] * t[1] ],
    endPoint: [ e.endPoint[0] * t[0], e.endPoint[1] * t[1] ],
    landmarks: e.landmarks.map(a => [ (a[0] + n[0]) * t[0], (a[1] + n[1]) * t[1] ]),
    confidence: e.confidence
}), e2 = (e, t, n) => {
    const a = t.shape[1], r = t.shape[2], s = [ e.startPoint[1] / a, e.startPoint[0] / r, e.endPoint[1] / a, e.endPoint[0] / r ], i = Ue.cropAndResize(t, [ s ], [ 0 ], n), l = ze(i, lt.tf255);
    return ae(i), l;
}, Lk = (e, t) => {
    const n = fh(e), a = wp(e), r = [ t * a[0] / 2, t * a[1] / 2 ];
    return {
        startPoint: [ n[0] - r[0], n[1] - r[1] ],
        endPoint: [ n[0] + r[0], n[1] + r[1] ],
        landmarks: e.landmarks,
        confidence: e.confidence,
        size: a
    };
}, Wk = e => {
    const t = fh(e), n = wp(e), a = Math.max(...n) / 2;
    return {
        startPoint: [ Math.round(t[0] - a), Math.round(t[1] - a) ],
        endPoint: [ Math.round(t[0] + a), Math.round(t[1] + a) ],
        landmarks: e.landmarks,
        confidence: e.confidence,
        size: [ Math.round(n[0]), Math.round(n[1]) ]
    };
}, t2 = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ], xK = (e, t) => {
    return (n = Math.PI / 2 - Math.atan2(-(t[1] - e[1]), t[0] - e[0])) - 2 * Math.PI * Math.floor((n + Math.PI) / (2 * Math.PI));
    var n;
}, Bk = (e, t) => [ [ 1, 0, e ], [ 0, 1, t ], [ 0, 0, 1 ] ], Go = (e, t) => {
    let n = 0;
    for (let a = 0; a < e.length; a++) n += e[a] * t[a];
    return n;
}, bK = (e, t) => {
    const n = [];
    for (let a = 0; a < e.length; a++) n.push(e[a][t]);
    return n;
}, Vk = (e, t) => {
    const n = [], a = e.length;
    for (let r = 0; r < a; r++) {
        n.push([]);
        for (let s = 0; s < a; s++) n[r].push(Go(e[r], bK(t, s)));
    }
    return n;
}, Uk = (e, t) => {
    const n = Math.cos(e), a = Math.sin(e), r = [ [ n, -a, 0 ], [ a, n, 0 ], [ 0, 0, 1 ] ], s = Bk(t[0], t[1]), i = Vk(s, r), l = Bk(-t[0], -t[1]);
    return Vk(i, l);
}, vK = e => {
    const t = [ [ e[0][0], e[1][0] ], [ e[0][1], e[1][1] ] ], n = [ e[0][2], e[1][2] ], a = [ -Go(t[0], n), -Go(t[1], n) ];
    return [ t[0].concat(a[0]), t[1].concat(a[1]), [ 0, 0, 1 ] ];
}, wK = (e, t) => [ Go(e, t[0]), Go(e, t[1]) ];

function kK(e, t, n, a, r) {
    const s = wp(t), i = e.map(h => [ s[0] / r * (h[0] - r / 2), s[1] / r * (h[1] - r / 2), h[2] || 0 ]), l = n && n !== 0 && Math.abs(n) > .2, o = l ? Uk(n, [ 0, 0 ]) : t2, p = l ? i.map(h => [ ...wK(h, o), h[2] ]) : i, u = l ? vK(a) : t2, c = fh(t), d = [ Go(c, u[0]), Go(c, u[1]) ];
    return p.map(h => [ Math.trunc(h[0] + d[0]), Math.trunc(h[1] + d[1]), Math.trunc(h[2] || 0) ]);
}

function IK(e, t, n, a) {
    const r = t.landmarks.length >= mk.count ? mk.symmetryLine : Ap.symmetryLine;
    let s, i = 0, l = t2;
    if (e && ce.kernels.includes("rotatewithoffset")) if (i = xK(t.landmarks[r[0]], t.landmarks[r[1]]), 
    i && i !== 0 && Math.abs(i) > .2) {
        const o = fh(t), p = [ o[0] / n.shape[2], o[1] / n.shape[1] ], u = Ue.rotateWithOffset(n, i, 0, [ p[0], p[1] ]);
        l = Uk(-i, o), s = e2(t, u, [ a, a ]), ae(u);
    } else s = e2(t, n, [ a, a ]); else s = e2(t, n, [ a, a ]);
    return [ i, l, s ];
}

var Ga, ha, SK = (e, t) => {
    const n = (r => {
        const s = r.map(l => l[0]), i = r.map(l => l[1]);
        return [ Math.min(...s) + (Math.max(...s) - Math.min(...s)) / 2, Math.min(...i) + (Math.max(...i) - Math.min(...i)) / 2 ];
    })(e), a = wp(t);
    return {
        startPoint: [ n[0] - a[0] / 2, n[1] - a[1] / 2 ],
        endPoint: [ n[0] + a[0] / 2, n[1] + a[1] / 2 ]
    };
}, Gk = 6, mh = null, ts = 0, Nu = null;

async function NK(e) {
    var t;
    return ce.initial && (Ga = null), Ga ? e.debug && ee(Ga.modelUrl) : Ga = await xt((t = e.face.detector) == null ? void 0 : t.modelPath), 
    ts = Ga.executor && Ga.inputs[0].shape ? Ga.inputs[0].shape[2] : 256, Nu = je(ts, "int32"), 
    mh = Dr(function(n) {
        const a = n === 192 ? {
            strides: [ 4 ],
            anchors: [ 1 ]
        } : {
            strides: [ n / 16, n / 8 ],
            anchors: [ 2, 6 ]
        }, r = [];
        for (let s = 0; s < a.strides.length; s++) {
            const i = a.strides[s], l = Math.floor((n + i - 1) / i), o = Math.floor((n + i - 1) / i), p = a.anchors[s];
            for (let u = 0; u < l; u++) {
                const c = i * (u + .5);
                for (let d = 0; d < o; d++) {
                    const h = i * (d + .5);
                    for (let f = 0; f < p; f++) r.push([ h, c ]);
                }
            }
        }
        return r;
    }(ts)), Ga;
}

async function CK(e, t) {
    var n, a, r, s, i, l, o;
    if (!e || e.isDisposedInternal || e.shape.length !== 4 || e.shape[1] < 1 || e.shape[2] < 1) return [];
    const p = {};
    p.resized = Ue.resizeBilinear(e, [ ts, ts ]), p.div = ze(p.resized, lt.tf127), 
    p.normalized = $e(p.div, lt.tf1);
    const u = Ga == null ? void 0 : Ga.execute(p.normalized);
    if (Array.isArray(u) && u.length > 2) {
        const f = u.sort((m, g) => m.size - g.size);
        p.concat384 = yt([ f[0], f[2] ], 2), p.concat512 = yt([ f[1], f[3] ], 2), 
        p.concat = yt([ p.concat512, p.concat384 ], 1), p.batch = at(p.concat, [ 0 ]);
    } else Array.isArray(u) ? p.batch = at(u[0]) : p.batch = at(u);
    ae(u), p.boxes = function(f) {
        if (!mh || !Nu) return ka([ 0, 0 ]);
        const m = {};
        m.boxStarts = He(f, [ 0, 1 ], [ -1, 2 ]), m.centers = _e(m.boxStarts, mh), 
        m.boxSizes = He(f, [ 0, 3 ], [ -1, 2 ]), m.boxSizesNormalized = ze(m.boxSizes, Nu), 
        m.centersNormalized = ze(m.centers, Nu), m.halfBoxSize = ze(m.boxSizesNormalized, lt.tf2), 
        m.starts = $e(m.centersNormalized, m.halfBoxSize), m.ends = _e(m.centersNormalized, m.halfBoxSize), 
        m.startNormalized = ne(m.starts, Nu), m.endNormalized = ne(m.ends, Nu);
        const g = Jp([ m.startNormalized, m.endNormalized ], 1);
        return Object.keys(m).forEach(y => ae(m[y])), g;
    }(p.batch), p.logits = He(p.batch, [ 0, 0 ], [ -1, 1 ]), p.sigmoid = va(p.logits), 
    p.scores = at(p.sigmoid), p.nms = await Ue.nonMaxSuppressionAsync(p.boxes, p.scores, ((n = t.face.detector) == null ? void 0 : n.maxDetected) || 0, ((a = t.face.detector) == null ? void 0 : a.iouThreshold) || 0, ((r = t.face.detector) == null ? void 0 : r.minConfidence) || 0);
    const c = await p.nms.array(), d = [], h = await p.scores.data();
    for (let f = 0; f < c.length; f++) {
        const m = h[c[f]];
        if (m > (((s = t.face.detector) == null ? void 0 : s.minConfidence) || 0)) {
            const g = {};
            g.bbox = He(p.boxes, [ c[f], 0 ], [ 1, -1 ]), g.slice = He(p.batch, [ c[f], Gk - 1 ], [ 1, -1 ]), 
            g.squeeze = at(g.slice), g.landmarks = Q(g.squeeze, [ Gk, -1 ]);
            const y = await g.bbox.data(), A = {
                startPoint: [ y[0], y[1] ],
                endPoint: [ y[2], y[3] ],
                landmarks: await g.landmarks.array(),
                confidence: m
            };
            g.anchor = He(mh, [ c[f], 0 ], [ 1, 2 ]);
            const x = await g.anchor.data(), b = AK(A, [ (e.shape[2] || 0) / ts, (e.shape[1] || 0) / ts ], x), v = Lk(b, ((i = t.face.detector) == null ? void 0 : i.scale) || 1.4), I = Wk(v);
            I.size[0] > (((l = t.face.detector) == null ? void 0 : l.minSize) || 0) && I.size[1] > (((o = t.face.detector) == null ? void 0 : o.minSize) || 0) && d.push(I), 
            Object.keys(g).forEach(N => ae(g[N]));
        }
    }
    return Object.keys(p).forEach(f => ae(p[f])), d;
}

var Ho = 0, n2 = or.leftEyeLower0, a2 = or.rightEyeLower0, Cu = {
    leftBounds: [ n2[0], n2[n2.length - 1] ],
    rightBounds: [ a2[0], a2[a2.length - 1] ]
}, Tu = {
    upperCenter: 3,
    lowerCenter: 4,
    index: 71,
    numCoordinates: 76
};

function gh(e, t, n, a) {
    for (let r = 0; r < gk.length; r++) {
        const {
            key: s,
            indices: i
        } = gk[r], l = or[`${n}${s}`];
        if (!a || a.includes(s)) for (let o = 0; o < i.length; o++) {
            const p = i[o];
            e[l[o]] = [ t[p][0], t[p][1], (t[p][2] + e[l[o]][2]) / 2 ];
        }
    }
}

var TK = e => e[Cu.leftBounds[0]][2] - e[Cu.rightBounds[0]][2], Hk = (e, t, n, a, r, s = !1, i = 2.3) => {
    const l = Wk(Lk((u => {
        const c = u.map(h => h[0]), d = u.map(h => h[1]);
        return {
            startPoint: [ Math.min(...c), Math.min(...d) ],
            endPoint: [ Math.max(...c), Math.max(...d) ],
            landmarks: u
        };
    })([ e[n], e[a] ]), i)), o = wp(l);
    let p = Ue.cropAndResize(t, [ [ l.startPoint[1] / r, l.startPoint[0] / r, l.endPoint[1] / r, l.endPoint[0] / r ] ], [ 0 ], [ Ho, Ho ]);
    if (s && ce.kernels.includes("flipleftright")) {
        const u = Ue.flipLeftRight(p);
        ae(p), p = u;
    }
    return {
        box: l,
        boxSize: o,
        crop: p
    };
}, jk = (e, t, n, a = !1) => {
    const r = [];
    for (let s = 0; s < Tu.numCoordinates; s++) {
        const i = e[3 * s], l = e[3 * s + 1], o = e[3 * s + 2];
        r.push([ (a ? 1 - i / Ho : i / Ho) * n[0] + t.startPoint[0], l / Ho * n[1] + t.startPoint[1], o ]);
    }
    return {
        rawCoords: r,
        iris: r.slice(Tu.index)
    };
}, qk = (e, t, n) => {
    const a = e[or[`${n}EyeUpper0`][Tu.upperCenter]][2], r = e[or[`${n}EyeLower0`][Tu.lowerCenter]][2], s = (a + r) / 2;
    return t.map((i, l) => {
        let o = s;
        return l === 2 ? o = a : l === 4 && (o = r), [ i[0], i[1], o ];
    });
};

async function RK(e, t, n, a) {
    var r, s;
    if (!(ha != null && ha.executor)) return e;
    const {
        box: i,
        boxSize: l,
        crop: o
    } = Hk(e, t, Cu.leftBounds[0], Cu.leftBounds[1], n, !0, ((r = a.face.iris) == null ? void 0 : r.scale) || 2.3), {
        box: p,
        boxSize: u,
        crop: c
    } = Hk(e, t, Cu.rightBounds[0], Cu.rightBounds[1], n, !0, ((s = a.face.iris) == null ? void 0 : s.scale) || 2.3), d = yt([ o, c ]);
    ae(o), ae(c);
    const h = ha.execute(d);
    ae(d);
    const f = await h.data();
    ae(h);
    const m = f.slice(0, 3 * Tu.numCoordinates), {
        rawCoords: g,
        iris: y
    } = jk(m, i, l, !0), A = f.slice(3 * Tu.numCoordinates), {
        rawCoords: x,
        iris: b
    } = jk(A, p, u, !1), v = TK(e);
    Math.abs(v) < 30 ? (gh(e, g, "left", null), gh(e, x, "right", null)) : v < 1 ? gh(e, g, "left", [ "EyeUpper0", "EyeLower0" ]) : gh(e, x, "right", [ "EyeUpper0", "EyeLower0" ]);
    const I = qk(e, y, "left"), N = qk(e, b, "right");
    return e.concat(I).concat(N);
}

async function EK(e, t) {
    var n, a, r, s, i, l, o, p, u, c;
    const d = {
        lips: await ((a = (n = t.filter(m => m.size === 160)) == null ? void 0 : n[0]) == null ? void 0 : a.data()),
        irisL: await ((s = (r = t.filter(m => m.size === 10)) == null ? void 0 : r[0]) == null ? void 0 : s.data()),
        eyeL: await ((l = (i = t.filter(m => m.size === 142)) == null ? void 0 : i[0]) == null ? void 0 : l.data()),
        irisR: await ((p = (o = t.filter(m => m.size === 10)) == null ? void 0 : o[1]) == null ? void 0 : p.data()),
        eyeR: await ((c = (u = t.filter(m => m.size === 142)) == null ? void 0 : u[1]) == null ? void 0 : c.data())
    };
    for (const m of Object.values(d)) if (!m) return e;
    const h = bp.reduce((m, g) => m + e[g][2], 0) / bp.length;
    for (let m = 0; m < d.irisL.length / 2; m++) e.push([ d.irisL[2 * m + 0], d.irisL[2 * m + 1], h ]);
    const f = vp.reduce((m, g) => m + e[g][2], 0) / vp.length;
    for (let m = 0; m < d.irisR.length / 2; m++) e.push([ d.irisR[2 * m + 0], d.irisR[2 * m + 1], f ]);
    for (let m = 0; m < d.eyeL.length / 2; m++) e[bp[m]] = [ d.eyeL[2 * m + 0], d.eyeL[2 * m + 1], e[bp[m]][2] ];
    for (let m = 0; m < d.eyeR.length / 2; m++) e[vp[m]] = [ d.eyeR[2 * m + 0], d.eyeR[2 * m + 1], e[vp[m]][2] ];
    for (let m = 0; m < d.lips.length / 2; m++) e[G1[m]] = [ d.lips[2 * m + 0], d.lips[2 * m + 1], e[G1[m]][2] ];
    return e;
}

var Ha = {
    boxes: [],
    skipped: Number.MAX_SAFE_INTEGER,
    timestamp: 0
}, Kt = null, kp = 0, Tn, Rn, $K = xp, MK = uh, Xk = [], yh = [], Kk = 0, Zk = 0, r2 = Number.MAX_SAFE_INTEGER, s2 = !1;

async function Yk(e, t, n, a) {
    var r, s;
    if (!Tn) return [];
    const i = r2 < (((r = t.face.emotion) == null ? void 0 : r.skipFrames) || 0), l = (((s = t.face.emotion) == null ? void 0 : s.skipTime) || 0) > se() - Zk;
    return t.skipAllowed && l && i && Kk === a && yh[n] && yh[n].length > 0 ? (r2++, 
    yh[n]) : (r2 = 0, new Promise(async o => {
        var p, u, c;
        const d = [];
        if ((p = t.face.emotion) != null && p.enabled) {
            const h = {}, f = Tn != null && Tn.inputs[0].shape ? Tn.inputs[0].shape[2] : 0;
            if (((u = t.face.emotion) == null ? void 0 : u.crop) > 0) {
                const g = (c = t.face.emotion) == null ? void 0 : c.crop, y = [ [ g, g, 1 - g, 1 - g ] ];
                h.resize = Ue.cropAndResize(e, y, [ 0 ], [ f, f ]);
            } else h.resize = Ue.resizeBilinear(e, [ f, f ], !1);
            s2 ? (h.mul = ne(h.resize, 255), h.normalize = $e(h.mul, [ 103.939, 116.779, 123.68 ]), 
            h.emotion = Tn == null ? void 0 : Tn.execute(h.normalize)) : (h.channels = ne(h.resize, lt.rgb), 
            h.grayscale = dt(h.channels, 3, !0), h.grayscaleSub = $e(h.grayscale, lt.tf05), 
            h.grayscaleMul = ne(h.grayscaleSub, lt.tf2), h.emotion = Tn == null ? void 0 : Tn.execute(h.grayscaleMul)), 
            Zk = se();
            const m = await h.emotion.data();
            for (let g = 0; g < m.length; g++) m[g] > (t.face.emotion.minConfidence || 0) && d.push({
                score: Math.min(.99, Math.trunc(100 * m[g]) / 100),
                emotion: Xk[g]
            });
            d.sort((g, y) => y.score - g.score), Object.keys(h).forEach(g => ae(h[g]));
        }
        yh[n] = d, Kk = a, o(d);
    }));
}

var Ru = [], Jk = 0, Qk = 0, i2 = Number.MAX_SAFE_INTEGER;

async function e4(e, t, n, a) {
    var r, s, i, l;
    const o = {
        age: 0,
        gender: "unknown",
        genderScore: 0,
        descriptor: []
    };
    if (!(Rn != null && Rn.executor)) return o;
    const p = i2 < (((r = t.face.description) == null ? void 0 : r.skipFrames) || 0), u = (((s = t.face.description) == null ? void 0 : s.skipTime) || 0) > se() - Jk;
    return t.skipAllowed && p && u && Qk === a && ((i = Ru == null ? void 0 : Ru[n]) == null ? void 0 : i.age) > 0 && ((l = Ru == null ? void 0 : Ru[n]) == null ? void 0 : l.genderScore) > 0 ? (i2++, 
    Ru[n]) : (i2 = 0, new Promise(async c => {
        var d;
        if ((d = t.face.description) != null && d.enabled) {
            const h = function(T, R) {
                var w, E;
                const $ = T.image || T.tensor || T;
                if (!(Rn != null && Rn.inputs[0].shape)) return $;
                let M;
                if (((w = R.face.description) == null ? void 0 : w.crop) > 0) {
                    const P = (E = R.face.description) == null ? void 0 : E.crop, L = [ [ P, P, 1 - P, 1 - P ] ];
                    M = Ue.cropAndResize($, L, [ 0 ], [ Rn.inputs[0].shape[2], Rn.inputs[0].shape[1] ]);
                } else M = Ue.resizeBilinear($, [ Rn.inputs[0].shape[2], Rn.inputs[0].shape[1] ], !1);
                const F = ne(M, lt.tf255);
                return ae(M), F;
            }(e, t), f = Rn == null ? void 0 : Rn.execute(h);
            Jk = se(), ae(h);
            const m = f.find(T => T.shape[1] === 1), g = await m.data(), y = Math.trunc(200 * Math.abs(g[0] - .5)) / 100;
            y > (t.face.description.minConfidence || 0) && (o.gender = g[0] <= .5 ? "female" : "male", 
            o.genderScore = Math.min(.99, y));
            const A = Zl(f.find(T => T.shape[1] === 100), 1), x = (await A.data())[0];
            ae(A);
            const b = f.find(T => T.shape[1] === 100), v = await b.data();
            o.age = Math.round(v[x - 1] > v[x + 1] ? 10 * x - 100 * v[x - 1] : 10 * x + 100 * v[x + 1]) / 10, 
            (Number.isNaN(g[0]) || Number.isNaN(v[0])) && ee();
            const I = f.find(T => T.shape[1] === 1024), N = I ? await I.data() : [];
            o.descriptor = Array.from(N), f.forEach(T => ae(T));
        }
        Ru[n] = o, Qk = a, c(o);
    }));
}

var En, Ah = .1;

function FK(e, t, n) {
    let a = !1, r = n.length - 1;
    for (let s = 0; s < n.length; r = s++) n[s].y > t != n[r].y > t && e < (n[r].x - n[s].x) * (t - n[s].y) / (n[r].y - n[s].y) + n[s].x && (a = !a);
    return a;
}

async function _K(e) {
    if (!e.tensor || !e.mesh || e.mesh.length < 100) return e.tensor;
    const t = e.tensor.shape[2] || 0, n = e.tensor.shape[1] || 0, a = await e.tensor.buffer();
    let r = [];
    for (const s of or.silhouette) r.push({
        x: (e.mesh[s][0] - e.box[0]) / e.box[2],
        y: (e.mesh[s][1] - e.box[1]) / e.box[3]
    });
    r = r.map(s => ({
        x: s.x > .5 ? s.x + Ah : s.x - Ah,
        y: s.y > .5 ? s.y + Ah : s.y - Ah
    }));
    for (let s = 0; s < t; s++) for (let i = 0; i < n; i++) FK(s / t, i / t, r) || (a.set(.5 * a.get(0, i, s, 0), 0, i, s, 0), 
    a.set(.5 * a.get(0, i, s, 1), 0, i, s, 1), a.set(.5 * a.get(0, i, s, 2), 0, i, s, 2));
    return a.toTensor();
}

var $n, xh = [], o2 = Number.MAX_SAFE_INTEGER, t4 = 0, n4 = 0;

async function a4(e, t, n, a) {
    var r, s;
    if (!(En != null && En.executor)) return 0;
    const i = (((r = t.face.antispoof) == null ? void 0 : r.skipTime) || 0) > se() - n4, l = o2 < (((s = t.face.antispoof) == null ? void 0 : s.skipFrames) || 0);
    return t.skipAllowed && i && l && t4 === a && xh[n] ? (o2++, xh[n]) : (o2 = 0, 
    new Promise(async o => {
        const p = Ue.resizeBilinear(e, [ En != null && En.inputs[0].shape ? En.inputs[0].shape[2] : 0, En != null && En.inputs[0].shape ? En.inputs[0].shape[1] : 0 ], !1), u = En == null ? void 0 : En.execute(p), c = (await u.data())[0];
        xh[n] = Math.round(100 * c) / 100, t4 = a, n4 = se(), ae([ p, u ]), o(xh[n]);
    }));
}

var Ra, bh = [], l2 = Number.MAX_SAFE_INTEGER, r4 = 0, s4 = 0;

async function i4(e, t, n, a) {
    var r, s;
    if (!($n != null && $n.executor)) return 0;
    const i = (((r = t.face.liveness) == null ? void 0 : r.skipTime) || 0) > se() - s4, l = l2 < (((s = t.face.liveness) == null ? void 0 : s.skipFrames) || 0);
    return t.skipAllowed && i && l && r4 === a && bh[n] ? (l2++, bh[n]) : (l2 = 0, 
    new Promise(async o => {
        const p = Ue.resizeBilinear(e, [ $n != null && $n.inputs[0].shape ? $n.inputs[0].shape[2] : 0, $n != null && $n.inputs[0].shape ? $n.inputs[0].shape[1] : 0 ], !1), u = $n == null ? void 0 : $n.execute(p), c = (await u.data())[0];
        bh[n] = Math.round(100 * c) / 100, r4 = a, s4 = se(), ae([ p, u ]), o(bh[n]);
    }));
}

var Mn, u2 = [], OK = [ "white", "black", "asian", "indian", "other" ], PK = [ 15, 23, 28, 35.5, 45.5, 55.5, 65 ], o4 = 0, l4 = 0, d2 = Number.MAX_SAFE_INTEGER;

async function u4(e, t, n, a) {
    var r, s;
    if (!Ra) return {
        age: 0,
        gender: "unknown",
        genderScore: 0,
        race: []
    };
    const i = d2 < (((r = t.face.gear) == null ? void 0 : r.skipFrames) || 0), l = (((s = t.face.gear) == null ? void 0 : s.skipTime) || 0) > se() - l4;
    return t.skipAllowed && l && i && o4 === a && u2[n] ? (d2++, u2[n]) : (d2 = 0, 
    new Promise(async o => {
        var p, u, c, d;
        if (!(Ra != null && Ra.inputs[0].shape)) return;
        const h = {};
        let f = [ [ 0, .1, .9, .9 ] ];
        if (((p = t.face.gear) == null ? void 0 : p.crop) > 0) {
            const b = (u = t.face.gear) == null ? void 0 : u.crop;
            f = [ [ b, b, 1 - b, 1 - b ] ];
        }
        h.resize = Ue.cropAndResize(e, f, [ 0 ], [ Ra.inputs[0].shape[2], Ra.inputs[0].shape[1] ]);
        const m = {
            age: 0,
            gender: "unknown",
            genderScore: 0,
            race: []
        };
        (c = t.face.gear) != null && c.enabled && ([ h.age, h.gender, h.race ] = Ra.execute(h.resize, [ "age_output", "gender_output", "race_output" ]));
        const g = await h.gender.data();
        m.gender = g[0] > g[1] ? "male" : "female", m.genderScore = Math.round(100 * (g[0] > g[1] ? g[0] : g[1])) / 100;
        const y = await h.race.data();
        for (let b = 0; b < y.length; b++) y[b] > (((d = t.face.gear) == null ? void 0 : d.minConfidence) || .2) && m.race.push({
            score: Math.round(100 * y[b]) / 100,
            race: OK[b]
        });
        m.race.sort((b, v) => v.score - b.score);
        const A = Array.from(await h.age.data()).map((b, v) => [ PK[v], b ]).sort((b, v) => v[1] - b[1]);
        let x = A[0][0];
        for (let b = 1; b < A.length; b++) x += A[b][1] * (A[b][0] - x);
        m.age = Math.round(10 * x) / 10, Object.keys(h).forEach(b => ae(h[b])), 
        u2[n] = m, o4 = a, l4 = se(), o(m);
    }));
}

var Fn, vh = [], d4 = 0, p4 = 0, p2 = Number.MAX_SAFE_INTEGER;

async function c4(e, t, n, a) {
    var r, s, i, l;
    if (!Mn) return {
        age: 0
    };
    const o = p2 < (((r = t.face.ssrnet) == null ? void 0 : r.skipFrames) || 0), p = (((s = t.face.ssrnet) == null ? void 0 : s.skipTime) || 0) > se() - p4;
    return t.skipAllowed && o && p && d4 === a && ((i = vh[n]) != null && i.age) && ((l = vh[n]) == null ? void 0 : l.age) > 0 ? (p2++, 
    vh[n]) : (p2 = 0, new Promise(async u => {
        var c, d, h;
        if (!(Mn != null && Mn.inputs) || !Mn.inputs[0] || !Mn.inputs[0].shape) return;
        const f = {};
        if (((c = t.face.ssrnet) == null ? void 0 : c.crop) > 0) {
            const g = (d = t.face.ssrnet) == null ? void 0 : d.crop, y = [ [ g, g, 1 - g, 1 - g ] ];
            f.resize = Ue.cropAndResize(e, y, [ 0 ], [ Mn.inputs[0].shape[2], Mn.inputs[0].shape[1] ]);
        } else f.resize = Ue.resizeBilinear(e, [ Mn.inputs[0].shape[2], Mn.inputs[0].shape[1] ], !1);
        f.enhance = ne(f.resize, lt.tf255);
        const m = {
            age: 0
        };
        if ((h = t.face.ssrnet) != null && h.enabled && (f.age = Mn.execute(f.enhance)), 
        f.age) {
            const g = await f.age.data();
            m.age = Math.trunc(10 * g[0]) / 10;
        }
        Object.keys(f).forEach(g => ae(f[g])), vh[n] = m, d4 = a, p4 = se(), u(m);
    }));
}

var fa, wh = [], h4 = 0, f4 = 0, c2 = Number.MAX_SAFE_INTEGER, h2 = [ .2989, .587, .114 ];

async function m4(e, t, n, a) {
    var r, s, i, l;
    if (!Fn) return {
        gender: "unknown",
        genderScore: 0
    };
    const o = c2 < (((r = t.face.ssrnet) == null ? void 0 : r.skipFrames) || 0), p = (((s = t.face.ssrnet) == null ? void 0 : s.skipTime) || 0) > se() - f4;
    return t.skipAllowed && o && p && h4 === a && ((i = wh[n]) != null && i.gender) && ((l = wh[n]) == null ? void 0 : l.genderScore) > 0 ? (c2++, 
    wh[n]) : (c2 = 0, new Promise(async u => {
        var c, d, h;
        if (!(Fn != null && Fn.inputs[0].shape)) return;
        const f = {};
        if (((c = t.face.ssrnet) == null ? void 0 : c.crop) > 0) {
            const y = (d = t.face.ssrnet) == null ? void 0 : d.crop, A = [ [ y, y, 1 - y, 1 - y ] ];
            f.resize = Ue.cropAndResize(e, A, [ 0 ], [ Fn.inputs[0].shape[2], Fn.inputs[0].shape[1] ]);
        } else f.resize = Ue.resizeBilinear(e, [ Fn.inputs[0].shape[2], Fn.inputs[0].shape[1] ], !1);
        f.enhance = qe(() => {
            var y, A;
            let x;
            if (((A = (y = Fn == null ? void 0 : Fn.inputs) == null ? void 0 : y[0].shape) == null ? void 0 : A[3]) === 1) {
                const [ b, v, I ] = Ia(f.resize, 3, 3), N = ne(b, h2[0]), T = ne(v, h2[1]), R = ne(I, h2[2]), w = hf([ N, T, R ]);
                x = ne($e(w, lt.tf05), 2);
            } else x = ne($e(f.resize, lt.tf05), 2);
            return x;
        });
        const m = {
            gender: "unknown",
            genderScore: 0
        };
        (h = t.face.ssrnet) != null && h.enabled && (f.gender = Fn.execute(f.enhance));
        const g = await f.gender.data();
        m.gender = g[0] > g[1] ? "female" : "male", m.genderScore = g[0] > g[1] ? Math.trunc(100 * g[0]) / 100 : Math.trunc(100 * g[1]) / 100, 
        Object.keys(f).forEach(y => ae(f[y])), wh[n] = m, h4 = a, f4 = se(), u(m);
    }));
}

var ma, f2 = [], g4 = 0, y4 = 0, A4 = Number.MAX_SAFE_INTEGER;

async function x4(e, t, n, a) {
    var r, s;
    if (!(fa != null && fa.executor)) return [];
    const i = A4 < (((r = t.face.mobilefacenet) == null ? void 0 : r.skipFrames) || 0), l = (((s = t.face.mobilefacenet) == null ? void 0 : s.skipTime) || 0) > se() - y4;
    return t.skipAllowed && l && i && g4 === a && f2[n] ? (A4++, f2[n]) : new Promise(async o => {
        var p;
        let u = [];
        if ((p = t.face.mobilefacenet) != null && p.enabled && (fa != null && fa.inputs[0].shape)) {
            const c = {};
            c.crop = Ue.resizeBilinear(e, [ fa.inputs[0].shape[2], fa.inputs[0].shape[1] ], !1), 
            c.data = fa.execute(c.crop);
            const d = await c.data.data();
            u = Array.from(d), Object.keys(c).forEach(h => ae(c[h]));
        }
        f2[n] = u, g4 = a, y4 = se(), o(u);
    });
}

var m2 = [], b4 = 0, v4 = 0, w4 = Number.MAX_SAFE_INTEGER;

async function k4(e, t, n, a) {
    var r, s;
    if (!(ma != null && ma.executor)) return [];
    const i = w4 < (((r = t.face.insightface) == null ? void 0 : r.skipFrames) || 0), l = (((s = t.face.insightface) == null ? void 0 : s.skipTime) || 0) > se() - v4;
    return t.skipAllowed && l && i && b4 === a && m2[n] ? (w4++, m2[n]) : new Promise(async o => {
        var p;
        let u = [];
        if ((p = t.face.insightface) != null && p.enabled && (ma != null && ma.inputs[0].shape)) {
            const c = {};
            c.crop = Ue.resizeBilinear(e, [ ma.inputs[0].shape[2], ma.inputs[0].shape[1] ], !1), 
            c.data = ma.execute(c.crop);
            const d = await c.data.data();
            u = Array.from(d), Object.keys(c).forEach(h => ae(c[h]));
        }
        m2[n] = u, b4 = a, v4 = se(), o(u);
    });
}

var DK = (e, t) => {
    const n = f => {
        const m = Math.sqrt(f[0] * f[0] + f[1] * f[1] + f[2] * f[2]);
        return f[0] /= m, f[1] /= m, f[2] /= m, f;
    }, a = (f, m) => [ f[0] - m[0], f[1] - m[1], f[2] - m[2] ], r = (f, m) => [ f[1] * m[2] - f[2] * m[1], f[2] * m[0] - f[0] * m[2], f[0] * m[1] - f[1] * m[0] ], s = e.meshRaw;
    if (!s || s.length < 300) return {
        angle: {
            pitch: 0,
            yaw: 0,
            roll: 0
        },
        matrix: [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ],
        gaze: {
            bearing: 0,
            strength: 0
        }
    };
    const i = Math.max(e.boxRaw[2] * t[0], e.boxRaw[3] * t[1]) / 1.5, l = [ s[10], s[152], s[234], s[454] ].map(f => [ f[0] * t[0] / i, f[1] * t[1] / i, f[2] ]), o = n(a(l[1], l[0]));
    let p = n(a(l[3], l[2]));
    const u = n(r(p, o));
    p = r(o, u);
    const c = [ p[0], p[1], p[2], o[0], o[1], o[2], u[0], u[1], u[2] ], d = (f => {
        const [ m, g, y, A, x, b, v, I, N ] = f;
        let T, R, w;
        return A < 1 ? A > -1 ? (w = Math.asin(A), R = Math.atan2(-v, m), T = Math.atan2(-b, x)) : (w = -Math.PI / 2, 
        R = -Math.atan2(I, N), T = 0) : (w = Math.PI / 2, R = Math.atan2(I, N), 
        T = 0), Number.isNaN(T) && (T = 0), Number.isNaN(R) && (R = 0), Number.isNaN(w) && (w = 0), 
        {
            pitch: 2 * -T,
            yaw: 2 * -R,
            roll: 2 * -w
        };
    })(c), h = s.length === 478 ? (f => {
        if (!f.annotations.rightEyeIris || !f.annotations.leftEyeIris) return {
            bearing: 0,
            strength: 0
        };
        const m = [ 0, -.1 ], g = (f.mesh[33][2] || 0) > (f.mesh[263][2] || 0), y = g ? f.mesh[473] : f.mesh[468], A = g ? [ (f.mesh[133][0] + f.mesh[33][0]) / 2, (f.mesh[133][1] + f.mesh[33][1]) / 2 ] : [ (f.mesh[263][0] + f.mesh[362][0]) / 2, (f.mesh[263][1] + f.mesh[362][1]) / 2 ], x = g ? [ f.mesh[133][0] - f.mesh[33][0], f.mesh[23][1] - f.mesh[27][1] ] : [ f.mesh[263][0] - f.mesh[362][0], f.mesh[253][1] - f.mesh[257][1] ], b = [ (A[0] - y[0]) / x[0] - m[0], 1 * (y[1] - A[1]) / x[1] - m[1] ];
        let v = Math.sqrt(b[0] * b[0] + b[1] * b[1]);
        var I, N;
        return v = Math.min(v, f.boxRaw[2] / 2, f.boxRaw[3] / 2), {
            bearing: (I = [ 0, 0 ], N = b, (Math.atan2(I[1] - N[1], I[0] - N[0]) + Math.PI / 2) % Math.PI),
            strength: v
        };
    })(e) : {
        bearing: 0,
        strength: 0
    };
    return {
        angle: d,
        matrix: c,
        gaze: h
    };
};

function zK(e, t) {
    const n = e == null ? void 0 : e.annotations;
    if (!(n != null && n.leftEyeIris) || !(n != null && n.rightEyeIris)) return 0;
    const a = Math.max(Math.abs(n.leftEyeIris[3][0] - n.leftEyeIris[1][0]), Math.abs(n.rightEyeIris[3][0] - n.rightEyeIris[1][0])) / t;
    return Math.round(1.17 / a) / 100;
}

var I4 = async (e, t) => {
    var n, a, r, s, i, l, o, p, u, c, d, h, f, m, g, y, A, x, b, v, I, N, T;
    let R, w, E, $, M, F, P, L, O, B = se();
    const G = [];
    e.state = "run:face";
    const W = await async function(z, X) {
        var q, Z, Y, te, re, pe, ge, Re, ye, Me;
        const Ee = (((q = X.face.detector) == null ? void 0 : q.skipTime) || 0) > se() - Ha.timestamp, me = Ha.skipped < (((Z = X.face.detector) == null ? void 0 : Z.skipFrames) || 0);
        X.skipAllowed && Ee && me && Ha.boxes.length !== 0 ? Ha.skipped++ : (Ha.boxes = await CK(z, X), 
        Ha.timestamp = se(), Ha.skipped = 0);
        const Oe = [], we = [];
        let Be = 0;
        const nt = kp;
        for (let Ve = 0; Ve < Ha.boxes.length; Ve++) {
            const ue = Ha.boxes[Ve];
            let ct, nn = 0;
            const K = {
                id: Be++,
                mesh: [],
                meshRaw: [],
                box: [ 0, 0, 0, 0 ],
                boxRaw: [ 0, 0, 0, 0 ],
                score: 0,
                boxScore: 0,
                faceScore: 0,
                size: [ 0, 0 ],
                annotations: {}
            };
            if ([ nn, ct, K.tensor ] = IK((Y = X.face.detector) == null ? void 0 : Y.rotation, ue, z, (te = X.face.mesh) != null && te.enabled ? kp : ts), 
            X.filter.equalization) {
                const ie = K.tensor ? await n7(K.tensor) : void 0;
                ae(K.tensor), ie && (K.tensor = ie);
            }
            if (K.boxScore = Math.round(100 * ue.confidence) / 100, ((re = X.face.mesh) == null ? void 0 : re.enabled) && (Kt == null ? void 0 : Kt.executor)) if (Kt) {
                if ((pe = X.face.attention) != null && pe.enabled && !ce.kernels.includes("atan2")) return X.face.attention.enabled = !1, 
                ae(K.tensor), Oe;
                const ie = Kt.execute(K.tensor), Pe = ie.find(De => De.shape[De.shape.length - 1] === 1), Ge = await Pe.data();
                if (K.faceScore = Math.round(100 * Ge[0]) / 100, K.faceScore < (((ge = X.face.detector) == null ? void 0 : ge.minConfidence) || 1)) {
                    if (ue.confidence = K.faceScore, X.face.mesh.keepInvalid) {
                        K.box = J1(ue, z), K.boxRaw = Q1(ue, z), K.size = ue.size, 
                        K.score = K.boxScore, K.mesh = ue.landmarks, K.meshRaw = K.mesh.map(De => [ De[0] / (z.shape[2] || 1), De[1] / (z.shape[1] || 1), (De[2] || 0) / nt ]);
                        for (const De of Object.keys(Ap)) K.annotations[De] = [ K.mesh[Ap[De]] ];
                    }
                } else {
                    const De = ie.find(mt => mt.shape[mt.shape.length - 1] === 1404), Xe = Q(De, [ -1, 3 ]);
                    let et = await Xe.array();
                    ae(Xe), (Re = X.face.attention) != null && Re.enabled ? et = await EK(et, ie) : (ye = X.face.iris) != null && ye.enabled && (et = await RK(et, K.tensor, kp, X)), 
                    K.mesh = kK(et, ue, nn, ct, kp), K.meshRaw = K.mesh.map(mt => [ mt[0] / (z.shape[2] || 0), mt[1] / (z.shape[1] || 0), (mt[2] || 0) / nt ]);
                    for (const mt of Object.keys(or)) K.annotations[mt] = or[mt].map(an => K.mesh[an]);
                    K.score = K.faceScore;
                    const Ce = {
                        ...SK(K.mesh, ue),
                        confidence: ue.confidence,
                        landmarks: ue.landmarks,
                        size: ue.size
                    };
                    K.box = J1(Ce, z), K.boxRaw = Q1(Ce, z), K.size = Ce.size, we.push(Ce);
                }
                ae(ie);
            } else X.debug && ee(); else {
                K.box = J1(ue, z), K.boxRaw = Q1(ue, z), K.score = K.boxScore, K.size = ue.size, 
                K.mesh = ue.landmarks, K.meshRaw = K.mesh.map(ie => [ ie[0] / (z.shape[2] || 0), ie[1] / (z.shape[1] || 0), (ie[2] || 0) / nt ]);
                for (const ie of Object.keys(Ap)) K.annotations[ie] = [ K.mesh[Ap[ie]] ];
            }
            K.score > (((Me = X.face.detector) == null ? void 0 : Me.minConfidence) || 1) ? Oe.push(K) : ae(K.tensor);
        }
        return Ha.boxes = we, Oe;
    }(t, e.config);
    if (e.performance.face = ce.perfadd ? (e.performance.face || 0) + Math.trunc(se() - B) : Math.trunc(se() - B), 
    !t.shape || t.shape.length !== 4) return [];
    if (!W) return [];
    for (let z = 0; z < W.length; z++) {
        if (e.analyze("Get Face"), !W[z].tensor || W[z].tensor.isDisposedInternal) {
            ee(W[z].tensor);
            continue;
        }
        if ((n = e.config.face.detector) != null && n.mask) {
            const te = await _K(W[z]);
            ae(W[z].tensor), te && (W[z].tensor = te);
        }
        const X = W[z].mesh && W[z].mesh.length > 200 ? DK(W[z], [ t.shape[2], t.shape[1] ]) : null;
        e.analyze("Start Emotion:"), e.config.async ? $ = (a = e.config.face.emotion) != null && a.enabled ? Yk(W[z].tensor || Ye([]), e.config, z, W.length) : [] : (e.state = "run:emotion", 
        B = se(), $ = (r = e.config.face.emotion) != null && r.enabled ? await Yk(W[z].tensor || Ye([]), e.config, z, W.length) : [], 
        e.performance.emotion = ce.perfadd ? (e.performance.emotion || 0) + Math.trunc(se() - B) : Math.trunc(se() - B)), 
        e.analyze("End Emotion:"), e.analyze("Start AntiSpoof:"), e.config.async ? P = (s = e.config.face.antispoof) != null && s.enabled ? a4(W[z].tensor || Ye([]), e.config, z, W.length) : 0 : (e.state = "run:antispoof", 
        B = se(), P = (i = e.config.face.antispoof) != null && i.enabled ? await a4(W[z].tensor || Ye([]), e.config, z, W.length) : 0, 
        e.performance.antispoof = ce.perfadd ? (e.performance.antispoof || 0) + Math.trunc(se() - B) : Math.trunc(se() - B)), 
        e.analyze("End AntiSpoof:"), e.analyze("Start Liveness:"), e.config.async ? L = (l = e.config.face.liveness) != null && l.enabled ? i4(W[z].tensor || Ye([]), e.config, z, W.length) : 0 : (e.state = "run:liveness", 
        B = se(), L = (o = e.config.face.liveness) != null && o.enabled ? await i4(W[z].tensor || Ye([]), e.config, z, W.length) : 0, 
        e.performance.liveness = ce.perfadd ? (e.performance.antispoof || 0) + Math.trunc(se() - B) : Math.trunc(se() - B)), 
        e.analyze("End Liveness:"), e.analyze("Start GEAR:"), e.config.async ? w = (p = e.config.face.gear) != null && p.enabled ? u4(W[z].tensor || Ye([]), e.config, z, W.length) : null : (e.state = "run:gear", 
        B = se(), w = (u = e.config.face.gear) != null && u.enabled ? await u4(W[z].tensor || Ye([]), e.config, z, W.length) : null, 
        e.performance.gear = Math.trunc(se() - B)), e.analyze("End GEAR:"), e.analyze("Start SSRNet:"), 
        e.config.async ? (R = (c = e.config.face.ssrnet) != null && c.enabled ? c4(W[z].tensor || Ye([]), e.config, z, W.length) : null, 
        E = (d = e.config.face.ssrnet) != null && d.enabled ? m4(W[z].tensor || Ye([]), e.config, z, W.length) : null) : (e.state = "run:ssrnet", 
        B = se(), R = (h = e.config.face.ssrnet) != null && h.enabled ? await c4(W[z].tensor || Ye([]), e.config, z, W.length) : null, 
        E = (f = e.config.face.ssrnet) != null && f.enabled ? await m4(W[z].tensor || Ye([]), e.config, z, W.length) : null, 
        e.performance.ssrnet = Math.trunc(se() - B)), e.analyze("End SSRNet:"), 
        e.analyze("Start MobileFaceNet:"), e.config.async ? M = (m = e.config.face.mobilefacenet) != null && m.enabled ? x4(W[z].tensor || Ye([]), e.config, z, W.length) : null : (e.state = "run:mobilefacenet", 
        B = se(), M = (g = e.config.face.mobilefacenet) != null && g.enabled ? await x4(W[z].tensor || Ye([]), e.config, z, W.length) : null, 
        e.performance.mobilefacenet = Math.trunc(se() - B)), e.analyze("End MobileFaceNet:"), 
        e.analyze("Start InsightFace:"), e.config.async ? F = (y = e.config.face.insightface) != null && y.enabled ? k4(W[z].tensor || Ye([]), e.config, z, W.length) : null : (e.state = "run:mobilefacenet", 
        B = se(), F = (A = e.config.face.insightface) != null && A.enabled ? await k4(W[z].tensor || Ye([]), e.config, z, W.length) : null, 
        e.performance.mobilefacenet = Math.trunc(se() - B)), e.analyze("End InsightFace:"), 
        e.analyze("Start Description:"), e.config.async ? O = e4(W[z].tensor || Ye([]), e.config, z, W.length) : (e.state = "run:description", 
        B = se(), O = await e4(W[z].tensor || Ye([]), e.config, z, W.length), e.performance.description = ce.perfadd ? (e.performance.description || 0) + Math.trunc(se() - B) : Math.trunc(se() - B)), 
        e.analyze("End Description:"), e.config.async && ([ R, E, $, M, F, O, w, P, L ] = await Promise.all([ R, E, $, M, F, O, w, P, L ])), 
        e.analyze("Finish Face:"), (x = e.config.face.ssrnet) != null && x.enabled && R && E && (O = {
            ...O,
            age: R.age,
            gender: E.gender,
            genderScore: E.genderScore
        }), (b = e.config.face.gear) != null && b.enabled && w && (O = {
            ...O,
            age: w.age,
            gender: w.gender,
            genderScore: w.genderScore,
            race: w.race
        }), (v = e.config.face.mobilefacenet) != null && v.enabled && M && (O.descriptor = M), 
        (I = e.config.face.insightface) != null && I.enabled && F && (O.descriptor = F);
        const q = (N = e.config.face.iris) != null && N.enabled ? zK(W[z], t.shape[2]) : 0, Z = (T = e.config.face.detector) != null && T.return ? at(W[z].tensor) : null;
        ae(W[z].tensor), W[z].tensor && delete W[z].tensor;
        const Y = {
            ...W[z],
            id: z
        };
        O.age && (Y.age = O.age), O.gender && (Y.gender = O.gender), O.genderScore && (Y.genderScore = O.genderScore), 
        O.descriptor && (Y.embedding = O.descriptor), O.race && (Y.race = O.race), 
        $ && (Y.emotion = $), P && (Y.real = P), L && (Y.live = L), q > 0 && (Y.distance = q), 
        X && (Y.rotation = X), Z && (Y.tensor = Z), G.push(Y), e.analyze("End Face");
    }
    return e.analyze("End FaceMesh:"), e.config.async && (e.performance.face && delete e.performance.face, 
    e.performance.age && delete e.performance.age, e.performance.gender && delete e.performance.gender, 
    e.performance.emotion && delete e.performance.emotion), G;
}, qn = {
    thumb: 0,
    index: 1,
    middle: 2,
    ring: 3,
    pinky: 4,
    all: [ 0, 1, 2, 3, 4 ],
    nameMapping: {
        0: "thumb",
        1: "index",
        2: "middle",
        3: "ring",
        4: "pinky"
    },
    pointsMapping: {
        0: [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 4 ] ],
        1: [ [ 0, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ],
        2: [ [ 0, 9 ], [ 9, 10 ], [ 10, 11 ], [ 11, 12 ] ],
        3: [ [ 0, 13 ], [ 13, 14 ], [ 14, 15 ], [ 15, 16 ] ],
        4: [ [ 0, 17 ], [ 17, 18 ], [ 18, 19 ], [ 19, 20 ] ]
    },
    getName: e => qn.nameMapping[e],
    getPoints: e => qn.pointsMapping[e]
}, Eu = {
    none: 0,
    half: 1,
    full: 2,
    nameMapping: {
        0: "none",
        1: "half",
        2: "full"
    },
    getName: e => Eu.nameMapping[e]
}, Rt = {
    verticalUp: 0,
    verticalDown: 1,
    horizontalLeft: 2,
    horizontalRight: 3,
    diagonalUpRight: 4,
    diagonalUpLeft: 5,
    diagonalDownRight: 6,
    diagonalDownLeft: 7,
    nameMapping: {
        0: "verticalUp",
        1: "verticalDown",
        2: "horizontalLeft",
        3: "horizontalRight",
        4: "diagonalUpRight",
        5: "diagonalUpLeft",
        6: "diagonalDownRight",
        7: "diagonalDownLeft"
    },
    getName: e => Rt.nameMapping[e]
}, Ip = class {
    constructor(e) {
        ve(this, "name"), ve(this, "curls"), ve(this, "directions"), ve(this, "weights"), 
        ve(this, "weightsRelative"), this.name = e, this.curls = {}, this.directions = {}, 
        this.weights = [ 1, 1, 1, 1, 1 ], this.weightsRelative = [ 1, 1, 1, 1, 1 ];
    }
    curl(e, t, n) {
        this.curls[e] === void 0 && (this.curls[e] = []), this.curls[e].push([ t, n ]);
    }
    direction(e, t, n) {
        this.directions[e] || (this.directions[e] = []), this.directions[e].push([ t, n ]);
    }
    weight(e, t) {
        this.weights[e] = t;
        const n = this.weights.reduce((a, r) => a + r, 0);
        this.weightsRelative = this.weights.map(a => 5 * a / n);
    }
    matchAgainst(e, t) {
        let n = 0;
        for (const a in e) {
            const r = e[a], s = this.curls[a];
            if (s !== void 0) {
                for (const [ i, l ] of s) if (r === i) {
                    n += l * this.weightsRelative[a];
                    break;
                }
            } else n += this.weightsRelative[a];
        }
        for (const a in t) {
            const r = t[a], s = this.directions[a];
            if (s !== void 0) {
                for (const [ i, l ] of s) if (r === i) {
                    n += l * this.weightsRelative[a];
                    break;
                }
            } else n += this.weightsRelative[a];
        }
        return n / 10;
    }
}, {
    thumb: Ea,
    index: lr,
    middle: ur,
    ring: jo,
    pinky: qo
} = qn, {
    none: $a,
    half: LK,
    full: Ma
} = Eu, {
    verticalUp: $u,
    verticalDown: TZ,
    horizontalLeft: g2,
    horizontalRight: WK,
    diagonalUpRight: BK,
    diagonalUpLeft: Mu,
    diagonalDownRight: RZ,
    diagonalDownLeft: EZ
} = Rt, ns = new Ip("thumbs up");

ns.curl(Ea, $a, 1), ns.direction(Ea, $u, 1), ns.direction(Ea, Mu, .25), ns.direction(Ea, BK, .25);

for (const e of [ qn.index, qn.middle, qn.ring, qn.pinky ]) ns.curl(e, Ma, 1), ns.direction(e, g2, 1), 
ns.direction(e, WK, 1);

var Ot = new Ip("victory");

Ot.curl(Ea, LK, .5), Ot.curl(Ea, $a, .5), Ot.direction(Ea, $u, 1), Ot.direction(Ea, Mu, 1), 
Ot.curl(lr, $a, 1), Ot.direction(lr, $u, .75), Ot.direction(lr, Mu, 1), Ot.curl(ur, $a, 1), 
Ot.direction(ur, $u, 1), Ot.direction(ur, Mu, .75), Ot.curl(jo, Ma, 1), Ot.direction(jo, $u, .2), 
Ot.direction(jo, Mu, 1), Ot.direction(jo, g2, .2), Ot.curl(qo, Ma, 1), Ot.direction(qo, $u, .2), 
Ot.direction(qo, Mu, 1), Ot.direction(qo, g2, .2), Ot.weight(lr, 2), Ot.weight(ur, 2);

var as = new Ip("point");

as.curl(Ea, Ma, 1), as.curl(lr, $a, .5), as.curl(ur, Ma, .5), as.curl(jo, Ma, .5), 
as.curl(qo, Ma, .5), as.weight(lr, 2), as.weight(ur, 2);

var rs = new Ip("middle finger");

rs.curl(Ea, $a, 1), rs.curl(lr, Ma, .5), rs.curl(ur, Ma, .5), rs.curl(jo, Ma, .5), 
rs.curl(qo, Ma, .5), rs.weight(lr, 2), rs.weight(ur, 2);

var Fu = new Ip("open palm");

Fu.curl(Ea, $a, .75), Fu.curl(lr, $a, .75), Fu.curl(ur, $a, .75), Fu.curl(jo, $a, .75), 
Fu.curl(qo, $a, .75);

var VK = [ ns, Ot, as, rs, Fu ], Xo = {
    HALF_CURL_START_LIMIT: 60,
    NO_CURL_START_LIMIT: 130,
    DISTANCE_VOTE_POWER: 1.1,
    SINGLE_ANGLE_VOTE_POWER: .9,
    TOTAL_ANGLE_VOTE_POWER: 1.6
};

function S4(e, t, n, a) {
    const r = (t - a) / (e - n);
    let s = 180 * Math.atan(r) / Math.PI;
    return s <= 0 ? s = -s : s > 0 && (s = 180 - s), s;
}

function N4(e, t) {
    if (!e || !t) return [ 0, 0 ];
    const n = S4(e[0], e[1], t[0], t[1]);
    return e.length === 2 ? n : [ n, S4(e[1], e[2], t[1], t[2]) ];
}

function C4(e, t = 1) {
    let n = 0, a = 0, r = 0;
    return e >= 75 && e <= 105 ? n = 1 * t : e >= 25 && e <= 155 ? a = 1 * t : r = 1 * t, 
    [ n, a, r ];
}

function UK(e, t, n) {
    const a = e[0] - t[0], r = e[0] - n[0], s = t[0] - n[0], i = e[1] - t[1], l = e[1] - n[1], o = t[1] - n[1], p = e[2] - t[2], u = e[2] - n[2], c = t[2] - n[2], d = Math.sqrt(a * a + i * i + p * p), h = Math.sqrt(r * r + l * l + u * u), f = Math.sqrt(s * s + o * o + c * c);
    let m = (f * f + d * d - h * h) / (2 * f * d);
    m > 1 ? m = 1 : m < -1 && (m = -1);
    let g, y = Math.acos(m);
    return y = 57.2958 * y % 180, g = y > Xo.NO_CURL_START_LIMIT ? Eu.none : y > Xo.HALF_CURL_START_LIMIT ? Eu.half : Eu.full, 
    g;
}

function T4(e, t, n, a) {
    let r;
    return r = a === Math.abs(e) ? e > 0 ? Rt.horizontalLeft : Rt.horizontalRight : a === Math.abs(t) ? t > 0 ? Rt.horizontalLeft : Rt.horizontalRight : n > 0 ? Rt.horizontalLeft : Rt.horizontalRight, 
    r;
}

function R4(e, t, n, a) {
    let r;
    return r = a === Math.abs(e) ? e < 0 ? Rt.verticalDown : Rt.verticalUp : a === Math.abs(t) ? t < 0 ? Rt.verticalDown : Rt.verticalUp : n < 0 ? Rt.verticalDown : Rt.verticalUp, 
    r;
}

function GK(e, t, n, a) {
    const r = e[0] - t[0], s = e[0] - n[0], i = t[0] - n[0], l = e[1] - t[1], o = e[1] - n[1], p = t[1] - n[1], u = Math.max(Math.abs(r), Math.abs(s), Math.abs(i)), c = Math.max(Math.abs(l), Math.abs(o), Math.abs(p));
    let d = 0, h = 0, f = 0;
    const m = c / (u + 1e-5);
    m > 1.5 ? d += Xo.DISTANCE_VOTE_POWER : m > .66 ? h += Xo.DISTANCE_VOTE_POWER : f += Xo.DISTANCE_VOTE_POWER;
    const g = Math.sqrt(r * r + l * l), y = Math.sqrt(s * s + o * o), A = Math.sqrt(i * i + p * p), x = Math.max(g, y, A);
    let b = e[0], v = e[1], I = n[0], N = n[1];
    x === g ? (I = n[0], N = n[1]) : x === A && (b = t[0], v = t[1]);
    const T = C4(N4([ b, v ], [ I, N ]), Xo.TOTAL_ANGLE_VOTE_POWER);
    d += T[0], h += T[1], f += T[2];
    for (const w of a) {
        const E = C4(w, Xo.SINGLE_ANGLE_VOTE_POWER);
        d += E[0], h += E[1], f += E[2];
    }
    let R;
    return R = d === Math.max(d, h, f) ? R4(o, l, p, c) : f === Math.max(h, f) ? T4(s, r, i, u) : function(w, E, $, M, F, P, L, O) {
        let B;
        const G = R4(w, E, $, M), W = T4(F, P, L, O);
        return B = G === Rt.verticalUp ? W === Rt.horizontalLeft ? Rt.diagonalUpLeft : Rt.diagonalUpRight : W === Rt.horizontalLeft ? Rt.diagonalDownLeft : Rt.diagonalDownRight, 
        B;
    }(o, l, p, c, s, r, i, u), R;
}

function E4(e) {
    const t = [], n = [], a = [];
    if (!e) return {
        curls: n,
        directions: a
    };
    for (const r of qn.all) {
        const s = qn.getPoints(r), i = [];
        for (const l of s) {
            const o = N4(e[l[0]], e[l[1]]), p = o[0];
            o[1], i.push(p);
        }
        t.push(i);
    }
    for (const r of qn.all) {
        const s = r === qn.thumb ? 1 : 0, i = qn.getPoints(r), l = e[i[s][0]], o = e[i[s + 1][1]], p = e[i[3][1]], u = UK(l, o, p), c = GK(l, o, p, t[r].slice(s));
        n[r] = u, a[r] = c;
    }
    return {
        curls: n,
        directions: a
    };
}

function $4(e) {
    if (!e || e.length === 0) return null;
    const t = E4(e), n = {};
    for (const a of qn.all) n[qn.getName(a)] = {
        curl: Eu.getName(t.curls[a]),
        direction: Rt.getName(t.directions[a])
    };
    return n;
}

function HK(e) {
    const t = [];
    if (!e || e.length === 0) return t;
    const n = E4(e);
    for (const a of VK) {
        const r = a.matchAgainst(n.curls, n.directions);
        r >= .7 && t.push({
            name: a.name,
            confidence: r
        });
    }
    return t;
}

var jK = e => {
    if (!e) return [];
    const t = [];
    for (let n = 0; n < e.length; n++) {
        const a = e[n].keypoints.find(o => o.part === "leftWrist"), r = e[n].keypoints.find(o => o.part === "rightWrist"), s = e[n].keypoints.find(o => o.part === "nose");
        s && a && r && a.position[1] < s.position[1] && r.position[1] < s.position[1] ? t.push({
            body: n,
            gesture: "i give up"
        }) : s && a && a.position[1] < s.position[1] ? t.push({
            body: n,
            gesture: "raise left hand"
        }) : s && r && r.position[1] < s.position[1] && t.push({
            body: n,
            gesture: "raise right hand"
        });
        const i = e[n].keypoints.find(o => o.part === "leftShoulder"), l = e[n].keypoints.find(o => o.part === "rightShoulder");
        i && l && Math.abs(i.positionRaw[1] - l.positionRaw[1]) > .1 && t.push({
            body: n,
            gesture: "leaning " + (i.position[1] > l.position[1] ? "left" : "right")
        });
    }
    return t;
}, qK = e => {
    if (!e) return [];
    const t = [];
    for (let n = 0; n < e.length; n++) if (e[n].mesh && e[n].mesh.length > 450) {
        const a = (e[n].mesh[33][2] || 0) - (e[n].mesh[263][2] || 0), r = e[n].mesh[33][0] - e[n].mesh[263][0];
        Math.abs(a / r) <= .15 ? t.push({
            face: n,
            gesture: "facing center"
        }) : t.push({
            face: n,
            gesture: "facing " + (a < 0 ? "left" : "right")
        }), Math.abs(e[n].mesh[374][1] - e[n].mesh[386][1]) / Math.abs(e[n].mesh[443][1] - e[n].mesh[450][1]) < .2 && t.push({
            face: n,
            gesture: "blink left eye"
        }), Math.abs(e[n].mesh[145][1] - e[n].mesh[159][1]) / Math.abs(e[n].mesh[223][1] - e[n].mesh[230][1]) < .2 && t.push({
            face: n,
            gesture: "blink right eye"
        });
        const s = Math.min(100, 500 * Math.abs(e[n].mesh[13][1] - e[n].mesh[14][1]) / Math.abs(e[n].mesh[10][1] - e[n].mesh[152][1]));
        s > 10 && t.push({
            face: n,
            gesture: `mouth ${Math.trunc(s)}% open`
        });
        const i = e[n].mesh[152][2] || 0;
        Math.abs(i) > 10 && t.push({
            face: n,
            gesture: "head " + (i < 0 ? "up" : "down")
        });
    }
    return t;
}, XK = e => {
    var t, n, a, r;
    if (!e) return [];
    const s = [];
    for (let i = 0; i < e.length; i++) {
        if (!((n = (t = e[i].annotations) == null ? void 0 : t.leftEyeIris) != null && n[0]) || !((r = (a = e[i].annotations) == null ? void 0 : a.rightEyeIris) != null && r[0])) continue;
        const l = e[i].annotations.leftEyeIris[3][0] - e[i].annotations.leftEyeIris[1][0], o = e[i].annotations.leftEyeIris[4][1] - e[i].annotations.leftEyeIris[2][1], p = Math.abs(l * o), u = e[i].annotations.rightEyeIris[3][0] - e[i].annotations.rightEyeIris[1][0], c = e[i].annotations.rightEyeIris[4][1] - e[i].annotations.rightEyeIris[2][1], d = Math.abs(u * c);
        let h = !1;
        Math.abs(p - d) / Math.max(p, d) < .25 && (h = !0, s.push({
            iris: i,
            gesture: "facing center"
        }));
        const f = Math.abs(e[i].mesh[263][0] - e[i].annotations.leftEyeIris[0][0]) / e[i].box[2], m = Math.abs(e[i].mesh[33][0] - e[i].annotations.rightEyeIris[0][0]) / e[i].box[2];
        (f > .06 || m > .06) && (h = !1), f > m ? m > .04 && s.push({
            iris: i,
            gesture: "looking right"
        }) : f > .04 && s.push({
            iris: i,
            gesture: "looking left"
        });
        const g = Math.abs(e[i].mesh[145][1] - e[i].annotations.rightEyeIris[0][1]) / e[i].box[3], y = Math.abs(e[i].mesh[374][1] - e[i].annotations.leftEyeIris[0][1]) / e[i].box[3];
        (y < .01 || g < .01 || y > .022 || g > .022) && (h = !1), (y < .01 || g < .01) && s.push({
            iris: i,
            gesture: "looking down"
        }), (y > .022 || g > .022) && s.push({
            iris: i,
            gesture: "looking up"
        }), h && s.push({
            iris: i,
            gesture: "looking center"
        });
    }
    return s;
}, KK = e => {
    if (!e) return [];
    const t = [];
    for (let n = 0; n < e.length; n++) {
        const a = [];
        if (e[n].annotations) for (const [ r, s ] of Object.entries(e[n].annotations)) r !== "palmBase" && Array.isArray(s) && s[0] && a.push({
            name: r.toLowerCase(),
            position: s[0]
        });
        if (a && a.length > 0) {
            const r = a.reduce((i, l) => (i.position[2] || 0) < (l.position[2] || 0) ? i : l);
            t.push({
                hand: n,
                gesture: `${r.name} forward`
            });
            const s = a.reduce((i, l) => i.position[1] < l.position[1] ? i : l);
            t.push({
                hand: n,
                gesture: `${s.name} up`
            });
        }
        if (e[n].keypoints) {
            const r = HK(e[n].keypoints);
            for (const s of r) t.push({
                hand: n,
                gesture: s.name
            });
        }
    }
    return t;
};

function y2(e) {
    return [ Math.abs(e.endPoint[0] - e.startPoint[0]), Math.abs(e.endPoint[1] - e.startPoint[1]) ];
}

function kh(e) {
    return [ e.startPoint[0] + (e.endPoint[0] - e.startPoint[0]) / 2, e.startPoint[1] + (e.endPoint[1] - e.startPoint[1]) / 2 ];
}

function ZK(e, t, n) {
    const a = t.shape[1], r = t.shape[2], s = [ [ e.startPoint[1] / a, e.startPoint[0] / r, e.endPoint[1] / a, e.endPoint[0] / r ] ];
    return Ue.cropAndResize(t, s, [ 0 ], n);
}

function YK(e, t) {
    return {
        startPoint: [ e.startPoint[0] * t[0], e.startPoint[1] * t[1] ],
        endPoint: [ e.endPoint[0] * t[0], e.endPoint[1] * t[1] ],
        palmLandmarks: e.palmLandmarks.map(n => [ n[0] * t[0], n[1] * t[1] ]),
        confidence: e.confidence
    };
}

function A2(e, t = 1.5) {
    const n = kh(e), a = y2(e), r = [ t * a[0] / 2, t * a[1] / 2 ];
    return {
        startPoint: [ n[0] - r[0], n[1] - r[1] ],
        endPoint: [ n[0] + r[0], n[1] + r[1] ],
        palmLandmarks: e.palmLandmarks
    };
}

function x2(e) {
    const t = kh(e), n = y2(e), a = Math.max(...n) / 2;
    return {
        startPoint: [ t[0] - a, t[1] - a ],
        endPoint: [ t[0] + a, t[1] + a ],
        palmLandmarks: e.palmLandmarks
    };
}

function JK(e, t) {
    return (a = Math.PI / 2 - Math.atan2(-(t[1] - e[1]), t[0] - e[0])) - 2 * Math.PI * Math.floor((a + Math.PI) / (2 * Math.PI));
    var a;
}

var M4 = (e, t) => [ [ 1, 0, e ], [ 0, 1, t ], [ 0, 0, 1 ] ];

function Ko(e, t) {
    let n = 0;
    for (let a = 0; a < e.length; a++) n += e[a] * t[a];
    return n;
}

function QK(e, t) {
    const n = [];
    for (let a = 0; a < e.length; a++) n.push(e[a][t]);
    return n;
}

function F4(e, t) {
    const n = [], a = e.length;
    for (let r = 0; r < a; r++) {
        n.push([]);
        for (let s = 0; s < a; s++) n[r].push(Ko(e[r], QK(t, s)));
    }
    return n;
}

function _4(e, t) {
    const n = Math.cos(e), a = Math.sin(e), r = [ [ n, -a, 0 ], [ a, n, 0 ], [ 0, 0, 1 ] ], s = F4(M4(t[0], t[1]), r);
    return F4(s, M4(-t[0], -t[1]));
}

function O4(e, t) {
    return [ Ko(e, t[0]), Ko(e, t[1]) ];
}

var Zo, Yo, b2, eZ = [ {
    x: .015625,
    y: .015625
}, {
    x: .015625,
    y: .015625
}, {
    x: .046875,
    y: .015625
}, {
    x: .046875,
    y: .015625
}, {
    x: .078125,
    y: .015625
}, {
    x: .078125,
    y: .015625
}, {
    x: .109375,
    y: .015625
}, {
    x: .109375,
    y: .015625
}, {
    x: .140625,
    y: .015625
}, {
    x: .140625,
    y: .015625
}, {
    x: .171875,
    y: .015625
}, {
    x: .171875,
    y: .015625
}, {
    x: .203125,
    y: .015625
}, {
    x: .203125,
    y: .015625
}, {
    x: .234375,
    y: .015625
}, {
    x: .234375,
    y: .015625
}, {
    x: .265625,
    y: .015625
}, {
    x: .265625,
    y: .015625
}, {
    x: .296875,
    y: .015625
}, {
    x: .296875,
    y: .015625
}, {
    x: .328125,
    y: .015625
}, {
    x: .328125,
    y: .015625
}, {
    x: .359375,
    y: .015625
}, {
    x: .359375,
    y: .015625
}, {
    x: .390625,
    y: .015625
}, {
    x: .390625,
    y: .015625
}, {
    x: .421875,
    y: .015625
}, {
    x: .421875,
    y: .015625
}, {
    x: .453125,
    y: .015625
}, {
    x: .453125,
    y: .015625
}, {
    x: .484375,
    y: .015625
}, {
    x: .484375,
    y: .015625
}, {
    x: .515625,
    y: .015625
}, {
    x: .515625,
    y: .015625
}, {
    x: .546875,
    y: .015625
}, {
    x: .546875,
    y: .015625
}, {
    x: .578125,
    y: .015625
}, {
    x: .578125,
    y: .015625
}, {
    x: .609375,
    y: .015625
}, {
    x: .609375,
    y: .015625
}, {
    x: .640625,
    y: .015625
}, {
    x: .640625,
    y: .015625
}, {
    x: .671875,
    y: .015625
}, {
    x: .671875,
    y: .015625
}, {
    x: .703125,
    y: .015625
}, {
    x: .703125,
    y: .015625
}, {
    x: .734375,
    y: .015625
}, {
    x: .734375,
    y: .015625
}, {
    x: .765625,
    y: .015625
}, {
    x: .765625,
    y: .015625
}, {
    x: .796875,
    y: .015625
}, {
    x: .796875,
    y: .015625
}, {
    x: .828125,
    y: .015625
}, {
    x: .828125,
    y: .015625
}, {
    x: .859375,
    y: .015625
}, {
    x: .859375,
    y: .015625
}, {
    x: .890625,
    y: .015625
}, {
    x: .890625,
    y: .015625
}, {
    x: .921875,
    y: .015625
}, {
    x: .921875,
    y: .015625
}, {
    x: .953125,
    y: .015625
}, {
    x: .953125,
    y: .015625
}, {
    x: .984375,
    y: .015625
}, {
    x: .984375,
    y: .015625
}, {
    x: .015625,
    y: .046875
}, {
    x: .015625,
    y: .046875
}, {
    x: .046875,
    y: .046875
}, {
    x: .046875,
    y: .046875
}, {
    x: .078125,
    y: .046875
}, {
    x: .078125,
    y: .046875
}, {
    x: .109375,
    y: .046875
}, {
    x: .109375,
    y: .046875
}, {
    x: .140625,
    y: .046875
}, {
    x: .140625,
    y: .046875
}, {
    x: .171875,
    y: .046875
}, {
    x: .171875,
    y: .046875
}, {
    x: .203125,
    y: .046875
}, {
    x: .203125,
    y: .046875
}, {
    x: .234375,
    y: .046875
}, {
    x: .234375,
    y: .046875
}, {
    x: .265625,
    y: .046875
}, {
    x: .265625,
    y: .046875
}, {
    x: .296875,
    y: .046875
}, {
    x: .296875,
    y: .046875
}, {
    x: .328125,
    y: .046875
}, {
    x: .328125,
    y: .046875
}, {
    x: .359375,
    y: .046875
}, {
    x: .359375,
    y: .046875
}, {
    x: .390625,
    y: .046875
}, {
    x: .390625,
    y: .046875
}, {
    x: .421875,
    y: .046875
}, {
    x: .421875,
    y: .046875
}, {
    x: .453125,
    y: .046875
}, {
    x: .453125,
    y: .046875
}, {
    x: .484375,
    y: .046875
}, {
    x: .484375,
    y: .046875
}, {
    x: .515625,
    y: .046875
}, {
    x: .515625,
    y: .046875
}, {
    x: .546875,
    y: .046875
}, {
    x: .546875,
    y: .046875
}, {
    x: .578125,
    y: .046875
}, {
    x: .578125,
    y: .046875
}, {
    x: .609375,
    y: .046875
}, {
    x: .609375,
    y: .046875
}, {
    x: .640625,
    y: .046875
}, {
    x: .640625,
    y: .046875
}, {
    x: .671875,
    y: .046875
}, {
    x: .671875,
    y: .046875
}, {
    x: .703125,
    y: .046875
}, {
    x: .703125,
    y: .046875
}, {
    x: .734375,
    y: .046875
}, {
    x: .734375,
    y: .046875
}, {
    x: .765625,
    y: .046875
}, {
    x: .765625,
    y: .046875
}, {
    x: .796875,
    y: .046875
}, {
    x: .796875,
    y: .046875
}, {
    x: .828125,
    y: .046875
}, {
    x: .828125,
    y: .046875
}, {
    x: .859375,
    y: .046875
}, {
    x: .859375,
    y: .046875
}, {
    x: .890625,
    y: .046875
}, {
    x: .890625,
    y: .046875
}, {
    x: .921875,
    y: .046875
}, {
    x: .921875,
    y: .046875
}, {
    x: .953125,
    y: .046875
}, {
    x: .953125,
    y: .046875
}, {
    x: .984375,
    y: .046875
}, {
    x: .984375,
    y: .046875
}, {
    x: .015625,
    y: .078125
}, {
    x: .015625,
    y: .078125
}, {
    x: .046875,
    y: .078125
}, {
    x: .046875,
    y: .078125
}, {
    x: .078125,
    y: .078125
}, {
    x: .078125,
    y: .078125
}, {
    x: .109375,
    y: .078125
}, {
    x: .109375,
    y: .078125
}, {
    x: .140625,
    y: .078125
}, {
    x: .140625,
    y: .078125
}, {
    x: .171875,
    y: .078125
}, {
    x: .171875,
    y: .078125
}, {
    x: .203125,
    y: .078125
}, {
    x: .203125,
    y: .078125
}, {
    x: .234375,
    y: .078125
}, {
    x: .234375,
    y: .078125
}, {
    x: .265625,
    y: .078125
}, {
    x: .265625,
    y: .078125
}, {
    x: .296875,
    y: .078125
}, {
    x: .296875,
    y: .078125
}, {
    x: .328125,
    y: .078125
}, {
    x: .328125,
    y: .078125
}, {
    x: .359375,
    y: .078125
}, {
    x: .359375,
    y: .078125
}, {
    x: .390625,
    y: .078125
}, {
    x: .390625,
    y: .078125
}, {
    x: .421875,
    y: .078125
}, {
    x: .421875,
    y: .078125
}, {
    x: .453125,
    y: .078125
}, {
    x: .453125,
    y: .078125
}, {
    x: .484375,
    y: .078125
}, {
    x: .484375,
    y: .078125
}, {
    x: .515625,
    y: .078125
}, {
    x: .515625,
    y: .078125
}, {
    x: .546875,
    y: .078125
}, {
    x: .546875,
    y: .078125
}, {
    x: .578125,
    y: .078125
}, {
    x: .578125,
    y: .078125
}, {
    x: .609375,
    y: .078125
}, {
    x: .609375,
    y: .078125
}, {
    x: .640625,
    y: .078125
}, {
    x: .640625,
    y: .078125
}, {
    x: .671875,
    y: .078125
}, {
    x: .671875,
    y: .078125
}, {
    x: .703125,
    y: .078125
}, {
    x: .703125,
    y: .078125
}, {
    x: .734375,
    y: .078125
}, {
    x: .734375,
    y: .078125
}, {
    x: .765625,
    y: .078125
}, {
    x: .765625,
    y: .078125
}, {
    x: .796875,
    y: .078125
}, {
    x: .796875,
    y: .078125
}, {
    x: .828125,
    y: .078125
}, {
    x: .828125,
    y: .078125
}, {
    x: .859375,
    y: .078125
}, {
    x: .859375,
    y: .078125
}, {
    x: .890625,
    y: .078125
}, {
    x: .890625,
    y: .078125
}, {
    x: .921875,
    y: .078125
}, {
    x: .921875,
    y: .078125
}, {
    x: .953125,
    y: .078125
}, {
    x: .953125,
    y: .078125
}, {
    x: .984375,
    y: .078125
}, {
    x: .984375,
    y: .078125
}, {
    x: .015625,
    y: .109375
}, {
    x: .015625,
    y: .109375
}, {
    x: .046875,
    y: .109375
}, {
    x: .046875,
    y: .109375
}, {
    x: .078125,
    y: .109375
}, {
    x: .078125,
    y: .109375
}, {
    x: .109375,
    y: .109375
}, {
    x: .109375,
    y: .109375
}, {
    x: .140625,
    y: .109375
}, {
    x: .140625,
    y: .109375
}, {
    x: .171875,
    y: .109375
}, {
    x: .171875,
    y: .109375
}, {
    x: .203125,
    y: .109375
}, {
    x: .203125,
    y: .109375
}, {
    x: .234375,
    y: .109375
}, {
    x: .234375,
    y: .109375
}, {
    x: .265625,
    y: .109375
}, {
    x: .265625,
    y: .109375
}, {
    x: .296875,
    y: .109375
}, {
    x: .296875,
    y: .109375
}, {
    x: .328125,
    y: .109375
}, {
    x: .328125,
    y: .109375
}, {
    x: .359375,
    y: .109375
}, {
    x: .359375,
    y: .109375
}, {
    x: .390625,
    y: .109375
}, {
    x: .390625,
    y: .109375
}, {
    x: .421875,
    y: .109375
}, {
    x: .421875,
    y: .109375
}, {
    x: .453125,
    y: .109375
}, {
    x: .453125,
    y: .109375
}, {
    x: .484375,
    y: .109375
}, {
    x: .484375,
    y: .109375
}, {
    x: .515625,
    y: .109375
}, {
    x: .515625,
    y: .109375
}, {
    x: .546875,
    y: .109375
}, {
    x: .546875,
    y: .109375
}, {
    x: .578125,
    y: .109375
}, {
    x: .578125,
    y: .109375
}, {
    x: .609375,
    y: .109375
}, {
    x: .609375,
    y: .109375
}, {
    x: .640625,
    y: .109375
}, {
    x: .640625,
    y: .109375
}, {
    x: .671875,
    y: .109375
}, {
    x: .671875,
    y: .109375
}, {
    x: .703125,
    y: .109375
}, {
    x: .703125,
    y: .109375
}, {
    x: .734375,
    y: .109375
}, {
    x: .734375,
    y: .109375
}, {
    x: .765625,
    y: .109375
}, {
    x: .765625,
    y: .109375
}, {
    x: .796875,
    y: .109375
}, {
    x: .796875,
    y: .109375
}, {
    x: .828125,
    y: .109375
}, {
    x: .828125,
    y: .109375
}, {
    x: .859375,
    y: .109375
}, {
    x: .859375,
    y: .109375
}, {
    x: .890625,
    y: .109375
}, {
    x: .890625,
    y: .109375
}, {
    x: .921875,
    y: .109375
}, {
    x: .921875,
    y: .109375
}, {
    x: .953125,
    y: .109375
}, {
    x: .953125,
    y: .109375
}, {
    x: .984375,
    y: .109375
}, {
    x: .984375,
    y: .109375
}, {
    x: .015625,
    y: .140625
}, {
    x: .015625,
    y: .140625
}, {
    x: .046875,
    y: .140625
}, {
    x: .046875,
    y: .140625
}, {
    x: .078125,
    y: .140625
}, {
    x: .078125,
    y: .140625
}, {
    x: .109375,
    y: .140625
}, {
    x: .109375,
    y: .140625
}, {
    x: .140625,
    y: .140625
}, {
    x: .140625,
    y: .140625
}, {
    x: .171875,
    y: .140625
}, {
    x: .171875,
    y: .140625
}, {
    x: .203125,
    y: .140625
}, {
    x: .203125,
    y: .140625
}, {
    x: .234375,
    y: .140625
}, {
    x: .234375,
    y: .140625
}, {
    x: .265625,
    y: .140625
}, {
    x: .265625,
    y: .140625
}, {
    x: .296875,
    y: .140625
}, {
    x: .296875,
    y: .140625
}, {
    x: .328125,
    y: .140625
}, {
    x: .328125,
    y: .140625
}, {
    x: .359375,
    y: .140625
}, {
    x: .359375,
    y: .140625
}, {
    x: .390625,
    y: .140625
}, {
    x: .390625,
    y: .140625
}, {
    x: .421875,
    y: .140625
}, {
    x: .421875,
    y: .140625
}, {
    x: .453125,
    y: .140625
}, {
    x: .453125,
    y: .140625
}, {
    x: .484375,
    y: .140625
}, {
    x: .484375,
    y: .140625
}, {
    x: .515625,
    y: .140625
}, {
    x: .515625,
    y: .140625
}, {
    x: .546875,
    y: .140625
}, {
    x: .546875,
    y: .140625
}, {
    x: .578125,
    y: .140625
}, {
    x: .578125,
    y: .140625
}, {
    x: .609375,
    y: .140625
}, {
    x: .609375,
    y: .140625
}, {
    x: .640625,
    y: .140625
}, {
    x: .640625,
    y: .140625
}, {
    x: .671875,
    y: .140625
}, {
    x: .671875,
    y: .140625
}, {
    x: .703125,
    y: .140625
}, {
    x: .703125,
    y: .140625
}, {
    x: .734375,
    y: .140625
}, {
    x: .734375,
    y: .140625
}, {
    x: .765625,
    y: .140625
}, {
    x: .765625,
    y: .140625
}, {
    x: .796875,
    y: .140625
}, {
    x: .796875,
    y: .140625
}, {
    x: .828125,
    y: .140625
}, {
    x: .828125,
    y: .140625
}, {
    x: .859375,
    y: .140625
}, {
    x: .859375,
    y: .140625
}, {
    x: .890625,
    y: .140625
}, {
    x: .890625,
    y: .140625
}, {
    x: .921875,
    y: .140625
}, {
    x: .921875,
    y: .140625
}, {
    x: .953125,
    y: .140625
}, {
    x: .953125,
    y: .140625
}, {
    x: .984375,
    y: .140625
}, {
    x: .984375,
    y: .140625
}, {
    x: .015625,
    y: .171875
}, {
    x: .015625,
    y: .171875
}, {
    x: .046875,
    y: .171875
}, {
    x: .046875,
    y: .171875
}, {
    x: .078125,
    y: .171875
}, {
    x: .078125,
    y: .171875
}, {
    x: .109375,
    y: .171875
}, {
    x: .109375,
    y: .171875
}, {
    x: .140625,
    y: .171875
}, {
    x: .140625,
    y: .171875
}, {
    x: .171875,
    y: .171875
}, {
    x: .171875,
    y: .171875
}, {
    x: .203125,
    y: .171875
}, {
    x: .203125,
    y: .171875
}, {
    x: .234375,
    y: .171875
}, {
    x: .234375,
    y: .171875
}, {
    x: .265625,
    y: .171875
}, {
    x: .265625,
    y: .171875
}, {
    x: .296875,
    y: .171875
}, {
    x: .296875,
    y: .171875
}, {
    x: .328125,
    y: .171875
}, {
    x: .328125,
    y: .171875
}, {
    x: .359375,
    y: .171875
}, {
    x: .359375,
    y: .171875
}, {
    x: .390625,
    y: .171875
}, {
    x: .390625,
    y: .171875
}, {
    x: .421875,
    y: .171875
}, {
    x: .421875,
    y: .171875
}, {
    x: .453125,
    y: .171875
}, {
    x: .453125,
    y: .171875
}, {
    x: .484375,
    y: .171875
}, {
    x: .484375,
    y: .171875
}, {
    x: .515625,
    y: .171875
}, {
    x: .515625,
    y: .171875
}, {
    x: .546875,
    y: .171875
}, {
    x: .546875,
    y: .171875
}, {
    x: .578125,
    y: .171875
}, {
    x: .578125,
    y: .171875
}, {
    x: .609375,
    y: .171875
}, {
    x: .609375,
    y: .171875
}, {
    x: .640625,
    y: .171875
}, {
    x: .640625,
    y: .171875
}, {
    x: .671875,
    y: .171875
}, {
    x: .671875,
    y: .171875
}, {
    x: .703125,
    y: .171875
}, {
    x: .703125,
    y: .171875
}, {
    x: .734375,
    y: .171875
}, {
    x: .734375,
    y: .171875
}, {
    x: .765625,
    y: .171875
}, {
    x: .765625,
    y: .171875
}, {
    x: .796875,
    y: .171875
}, {
    x: .796875,
    y: .171875
}, {
    x: .828125,
    y: .171875
}, {
    x: .828125,
    y: .171875
}, {
    x: .859375,
    y: .171875
}, {
    x: .859375,
    y: .171875
}, {
    x: .890625,
    y: .171875
}, {
    x: .890625,
    y: .171875
}, {
    x: .921875,
    y: .171875
}, {
    x: .921875,
    y: .171875
}, {
    x: .953125,
    y: .171875
}, {
    x: .953125,
    y: .171875
}, {
    x: .984375,
    y: .171875
}, {
    x: .984375,
    y: .171875
}, {
    x: .015625,
    y: .203125
}, {
    x: .015625,
    y: .203125
}, {
    x: .046875,
    y: .203125
}, {
    x: .046875,
    y: .203125
}, {
    x: .078125,
    y: .203125
}, {
    x: .078125,
    y: .203125
}, {
    x: .109375,
    y: .203125
}, {
    x: .109375,
    y: .203125
}, {
    x: .140625,
    y: .203125
}, {
    x: .140625,
    y: .203125
}, {
    x: .171875,
    y: .203125
}, {
    x: .171875,
    y: .203125
}, {
    x: .203125,
    y: .203125
}, {
    x: .203125,
    y: .203125
}, {
    x: .234375,
    y: .203125
}, {
    x: .234375,
    y: .203125
}, {
    x: .265625,
    y: .203125
}, {
    x: .265625,
    y: .203125
}, {
    x: .296875,
    y: .203125
}, {
    x: .296875,
    y: .203125
}, {
    x: .328125,
    y: .203125
}, {
    x: .328125,
    y: .203125
}, {
    x: .359375,
    y: .203125
}, {
    x: .359375,
    y: .203125
}, {
    x: .390625,
    y: .203125
}, {
    x: .390625,
    y: .203125
}, {
    x: .421875,
    y: .203125
}, {
    x: .421875,
    y: .203125
}, {
    x: .453125,
    y: .203125
}, {
    x: .453125,
    y: .203125
}, {
    x: .484375,
    y: .203125
}, {
    x: .484375,
    y: .203125
}, {
    x: .515625,
    y: .203125
}, {
    x: .515625,
    y: .203125
}, {
    x: .546875,
    y: .203125
}, {
    x: .546875,
    y: .203125
}, {
    x: .578125,
    y: .203125
}, {
    x: .578125,
    y: .203125
}, {
    x: .609375,
    y: .203125
}, {
    x: .609375,
    y: .203125
}, {
    x: .640625,
    y: .203125
}, {
    x: .640625,
    y: .203125
}, {
    x: .671875,
    y: .203125
}, {
    x: .671875,
    y: .203125
}, {
    x: .703125,
    y: .203125
}, {
    x: .703125,
    y: .203125
}, {
    x: .734375,
    y: .203125
}, {
    x: .734375,
    y: .203125
}, {
    x: .765625,
    y: .203125
}, {
    x: .765625,
    y: .203125
}, {
    x: .796875,
    y: .203125
}, {
    x: .796875,
    y: .203125
}, {
    x: .828125,
    y: .203125
}, {
    x: .828125,
    y: .203125
}, {
    x: .859375,
    y: .203125
}, {
    x: .859375,
    y: .203125
}, {
    x: .890625,
    y: .203125
}, {
    x: .890625,
    y: .203125
}, {
    x: .921875,
    y: .203125
}, {
    x: .921875,
    y: .203125
}, {
    x: .953125,
    y: .203125
}, {
    x: .953125,
    y: .203125
}, {
    x: .984375,
    y: .203125
}, {
    x: .984375,
    y: .203125
}, {
    x: .015625,
    y: .234375
}, {
    x: .015625,
    y: .234375
}, {
    x: .046875,
    y: .234375
}, {
    x: .046875,
    y: .234375
}, {
    x: .078125,
    y: .234375
}, {
    x: .078125,
    y: .234375
}, {
    x: .109375,
    y: .234375
}, {
    x: .109375,
    y: .234375
}, {
    x: .140625,
    y: .234375
}, {
    x: .140625,
    y: .234375
}, {
    x: .171875,
    y: .234375
}, {
    x: .171875,
    y: .234375
}, {
    x: .203125,
    y: .234375
}, {
    x: .203125,
    y: .234375
}, {
    x: .234375,
    y: .234375
}, {
    x: .234375,
    y: .234375
}, {
    x: .265625,
    y: .234375
}, {
    x: .265625,
    y: .234375
}, {
    x: .296875,
    y: .234375
}, {
    x: .296875,
    y: .234375
}, {
    x: .328125,
    y: .234375
}, {
    x: .328125,
    y: .234375
}, {
    x: .359375,
    y: .234375
}, {
    x: .359375,
    y: .234375
}, {
    x: .390625,
    y: .234375
}, {
    x: .390625,
    y: .234375
}, {
    x: .421875,
    y: .234375
}, {
    x: .421875,
    y: .234375
}, {
    x: .453125,
    y: .234375
}, {
    x: .453125,
    y: .234375
}, {
    x: .484375,
    y: .234375
}, {
    x: .484375,
    y: .234375
}, {
    x: .515625,
    y: .234375
}, {
    x: .515625,
    y: .234375
}, {
    x: .546875,
    y: .234375
}, {
    x: .546875,
    y: .234375
}, {
    x: .578125,
    y: .234375
}, {
    x: .578125,
    y: .234375
}, {
    x: .609375,
    y: .234375
}, {
    x: .609375,
    y: .234375
}, {
    x: .640625,
    y: .234375
}, {
    x: .640625,
    y: .234375
}, {
    x: .671875,
    y: .234375
}, {
    x: .671875,
    y: .234375
}, {
    x: .703125,
    y: .234375
}, {
    x: .703125,
    y: .234375
}, {
    x: .734375,
    y: .234375
}, {
    x: .734375,
    y: .234375
}, {
    x: .765625,
    y: .234375
}, {
    x: .765625,
    y: .234375
}, {
    x: .796875,
    y: .234375
}, {
    x: .796875,
    y: .234375
}, {
    x: .828125,
    y: .234375
}, {
    x: .828125,
    y: .234375
}, {
    x: .859375,
    y: .234375
}, {
    x: .859375,
    y: .234375
}, {
    x: .890625,
    y: .234375
}, {
    x: .890625,
    y: .234375
}, {
    x: .921875,
    y: .234375
}, {
    x: .921875,
    y: .234375
}, {
    x: .953125,
    y: .234375
}, {
    x: .953125,
    y: .234375
}, {
    x: .984375,
    y: .234375
}, {
    x: .984375,
    y: .234375
}, {
    x: .015625,
    y: .265625
}, {
    x: .015625,
    y: .265625
}, {
    x: .046875,
    y: .265625
}, {
    x: .046875,
    y: .265625
}, {
    x: .078125,
    y: .265625
}, {
    x: .078125,
    y: .265625
}, {
    x: .109375,
    y: .265625
}, {
    x: .109375,
    y: .265625
}, {
    x: .140625,
    y: .265625
}, {
    x: .140625,
    y: .265625
}, {
    x: .171875,
    y: .265625
}, {
    x: .171875,
    y: .265625
}, {
    x: .203125,
    y: .265625
}, {
    x: .203125,
    y: .265625
}, {
    x: .234375,
    y: .265625
}, {
    x: .234375,
    y: .265625
}, {
    x: .265625,
    y: .265625
}, {
    x: .265625,
    y: .265625
}, {
    x: .296875,
    y: .265625
}, {
    x: .296875,
    y: .265625
}, {
    x: .328125,
    y: .265625
}, {
    x: .328125,
    y: .265625
}, {
    x: .359375,
    y: .265625
}, {
    x: .359375,
    y: .265625
}, {
    x: .390625,
    y: .265625
}, {
    x: .390625,
    y: .265625
}, {
    x: .421875,
    y: .265625
}, {
    x: .421875,
    y: .265625
}, {
    x: .453125,
    y: .265625
}, {
    x: .453125,
    y: .265625
}, {
    x: .484375,
    y: .265625
}, {
    x: .484375,
    y: .265625
}, {
    x: .515625,
    y: .265625
}, {
    x: .515625,
    y: .265625
}, {
    x: .546875,
    y: .265625
}, {
    x: .546875,
    y: .265625
}, {
    x: .578125,
    y: .265625
}, {
    x: .578125,
    y: .265625
}, {
    x: .609375,
    y: .265625
}, {
    x: .609375,
    y: .265625
}, {
    x: .640625,
    y: .265625
}, {
    x: .640625,
    y: .265625
}, {
    x: .671875,
    y: .265625
}, {
    x: .671875,
    y: .265625
}, {
    x: .703125,
    y: .265625
}, {
    x: .703125,
    y: .265625
}, {
    x: .734375,
    y: .265625
}, {
    x: .734375,
    y: .265625
}, {
    x: .765625,
    y: .265625
}, {
    x: .765625,
    y: .265625
}, {
    x: .796875,
    y: .265625
}, {
    x: .796875,
    y: .265625
}, {
    x: .828125,
    y: .265625
}, {
    x: .828125,
    y: .265625
}, {
    x: .859375,
    y: .265625
}, {
    x: .859375,
    y: .265625
}, {
    x: .890625,
    y: .265625
}, {
    x: .890625,
    y: .265625
}, {
    x: .921875,
    y: .265625
}, {
    x: .921875,
    y: .265625
}, {
    x: .953125,
    y: .265625
}, {
    x: .953125,
    y: .265625
}, {
    x: .984375,
    y: .265625
}, {
    x: .984375,
    y: .265625
}, {
    x: .015625,
    y: .296875
}, {
    x: .015625,
    y: .296875
}, {
    x: .046875,
    y: .296875
}, {
    x: .046875,
    y: .296875
}, {
    x: .078125,
    y: .296875
}, {
    x: .078125,
    y: .296875
}, {
    x: .109375,
    y: .296875
}, {
    x: .109375,
    y: .296875
}, {
    x: .140625,
    y: .296875
}, {
    x: .140625,
    y: .296875
}, {
    x: .171875,
    y: .296875
}, {
    x: .171875,
    y: .296875
}, {
    x: .203125,
    y: .296875
}, {
    x: .203125,
    y: .296875
}, {
    x: .234375,
    y: .296875
}, {
    x: .234375,
    y: .296875
}, {
    x: .265625,
    y: .296875
}, {
    x: .265625,
    y: .296875
}, {
    x: .296875,
    y: .296875
}, {
    x: .296875,
    y: .296875
}, {
    x: .328125,
    y: .296875
}, {
    x: .328125,
    y: .296875
}, {
    x: .359375,
    y: .296875
}, {
    x: .359375,
    y: .296875
}, {
    x: .390625,
    y: .296875
}, {
    x: .390625,
    y: .296875
}, {
    x: .421875,
    y: .296875
}, {
    x: .421875,
    y: .296875
}, {
    x: .453125,
    y: .296875
}, {
    x: .453125,
    y: .296875
}, {
    x: .484375,
    y: .296875
}, {
    x: .484375,
    y: .296875
}, {
    x: .515625,
    y: .296875
}, {
    x: .515625,
    y: .296875
}, {
    x: .546875,
    y: .296875
}, {
    x: .546875,
    y: .296875
}, {
    x: .578125,
    y: .296875
}, {
    x: .578125,
    y: .296875
}, {
    x: .609375,
    y: .296875
}, {
    x: .609375,
    y: .296875
}, {
    x: .640625,
    y: .296875
}, {
    x: .640625,
    y: .296875
}, {
    x: .671875,
    y: .296875
}, {
    x: .671875,
    y: .296875
}, {
    x: .703125,
    y: .296875
}, {
    x: .703125,
    y: .296875
}, {
    x: .734375,
    y: .296875
}, {
    x: .734375,
    y: .296875
}, {
    x: .765625,
    y: .296875
}, {
    x: .765625,
    y: .296875
}, {
    x: .796875,
    y: .296875
}, {
    x: .796875,
    y: .296875
}, {
    x: .828125,
    y: .296875
}, {
    x: .828125,
    y: .296875
}, {
    x: .859375,
    y: .296875
}, {
    x: .859375,
    y: .296875
}, {
    x: .890625,
    y: .296875
}, {
    x: .890625,
    y: .296875
}, {
    x: .921875,
    y: .296875
}, {
    x: .921875,
    y: .296875
}, {
    x: .953125,
    y: .296875
}, {
    x: .953125,
    y: .296875
}, {
    x: .984375,
    y: .296875
}, {
    x: .984375,
    y: .296875
}, {
    x: .015625,
    y: .328125
}, {
    x: .015625,
    y: .328125
}, {
    x: .046875,
    y: .328125
}, {
    x: .046875,
    y: .328125
}, {
    x: .078125,
    y: .328125
}, {
    x: .078125,
    y: .328125
}, {
    x: .109375,
    y: .328125
}, {
    x: .109375,
    y: .328125
}, {
    x: .140625,
    y: .328125
}, {
    x: .140625,
    y: .328125
}, {
    x: .171875,
    y: .328125
}, {
    x: .171875,
    y: .328125
}, {
    x: .203125,
    y: .328125
}, {
    x: .203125,
    y: .328125
}, {
    x: .234375,
    y: .328125
}, {
    x: .234375,
    y: .328125
}, {
    x: .265625,
    y: .328125
}, {
    x: .265625,
    y: .328125
}, {
    x: .296875,
    y: .328125
}, {
    x: .296875,
    y: .328125
}, {
    x: .328125,
    y: .328125
}, {
    x: .328125,
    y: .328125
}, {
    x: .359375,
    y: .328125
}, {
    x: .359375,
    y: .328125
}, {
    x: .390625,
    y: .328125
}, {
    x: .390625,
    y: .328125
}, {
    x: .421875,
    y: .328125
}, {
    x: .421875,
    y: .328125
}, {
    x: .453125,
    y: .328125
}, {
    x: .453125,
    y: .328125
}, {
    x: .484375,
    y: .328125
}, {
    x: .484375,
    y: .328125
}, {
    x: .515625,
    y: .328125
}, {
    x: .515625,
    y: .328125
}, {
    x: .546875,
    y: .328125
}, {
    x: .546875,
    y: .328125
}, {
    x: .578125,
    y: .328125
}, {
    x: .578125,
    y: .328125
}, {
    x: .609375,
    y: .328125
}, {
    x: .609375,
    y: .328125
}, {
    x: .640625,
    y: .328125
}, {
    x: .640625,
    y: .328125
}, {
    x: .671875,
    y: .328125
}, {
    x: .671875,
    y: .328125
}, {
    x: .703125,
    y: .328125
}, {
    x: .703125,
    y: .328125
}, {
    x: .734375,
    y: .328125
}, {
    x: .734375,
    y: .328125
}, {
    x: .765625,
    y: .328125
}, {
    x: .765625,
    y: .328125
}, {
    x: .796875,
    y: .328125
}, {
    x: .796875,
    y: .328125
}, {
    x: .828125,
    y: .328125
}, {
    x: .828125,
    y: .328125
}, {
    x: .859375,
    y: .328125
}, {
    x: .859375,
    y: .328125
}, {
    x: .890625,
    y: .328125
}, {
    x: .890625,
    y: .328125
}, {
    x: .921875,
    y: .328125
}, {
    x: .921875,
    y: .328125
}, {
    x: .953125,
    y: .328125
}, {
    x: .953125,
    y: .328125
}, {
    x: .984375,
    y: .328125
}, {
    x: .984375,
    y: .328125
}, {
    x: .015625,
    y: .359375
}, {
    x: .015625,
    y: .359375
}, {
    x: .046875,
    y: .359375
}, {
    x: .046875,
    y: .359375
}, {
    x: .078125,
    y: .359375
}, {
    x: .078125,
    y: .359375
}, {
    x: .109375,
    y: .359375
}, {
    x: .109375,
    y: .359375
}, {
    x: .140625,
    y: .359375
}, {
    x: .140625,
    y: .359375
}, {
    x: .171875,
    y: .359375
}, {
    x: .171875,
    y: .359375
}, {
    x: .203125,
    y: .359375
}, {
    x: .203125,
    y: .359375
}, {
    x: .234375,
    y: .359375
}, {
    x: .234375,
    y: .359375
}, {
    x: .265625,
    y: .359375
}, {
    x: .265625,
    y: .359375
}, {
    x: .296875,
    y: .359375
}, {
    x: .296875,
    y: .359375
}, {
    x: .328125,
    y: .359375
}, {
    x: .328125,
    y: .359375
}, {
    x: .359375,
    y: .359375
}, {
    x: .359375,
    y: .359375
}, {
    x: .390625,
    y: .359375
}, {
    x: .390625,
    y: .359375
}, {
    x: .421875,
    y: .359375
}, {
    x: .421875,
    y: .359375
}, {
    x: .453125,
    y: .359375
}, {
    x: .453125,
    y: .359375
}, {
    x: .484375,
    y: .359375
}, {
    x: .484375,
    y: .359375
}, {
    x: .515625,
    y: .359375
}, {
    x: .515625,
    y: .359375
}, {
    x: .546875,
    y: .359375
}, {
    x: .546875,
    y: .359375
}, {
    x: .578125,
    y: .359375
}, {
    x: .578125,
    y: .359375
}, {
    x: .609375,
    y: .359375
}, {
    x: .609375,
    y: .359375
}, {
    x: .640625,
    y: .359375
}, {
    x: .640625,
    y: .359375
}, {
    x: .671875,
    y: .359375
}, {
    x: .671875,
    y: .359375
}, {
    x: .703125,
    y: .359375
}, {
    x: .703125,
    y: .359375
}, {
    x: .734375,
    y: .359375
}, {
    x: .734375,
    y: .359375
}, {
    x: .765625,
    y: .359375
}, {
    x: .765625,
    y: .359375
}, {
    x: .796875,
    y: .359375
}, {
    x: .796875,
    y: .359375
}, {
    x: .828125,
    y: .359375
}, {
    x: .828125,
    y: .359375
}, {
    x: .859375,
    y: .359375
}, {
    x: .859375,
    y: .359375
}, {
    x: .890625,
    y: .359375
}, {
    x: .890625,
    y: .359375
}, {
    x: .921875,
    y: .359375
}, {
    x: .921875,
    y: .359375
}, {
    x: .953125,
    y: .359375
}, {
    x: .953125,
    y: .359375
}, {
    x: .984375,
    y: .359375
}, {
    x: .984375,
    y: .359375
}, {
    x: .015625,
    y: .390625
}, {
    x: .015625,
    y: .390625
}, {
    x: .046875,
    y: .390625
}, {
    x: .046875,
    y: .390625
}, {
    x: .078125,
    y: .390625
}, {
    x: .078125,
    y: .390625
}, {
    x: .109375,
    y: .390625
}, {
    x: .109375,
    y: .390625
}, {
    x: .140625,
    y: .390625
}, {
    x: .140625,
    y: .390625
}, {
    x: .171875,
    y: .390625
}, {
    x: .171875,
    y: .390625
}, {
    x: .203125,
    y: .390625
}, {
    x: .203125,
    y: .390625
}, {
    x: .234375,
    y: .390625
}, {
    x: .234375,
    y: .390625
}, {
    x: .265625,
    y: .390625
}, {
    x: .265625,
    y: .390625
}, {
    x: .296875,
    y: .390625
}, {
    x: .296875,
    y: .390625
}, {
    x: .328125,
    y: .390625
}, {
    x: .328125,
    y: .390625
}, {
    x: .359375,
    y: .390625
}, {
    x: .359375,
    y: .390625
}, {
    x: .390625,
    y: .390625
}, {
    x: .390625,
    y: .390625
}, {
    x: .421875,
    y: .390625
}, {
    x: .421875,
    y: .390625
}, {
    x: .453125,
    y: .390625
}, {
    x: .453125,
    y: .390625
}, {
    x: .484375,
    y: .390625
}, {
    x: .484375,
    y: .390625
}, {
    x: .515625,
    y: .390625
}, {
    x: .515625,
    y: .390625
}, {
    x: .546875,
    y: .390625
}, {
    x: .546875,
    y: .390625
}, {
    x: .578125,
    y: .390625
}, {
    x: .578125,
    y: .390625
}, {
    x: .609375,
    y: .390625
}, {
    x: .609375,
    y: .390625
}, {
    x: .640625,
    y: .390625
}, {
    x: .640625,
    y: .390625
}, {
    x: .671875,
    y: .390625
}, {
    x: .671875,
    y: .390625
}, {
    x: .703125,
    y: .390625
}, {
    x: .703125,
    y: .390625
}, {
    x: .734375,
    y: .390625
}, {
    x: .734375,
    y: .390625
}, {
    x: .765625,
    y: .390625
}, {
    x: .765625,
    y: .390625
}, {
    x: .796875,
    y: .390625
}, {
    x: .796875,
    y: .390625
}, {
    x: .828125,
    y: .390625
}, {
    x: .828125,
    y: .390625
}, {
    x: .859375,
    y: .390625
}, {
    x: .859375,
    y: .390625
}, {
    x: .890625,
    y: .390625
}, {
    x: .890625,
    y: .390625
}, {
    x: .921875,
    y: .390625
}, {
    x: .921875,
    y: .390625
}, {
    x: .953125,
    y: .390625
}, {
    x: .953125,
    y: .390625
}, {
    x: .984375,
    y: .390625
}, {
    x: .984375,
    y: .390625
}, {
    x: .015625,
    y: .421875
}, {
    x: .015625,
    y: .421875
}, {
    x: .046875,
    y: .421875
}, {
    x: .046875,
    y: .421875
}, {
    x: .078125,
    y: .421875
}, {
    x: .078125,
    y: .421875
}, {
    x: .109375,
    y: .421875
}, {
    x: .109375,
    y: .421875
}, {
    x: .140625,
    y: .421875
}, {
    x: .140625,
    y: .421875
}, {
    x: .171875,
    y: .421875
}, {
    x: .171875,
    y: .421875
}, {
    x: .203125,
    y: .421875
}, {
    x: .203125,
    y: .421875
}, {
    x: .234375,
    y: .421875
}, {
    x: .234375,
    y: .421875
}, {
    x: .265625,
    y: .421875
}, {
    x: .265625,
    y: .421875
}, {
    x: .296875,
    y: .421875
}, {
    x: .296875,
    y: .421875
}, {
    x: .328125,
    y: .421875
}, {
    x: .328125,
    y: .421875
}, {
    x: .359375,
    y: .421875
}, {
    x: .359375,
    y: .421875
}, {
    x: .390625,
    y: .421875
}, {
    x: .390625,
    y: .421875
}, {
    x: .421875,
    y: .421875
}, {
    x: .421875,
    y: .421875
}, {
    x: .453125,
    y: .421875
}, {
    x: .453125,
    y: .421875
}, {
    x: .484375,
    y: .421875
}, {
    x: .484375,
    y: .421875
}, {
    x: .515625,
    y: .421875
}, {
    x: .515625,
    y: .421875
}, {
    x: .546875,
    y: .421875
}, {
    x: .546875,
    y: .421875
}, {
    x: .578125,
    y: .421875
}, {
    x: .578125,
    y: .421875
}, {
    x: .609375,
    y: .421875
}, {
    x: .609375,
    y: .421875
}, {
    x: .640625,
    y: .421875
}, {
    x: .640625,
    y: .421875
}, {
    x: .671875,
    y: .421875
}, {
    x: .671875,
    y: .421875
}, {
    x: .703125,
    y: .421875
}, {
    x: .703125,
    y: .421875
}, {
    x: .734375,
    y: .421875
}, {
    x: .734375,
    y: .421875
}, {
    x: .765625,
    y: .421875
}, {
    x: .765625,
    y: .421875
}, {
    x: .796875,
    y: .421875
}, {
    x: .796875,
    y: .421875
}, {
    x: .828125,
    y: .421875
}, {
    x: .828125,
    y: .421875
}, {
    x: .859375,
    y: .421875
}, {
    x: .859375,
    y: .421875
}, {
    x: .890625,
    y: .421875
}, {
    x: .890625,
    y: .421875
}, {
    x: .921875,
    y: .421875
}, {
    x: .921875,
    y: .421875
}, {
    x: .953125,
    y: .421875
}, {
    x: .953125,
    y: .421875
}, {
    x: .984375,
    y: .421875
}, {
    x: .984375,
    y: .421875
}, {
    x: .015625,
    y: .453125
}, {
    x: .015625,
    y: .453125
}, {
    x: .046875,
    y: .453125
}, {
    x: .046875,
    y: .453125
}, {
    x: .078125,
    y: .453125
}, {
    x: .078125,
    y: .453125
}, {
    x: .109375,
    y: .453125
}, {
    x: .109375,
    y: .453125
}, {
    x: .140625,
    y: .453125
}, {
    x: .140625,
    y: .453125
}, {
    x: .171875,
    y: .453125
}, {
    x: .171875,
    y: .453125
}, {
    x: .203125,
    y: .453125
}, {
    x: .203125,
    y: .453125
}, {
    x: .234375,
    y: .453125
}, {
    x: .234375,
    y: .453125
}, {
    x: .265625,
    y: .453125
}, {
    x: .265625,
    y: .453125
}, {
    x: .296875,
    y: .453125
}, {
    x: .296875,
    y: .453125
}, {
    x: .328125,
    y: .453125
}, {
    x: .328125,
    y: .453125
}, {
    x: .359375,
    y: .453125
}, {
    x: .359375,
    y: .453125
}, {
    x: .390625,
    y: .453125
}, {
    x: .390625,
    y: .453125
}, {
    x: .421875,
    y: .453125
}, {
    x: .421875,
    y: .453125
}, {
    x: .453125,
    y: .453125
}, {
    x: .453125,
    y: .453125
}, {
    x: .484375,
    y: .453125
}, {
    x: .484375,
    y: .453125
}, {
    x: .515625,
    y: .453125
}, {
    x: .515625,
    y: .453125
}, {
    x: .546875,
    y: .453125
}, {
    x: .546875,
    y: .453125
}, {
    x: .578125,
    y: .453125
}, {
    x: .578125,
    y: .453125
}, {
    x: .609375,
    y: .453125
}, {
    x: .609375,
    y: .453125
}, {
    x: .640625,
    y: .453125
}, {
    x: .640625,
    y: .453125
}, {
    x: .671875,
    y: .453125
}, {
    x: .671875,
    y: .453125
}, {
    x: .703125,
    y: .453125
}, {
    x: .703125,
    y: .453125
}, {
    x: .734375,
    y: .453125
}, {
    x: .734375,
    y: .453125
}, {
    x: .765625,
    y: .453125
}, {
    x: .765625,
    y: .453125
}, {
    x: .796875,
    y: .453125
}, {
    x: .796875,
    y: .453125
}, {
    x: .828125,
    y: .453125
}, {
    x: .828125,
    y: .453125
}, {
    x: .859375,
    y: .453125
}, {
    x: .859375,
    y: .453125
}, {
    x: .890625,
    y: .453125
}, {
    x: .890625,
    y: .453125
}, {
    x: .921875,
    y: .453125
}, {
    x: .921875,
    y: .453125
}, {
    x: .953125,
    y: .453125
}, {
    x: .953125,
    y: .453125
}, {
    x: .984375,
    y: .453125
}, {
    x: .984375,
    y: .453125
}, {
    x: .015625,
    y: .484375
}, {
    x: .015625,
    y: .484375
}, {
    x: .046875,
    y: .484375
}, {
    x: .046875,
    y: .484375
}, {
    x: .078125,
    y: .484375
}, {
    x: .078125,
    y: .484375
}, {
    x: .109375,
    y: .484375
}, {
    x: .109375,
    y: .484375
}, {
    x: .140625,
    y: .484375
}, {
    x: .140625,
    y: .484375
}, {
    x: .171875,
    y: .484375
}, {
    x: .171875,
    y: .484375
}, {
    x: .203125,
    y: .484375
}, {
    x: .203125,
    y: .484375
}, {
    x: .234375,
    y: .484375
}, {
    x: .234375,
    y: .484375
}, {
    x: .265625,
    y: .484375
}, {
    x: .265625,
    y: .484375
}, {
    x: .296875,
    y: .484375
}, {
    x: .296875,
    y: .484375
}, {
    x: .328125,
    y: .484375
}, {
    x: .328125,
    y: .484375
}, {
    x: .359375,
    y: .484375
}, {
    x: .359375,
    y: .484375
}, {
    x: .390625,
    y: .484375
}, {
    x: .390625,
    y: .484375
}, {
    x: .421875,
    y: .484375
}, {
    x: .421875,
    y: .484375
}, {
    x: .453125,
    y: .484375
}, {
    x: .453125,
    y: .484375
}, {
    x: .484375,
    y: .484375
}, {
    x: .484375,
    y: .484375
}, {
    x: .515625,
    y: .484375
}, {
    x: .515625,
    y: .484375
}, {
    x: .546875,
    y: .484375
}, {
    x: .546875,
    y: .484375
}, {
    x: .578125,
    y: .484375
}, {
    x: .578125,
    y: .484375
}, {
    x: .609375,
    y: .484375
}, {
    x: .609375,
    y: .484375
}, {
    x: .640625,
    y: .484375
}, {
    x: .640625,
    y: .484375
}, {
    x: .671875,
    y: .484375
}, {
    x: .671875,
    y: .484375
}, {
    x: .703125,
    y: .484375
}, {
    x: .703125,
    y: .484375
}, {
    x: .734375,
    y: .484375
}, {
    x: .734375,
    y: .484375
}, {
    x: .765625,
    y: .484375
}, {
    x: .765625,
    y: .484375
}, {
    x: .796875,
    y: .484375
}, {
    x: .796875,
    y: .484375
}, {
    x: .828125,
    y: .484375
}, {
    x: .828125,
    y: .484375
}, {
    x: .859375,
    y: .484375
}, {
    x: .859375,
    y: .484375
}, {
    x: .890625,
    y: .484375
}, {
    x: .890625,
    y: .484375
}, {
    x: .921875,
    y: .484375
}, {
    x: .921875,
    y: .484375
}, {
    x: .953125,
    y: .484375
}, {
    x: .953125,
    y: .484375
}, {
    x: .984375,
    y: .484375
}, {
    x: .984375,
    y: .484375
}, {
    x: .015625,
    y: .515625
}, {
    x: .015625,
    y: .515625
}, {
    x: .046875,
    y: .515625
}, {
    x: .046875,
    y: .515625
}, {
    x: .078125,
    y: .515625
}, {
    x: .078125,
    y: .515625
}, {
    x: .109375,
    y: .515625
}, {
    x: .109375,
    y: .515625
}, {
    x: .140625,
    y: .515625
}, {
    x: .140625,
    y: .515625
}, {
    x: .171875,
    y: .515625
}, {
    x: .171875,
    y: .515625
}, {
    x: .203125,
    y: .515625
}, {
    x: .203125,
    y: .515625
}, {
    x: .234375,
    y: .515625
}, {
    x: .234375,
    y: .515625
}, {
    x: .265625,
    y: .515625
}, {
    x: .265625,
    y: .515625
}, {
    x: .296875,
    y: .515625
}, {
    x: .296875,
    y: .515625
}, {
    x: .328125,
    y: .515625
}, {
    x: .328125,
    y: .515625
}, {
    x: .359375,
    y: .515625
}, {
    x: .359375,
    y: .515625
}, {
    x: .390625,
    y: .515625
}, {
    x: .390625,
    y: .515625
}, {
    x: .421875,
    y: .515625
}, {
    x: .421875,
    y: .515625
}, {
    x: .453125,
    y: .515625
}, {
    x: .453125,
    y: .515625
}, {
    x: .484375,
    y: .515625
}, {
    x: .484375,
    y: .515625
}, {
    x: .515625,
    y: .515625
}, {
    x: .515625,
    y: .515625
}, {
    x: .546875,
    y: .515625
}, {
    x: .546875,
    y: .515625
}, {
    x: .578125,
    y: .515625
}, {
    x: .578125,
    y: .515625
}, {
    x: .609375,
    y: .515625
}, {
    x: .609375,
    y: .515625
}, {
    x: .640625,
    y: .515625
}, {
    x: .640625,
    y: .515625
}, {
    x: .671875,
    y: .515625
}, {
    x: .671875,
    y: .515625
}, {
    x: .703125,
    y: .515625
}, {
    x: .703125,
    y: .515625
}, {
    x: .734375,
    y: .515625
}, {
    x: .734375,
    y: .515625
}, {
    x: .765625,
    y: .515625
}, {
    x: .765625,
    y: .515625
}, {
    x: .796875,
    y: .515625
}, {
    x: .796875,
    y: .515625
}, {
    x: .828125,
    y: .515625
}, {
    x: .828125,
    y: .515625
}, {
    x: .859375,
    y: .515625
}, {
    x: .859375,
    y: .515625
}, {
    x: .890625,
    y: .515625
}, {
    x: .890625,
    y: .515625
}, {
    x: .921875,
    y: .515625
}, {
    x: .921875,
    y: .515625
}, {
    x: .953125,
    y: .515625
}, {
    x: .953125,
    y: .515625
}, {
    x: .984375,
    y: .515625
}, {
    x: .984375,
    y: .515625
}, {
    x: .015625,
    y: .546875
}, {
    x: .015625,
    y: .546875
}, {
    x: .046875,
    y: .546875
}, {
    x: .046875,
    y: .546875
}, {
    x: .078125,
    y: .546875
}, {
    x: .078125,
    y: .546875
}, {
    x: .109375,
    y: .546875
}, {
    x: .109375,
    y: .546875
}, {
    x: .140625,
    y: .546875
}, {
    x: .140625,
    y: .546875
}, {
    x: .171875,
    y: .546875
}, {
    x: .171875,
    y: .546875
}, {
    x: .203125,
    y: .546875
}, {
    x: .203125,
    y: .546875
}, {
    x: .234375,
    y: .546875
}, {
    x: .234375,
    y: .546875
}, {
    x: .265625,
    y: .546875
}, {
    x: .265625,
    y: .546875
}, {
    x: .296875,
    y: .546875
}, {
    x: .296875,
    y: .546875
}, {
    x: .328125,
    y: .546875
}, {
    x: .328125,
    y: .546875
}, {
    x: .359375,
    y: .546875
}, {
    x: .359375,
    y: .546875
}, {
    x: .390625,
    y: .546875
}, {
    x: .390625,
    y: .546875
}, {
    x: .421875,
    y: .546875
}, {
    x: .421875,
    y: .546875
}, {
    x: .453125,
    y: .546875
}, {
    x: .453125,
    y: .546875
}, {
    x: .484375,
    y: .546875
}, {
    x: .484375,
    y: .546875
}, {
    x: .515625,
    y: .546875
}, {
    x: .515625,
    y: .546875
}, {
    x: .546875,
    y: .546875
}, {
    x: .546875,
    y: .546875
}, {
    x: .578125,
    y: .546875
}, {
    x: .578125,
    y: .546875
}, {
    x: .609375,
    y: .546875
}, {
    x: .609375,
    y: .546875
}, {
    x: .640625,
    y: .546875
}, {
    x: .640625,
    y: .546875
}, {
    x: .671875,
    y: .546875
}, {
    x: .671875,
    y: .546875
}, {
    x: .703125,
    y: .546875
}, {
    x: .703125,
    y: .546875
}, {
    x: .734375,
    y: .546875
}, {
    x: .734375,
    y: .546875
}, {
    x: .765625,
    y: .546875
}, {
    x: .765625,
    y: .546875
}, {
    x: .796875,
    y: .546875
}, {
    x: .796875,
    y: .546875
}, {
    x: .828125,
    y: .546875
}, {
    x: .828125,
    y: .546875
}, {
    x: .859375,
    y: .546875
}, {
    x: .859375,
    y: .546875
}, {
    x: .890625,
    y: .546875
}, {
    x: .890625,
    y: .546875
}, {
    x: .921875,
    y: .546875
}, {
    x: .921875,
    y: .546875
}, {
    x: .953125,
    y: .546875
}, {
    x: .953125,
    y: .546875
}, {
    x: .984375,
    y: .546875
}, {
    x: .984375,
    y: .546875
}, {
    x: .015625,
    y: .578125
}, {
    x: .015625,
    y: .578125
}, {
    x: .046875,
    y: .578125
}, {
    x: .046875,
    y: .578125
}, {
    x: .078125,
    y: .578125
}, {
    x: .078125,
    y: .578125
}, {
    x: .109375,
    y: .578125
}, {
    x: .109375,
    y: .578125
}, {
    x: .140625,
    y: .578125
}, {
    x: .140625,
    y: .578125
}, {
    x: .171875,
    y: .578125
}, {
    x: .171875,
    y: .578125
}, {
    x: .203125,
    y: .578125
}, {
    x: .203125,
    y: .578125
}, {
    x: .234375,
    y: .578125
}, {
    x: .234375,
    y: .578125
}, {
    x: .265625,
    y: .578125
}, {
    x: .265625,
    y: .578125
}, {
    x: .296875,
    y: .578125
}, {
    x: .296875,
    y: .578125
}, {
    x: .328125,
    y: .578125
}, {
    x: .328125,
    y: .578125
}, {
    x: .359375,
    y: .578125
}, {
    x: .359375,
    y: .578125
}, {
    x: .390625,
    y: .578125
}, {
    x: .390625,
    y: .578125
}, {
    x: .421875,
    y: .578125
}, {
    x: .421875,
    y: .578125
}, {
    x: .453125,
    y: .578125
}, {
    x: .453125,
    y: .578125
}, {
    x: .484375,
    y: .578125
}, {
    x: .484375,
    y: .578125
}, {
    x: .515625,
    y: .578125
}, {
    x: .515625,
    y: .578125
}, {
    x: .546875,
    y: .578125
}, {
    x: .546875,
    y: .578125
}, {
    x: .578125,
    y: .578125
}, {
    x: .578125,
    y: .578125
}, {
    x: .609375,
    y: .578125
}, {
    x: .609375,
    y: .578125
}, {
    x: .640625,
    y: .578125
}, {
    x: .640625,
    y: .578125
}, {
    x: .671875,
    y: .578125
}, {
    x: .671875,
    y: .578125
}, {
    x: .703125,
    y: .578125
}, {
    x: .703125,
    y: .578125
}, {
    x: .734375,
    y: .578125
}, {
    x: .734375,
    y: .578125
}, {
    x: .765625,
    y: .578125
}, {
    x: .765625,
    y: .578125
}, {
    x: .796875,
    y: .578125
}, {
    x: .796875,
    y: .578125
}, {
    x: .828125,
    y: .578125
}, {
    x: .828125,
    y: .578125
}, {
    x: .859375,
    y: .578125
}, {
    x: .859375,
    y: .578125
}, {
    x: .890625,
    y: .578125
}, {
    x: .890625,
    y: .578125
}, {
    x: .921875,
    y: .578125
}, {
    x: .921875,
    y: .578125
}, {
    x: .953125,
    y: .578125
}, {
    x: .953125,
    y: .578125
}, {
    x: .984375,
    y: .578125
}, {
    x: .984375,
    y: .578125
}, {
    x: .015625,
    y: .609375
}, {
    x: .015625,
    y: .609375
}, {
    x: .046875,
    y: .609375
}, {
    x: .046875,
    y: .609375
}, {
    x: .078125,
    y: .609375
}, {
    x: .078125,
    y: .609375
}, {
    x: .109375,
    y: .609375
}, {
    x: .109375,
    y: .609375
}, {
    x: .140625,
    y: .609375
}, {
    x: .140625,
    y: .609375
}, {
    x: .171875,
    y: .609375
}, {
    x: .171875,
    y: .609375
}, {
    x: .203125,
    y: .609375
}, {
    x: .203125,
    y: .609375
}, {
    x: .234375,
    y: .609375
}, {
    x: .234375,
    y: .609375
}, {
    x: .265625,
    y: .609375
}, {
    x: .265625,
    y: .609375
}, {
    x: .296875,
    y: .609375
}, {
    x: .296875,
    y: .609375
}, {
    x: .328125,
    y: .609375
}, {
    x: .328125,
    y: .609375
}, {
    x: .359375,
    y: .609375
}, {
    x: .359375,
    y: .609375
}, {
    x: .390625,
    y: .609375
}, {
    x: .390625,
    y: .609375
}, {
    x: .421875,
    y: .609375
}, {
    x: .421875,
    y: .609375
}, {
    x: .453125,
    y: .609375
}, {
    x: .453125,
    y: .609375
}, {
    x: .484375,
    y: .609375
}, {
    x: .484375,
    y: .609375
}, {
    x: .515625,
    y: .609375
}, {
    x: .515625,
    y: .609375
}, {
    x: .546875,
    y: .609375
}, {
    x: .546875,
    y: .609375
}, {
    x: .578125,
    y: .609375
}, {
    x: .578125,
    y: .609375
}, {
    x: .609375,
    y: .609375
}, {
    x: .609375,
    y: .609375
}, {
    x: .640625,
    y: .609375
}, {
    x: .640625,
    y: .609375
}, {
    x: .671875,
    y: .609375
}, {
    x: .671875,
    y: .609375
}, {
    x: .703125,
    y: .609375
}, {
    x: .703125,
    y: .609375
}, {
    x: .734375,
    y: .609375
}, {
    x: .734375,
    y: .609375
}, {
    x: .765625,
    y: .609375
}, {
    x: .765625,
    y: .609375
}, {
    x: .796875,
    y: .609375
}, {
    x: .796875,
    y: .609375
}, {
    x: .828125,
    y: .609375
}, {
    x: .828125,
    y: .609375
}, {
    x: .859375,
    y: .609375
}, {
    x: .859375,
    y: .609375
}, {
    x: .890625,
    y: .609375
}, {
    x: .890625,
    y: .609375
}, {
    x: .921875,
    y: .609375
}, {
    x: .921875,
    y: .609375
}, {
    x: .953125,
    y: .609375
}, {
    x: .953125,
    y: .609375
}, {
    x: .984375,
    y: .609375
}, {
    x: .984375,
    y: .609375
}, {
    x: .015625,
    y: .640625
}, {
    x: .015625,
    y: .640625
}, {
    x: .046875,
    y: .640625
}, {
    x: .046875,
    y: .640625
}, {
    x: .078125,
    y: .640625
}, {
    x: .078125,
    y: .640625
}, {
    x: .109375,
    y: .640625
}, {
    x: .109375,
    y: .640625
}, {
    x: .140625,
    y: .640625
}, {
    x: .140625,
    y: .640625
}, {
    x: .171875,
    y: .640625
}, {
    x: .171875,
    y: .640625
}, {
    x: .203125,
    y: .640625
}, {
    x: .203125,
    y: .640625
}, {
    x: .234375,
    y: .640625
}, {
    x: .234375,
    y: .640625
}, {
    x: .265625,
    y: .640625
}, {
    x: .265625,
    y: .640625
}, {
    x: .296875,
    y: .640625
}, {
    x: .296875,
    y: .640625
}, {
    x: .328125,
    y: .640625
}, {
    x: .328125,
    y: .640625
}, {
    x: .359375,
    y: .640625
}, {
    x: .359375,
    y: .640625
}, {
    x: .390625,
    y: .640625
}, {
    x: .390625,
    y: .640625
}, {
    x: .421875,
    y: .640625
}, {
    x: .421875,
    y: .640625
}, {
    x: .453125,
    y: .640625
}, {
    x: .453125,
    y: .640625
}, {
    x: .484375,
    y: .640625
}, {
    x: .484375,
    y: .640625
}, {
    x: .515625,
    y: .640625
}, {
    x: .515625,
    y: .640625
}, {
    x: .546875,
    y: .640625
}, {
    x: .546875,
    y: .640625
}, {
    x: .578125,
    y: .640625
}, {
    x: .578125,
    y: .640625
}, {
    x: .609375,
    y: .640625
}, {
    x: .609375,
    y: .640625
}, {
    x: .640625,
    y: .640625
}, {
    x: .640625,
    y: .640625
}, {
    x: .671875,
    y: .640625
}, {
    x: .671875,
    y: .640625
}, {
    x: .703125,
    y: .640625
}, {
    x: .703125,
    y: .640625
}, {
    x: .734375,
    y: .640625
}, {
    x: .734375,
    y: .640625
}, {
    x: .765625,
    y: .640625
}, {
    x: .765625,
    y: .640625
}, {
    x: .796875,
    y: .640625
}, {
    x: .796875,
    y: .640625
}, {
    x: .828125,
    y: .640625
}, {
    x: .828125,
    y: .640625
}, {
    x: .859375,
    y: .640625
}, {
    x: .859375,
    y: .640625
}, {
    x: .890625,
    y: .640625
}, {
    x: .890625,
    y: .640625
}, {
    x: .921875,
    y: .640625
}, {
    x: .921875,
    y: .640625
}, {
    x: .953125,
    y: .640625
}, {
    x: .953125,
    y: .640625
}, {
    x: .984375,
    y: .640625
}, {
    x: .984375,
    y: .640625
}, {
    x: .015625,
    y: .671875
}, {
    x: .015625,
    y: .671875
}, {
    x: .046875,
    y: .671875
}, {
    x: .046875,
    y: .671875
}, {
    x: .078125,
    y: .671875
}, {
    x: .078125,
    y: .671875
}, {
    x: .109375,
    y: .671875
}, {
    x: .109375,
    y: .671875
}, {
    x: .140625,
    y: .671875
}, {
    x: .140625,
    y: .671875
}, {
    x: .171875,
    y: .671875
}, {
    x: .171875,
    y: .671875
}, {
    x: .203125,
    y: .671875
}, {
    x: .203125,
    y: .671875
}, {
    x: .234375,
    y: .671875
}, {
    x: .234375,
    y: .671875
}, {
    x: .265625,
    y: .671875
}, {
    x: .265625,
    y: .671875
}, {
    x: .296875,
    y: .671875
}, {
    x: .296875,
    y: .671875
}, {
    x: .328125,
    y: .671875
}, {
    x: .328125,
    y: .671875
}, {
    x: .359375,
    y: .671875
}, {
    x: .359375,
    y: .671875
}, {
    x: .390625,
    y: .671875
}, {
    x: .390625,
    y: .671875
}, {
    x: .421875,
    y: .671875
}, {
    x: .421875,
    y: .671875
}, {
    x: .453125,
    y: .671875
}, {
    x: .453125,
    y: .671875
}, {
    x: .484375,
    y: .671875
}, {
    x: .484375,
    y: .671875
}, {
    x: .515625,
    y: .671875
}, {
    x: .515625,
    y: .671875
}, {
    x: .546875,
    y: .671875
}, {
    x: .546875,
    y: .671875
}, {
    x: .578125,
    y: .671875
}, {
    x: .578125,
    y: .671875
}, {
    x: .609375,
    y: .671875
}, {
    x: .609375,
    y: .671875
}, {
    x: .640625,
    y: .671875
}, {
    x: .640625,
    y: .671875
}, {
    x: .671875,
    y: .671875
}, {
    x: .671875,
    y: .671875
}, {
    x: .703125,
    y: .671875
}, {
    x: .703125,
    y: .671875
}, {
    x: .734375,
    y: .671875
}, {
    x: .734375,
    y: .671875
}, {
    x: .765625,
    y: .671875
}, {
    x: .765625,
    y: .671875
}, {
    x: .796875,
    y: .671875
}, {
    x: .796875,
    y: .671875
}, {
    x: .828125,
    y: .671875
}, {
    x: .828125,
    y: .671875
}, {
    x: .859375,
    y: .671875
}, {
    x: .859375,
    y: .671875
}, {
    x: .890625,
    y: .671875
}, {
    x: .890625,
    y: .671875
}, {
    x: .921875,
    y: .671875
}, {
    x: .921875,
    y: .671875
}, {
    x: .953125,
    y: .671875
}, {
    x: .953125,
    y: .671875
}, {
    x: .984375,
    y: .671875
}, {
    x: .984375,
    y: .671875
}, {
    x: .015625,
    y: .703125
}, {
    x: .015625,
    y: .703125
}, {
    x: .046875,
    y: .703125
}, {
    x: .046875,
    y: .703125
}, {
    x: .078125,
    y: .703125
}, {
    x: .078125,
    y: .703125
}, {
    x: .109375,
    y: .703125
}, {
    x: .109375,
    y: .703125
}, {
    x: .140625,
    y: .703125
}, {
    x: .140625,
    y: .703125
}, {
    x: .171875,
    y: .703125
}, {
    x: .171875,
    y: .703125
}, {
    x: .203125,
    y: .703125
}, {
    x: .203125,
    y: .703125
}, {
    x: .234375,
    y: .703125
}, {
    x: .234375,
    y: .703125
}, {
    x: .265625,
    y: .703125
}, {
    x: .265625,
    y: .703125
}, {
    x: .296875,
    y: .703125
}, {
    x: .296875,
    y: .703125
}, {
    x: .328125,
    y: .703125
}, {
    x: .328125,
    y: .703125
}, {
    x: .359375,
    y: .703125
}, {
    x: .359375,
    y: .703125
}, {
    x: .390625,
    y: .703125
}, {
    x: .390625,
    y: .703125
}, {
    x: .421875,
    y: .703125
}, {
    x: .421875,
    y: .703125
}, {
    x: .453125,
    y: .703125
}, {
    x: .453125,
    y: .703125
}, {
    x: .484375,
    y: .703125
}, {
    x: .484375,
    y: .703125
}, {
    x: .515625,
    y: .703125
}, {
    x: .515625,
    y: .703125
}, {
    x: .546875,
    y: .703125
}, {
    x: .546875,
    y: .703125
}, {
    x: .578125,
    y: .703125
}, {
    x: .578125,
    y: .703125
}, {
    x: .609375,
    y: .703125
}, {
    x: .609375,
    y: .703125
}, {
    x: .640625,
    y: .703125
}, {
    x: .640625,
    y: .703125
}, {
    x: .671875,
    y: .703125
}, {
    x: .671875,
    y: .703125
}, {
    x: .703125,
    y: .703125
}, {
    x: .703125,
    y: .703125
}, {
    x: .734375,
    y: .703125
}, {
    x: .734375,
    y: .703125
}, {
    x: .765625,
    y: .703125
}, {
    x: .765625,
    y: .703125
}, {
    x: .796875,
    y: .703125
}, {
    x: .796875,
    y: .703125
}, {
    x: .828125,
    y: .703125
}, {
    x: .828125,
    y: .703125
}, {
    x: .859375,
    y: .703125
}, {
    x: .859375,
    y: .703125
}, {
    x: .890625,
    y: .703125
}, {
    x: .890625,
    y: .703125
}, {
    x: .921875,
    y: .703125
}, {
    x: .921875,
    y: .703125
}, {
    x: .953125,
    y: .703125
}, {
    x: .953125,
    y: .703125
}, {
    x: .984375,
    y: .703125
}, {
    x: .984375,
    y: .703125
}, {
    x: .015625,
    y: .734375
}, {
    x: .015625,
    y: .734375
}, {
    x: .046875,
    y: .734375
}, {
    x: .046875,
    y: .734375
}, {
    x: .078125,
    y: .734375
}, {
    x: .078125,
    y: .734375
}, {
    x: .109375,
    y: .734375
}, {
    x: .109375,
    y: .734375
}, {
    x: .140625,
    y: .734375
}, {
    x: .140625,
    y: .734375
}, {
    x: .171875,
    y: .734375
}, {
    x: .171875,
    y: .734375
}, {
    x: .203125,
    y: .734375
}, {
    x: .203125,
    y: .734375
}, {
    x: .234375,
    y: .734375
}, {
    x: .234375,
    y: .734375
}, {
    x: .265625,
    y: .734375
}, {
    x: .265625,
    y: .734375
}, {
    x: .296875,
    y: .734375
}, {
    x: .296875,
    y: .734375
}, {
    x: .328125,
    y: .734375
}, {
    x: .328125,
    y: .734375
}, {
    x: .359375,
    y: .734375
}, {
    x: .359375,
    y: .734375
}, {
    x: .390625,
    y: .734375
}, {
    x: .390625,
    y: .734375
}, {
    x: .421875,
    y: .734375
}, {
    x: .421875,
    y: .734375
}, {
    x: .453125,
    y: .734375
}, {
    x: .453125,
    y: .734375
}, {
    x: .484375,
    y: .734375
}, {
    x: .484375,
    y: .734375
}, {
    x: .515625,
    y: .734375
}, {
    x: .515625,
    y: .734375
}, {
    x: .546875,
    y: .734375
}, {
    x: .546875,
    y: .734375
}, {
    x: .578125,
    y: .734375
}, {
    x: .578125,
    y: .734375
}, {
    x: .609375,
    y: .734375
}, {
    x: .609375,
    y: .734375
}, {
    x: .640625,
    y: .734375
}, {
    x: .640625,
    y: .734375
}, {
    x: .671875,
    y: .734375
}, {
    x: .671875,
    y: .734375
}, {
    x: .703125,
    y: .734375
}, {
    x: .703125,
    y: .734375
}, {
    x: .734375,
    y: .734375
}, {
    x: .734375,
    y: .734375
}, {
    x: .765625,
    y: .734375
}, {
    x: .765625,
    y: .734375
}, {
    x: .796875,
    y: .734375
}, {
    x: .796875,
    y: .734375
}, {
    x: .828125,
    y: .734375
}, {
    x: .828125,
    y: .734375
}, {
    x: .859375,
    y: .734375
}, {
    x: .859375,
    y: .734375
}, {
    x: .890625,
    y: .734375
}, {
    x: .890625,
    y: .734375
}, {
    x: .921875,
    y: .734375
}, {
    x: .921875,
    y: .734375
}, {
    x: .953125,
    y: .734375
}, {
    x: .953125,
    y: .734375
}, {
    x: .984375,
    y: .734375
}, {
    x: .984375,
    y: .734375
}, {
    x: .015625,
    y: .765625
}, {
    x: .015625,
    y: .765625
}, {
    x: .046875,
    y: .765625
}, {
    x: .046875,
    y: .765625
}, {
    x: .078125,
    y: .765625
}, {
    x: .078125,
    y: .765625
}, {
    x: .109375,
    y: .765625
}, {
    x: .109375,
    y: .765625
}, {
    x: .140625,
    y: .765625
}, {
    x: .140625,
    y: .765625
}, {
    x: .171875,
    y: .765625
}, {
    x: .171875,
    y: .765625
}, {
    x: .203125,
    y: .765625
}, {
    x: .203125,
    y: .765625
}, {
    x: .234375,
    y: .765625
}, {
    x: .234375,
    y: .765625
}, {
    x: .265625,
    y: .765625
}, {
    x: .265625,
    y: .765625
}, {
    x: .296875,
    y: .765625
}, {
    x: .296875,
    y: .765625
}, {
    x: .328125,
    y: .765625
}, {
    x: .328125,
    y: .765625
}, {
    x: .359375,
    y: .765625
}, {
    x: .359375,
    y: .765625
}, {
    x: .390625,
    y: .765625
}, {
    x: .390625,
    y: .765625
}, {
    x: .421875,
    y: .765625
}, {
    x: .421875,
    y: .765625
}, {
    x: .453125,
    y: .765625
}, {
    x: .453125,
    y: .765625
}, {
    x: .484375,
    y: .765625
}, {
    x: .484375,
    y: .765625
}, {
    x: .515625,
    y: .765625
}, {
    x: .515625,
    y: .765625
}, {
    x: .546875,
    y: .765625
}, {
    x: .546875,
    y: .765625
}, {
    x: .578125,
    y: .765625
}, {
    x: .578125,
    y: .765625
}, {
    x: .609375,
    y: .765625
}, {
    x: .609375,
    y: .765625
}, {
    x: .640625,
    y: .765625
}, {
    x: .640625,
    y: .765625
}, {
    x: .671875,
    y: .765625
}, {
    x: .671875,
    y: .765625
}, {
    x: .703125,
    y: .765625
}, {
    x: .703125,
    y: .765625
}, {
    x: .734375,
    y: .765625
}, {
    x: .734375,
    y: .765625
}, {
    x: .765625,
    y: .765625
}, {
    x: .765625,
    y: .765625
}, {
    x: .796875,
    y: .765625
}, {
    x: .796875,
    y: .765625
}, {
    x: .828125,
    y: .765625
}, {
    x: .828125,
    y: .765625
}, {
    x: .859375,
    y: .765625
}, {
    x: .859375,
    y: .765625
}, {
    x: .890625,
    y: .765625
}, {
    x: .890625,
    y: .765625
}, {
    x: .921875,
    y: .765625
}, {
    x: .921875,
    y: .765625
}, {
    x: .953125,
    y: .765625
}, {
    x: .953125,
    y: .765625
}, {
    x: .984375,
    y: .765625
}, {
    x: .984375,
    y: .765625
}, {
    x: .015625,
    y: .796875
}, {
    x: .015625,
    y: .796875
}, {
    x: .046875,
    y: .796875
}, {
    x: .046875,
    y: .796875
}, {
    x: .078125,
    y: .796875
}, {
    x: .078125,
    y: .796875
}, {
    x: .109375,
    y: .796875
}, {
    x: .109375,
    y: .796875
}, {
    x: .140625,
    y: .796875
}, {
    x: .140625,
    y: .796875
}, {
    x: .171875,
    y: .796875
}, {
    x: .171875,
    y: .796875
}, {
    x: .203125,
    y: .796875
}, {
    x: .203125,
    y: .796875
}, {
    x: .234375,
    y: .796875
}, {
    x: .234375,
    y: .796875
}, {
    x: .265625,
    y: .796875
}, {
    x: .265625,
    y: .796875
}, {
    x: .296875,
    y: .796875
}, {
    x: .296875,
    y: .796875
}, {
    x: .328125,
    y: .796875
}, {
    x: .328125,
    y: .796875
}, {
    x: .359375,
    y: .796875
}, {
    x: .359375,
    y: .796875
}, {
    x: .390625,
    y: .796875
}, {
    x: .390625,
    y: .796875
}, {
    x: .421875,
    y: .796875
}, {
    x: .421875,
    y: .796875
}, {
    x: .453125,
    y: .796875
}, {
    x: .453125,
    y: .796875
}, {
    x: .484375,
    y: .796875
}, {
    x: .484375,
    y: .796875
}, {
    x: .515625,
    y: .796875
}, {
    x: .515625,
    y: .796875
}, {
    x: .546875,
    y: .796875
}, {
    x: .546875,
    y: .796875
}, {
    x: .578125,
    y: .796875
}, {
    x: .578125,
    y: .796875
}, {
    x: .609375,
    y: .796875
}, {
    x: .609375,
    y: .796875
}, {
    x: .640625,
    y: .796875
}, {
    x: .640625,
    y: .796875
}, {
    x: .671875,
    y: .796875
}, {
    x: .671875,
    y: .796875
}, {
    x: .703125,
    y: .796875
}, {
    x: .703125,
    y: .796875
}, {
    x: .734375,
    y: .796875
}, {
    x: .734375,
    y: .796875
}, {
    x: .765625,
    y: .796875
}, {
    x: .765625,
    y: .796875
}, {
    x: .796875,
    y: .796875
}, {
    x: .796875,
    y: .796875
}, {
    x: .828125,
    y: .796875
}, {
    x: .828125,
    y: .796875
}, {
    x: .859375,
    y: .796875
}, {
    x: .859375,
    y: .796875
}, {
    x: .890625,
    y: .796875
}, {
    x: .890625,
    y: .796875
}, {
    x: .921875,
    y: .796875
}, {
    x: .921875,
    y: .796875
}, {
    x: .953125,
    y: .796875
}, {
    x: .953125,
    y: .796875
}, {
    x: .984375,
    y: .796875
}, {
    x: .984375,
    y: .796875
}, {
    x: .015625,
    y: .828125
}, {
    x: .015625,
    y: .828125
}, {
    x: .046875,
    y: .828125
}, {
    x: .046875,
    y: .828125
}, {
    x: .078125,
    y: .828125
}, {
    x: .078125,
    y: .828125
}, {
    x: .109375,
    y: .828125
}, {
    x: .109375,
    y: .828125
}, {
    x: .140625,
    y: .828125
}, {
    x: .140625,
    y: .828125
}, {
    x: .171875,
    y: .828125
}, {
    x: .171875,
    y: .828125
}, {
    x: .203125,
    y: .828125
}, {
    x: .203125,
    y: .828125
}, {
    x: .234375,
    y: .828125
}, {
    x: .234375,
    y: .828125
}, {
    x: .265625,
    y: .828125
}, {
    x: .265625,
    y: .828125
}, {
    x: .296875,
    y: .828125
}, {
    x: .296875,
    y: .828125
}, {
    x: .328125,
    y: .828125
}, {
    x: .328125,
    y: .828125
}, {
    x: .359375,
    y: .828125
}, {
    x: .359375,
    y: .828125
}, {
    x: .390625,
    y: .828125
}, {
    x: .390625,
    y: .828125
}, {
    x: .421875,
    y: .828125
}, {
    x: .421875,
    y: .828125
}, {
    x: .453125,
    y: .828125
}, {
    x: .453125,
    y: .828125
}, {
    x: .484375,
    y: .828125
}, {
    x: .484375,
    y: .828125
}, {
    x: .515625,
    y: .828125
}, {
    x: .515625,
    y: .828125
}, {
    x: .546875,
    y: .828125
}, {
    x: .546875,
    y: .828125
}, {
    x: .578125,
    y: .828125
}, {
    x: .578125,
    y: .828125
}, {
    x: .609375,
    y: .828125
}, {
    x: .609375,
    y: .828125
}, {
    x: .640625,
    y: .828125
}, {
    x: .640625,
    y: .828125
}, {
    x: .671875,
    y: .828125
}, {
    x: .671875,
    y: .828125
}, {
    x: .703125,
    y: .828125
}, {
    x: .703125,
    y: .828125
}, {
    x: .734375,
    y: .828125
}, {
    x: .734375,
    y: .828125
}, {
    x: .765625,
    y: .828125
}, {
    x: .765625,
    y: .828125
}, {
    x: .796875,
    y: .828125
}, {
    x: .796875,
    y: .828125
}, {
    x: .828125,
    y: .828125
}, {
    x: .828125,
    y: .828125
}, {
    x: .859375,
    y: .828125
}, {
    x: .859375,
    y: .828125
}, {
    x: .890625,
    y: .828125
}, {
    x: .890625,
    y: .828125
}, {
    x: .921875,
    y: .828125
}, {
    x: .921875,
    y: .828125
}, {
    x: .953125,
    y: .828125
}, {
    x: .953125,
    y: .828125
}, {
    x: .984375,
    y: .828125
}, {
    x: .984375,
    y: .828125
}, {
    x: .015625,
    y: .859375
}, {
    x: .015625,
    y: .859375
}, {
    x: .046875,
    y: .859375
}, {
    x: .046875,
    y: .859375
}, {
    x: .078125,
    y: .859375
}, {
    x: .078125,
    y: .859375
}, {
    x: .109375,
    y: .859375
}, {
    x: .109375,
    y: .859375
}, {
    x: .140625,
    y: .859375
}, {
    x: .140625,
    y: .859375
}, {
    x: .171875,
    y: .859375
}, {
    x: .171875,
    y: .859375
}, {
    x: .203125,
    y: .859375
}, {
    x: .203125,
    y: .859375
}, {
    x: .234375,
    y: .859375
}, {
    x: .234375,
    y: .859375
}, {
    x: .265625,
    y: .859375
}, {
    x: .265625,
    y: .859375
}, {
    x: .296875,
    y: .859375
}, {
    x: .296875,
    y: .859375
}, {
    x: .328125,
    y: .859375
}, {
    x: .328125,
    y: .859375
}, {
    x: .359375,
    y: .859375
}, {
    x: .359375,
    y: .859375
}, {
    x: .390625,
    y: .859375
}, {
    x: .390625,
    y: .859375
}, {
    x: .421875,
    y: .859375
}, {
    x: .421875,
    y: .859375
}, {
    x: .453125,
    y: .859375
}, {
    x: .453125,
    y: .859375
}, {
    x: .484375,
    y: .859375
}, {
    x: .484375,
    y: .859375
}, {
    x: .515625,
    y: .859375
}, {
    x: .515625,
    y: .859375
}, {
    x: .546875,
    y: .859375
}, {
    x: .546875,
    y: .859375
}, {
    x: .578125,
    y: .859375
}, {
    x: .578125,
    y: .859375
}, {
    x: .609375,
    y: .859375
}, {
    x: .609375,
    y: .859375
}, {
    x: .640625,
    y: .859375
}, {
    x: .640625,
    y: .859375
}, {
    x: .671875,
    y: .859375
}, {
    x: .671875,
    y: .859375
}, {
    x: .703125,
    y: .859375
}, {
    x: .703125,
    y: .859375
}, {
    x: .734375,
    y: .859375
}, {
    x: .734375,
    y: .859375
}, {
    x: .765625,
    y: .859375
}, {
    x: .765625,
    y: .859375
}, {
    x: .796875,
    y: .859375
}, {
    x: .796875,
    y: .859375
}, {
    x: .828125,
    y: .859375
}, {
    x: .828125,
    y: .859375
}, {
    x: .859375,
    y: .859375
}, {
    x: .859375,
    y: .859375
}, {
    x: .890625,
    y: .859375
}, {
    x: .890625,
    y: .859375
}, {
    x: .921875,
    y: .859375
}, {
    x: .921875,
    y: .859375
}, {
    x: .953125,
    y: .859375
}, {
    x: .953125,
    y: .859375
}, {
    x: .984375,
    y: .859375
}, {
    x: .984375,
    y: .859375
}, {
    x: .015625,
    y: .890625
}, {
    x: .015625,
    y: .890625
}, {
    x: .046875,
    y: .890625
}, {
    x: .046875,
    y: .890625
}, {
    x: .078125,
    y: .890625
}, {
    x: .078125,
    y: .890625
}, {
    x: .109375,
    y: .890625
}, {
    x: .109375,
    y: .890625
}, {
    x: .140625,
    y: .890625
}, {
    x: .140625,
    y: .890625
}, {
    x: .171875,
    y: .890625
}, {
    x: .171875,
    y: .890625
}, {
    x: .203125,
    y: .890625
}, {
    x: .203125,
    y: .890625
}, {
    x: .234375,
    y: .890625
}, {
    x: .234375,
    y: .890625
}, {
    x: .265625,
    y: .890625
}, {
    x: .265625,
    y: .890625
}, {
    x: .296875,
    y: .890625
}, {
    x: .296875,
    y: .890625
}, {
    x: .328125,
    y: .890625
}, {
    x: .328125,
    y: .890625
}, {
    x: .359375,
    y: .890625
}, {
    x: .359375,
    y: .890625
}, {
    x: .390625,
    y: .890625
}, {
    x: .390625,
    y: .890625
}, {
    x: .421875,
    y: .890625
}, {
    x: .421875,
    y: .890625
}, {
    x: .453125,
    y: .890625
}, {
    x: .453125,
    y: .890625
}, {
    x: .484375,
    y: .890625
}, {
    x: .484375,
    y: .890625
}, {
    x: .515625,
    y: .890625
}, {
    x: .515625,
    y: .890625
}, {
    x: .546875,
    y: .890625
}, {
    x: .546875,
    y: .890625
}, {
    x: .578125,
    y: .890625
}, {
    x: .578125,
    y: .890625
}, {
    x: .609375,
    y: .890625
}, {
    x: .609375,
    y: .890625
}, {
    x: .640625,
    y: .890625
}, {
    x: .640625,
    y: .890625
}, {
    x: .671875,
    y: .890625
}, {
    x: .671875,
    y: .890625
}, {
    x: .703125,
    y: .890625
}, {
    x: .703125,
    y: .890625
}, {
    x: .734375,
    y: .890625
}, {
    x: .734375,
    y: .890625
}, {
    x: .765625,
    y: .890625
}, {
    x: .765625,
    y: .890625
}, {
    x: .796875,
    y: .890625
}, {
    x: .796875,
    y: .890625
}, {
    x: .828125,
    y: .890625
}, {
    x: .828125,
    y: .890625
}, {
    x: .859375,
    y: .890625
}, {
    x: .859375,
    y: .890625
}, {
    x: .890625,
    y: .890625
}, {
    x: .890625,
    y: .890625
}, {
    x: .921875,
    y: .890625
}, {
    x: .921875,
    y: .890625
}, {
    x: .953125,
    y: .890625
}, {
    x: .953125,
    y: .890625
}, {
    x: .984375,
    y: .890625
}, {
    x: .984375,
    y: .890625
}, {
    x: .015625,
    y: .921875
}, {
    x: .015625,
    y: .921875
}, {
    x: .046875,
    y: .921875
}, {
    x: .046875,
    y: .921875
}, {
    x: .078125,
    y: .921875
}, {
    x: .078125,
    y: .921875
}, {
    x: .109375,
    y: .921875
}, {
    x: .109375,
    y: .921875
}, {
    x: .140625,
    y: .921875
}, {
    x: .140625,
    y: .921875
}, {
    x: .171875,
    y: .921875
}, {
    x: .171875,
    y: .921875
}, {
    x: .203125,
    y: .921875
}, {
    x: .203125,
    y: .921875
}, {
    x: .234375,
    y: .921875
}, {
    x: .234375,
    y: .921875
}, {
    x: .265625,
    y: .921875
}, {
    x: .265625,
    y: .921875
}, {
    x: .296875,
    y: .921875
}, {
    x: .296875,
    y: .921875
}, {
    x: .328125,
    y: .921875
}, {
    x: .328125,
    y: .921875
}, {
    x: .359375,
    y: .921875
}, {
    x: .359375,
    y: .921875
}, {
    x: .390625,
    y: .921875
}, {
    x: .390625,
    y: .921875
}, {
    x: .421875,
    y: .921875
}, {
    x: .421875,
    y: .921875
}, {
    x: .453125,
    y: .921875
}, {
    x: .453125,
    y: .921875
}, {
    x: .484375,
    y: .921875
}, {
    x: .484375,
    y: .921875
}, {
    x: .515625,
    y: .921875
}, {
    x: .515625,
    y: .921875
}, {
    x: .546875,
    y: .921875
}, {
    x: .546875,
    y: .921875
}, {
    x: .578125,
    y: .921875
}, {
    x: .578125,
    y: .921875
}, {
    x: .609375,
    y: .921875
}, {
    x: .609375,
    y: .921875
}, {
    x: .640625,
    y: .921875
}, {
    x: .640625,
    y: .921875
}, {
    x: .671875,
    y: .921875
}, {
    x: .671875,
    y: .921875
}, {
    x: .703125,
    y: .921875
}, {
    x: .703125,
    y: .921875
}, {
    x: .734375,
    y: .921875
}, {
    x: .734375,
    y: .921875
}, {
    x: .765625,
    y: .921875
}, {
    x: .765625,
    y: .921875
}, {
    x: .796875,
    y: .921875
}, {
    x: .796875,
    y: .921875
}, {
    x: .828125,
    y: .921875
}, {
    x: .828125,
    y: .921875
}, {
    x: .859375,
    y: .921875
}, {
    x: .859375,
    y: .921875
}, {
    x: .890625,
    y: .921875
}, {
    x: .890625,
    y: .921875
}, {
    x: .921875,
    y: .921875
}, {
    x: .921875,
    y: .921875
}, {
    x: .953125,
    y: .921875
}, {
    x: .953125,
    y: .921875
}, {
    x: .984375,
    y: .921875
}, {
    x: .984375,
    y: .921875
}, {
    x: .015625,
    y: .953125
}, {
    x: .015625,
    y: .953125
}, {
    x: .046875,
    y: .953125
}, {
    x: .046875,
    y: .953125
}, {
    x: .078125,
    y: .953125
}, {
    x: .078125,
    y: .953125
}, {
    x: .109375,
    y: .953125
}, {
    x: .109375,
    y: .953125
}, {
    x: .140625,
    y: .953125
}, {
    x: .140625,
    y: .953125
}, {
    x: .171875,
    y: .953125
}, {
    x: .171875,
    y: .953125
}, {
    x: .203125,
    y: .953125
}, {
    x: .203125,
    y: .953125
}, {
    x: .234375,
    y: .953125
}, {
    x: .234375,
    y: .953125
}, {
    x: .265625,
    y: .953125
}, {
    x: .265625,
    y: .953125
}, {
    x: .296875,
    y: .953125
}, {
    x: .296875,
    y: .953125
}, {
    x: .328125,
    y: .953125
}, {
    x: .328125,
    y: .953125
}, {
    x: .359375,
    y: .953125
}, {
    x: .359375,
    y: .953125
}, {
    x: .390625,
    y: .953125
}, {
    x: .390625,
    y: .953125
}, {
    x: .421875,
    y: .953125
}, {
    x: .421875,
    y: .953125
}, {
    x: .453125,
    y: .953125
}, {
    x: .453125,
    y: .953125
}, {
    x: .484375,
    y: .953125
}, {
    x: .484375,
    y: .953125
}, {
    x: .515625,
    y: .953125
}, {
    x: .515625,
    y: .953125
}, {
    x: .546875,
    y: .953125
}, {
    x: .546875,
    y: .953125
}, {
    x: .578125,
    y: .953125
}, {
    x: .578125,
    y: .953125
}, {
    x: .609375,
    y: .953125
}, {
    x: .609375,
    y: .953125
}, {
    x: .640625,
    y: .953125
}, {
    x: .640625,
    y: .953125
}, {
    x: .671875,
    y: .953125
}, {
    x: .671875,
    y: .953125
}, {
    x: .703125,
    y: .953125
}, {
    x: .703125,
    y: .953125
}, {
    x: .734375,
    y: .953125
}, {
    x: .734375,
    y: .953125
}, {
    x: .765625,
    y: .953125
}, {
    x: .765625,
    y: .953125
}, {
    x: .796875,
    y: .953125
}, {
    x: .796875,
    y: .953125
}, {
    x: .828125,
    y: .953125
}, {
    x: .828125,
    y: .953125
}, {
    x: .859375,
    y: .953125
}, {
    x: .859375,
    y: .953125
}, {
    x: .890625,
    y: .953125
}, {
    x: .890625,
    y: .953125
}, {
    x: .921875,
    y: .953125
}, {
    x: .921875,
    y: .953125
}, {
    x: .953125,
    y: .953125
}, {
    x: .953125,
    y: .953125
}, {
    x: .984375,
    y: .953125
}, {
    x: .984375,
    y: .953125
}, {
    x: .015625,
    y: .984375
}, {
    x: .015625,
    y: .984375
}, {
    x: .046875,
    y: .984375
}, {
    x: .046875,
    y: .984375
}, {
    x: .078125,
    y: .984375
}, {
    x: .078125,
    y: .984375
}, {
    x: .109375,
    y: .984375
}, {
    x: .109375,
    y: .984375
}, {
    x: .140625,
    y: .984375
}, {
    x: .140625,
    y: .984375
}, {
    x: .171875,
    y: .984375
}, {
    x: .171875,
    y: .984375
}, {
    x: .203125,
    y: .984375
}, {
    x: .203125,
    y: .984375
}, {
    x: .234375,
    y: .984375
}, {
    x: .234375,
    y: .984375
}, {
    x: .265625,
    y: .984375
}, {
    x: .265625,
    y: .984375
}, {
    x: .296875,
    y: .984375
}, {
    x: .296875,
    y: .984375
}, {
    x: .328125,
    y: .984375
}, {
    x: .328125,
    y: .984375
}, {
    x: .359375,
    y: .984375
}, {
    x: .359375,
    y: .984375
}, {
    x: .390625,
    y: .984375
}, {
    x: .390625,
    y: .984375
}, {
    x: .421875,
    y: .984375
}, {
    x: .421875,
    y: .984375
}, {
    x: .453125,
    y: .984375
}, {
    x: .453125,
    y: .984375
}, {
    x: .484375,
    y: .984375
}, {
    x: .484375,
    y: .984375
}, {
    x: .515625,
    y: .984375
}, {
    x: .515625,
    y: .984375
}, {
    x: .546875,
    y: .984375
}, {
    x: .546875,
    y: .984375
}, {
    x: .578125,
    y: .984375
}, {
    x: .578125,
    y: .984375
}, {
    x: .609375,
    y: .984375
}, {
    x: .609375,
    y: .984375
}, {
    x: .640625,
    y: .984375
}, {
    x: .640625,
    y: .984375
}, {
    x: .671875,
    y: .984375
}, {
    x: .671875,
    y: .984375
}, {
    x: .703125,
    y: .984375
}, {
    x: .703125,
    y: .984375
}, {
    x: .734375,
    y: .984375
}, {
    x: .734375,
    y: .984375
}, {
    x: .765625,
    y: .984375
}, {
    x: .765625,
    y: .984375
}, {
    x: .796875,
    y: .984375
}, {
    x: .796875,
    y: .984375
}, {
    x: .828125,
    y: .984375
}, {
    x: .828125,
    y: .984375
}, {
    x: .859375,
    y: .984375
}, {
    x: .859375,
    y: .984375
}, {
    x: .890625,
    y: .984375
}, {
    x: .890625,
    y: .984375
}, {
    x: .921875,
    y: .984375
}, {
    x: .921875,
    y: .984375
}, {
    x: .953125,
    y: .984375
}, {
    x: .953125,
    y: .984375
}, {
    x: .984375,
    y: .984375
}, {
    x: .984375,
    y: .984375
}, {
    x: .03125,
    y: .03125
}, {
    x: .03125,
    y: .03125
}, {
    x: .09375,
    y: .03125
}, {
    x: .09375,
    y: .03125
}, {
    x: .15625,
    y: .03125
}, {
    x: .15625,
    y: .03125
}, {
    x: .21875,
    y: .03125
}, {
    x: .21875,
    y: .03125
}, {
    x: .28125,
    y: .03125
}, {
    x: .28125,
    y: .03125
}, {
    x: .34375,
    y: .03125
}, {
    x: .34375,
    y: .03125
}, {
    x: .40625,
    y: .03125
}, {
    x: .40625,
    y: .03125
}, {
    x: .46875,
    y: .03125
}, {
    x: .46875,
    y: .03125
}, {
    x: .53125,
    y: .03125
}, {
    x: .53125,
    y: .03125
}, {
    x: .59375,
    y: .03125
}, {
    x: .59375,
    y: .03125
}, {
    x: .65625,
    y: .03125
}, {
    x: .65625,
    y: .03125
}, {
    x: .71875,
    y: .03125
}, {
    x: .71875,
    y: .03125
}, {
    x: .78125,
    y: .03125
}, {
    x: .78125,
    y: .03125
}, {
    x: .84375,
    y: .03125
}, {
    x: .84375,
    y: .03125
}, {
    x: .90625,
    y: .03125
}, {
    x: .90625,
    y: .03125
}, {
    x: .96875,
    y: .03125
}, {
    x: .96875,
    y: .03125
}, {
    x: .03125,
    y: .09375
}, {
    x: .03125,
    y: .09375
}, {
    x: .09375,
    y: .09375
}, {
    x: .09375,
    y: .09375
}, {
    x: .15625,
    y: .09375
}, {
    x: .15625,
    y: .09375
}, {
    x: .21875,
    y: .09375
}, {
    x: .21875,
    y: .09375
}, {
    x: .28125,
    y: .09375
}, {
    x: .28125,
    y: .09375
}, {
    x: .34375,
    y: .09375
}, {
    x: .34375,
    y: .09375
}, {
    x: .40625,
    y: .09375
}, {
    x: .40625,
    y: .09375
}, {
    x: .46875,
    y: .09375
}, {
    x: .46875,
    y: .09375
}, {
    x: .53125,
    y: .09375
}, {
    x: .53125,
    y: .09375
}, {
    x: .59375,
    y: .09375
}, {
    x: .59375,
    y: .09375
}, {
    x: .65625,
    y: .09375
}, {
    x: .65625,
    y: .09375
}, {
    x: .71875,
    y: .09375
}, {
    x: .71875,
    y: .09375
}, {
    x: .78125,
    y: .09375
}, {
    x: .78125,
    y: .09375
}, {
    x: .84375,
    y: .09375
}, {
    x: .84375,
    y: .09375
}, {
    x: .90625,
    y: .09375
}, {
    x: .90625,
    y: .09375
}, {
    x: .96875,
    y: .09375
}, {
    x: .96875,
    y: .09375
}, {
    x: .03125,
    y: .15625
}, {
    x: .03125,
    y: .15625
}, {
    x: .09375,
    y: .15625
}, {
    x: .09375,
    y: .15625
}, {
    x: .15625,
    y: .15625
}, {
    x: .15625,
    y: .15625
}, {
    x: .21875,
    y: .15625
}, {
    x: .21875,
    y: .15625
}, {
    x: .28125,
    y: .15625
}, {
    x: .28125,
    y: .15625
}, {
    x: .34375,
    y: .15625
}, {
    x: .34375,
    y: .15625
}, {
    x: .40625,
    y: .15625
}, {
    x: .40625,
    y: .15625
}, {
    x: .46875,
    y: .15625
}, {
    x: .46875,
    y: .15625
}, {
    x: .53125,
    y: .15625
}, {
    x: .53125,
    y: .15625
}, {
    x: .59375,
    y: .15625
}, {
    x: .59375,
    y: .15625
}, {
    x: .65625,
    y: .15625
}, {
    x: .65625,
    y: .15625
}, {
    x: .71875,
    y: .15625
}, {
    x: .71875,
    y: .15625
}, {
    x: .78125,
    y: .15625
}, {
    x: .78125,
    y: .15625
}, {
    x: .84375,
    y: .15625
}, {
    x: .84375,
    y: .15625
}, {
    x: .90625,
    y: .15625
}, {
    x: .90625,
    y: .15625
}, {
    x: .96875,
    y: .15625
}, {
    x: .96875,
    y: .15625
}, {
    x: .03125,
    y: .21875
}, {
    x: .03125,
    y: .21875
}, {
    x: .09375,
    y: .21875
}, {
    x: .09375,
    y: .21875
}, {
    x: .15625,
    y: .21875
}, {
    x: .15625,
    y: .21875
}, {
    x: .21875,
    y: .21875
}, {
    x: .21875,
    y: .21875
}, {
    x: .28125,
    y: .21875
}, {
    x: .28125,
    y: .21875
}, {
    x: .34375,
    y: .21875
}, {
    x: .34375,
    y: .21875
}, {
    x: .40625,
    y: .21875
}, {
    x: .40625,
    y: .21875
}, {
    x: .46875,
    y: .21875
}, {
    x: .46875,
    y: .21875
}, {
    x: .53125,
    y: .21875
}, {
    x: .53125,
    y: .21875
}, {
    x: .59375,
    y: .21875
}, {
    x: .59375,
    y: .21875
}, {
    x: .65625,
    y: .21875
}, {
    x: .65625,
    y: .21875
}, {
    x: .71875,
    y: .21875
}, {
    x: .71875,
    y: .21875
}, {
    x: .78125,
    y: .21875
}, {
    x: .78125,
    y: .21875
}, {
    x: .84375,
    y: .21875
}, {
    x: .84375,
    y: .21875
}, {
    x: .90625,
    y: .21875
}, {
    x: .90625,
    y: .21875
}, {
    x: .96875,
    y: .21875
}, {
    x: .96875,
    y: .21875
}, {
    x: .03125,
    y: .28125
}, {
    x: .03125,
    y: .28125
}, {
    x: .09375,
    y: .28125
}, {
    x: .09375,
    y: .28125
}, {
    x: .15625,
    y: .28125
}, {
    x: .15625,
    y: .28125
}, {
    x: .21875,
    y: .28125
}, {
    x: .21875,
    y: .28125
}, {
    x: .28125,
    y: .28125
}, {
    x: .28125,
    y: .28125
}, {
    x: .34375,
    y: .28125
}, {
    x: .34375,
    y: .28125
}, {
    x: .40625,
    y: .28125
}, {
    x: .40625,
    y: .28125
}, {
    x: .46875,
    y: .28125
}, {
    x: .46875,
    y: .28125
}, {
    x: .53125,
    y: .28125
}, {
    x: .53125,
    y: .28125
}, {
    x: .59375,
    y: .28125
}, {
    x: .59375,
    y: .28125
}, {
    x: .65625,
    y: .28125
}, {
    x: .65625,
    y: .28125
}, {
    x: .71875,
    y: .28125
}, {
    x: .71875,
    y: .28125
}, {
    x: .78125,
    y: .28125
}, {
    x: .78125,
    y: .28125
}, {
    x: .84375,
    y: .28125
}, {
    x: .84375,
    y: .28125
}, {
    x: .90625,
    y: .28125
}, {
    x: .90625,
    y: .28125
}, {
    x: .96875,
    y: .28125
}, {
    x: .96875,
    y: .28125
}, {
    x: .03125,
    y: .34375
}, {
    x: .03125,
    y: .34375
}, {
    x: .09375,
    y: .34375
}, {
    x: .09375,
    y: .34375
}, {
    x: .15625,
    y: .34375
}, {
    x: .15625,
    y: .34375
}, {
    x: .21875,
    y: .34375
}, {
    x: .21875,
    y: .34375
}, {
    x: .28125,
    y: .34375
}, {
    x: .28125,
    y: .34375
}, {
    x: .34375,
    y: .34375
}, {
    x: .34375,
    y: .34375
}, {
    x: .40625,
    y: .34375
}, {
    x: .40625,
    y: .34375
}, {
    x: .46875,
    y: .34375
}, {
    x: .46875,
    y: .34375
}, {
    x: .53125,
    y: .34375
}, {
    x: .53125,
    y: .34375
}, {
    x: .59375,
    y: .34375
}, {
    x: .59375,
    y: .34375
}, {
    x: .65625,
    y: .34375
}, {
    x: .65625,
    y: .34375
}, {
    x: .71875,
    y: .34375
}, {
    x: .71875,
    y: .34375
}, {
    x: .78125,
    y: .34375
}, {
    x: .78125,
    y: .34375
}, {
    x: .84375,
    y: .34375
}, {
    x: .84375,
    y: .34375
}, {
    x: .90625,
    y: .34375
}, {
    x: .90625,
    y: .34375
}, {
    x: .96875,
    y: .34375
}, {
    x: .96875,
    y: .34375
}, {
    x: .03125,
    y: .40625
}, {
    x: .03125,
    y: .40625
}, {
    x: .09375,
    y: .40625
}, {
    x: .09375,
    y: .40625
}, {
    x: .15625,
    y: .40625
}, {
    x: .15625,
    y: .40625
}, {
    x: .21875,
    y: .40625
}, {
    x: .21875,
    y: .40625
}, {
    x: .28125,
    y: .40625
}, {
    x: .28125,
    y: .40625
}, {
    x: .34375,
    y: .40625
}, {
    x: .34375,
    y: .40625
}, {
    x: .40625,
    y: .40625
}, {
    x: .40625,
    y: .40625
}, {
    x: .46875,
    y: .40625
}, {
    x: .46875,
    y: .40625
}, {
    x: .53125,
    y: .40625
}, {
    x: .53125,
    y: .40625
}, {
    x: .59375,
    y: .40625
}, {
    x: .59375,
    y: .40625
}, {
    x: .65625,
    y: .40625
}, {
    x: .65625,
    y: .40625
}, {
    x: .71875,
    y: .40625
}, {
    x: .71875,
    y: .40625
}, {
    x: .78125,
    y: .40625
}, {
    x: .78125,
    y: .40625
}, {
    x: .84375,
    y: .40625
}, {
    x: .84375,
    y: .40625
}, {
    x: .90625,
    y: .40625
}, {
    x: .90625,
    y: .40625
}, {
    x: .96875,
    y: .40625
}, {
    x: .96875,
    y: .40625
}, {
    x: .03125,
    y: .46875
}, {
    x: .03125,
    y: .46875
}, {
    x: .09375,
    y: .46875
}, {
    x: .09375,
    y: .46875
}, {
    x: .15625,
    y: .46875
}, {
    x: .15625,
    y: .46875
}, {
    x: .21875,
    y: .46875
}, {
    x: .21875,
    y: .46875
}, {
    x: .28125,
    y: .46875
}, {
    x: .28125,
    y: .46875
}, {
    x: .34375,
    y: .46875
}, {
    x: .34375,
    y: .46875
}, {
    x: .40625,
    y: .46875
}, {
    x: .40625,
    y: .46875
}, {
    x: .46875,
    y: .46875
}, {
    x: .46875,
    y: .46875
}, {
    x: .53125,
    y: .46875
}, {
    x: .53125,
    y: .46875
}, {
    x: .59375,
    y: .46875
}, {
    x: .59375,
    y: .46875
}, {
    x: .65625,
    y: .46875
}, {
    x: .65625,
    y: .46875
}, {
    x: .71875,
    y: .46875
}, {
    x: .71875,
    y: .46875
}, {
    x: .78125,
    y: .46875
}, {
    x: .78125,
    y: .46875
}, {
    x: .84375,
    y: .46875
}, {
    x: .84375,
    y: .46875
}, {
    x: .90625,
    y: .46875
}, {
    x: .90625,
    y: .46875
}, {
    x: .96875,
    y: .46875
}, {
    x: .96875,
    y: .46875
}, {
    x: .03125,
    y: .53125
}, {
    x: .03125,
    y: .53125
}, {
    x: .09375,
    y: .53125
}, {
    x: .09375,
    y: .53125
}, {
    x: .15625,
    y: .53125
}, {
    x: .15625,
    y: .53125
}, {
    x: .21875,
    y: .53125
}, {
    x: .21875,
    y: .53125
}, {
    x: .28125,
    y: .53125
}, {
    x: .28125,
    y: .53125
}, {
    x: .34375,
    y: .53125
}, {
    x: .34375,
    y: .53125
}, {
    x: .40625,
    y: .53125
}, {
    x: .40625,
    y: .53125
}, {
    x: .46875,
    y: .53125
}, {
    x: .46875,
    y: .53125
}, {
    x: .53125,
    y: .53125
}, {
    x: .53125,
    y: .53125
}, {
    x: .59375,
    y: .53125
}, {
    x: .59375,
    y: .53125
}, {
    x: .65625,
    y: .53125
}, {
    x: .65625,
    y: .53125
}, {
    x: .71875,
    y: .53125
}, {
    x: .71875,
    y: .53125
}, {
    x: .78125,
    y: .53125
}, {
    x: .78125,
    y: .53125
}, {
    x: .84375,
    y: .53125
}, {
    x: .84375,
    y: .53125
}, {
    x: .90625,
    y: .53125
}, {
    x: .90625,
    y: .53125
}, {
    x: .96875,
    y: .53125
}, {
    x: .96875,
    y: .53125
}, {
    x: .03125,
    y: .59375
}, {
    x: .03125,
    y: .59375
}, {
    x: .09375,
    y: .59375
}, {
    x: .09375,
    y: .59375
}, {
    x: .15625,
    y: .59375
}, {
    x: .15625,
    y: .59375
}, {
    x: .21875,
    y: .59375
}, {
    x: .21875,
    y: .59375
}, {
    x: .28125,
    y: .59375
}, {
    x: .28125,
    y: .59375
}, {
    x: .34375,
    y: .59375
}, {
    x: .34375,
    y: .59375
}, {
    x: .40625,
    y: .59375
}, {
    x: .40625,
    y: .59375
}, {
    x: .46875,
    y: .59375
}, {
    x: .46875,
    y: .59375
}, {
    x: .53125,
    y: .59375
}, {
    x: .53125,
    y: .59375
}, {
    x: .59375,
    y: .59375
}, {
    x: .59375,
    y: .59375
}, {
    x: .65625,
    y: .59375
}, {
    x: .65625,
    y: .59375
}, {
    x: .71875,
    y: .59375
}, {
    x: .71875,
    y: .59375
}, {
    x: .78125,
    y: .59375
}, {
    x: .78125,
    y: .59375
}, {
    x: .84375,
    y: .59375
}, {
    x: .84375,
    y: .59375
}, {
    x: .90625,
    y: .59375
}, {
    x: .90625,
    y: .59375
}, {
    x: .96875,
    y: .59375
}, {
    x: .96875,
    y: .59375
}, {
    x: .03125,
    y: .65625
}, {
    x: .03125,
    y: .65625
}, {
    x: .09375,
    y: .65625
}, {
    x: .09375,
    y: .65625
}, {
    x: .15625,
    y: .65625
}, {
    x: .15625,
    y: .65625
}, {
    x: .21875,
    y: .65625
}, {
    x: .21875,
    y: .65625
}, {
    x: .28125,
    y: .65625
}, {
    x: .28125,
    y: .65625
}, {
    x: .34375,
    y: .65625
}, {
    x: .34375,
    y: .65625
}, {
    x: .40625,
    y: .65625
}, {
    x: .40625,
    y: .65625
}, {
    x: .46875,
    y: .65625
}, {
    x: .46875,
    y: .65625
}, {
    x: .53125,
    y: .65625
}, {
    x: .53125,
    y: .65625
}, {
    x: .59375,
    y: .65625
}, {
    x: .59375,
    y: .65625
}, {
    x: .65625,
    y: .65625
}, {
    x: .65625,
    y: .65625
}, {
    x: .71875,
    y: .65625
}, {
    x: .71875,
    y: .65625
}, {
    x: .78125,
    y: .65625
}, {
    x: .78125,
    y: .65625
}, {
    x: .84375,
    y: .65625
}, {
    x: .84375,
    y: .65625
}, {
    x: .90625,
    y: .65625
}, {
    x: .90625,
    y: .65625
}, {
    x: .96875,
    y: .65625
}, {
    x: .96875,
    y: .65625
}, {
    x: .03125,
    y: .71875
}, {
    x: .03125,
    y: .71875
}, {
    x: .09375,
    y: .71875
}, {
    x: .09375,
    y: .71875
}, {
    x: .15625,
    y: .71875
}, {
    x: .15625,
    y: .71875
}, {
    x: .21875,
    y: .71875
}, {
    x: .21875,
    y: .71875
}, {
    x: .28125,
    y: .71875
}, {
    x: .28125,
    y: .71875
}, {
    x: .34375,
    y: .71875
}, {
    x: .34375,
    y: .71875
}, {
    x: .40625,
    y: .71875
}, {
    x: .40625,
    y: .71875
}, {
    x: .46875,
    y: .71875
}, {
    x: .46875,
    y: .71875
}, {
    x: .53125,
    y: .71875
}, {
    x: .53125,
    y: .71875
}, {
    x: .59375,
    y: .71875
}, {
    x: .59375,
    y: .71875
}, {
    x: .65625,
    y: .71875
}, {
    x: .65625,
    y: .71875
}, {
    x: .71875,
    y: .71875
}, {
    x: .71875,
    y: .71875
}, {
    x: .78125,
    y: .71875
}, {
    x: .78125,
    y: .71875
}, {
    x: .84375,
    y: .71875
}, {
    x: .84375,
    y: .71875
}, {
    x: .90625,
    y: .71875
}, {
    x: .90625,
    y: .71875
}, {
    x: .96875,
    y: .71875
}, {
    x: .96875,
    y: .71875
}, {
    x: .03125,
    y: .78125
}, {
    x: .03125,
    y: .78125
}, {
    x: .09375,
    y: .78125
}, {
    x: .09375,
    y: .78125
}, {
    x: .15625,
    y: .78125
}, {
    x: .15625,
    y: .78125
}, {
    x: .21875,
    y: .78125
}, {
    x: .21875,
    y: .78125
}, {
    x: .28125,
    y: .78125
}, {
    x: .28125,
    y: .78125
}, {
    x: .34375,
    y: .78125
}, {
    x: .34375,
    y: .78125
}, {
    x: .40625,
    y: .78125
}, {
    x: .40625,
    y: .78125
}, {
    x: .46875,
    y: .78125
}, {
    x: .46875,
    y: .78125
}, {
    x: .53125,
    y: .78125
}, {
    x: .53125,
    y: .78125
}, {
    x: .59375,
    y: .78125
}, {
    x: .59375,
    y: .78125
}, {
    x: .65625,
    y: .78125
}, {
    x: .65625,
    y: .78125
}, {
    x: .71875,
    y: .78125
}, {
    x: .71875,
    y: .78125
}, {
    x: .78125,
    y: .78125
}, {
    x: .78125,
    y: .78125
}, {
    x: .84375,
    y: .78125
}, {
    x: .84375,
    y: .78125
}, {
    x: .90625,
    y: .78125
}, {
    x: .90625,
    y: .78125
}, {
    x: .96875,
    y: .78125
}, {
    x: .96875,
    y: .78125
}, {
    x: .03125,
    y: .84375
}, {
    x: .03125,
    y: .84375
}, {
    x: .09375,
    y: .84375
}, {
    x: .09375,
    y: .84375
}, {
    x: .15625,
    y: .84375
}, {
    x: .15625,
    y: .84375
}, {
    x: .21875,
    y: .84375
}, {
    x: .21875,
    y: .84375
}, {
    x: .28125,
    y: .84375
}, {
    x: .28125,
    y: .84375
}, {
    x: .34375,
    y: .84375
}, {
    x: .34375,
    y: .84375
}, {
    x: .40625,
    y: .84375
}, {
    x: .40625,
    y: .84375
}, {
    x: .46875,
    y: .84375
}, {
    x: .46875,
    y: .84375
}, {
    x: .53125,
    y: .84375
}, {
    x: .53125,
    y: .84375
}, {
    x: .59375,
    y: .84375
}, {
    x: .59375,
    y: .84375
}, {
    x: .65625,
    y: .84375
}, {
    x: .65625,
    y: .84375
}, {
    x: .71875,
    y: .84375
}, {
    x: .71875,
    y: .84375
}, {
    x: .78125,
    y: .84375
}, {
    x: .78125,
    y: .84375
}, {
    x: .84375,
    y: .84375
}, {
    x: .84375,
    y: .84375
}, {
    x: .90625,
    y: .84375
}, {
    x: .90625,
    y: .84375
}, {
    x: .96875,
    y: .84375
}, {
    x: .96875,
    y: .84375
}, {
    x: .03125,
    y: .90625
}, {
    x: .03125,
    y: .90625
}, {
    x: .09375,
    y: .90625
}, {
    x: .09375,
    y: .90625
}, {
    x: .15625,
    y: .90625
}, {
    x: .15625,
    y: .90625
}, {
    x: .21875,
    y: .90625
}, {
    x: .21875,
    y: .90625
}, {
    x: .28125,
    y: .90625
}, {
    x: .28125,
    y: .90625
}, {
    x: .34375,
    y: .90625
}, {
    x: .34375,
    y: .90625
}, {
    x: .40625,
    y: .90625
}, {
    x: .40625,
    y: .90625
}, {
    x: .46875,
    y: .90625
}, {
    x: .46875,
    y: .90625
}, {
    x: .53125,
    y: .90625
}, {
    x: .53125,
    y: .90625
}, {
    x: .59375,
    y: .90625
}, {
    x: .59375,
    y: .90625
}, {
    x: .65625,
    y: .90625
}, {
    x: .65625,
    y: .90625
}, {
    x: .71875,
    y: .90625
}, {
    x: .71875,
    y: .90625
}, {
    x: .78125,
    y: .90625
}, {
    x: .78125,
    y: .90625
}, {
    x: .84375,
    y: .90625
}, {
    x: .84375,
    y: .90625
}, {
    x: .90625,
    y: .90625
}, {
    x: .90625,
    y: .90625
}, {
    x: .96875,
    y: .90625
}, {
    x: .96875,
    y: .90625
}, {
    x: .03125,
    y: .96875
}, {
    x: .03125,
    y: .96875
}, {
    x: .09375,
    y: .96875
}, {
    x: .09375,
    y: .96875
}, {
    x: .15625,
    y: .96875
}, {
    x: .15625,
    y: .96875
}, {
    x: .21875,
    y: .96875
}, {
    x: .21875,
    y: .96875
}, {
    x: .28125,
    y: .96875
}, {
    x: .28125,
    y: .96875
}, {
    x: .34375,
    y: .96875
}, {
    x: .34375,
    y: .96875
}, {
    x: .40625,
    y: .96875
}, {
    x: .40625,
    y: .96875
}, {
    x: .46875,
    y: .96875
}, {
    x: .46875,
    y: .96875
}, {
    x: .53125,
    y: .96875
}, {
    x: .53125,
    y: .96875
}, {
    x: .59375,
    y: .96875
}, {
    x: .59375,
    y: .96875
}, {
    x: .65625,
    y: .96875
}, {
    x: .65625,
    y: .96875
}, {
    x: .71875,
    y: .96875
}, {
    x: .71875,
    y: .96875
}, {
    x: .78125,
    y: .96875
}, {
    x: .78125,
    y: .96875
}, {
    x: .84375,
    y: .96875
}, {
    x: .84375,
    y: .96875
}, {
    x: .90625,
    y: .96875
}, {
    x: .90625,
    y: .96875
}, {
    x: .96875,
    y: .96875
}, {
    x: .96875,
    y: .96875
}, {
    x: .0625,
    y: .0625
}, {
    x: .0625,
    y: .0625
}, {
    x: .0625,
    y: .0625
}, {
    x: .0625,
    y: .0625
}, {
    x: .0625,
    y: .0625
}, {
    x: .0625,
    y: .0625
}, {
    x: .1875,
    y: .0625
}, {
    x: .1875,
    y: .0625
}, {
    x: .1875,
    y: .0625
}, {
    x: .1875,
    y: .0625
}, {
    x: .1875,
    y: .0625
}, {
    x: .1875,
    y: .0625
}, {
    x: .3125,
    y: .0625
}, {
    x: .3125,
    y: .0625
}, {
    x: .3125,
    y: .0625
}, {
    x: .3125,
    y: .0625
}, {
    x: .3125,
    y: .0625
}, {
    x: .3125,
    y: .0625
}, {
    x: .4375,
    y: .0625
}, {
    x: .4375,
    y: .0625
}, {
    x: .4375,
    y: .0625
}, {
    x: .4375,
    y: .0625
}, {
    x: .4375,
    y: .0625
}, {
    x: .4375,
    y: .0625
}, {
    x: .5625,
    y: .0625
}, {
    x: .5625,
    y: .0625
}, {
    x: .5625,
    y: .0625
}, {
    x: .5625,
    y: .0625
}, {
    x: .5625,
    y: .0625
}, {
    x: .5625,
    y: .0625
}, {
    x: .6875,
    y: .0625
}, {
    x: .6875,
    y: .0625
}, {
    x: .6875,
    y: .0625
}, {
    x: .6875,
    y: .0625
}, {
    x: .6875,
    y: .0625
}, {
    x: .6875,
    y: .0625
}, {
    x: .8125,
    y: .0625
}, {
    x: .8125,
    y: .0625
}, {
    x: .8125,
    y: .0625
}, {
    x: .8125,
    y: .0625
}, {
    x: .8125,
    y: .0625
}, {
    x: .8125,
    y: .0625
}, {
    x: .9375,
    y: .0625
}, {
    x: .9375,
    y: .0625
}, {
    x: .9375,
    y: .0625
}, {
    x: .9375,
    y: .0625
}, {
    x: .9375,
    y: .0625
}, {
    x: .9375,
    y: .0625
}, {
    x: .0625,
    y: .1875
}, {
    x: .0625,
    y: .1875
}, {
    x: .0625,
    y: .1875
}, {
    x: .0625,
    y: .1875
}, {
    x: .0625,
    y: .1875
}, {
    x: .0625,
    y: .1875
}, {
    x: .1875,
    y: .1875
}, {
    x: .1875,
    y: .1875
}, {
    x: .1875,
    y: .1875
}, {
    x: .1875,
    y: .1875
}, {
    x: .1875,
    y: .1875
}, {
    x: .1875,
    y: .1875
}, {
    x: .3125,
    y: .1875
}, {
    x: .3125,
    y: .1875
}, {
    x: .3125,
    y: .1875
}, {
    x: .3125,
    y: .1875
}, {
    x: .3125,
    y: .1875
}, {
    x: .3125,
    y: .1875
}, {
    x: .4375,
    y: .1875
}, {
    x: .4375,
    y: .1875
}, {
    x: .4375,
    y: .1875
}, {
    x: .4375,
    y: .1875
}, {
    x: .4375,
    y: .1875
}, {
    x: .4375,
    y: .1875
}, {
    x: .5625,
    y: .1875
}, {
    x: .5625,
    y: .1875
}, {
    x: .5625,
    y: .1875
}, {
    x: .5625,
    y: .1875
}, {
    x: .5625,
    y: .1875
}, {
    x: .5625,
    y: .1875
}, {
    x: .6875,
    y: .1875
}, {
    x: .6875,
    y: .1875
}, {
    x: .6875,
    y: .1875
}, {
    x: .6875,
    y: .1875
}, {
    x: .6875,
    y: .1875
}, {
    x: .6875,
    y: .1875
}, {
    x: .8125,
    y: .1875
}, {
    x: .8125,
    y: .1875
}, {
    x: .8125,
    y: .1875
}, {
    x: .8125,
    y: .1875
}, {
    x: .8125,
    y: .1875
}, {
    x: .8125,
    y: .1875
}, {
    x: .9375,
    y: .1875
}, {
    x: .9375,
    y: .1875
}, {
    x: .9375,
    y: .1875
}, {
    x: .9375,
    y: .1875
}, {
    x: .9375,
    y: .1875
}, {
    x: .9375,
    y: .1875
}, {
    x: .0625,
    y: .3125
}, {
    x: .0625,
    y: .3125
}, {
    x: .0625,
    y: .3125
}, {
    x: .0625,
    y: .3125
}, {
    x: .0625,
    y: .3125
}, {
    x: .0625,
    y: .3125
}, {
    x: .1875,
    y: .3125
}, {
    x: .1875,
    y: .3125
}, {
    x: .1875,
    y: .3125
}, {
    x: .1875,
    y: .3125
}, {
    x: .1875,
    y: .3125
}, {
    x: .1875,
    y: .3125
}, {
    x: .3125,
    y: .3125
}, {
    x: .3125,
    y: .3125
}, {
    x: .3125,
    y: .3125
}, {
    x: .3125,
    y: .3125
}, {
    x: .3125,
    y: .3125
}, {
    x: .3125,
    y: .3125
}, {
    x: .4375,
    y: .3125
}, {
    x: .4375,
    y: .3125
}, {
    x: .4375,
    y: .3125
}, {
    x: .4375,
    y: .3125
}, {
    x: .4375,
    y: .3125
}, {
    x: .4375,
    y: .3125
}, {
    x: .5625,
    y: .3125
}, {
    x: .5625,
    y: .3125
}, {
    x: .5625,
    y: .3125
}, {
    x: .5625,
    y: .3125
}, {
    x: .5625,
    y: .3125
}, {
    x: .5625,
    y: .3125
}, {
    x: .6875,
    y: .3125
}, {
    x: .6875,
    y: .3125
}, {
    x: .6875,
    y: .3125
}, {
    x: .6875,
    y: .3125
}, {
    x: .6875,
    y: .3125
}, {
    x: .6875,
    y: .3125
}, {
    x: .8125,
    y: .3125
}, {
    x: .8125,
    y: .3125
}, {
    x: .8125,
    y: .3125
}, {
    x: .8125,
    y: .3125
}, {
    x: .8125,
    y: .3125
}, {
    x: .8125,
    y: .3125
}, {
    x: .9375,
    y: .3125
}, {
    x: .9375,
    y: .3125
}, {
    x: .9375,
    y: .3125
}, {
    x: .9375,
    y: .3125
}, {
    x: .9375,
    y: .3125
}, {
    x: .9375,
    y: .3125
}, {
    x: .0625,
    y: .4375
}, {
    x: .0625,
    y: .4375
}, {
    x: .0625,
    y: .4375
}, {
    x: .0625,
    y: .4375
}, {
    x: .0625,
    y: .4375
}, {
    x: .0625,
    y: .4375
}, {
    x: .1875,
    y: .4375
}, {
    x: .1875,
    y: .4375
}, {
    x: .1875,
    y: .4375
}, {
    x: .1875,
    y: .4375
}, {
    x: .1875,
    y: .4375
}, {
    x: .1875,
    y: .4375
}, {
    x: .3125,
    y: .4375
}, {
    x: .3125,
    y: .4375
}, {
    x: .3125,
    y: .4375
}, {
    x: .3125,
    y: .4375
}, {
    x: .3125,
    y: .4375
}, {
    x: .3125,
    y: .4375
}, {
    x: .4375,
    y: .4375
}, {
    x: .4375,
    y: .4375
}, {
    x: .4375,
    y: .4375
}, {
    x: .4375,
    y: .4375
}, {
    x: .4375,
    y: .4375
}, {
    x: .4375,
    y: .4375
}, {
    x: .5625,
    y: .4375
}, {
    x: .5625,
    y: .4375
}, {
    x: .5625,
    y: .4375
}, {
    x: .5625,
    y: .4375
}, {
    x: .5625,
    y: .4375
}, {
    x: .5625,
    y: .4375
}, {
    x: .6875,
    y: .4375
}, {
    x: .6875,
    y: .4375
}, {
    x: .6875,
    y: .4375
}, {
    x: .6875,
    y: .4375
}, {
    x: .6875,
    y: .4375
}, {
    x: .6875,
    y: .4375
}, {
    x: .8125,
    y: .4375
}, {
    x: .8125,
    y: .4375
}, {
    x: .8125,
    y: .4375
}, {
    x: .8125,
    y: .4375
}, {
    x: .8125,
    y: .4375
}, {
    x: .8125,
    y: .4375
}, {
    x: .9375,
    y: .4375
}, {
    x: .9375,
    y: .4375
}, {
    x: .9375,
    y: .4375
}, {
    x: .9375,
    y: .4375
}, {
    x: .9375,
    y: .4375
}, {
    x: .9375,
    y: .4375
}, {
    x: .0625,
    y: .5625
}, {
    x: .0625,
    y: .5625
}, {
    x: .0625,
    y: .5625
}, {
    x: .0625,
    y: .5625
}, {
    x: .0625,
    y: .5625
}, {
    x: .0625,
    y: .5625
}, {
    x: .1875,
    y: .5625
}, {
    x: .1875,
    y: .5625
}, {
    x: .1875,
    y: .5625
}, {
    x: .1875,
    y: .5625
}, {
    x: .1875,
    y: .5625
}, {
    x: .1875,
    y: .5625
}, {
    x: .3125,
    y: .5625
}, {
    x: .3125,
    y: .5625
}, {
    x: .3125,
    y: .5625
}, {
    x: .3125,
    y: .5625
}, {
    x: .3125,
    y: .5625
}, {
    x: .3125,
    y: .5625
}, {
    x: .4375,
    y: .5625
}, {
    x: .4375,
    y: .5625
}, {
    x: .4375,
    y: .5625
}, {
    x: .4375,
    y: .5625
}, {
    x: .4375,
    y: .5625
}, {
    x: .4375,
    y: .5625
}, {
    x: .5625,
    y: .5625
}, {
    x: .5625,
    y: .5625
}, {
    x: .5625,
    y: .5625
}, {
    x: .5625,
    y: .5625
}, {
    x: .5625,
    y: .5625
}, {
    x: .5625,
    y: .5625
}, {
    x: .6875,
    y: .5625
}, {
    x: .6875,
    y: .5625
}, {
    x: .6875,
    y: .5625
}, {
    x: .6875,
    y: .5625
}, {
    x: .6875,
    y: .5625
}, {
    x: .6875,
    y: .5625
}, {
    x: .8125,
    y: .5625
}, {
    x: .8125,
    y: .5625
}, {
    x: .8125,
    y: .5625
}, {
    x: .8125,
    y: .5625
}, {
    x: .8125,
    y: .5625
}, {
    x: .8125,
    y: .5625
}, {
    x: .9375,
    y: .5625
}, {
    x: .9375,
    y: .5625
}, {
    x: .9375,
    y: .5625
}, {
    x: .9375,
    y: .5625
}, {
    x: .9375,
    y: .5625
}, {
    x: .9375,
    y: .5625
}, {
    x: .0625,
    y: .6875
}, {
    x: .0625,
    y: .6875
}, {
    x: .0625,
    y: .6875
}, {
    x: .0625,
    y: .6875
}, {
    x: .0625,
    y: .6875
}, {
    x: .0625,
    y: .6875
}, {
    x: .1875,
    y: .6875
}, {
    x: .1875,
    y: .6875
}, {
    x: .1875,
    y: .6875
}, {
    x: .1875,
    y: .6875
}, {
    x: .1875,
    y: .6875
}, {
    x: .1875,
    y: .6875
}, {
    x: .3125,
    y: .6875
}, {
    x: .3125,
    y: .6875
}, {
    x: .3125,
    y: .6875
}, {
    x: .3125,
    y: .6875
}, {
    x: .3125,
    y: .6875
}, {
    x: .3125,
    y: .6875
}, {
    x: .4375,
    y: .6875
}, {
    x: .4375,
    y: .6875
}, {
    x: .4375,
    y: .6875
}, {
    x: .4375,
    y: .6875
}, {
    x: .4375,
    y: .6875
}, {
    x: .4375,
    y: .6875
}, {
    x: .5625,
    y: .6875
}, {
    x: .5625,
    y: .6875
}, {
    x: .5625,
    y: .6875
}, {
    x: .5625,
    y: .6875
}, {
    x: .5625,
    y: .6875
}, {
    x: .5625,
    y: .6875
}, {
    x: .6875,
    y: .6875
}, {
    x: .6875,
    y: .6875
}, {
    x: .6875,
    y: .6875
}, {
    x: .6875,
    y: .6875
}, {
    x: .6875,
    y: .6875
}, {
    x: .6875,
    y: .6875
}, {
    x: .8125,
    y: .6875
}, {
    x: .8125,
    y: .6875
}, {
    x: .8125,
    y: .6875
}, {
    x: .8125,
    y: .6875
}, {
    x: .8125,
    y: .6875
}, {
    x: .8125,
    y: .6875
}, {
    x: .9375,
    y: .6875
}, {
    x: .9375,
    y: .6875
}, {
    x: .9375,
    y: .6875
}, {
    x: .9375,
    y: .6875
}, {
    x: .9375,
    y: .6875
}, {
    x: .9375,
    y: .6875
}, {
    x: .0625,
    y: .8125
}, {
    x: .0625,
    y: .8125
}, {
    x: .0625,
    y: .8125
}, {
    x: .0625,
    y: .8125
}, {
    x: .0625,
    y: .8125
}, {
    x: .0625,
    y: .8125
}, {
    x: .1875,
    y: .8125
}, {
    x: .1875,
    y: .8125
}, {
    x: .1875,
    y: .8125
}, {
    x: .1875,
    y: .8125
}, {
    x: .1875,
    y: .8125
}, {
    x: .1875,
    y: .8125
}, {
    x: .3125,
    y: .8125
}, {
    x: .3125,
    y: .8125
}, {
    x: .3125,
    y: .8125
}, {
    x: .3125,
    y: .8125
}, {
    x: .3125,
    y: .8125
}, {
    x: .3125,
    y: .8125
}, {
    x: .4375,
    y: .8125
}, {
    x: .4375,
    y: .8125
}, {
    x: .4375,
    y: .8125
}, {
    x: .4375,
    y: .8125
}, {
    x: .4375,
    y: .8125
}, {
    x: .4375,
    y: .8125
}, {
    x: .5625,
    y: .8125
}, {
    x: .5625,
    y: .8125
}, {
    x: .5625,
    y: .8125
}, {
    x: .5625,
    y: .8125
}, {
    x: .5625,
    y: .8125
}, {
    x: .5625,
    y: .8125
}, {
    x: .6875,
    y: .8125
}, {
    x: .6875,
    y: .8125
}, {
    x: .6875,
    y: .8125
}, {
    x: .6875,
    y: .8125
}, {
    x: .6875,
    y: .8125
}, {
    x: .6875,
    y: .8125
}, {
    x: .8125,
    y: .8125
}, {
    x: .8125,
    y: .8125
}, {
    x: .8125,
    y: .8125
}, {
    x: .8125,
    y: .8125
}, {
    x: .8125,
    y: .8125
}, {
    x: .8125,
    y: .8125
}, {
    x: .9375,
    y: .8125
}, {
    x: .9375,
    y: .8125
}, {
    x: .9375,
    y: .8125
}, {
    x: .9375,
    y: .8125
}, {
    x: .9375,
    y: .8125
}, {
    x: .9375,
    y: .8125
}, {
    x: .0625,
    y: .9375
}, {
    x: .0625,
    y: .9375
}, {
    x: .0625,
    y: .9375
}, {
    x: .0625,
    y: .9375
}, {
    x: .0625,
    y: .9375
}, {
    x: .0625,
    y: .9375
}, {
    x: .1875,
    y: .9375
}, {
    x: .1875,
    y: .9375
}, {
    x: .1875,
    y: .9375
}, {
    x: .1875,
    y: .9375
}, {
    x: .1875,
    y: .9375
}, {
    x: .1875,
    y: .9375
}, {
    x: .3125,
    y: .9375
}, {
    x: .3125,
    y: .9375
}, {
    x: .3125,
    y: .9375
}, {
    x: .3125,
    y: .9375
}, {
    x: .3125,
    y: .9375
}, {
    x: .3125,
    y: .9375
}, {
    x: .4375,
    y: .9375
}, {
    x: .4375,
    y: .9375
}, {
    x: .4375,
    y: .9375
}, {
    x: .4375,
    y: .9375
}, {
    x: .4375,
    y: .9375
}, {
    x: .4375,
    y: .9375
}, {
    x: .5625,
    y: .9375
}, {
    x: .5625,
    y: .9375
}, {
    x: .5625,
    y: .9375
}, {
    x: .5625,
    y: .9375
}, {
    x: .5625,
    y: .9375
}, {
    x: .5625,
    y: .9375
}, {
    x: .6875,
    y: .9375
}, {
    x: .6875,
    y: .9375
}, {
    x: .6875,
    y: .9375
}, {
    x: .6875,
    y: .9375
}, {
    x: .6875,
    y: .9375
}, {
    x: .6875,
    y: .9375
}, {
    x: .8125,
    y: .9375
}, {
    x: .8125,
    y: .9375
}, {
    x: .8125,
    y: .9375
}, {
    x: .8125,
    y: .9375
}, {
    x: .8125,
    y: .9375
}, {
    x: .8125,
    y: .9375
}, {
    x: .9375,
    y: .9375
}, {
    x: .9375,
    y: .9375
}, {
    x: .9375,
    y: .9375
}, {
    x: .9375,
    y: .9375
}, {
    x: .9375,
    y: .9375
}, {
    x: .9375,
    y: .9375
} ], tZ = class {
    constructor(e) {
        var t, n, a, r;
        ve(this, "model"), ve(this, "anchors"), ve(this, "anchorsTensor"), ve(this, "inputSize"), 
        ve(this, "inputSizeTensor"), ve(this, "doubleInputSizeTensor"), this.model = e, 
        this.anchors = eZ.map(s => [ s.x, s.y ]), this.anchorsTensor = Dr(this.anchors), 
        this.inputSize = ((r = (a = (n = (t = this == null ? void 0 : this.model) == null ? void 0 : t.inputs) == null ? void 0 : n[0]) == null ? void 0 : a.shape) == null ? void 0 : r[2]) || 0, 
        this.inputSizeTensor = Yt([ this.inputSize, this.inputSize ]), this.doubleInputSizeTensor = Yt([ 2 * this.inputSize, 2 * this.inputSize ]);
    }
    normalizeBoxes(e) {
        const t = {};
        t.boxOffsets = He(e, [ 0, 0 ], [ -1, 2 ]), t.boxSizes = He(e, [ 0, 2 ], [ -1, 2 ]), 
        t.div = ze(t.boxOffsets, this.inputSizeTensor), t.boxCenterPoints = _e(t.div, this.anchorsTensor), 
        t.halfBoxSizes = ze(t.boxSizes, this.doubleInputSizeTensor), t.sub = $e(t.boxCenterPoints, t.halfBoxSizes), 
        t.startPoints = ne(t.sub, this.inputSizeTensor), t.add = _e(t.boxCenterPoints, t.halfBoxSizes), 
        t.endPoints = ne(t.add, this.inputSizeTensor);
        const n = Jp([ t.startPoints, t.endPoints ], 1);
        return Object.keys(t).forEach(a => ae(t[a])), n;
    }
    normalizeLandmarks(e, t) {
        const n = {};
        n.reshape = Q(e, [ -1, 7, 2 ]), n.div = ze(n.reshape, this.inputSizeTensor), 
        n.landmarks = _e(n.div, this.anchors[t] ? this.anchors[t] : 0);
        const a = ne(n.landmarks, this.inputSizeTensor);
        return Object.keys(n).forEach(r => ae(n[r])), a;
    }
    async predict(e, t) {
        var n;
        const a = {};
        a.resize = Ue.resizeBilinear(e, [ this.inputSize, this.inputSize ]), a.div = ze(a.resize, lt.tf127), 
        a.image = $e(a.div, lt.tf1), a.batched = this.model.execute(a.image), a.predictions = at(a.batched), 
        a.slice = He(a.predictions, [ 0, 0 ], [ -1, 1 ]), a.sigmoid = va(a.slice), 
        a.scores = at(a.sigmoid);
        const r = await a.scores.data();
        a.boxes = He(a.predictions, [ 0, 1 ], [ -1, 4 ]), a.norm = this.normalizeBoxes(a.boxes), 
        a.nms = await Ue.nonMaxSuppressionAsync(a.norm, a.scores, 3 * (((n = t.hand) == null ? void 0 : n.maxDetected) || 1), t.hand.iouThreshold, t.hand.minConfidence);
        const s = await a.nms.array(), i = [];
        for (const l of s) {
            const o = {};
            o.box = He(a.norm, [ l, 0 ], [ 1, -1 ]), o.slice = He(a.predictions, [ l, 5 ], [ 1, 14 ]), 
            o.norm = this.normalizeLandmarks(o.slice, l), o.palmLandmarks = Q(o.norm, [ -1, 2 ]);
            const p = await o.box.data(), u = YK({
                startPoint: p.slice(0, 2),
                endPoint: p.slice(2, 4),
                palmLandmarks: await o.palmLandmarks.array(),
                confidence: r[l]
            }, [ (e.shape[2] || 1) / this.inputSize, (e.shape[1] || 0) / this.inputSize ]);
            i.push(u), Object.keys(o).forEach(c => ae(o[c]));
        }
        return Object.keys(a).forEach(l => ae(a[l])), i;
    }
}, P4 = [ 0, 5, 9, 13, 17, 1, 2 ], D4 = 0, nZ = class {
    constructor(e, t) {
        var n, a, r;
        ve(this, "handDetector"), ve(this, "handPoseModel"), ve(this, "inputSize"), 
        ve(this, "storedBoxes"), ve(this, "skipped"), ve(this, "detectedHands"), 
        this.handDetector = e, this.handPoseModel = t, this.inputSize = ((r = (a = (n = this.handPoseModel) == null ? void 0 : n.inputs) == null ? void 0 : a[0].shape) == null ? void 0 : r[2]) || 0, 
        this.storedBoxes = [], this.skipped = Number.MAX_SAFE_INTEGER, this.detectedHands = 0;
    }
    calculateLandmarksBoundingBox(e) {
        const t = e.map(a => a[0]), n = e.map(a => a[1]);
        return {
            startPoint: [ Math.min(...t), Math.min(...n) ],
            endPoint: [ Math.max(...t), Math.max(...n) ]
        };
    }
    getBoxForPalmLandmarks(e, t) {
        const n = e.map(a => O4([ ...a, 1 ], t));
        return A2(x2(this.calculateLandmarksBoundingBox(n)), 5);
    }
    getBoxForHandLandmarks(e) {
        const t = A2(x2(this.calculateLandmarksBoundingBox(e)), 1.65);
        t.palmLandmarks = [];
        for (let n = 0; n < P4.length; n++) t.palmLandmarks.push(e[P4[n]].slice(0, 2));
        return t;
    }
    transformRawCoords(e, t, n, a) {
        const r = y2(t), s = [ r[0] / this.inputSize, r[1] / this.inputSize, (r[0] + r[1]) / this.inputSize / 2 ], i = e.map(d => [ s[0] * (d[0] - this.inputSize / 2), s[1] * (d[1] - this.inputSize / 2), s[2] * d[2] ]), l = _4(n, [ 0, 0 ]), o = i.map(d => [ ...O4(d, l), d[2] ]), p = function(d) {
            const h = [ [ d[0][0], d[1][0] ], [ d[0][1], d[1][1] ] ], f = [ d[0][2], d[1][2] ], m = [ -Ko(h[0], f), -Ko(h[1], f) ];
            return [ h[0].concat(m[0]), h[1].concat(m[1]), [ 0, 0, 1 ] ];
        }(a), u = [ ...kh(t), 1 ], c = [ Ko(u, p[0]), Ko(u, p[1]) ];
        return o.map(d => [ Math.trunc(d[0] + c[0]), Math.trunc(d[1] + c[1]), Math.trunc(d[2]) ]);
    }
    async estimateHands(e, t) {
        let n, a = !1;
        const r = (t.hand.skipTime || 0) > se() - D4, s = this.skipped < (t.hand.skipFrames || 0);
        t.skipAllowed && r && s ? this.skipped++ : (n = await this.handDetector.predict(e, t), 
        this.skipped = 0), n && n.length > 0 && (n.length !== this.detectedHands && this.detectedHands !== t.hand.maxDetected || !t.hand.landmarks) && (this.detectedHands = 0, 
        this.storedBoxes = [ ...n ], this.storedBoxes.length > 0 && (a = !0));
        const i = [];
        for (let l = 0; l < this.storedBoxes.length; l++) {
            const o = this.storedBoxes[l];
            if (o) if (t.hand.landmarks) {
                const p = t.hand.rotation ? JK(o.palmLandmarks[0], o.palmLandmarks[2]) : 0, u = kh(o), c = [ u[0] / e.shape[2], u[1] / e.shape[1] ], d = t.hand.rotation && ce.kernels.includes("rotatewithoffset") ? Ue.rotateWithOffset(e, p, 0, c) : e.clone(), h = _4(-p, u), f = a ? this.getBoxForPalmLandmarks(o.palmLandmarks, h) : o, m = ZK(f, d, [ this.inputSize, this.inputSize ]), g = ze(m, lt.tf255);
                ae(m), ae(d);
                const [ y, A ] = this.handPoseModel.execute(g);
                D4 = se(), ae(g);
                const x = (await y.data())[0];
                if (ae(y), x >= t.hand.minConfidence / 4) {
                    const b = Q(A, [ -1, 3 ]), v = await b.array();
                    ae(A), ae(b);
                    const I = this.transformRawCoords(v, f, p, h), N = this.getBoxForHandLandmarks(I);
                    this.storedBoxes[l] = {
                        ...N,
                        confidence: x
                    };
                    const T = {
                        landmarks: I,
                        confidence: x,
                        boxConfidence: o.confidence,
                        fingerConfidence: x,
                        box: {
                            topLeft: N.startPoint,
                            bottomRight: N.endPoint
                        }
                    };
                    i.push(T);
                } else this.storedBoxes[l] = null;
                ae(A);
            } else {
                const p = A2(x2(o), 1.65), u = {
                    confidence: o.confidence,
                    boxConfidence: o.confidence,
                    fingerConfidence: 0,
                    box: {
                        topLeft: p.startPoint,
                        bottomRight: p.endPoint
                    },
                    landmarks: []
                };
                i.push(u);
            }
        }
        return this.storedBoxes = this.storedBoxes.filter(l => l !== null), this.detectedHands = i.length, 
        i.length > t.hand.maxDetected && (i.length = t.hand.maxDetected), i;
    }
}, z4 = {
    thumb: [ 1, 2, 3, 4 ],
    index: [ 5, 6, 7, 8 ],
    middle: [ 9, 10, 11, 12 ],
    ring: [ 13, 14, 15, 16 ],
    pinky: [ 17, 18, 19, 20 ],
    palm: [ 0 ]
};

async function L4(e, t) {
    b2 || function() {
        const r = Zo ? new tZ(Zo) : void 0;
        r && Yo && (b2 = new nZ(r, Yo));
    }();
    const n = await b2.estimateHands(e, t);
    if (!n) return [];
    const a = [];
    for (let r = 0; r < n.length; r++) {
        const s = {};
        if (n[r].landmarks) for (const u of Object.keys(z4)) s[u] = z4[u].map(c => n[r].landmarks[c]);
        const i = n[r].landmarks;
        let l = [ Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0, 0 ], o = [ 0, 0, 0, 0 ];
        if (i && i.length > 0) {
            for (const u of i) u[0] < l[0] && (l[0] = u[0]), u[1] < l[1] && (l[1] = u[1]), 
            u[0] > l[2] && (l[2] = u[0]), u[1] > l[3] && (l[3] = u[1]);
            l[2] -= l[0], l[3] -= l[1], o = [ l[0] / (e.shape[2] || 0), l[1] / (e.shape[1] || 0), l[2] / (e.shape[2] || 0), l[3] / (e.shape[1] || 0) ];
        } else l = n[r].box ? [ Math.trunc(Math.max(0, n[r].box.topLeft[0])), Math.trunc(Math.max(0, n[r].box.topLeft[1])), Math.trunc(Math.min(e.shape[2] || 0, n[r].box.bottomRight[0]) - Math.max(0, n[r].box.topLeft[0])), Math.trunc(Math.min(e.shape[1] || 0, n[r].box.bottomRight[1]) - Math.max(0, n[r].box.topLeft[1])) ] : [ 0, 0, 0, 0 ], 
        o = [ n[r].box.topLeft[0] / (e.shape[2] || 0), n[r].box.topLeft[1] / (e.shape[1] || 0), (n[r].box.bottomRight[0] - n[r].box.topLeft[0]) / (e.shape[2] || 0), (n[r].box.bottomRight[1] - n[r].box.topLeft[1]) / (e.shape[1] || 0) ];
        const p = $4(i);
        a.push({
            id: r,
            score: Math.round(100 * n[r].confidence) / 100,
            boxScore: Math.round(100 * n[r].boxConfidence) / 100,
            fingerScore: Math.round(100 * n[r].fingerConfidence) / 100,
            label: "hand",
            box: l,
            boxRaw: o,
            keypoints: i,
            annotations: s,
            landmarks: p
        });
    }
    return a;
}

var Et = [ null, null ], aZ = [ "StatefulPartitionedCall/Postprocessor/Slice", "StatefulPartitionedCall/Postprocessor/ExpandDims_1" ], ss = [ [ 0, 0 ], [ 0, 0 ] ], rZ = [ "hand", "fist", "pinch", "point", "face", "tip", "pinchtip" ], W4 = 4, sZ = 512, iZ = 1.4, Ih = Number.MAX_SAFE_INTEGER, v2 = 0, dr = [ 0, 0 ], Wt = {
    boxes: [],
    hands: []
}, B4 = {
    thumb: [ 1, 2, 3, 4 ],
    index: [ 5, 6, 7, 8 ],
    middle: [ 9, 10, 11, 12 ],
    ring: [ 13, 14, 15, 16 ],
    pinky: [ 17, 18, 19, 20 ],
    base: [ 0 ],
    palm: [ 0, 17, 13, 9, 5, 1, 0 ]
};

async function V4(e, t, n) {
    const a = {
        id: t.id,
        score: Math.round(100 * t.score) / 100,
        boxScore: Math.round(100 * t.score) / 100,
        fingerScore: 0,
        box: t.box,
        boxRaw: t.boxRaw,
        label: t.label,
        keypoints: [],
        landmarks: {},
        annotations: {}
    };
    if (e && Et[1] && n.hand.landmarks && t.score > (n.hand.minConfidence || 0)) {
        const r = {}, s = [ t.boxRaw[1], t.boxRaw[0], t.boxRaw[3] + t.boxRaw[1], t.boxRaw[2] + t.boxRaw[0] ];
        r.crop = Ue.cropAndResize(e, [ s ], [ 0 ], [ ss[1][0], ss[1][1] ], "bilinear"), 
        r.div = ze(r.crop, lt.tf255), [ r.score, r.keypoints ] = Et[1].execute(r.div, [ "Identity_1", "Identity" ]);
        const i = (await r.score.data())[0], l = (100 - Math.trunc(100 / (1 + Math.exp(i)))) / 100;
        if (l >= (n.hand.minConfidence || 0)) {
            a.fingerScore = l, r.reshaped = Q(r.keypoints, [ -1, 3 ]);
            const o = (await r.reshaped.array()).map(p => [ p[0] / ss[1][1], p[1] / ss[1][0], p[2] || 0 ]).map(p => [ p[0] * t.boxRaw[2], p[1] * t.boxRaw[3], p[2] || 0 ]);
            a.keypoints = o.map(p => [ dr[0] * (p[0] + t.boxRaw[0]), dr[1] * (p[1] + t.boxRaw[1]), p[2] || 0 ]), 
            a.landmarks = $4(a.keypoints);
            for (const p of Object.keys(B4)) a.annotations[p] = B4[p].map(u => a.landmarks && a.keypoints[u] ? a.keypoints[u] : null);
        }
        Object.keys(r).forEach(o => ae(r[o]));
    }
    return a;
}

async function U4(e, t) {
    var n, a;
    if (!((n = Et[0]) != null && n.executor && ((a = Et[1]) != null && a.executor) && Et[0].inputs[0].shape && Et[1].inputs[0].shape)) return [];
    dr = [ e.shape[2] || 0, e.shape[1] || 0 ], Ih++;
    const r = (t.hand.skipTime || 0) > se() - v2, s = Ih < (t.hand.skipFrames || 0);
    return t.skipAllowed && r && s ? Wt.hands : new Promise(async i => {
        const l = 3 * (t.hand.skipTime || 0) > se() - v2, o = Ih < 3 * (t.hand.skipFrames || 0);
        t.skipAllowed && Wt.hands.length === t.hand.maxDetected || t.skipAllowed && l && o && Wt.hands.length > 0 ? Wt.hands = await Promise.all(Wt.boxes.map(u => V4(e, u, t))) : (Wt.boxes = await async function(u, c) {
            const d = [];
            if (!u || !Et[0]) return d;
            const h = {}, f = (u.shape[2] || 1) / (u.shape[1] || 1), m = Math.min(8 * Math.round((u.shape[1] || 0) / 8), sZ), g = 8 * Math.round(m * f / 8);
            h.resize = Ue.resizeBilinear(u, [ m, g ]), h.cast = Qe(h.resize, "int32"), 
            [ h.rawScores, h.rawBoxes ] = await Et[0].executeAsync(h.cast, aZ), 
            h.boxes = at(h.rawBoxes, [ 0, 2 ]), h.scores = at(h.rawScores, [ 0 ]);
            const y = la(h.scores, 1);
            ae(y[W4]), y.splice(W4, 1), h.filtered = Bn(y, 1), ae(y), h.max = Jn(h.filtered, 1), 
            h.argmax = Zl(h.filtered, 1);
            let A = 0;
            h.nms = await Ue.nonMaxSuppressionAsync(h.boxes, h.max, (c.hand.maxDetected || 0) + 1, c.hand.iouThreshold || 0, c.hand.minConfidence || 1);
            const x = await h.nms.data(), b = await h.max.data(), v = await h.argmax.data();
            for (const I of Array.from(x)) {
                const N = He(h.boxes, I, 1), T = await N.data();
                ae(N);
                const R = [ T[1], T[0], T[3] - T[1], T[2] - T[0] ], w = j1(R, iZ), E = [ Math.trunc(R[0] * dr[0]), Math.trunc(R[1] * dr[1]), Math.trunc(R[2] * dr[0]), Math.trunc(R[3] * dr[1]) ], $ = {
                    id: A++,
                    score: b[I],
                    box: E,
                    boxRaw: w,
                    label: rZ[v[I]]
                };
                d.push($);
            }
            return Object.keys(h).forEach(I => ae(h[I])), d.sort((I, N) => N.score - I.score), 
            d.length > (c.hand.maxDetected || 1) && (d.length = c.hand.maxDetected || 1), 
            d;
        }(e, t), v2 = se(), Wt.hands = await Promise.all(Wt.boxes.map(u => V4(e, u, t))), 
        Ih = 0);
        const p = [ ...Wt.boxes ];
        if (Wt.boxes.length = 0, t.cacheSensitivity > 0) for (let u = 0; u < Wt.hands.length; u++) {
            const c = fK(Wt.hands[u].keypoints, dr);
            if (c.box[2] / (e.shape[2] || 1) > .05 && c.box[3] / (e.shape[1] || 1) > .05 && Wt.hands[u].fingerScore && Wt.hands[u].fingerScore > (t.hand.minConfidence || 0)) {
                const d = j1(c.box, 1.6), h = j1(c.boxRaw, 1.6);
                Wt.boxes.push({
                    ...p[u],
                    box: d,
                    boxRaw: h
                });
            }
        }
        for (let u = 0; u < Wt.hands.length; u++) {
            const c = ph(Wt.hands[u].keypoints, dr);
            Wt.hands[u].box = c.box, Wt.hands[u].boxRaw = c.boxRaw;
        }
        i(Wt.hands);
    });
}

var _u = (e = null) => ({
    face: [],
    body: [],
    hand: [],
    gesture: [],
    object: [],
    persons: [],
    performance: {},
    timestamp: 0,
    width: 0,
    height: 0,
    error: e
}), G4 = {};

fr(G4, {
    connected: () => k2,
    horizontal: () => H4,
    kpt: () => w2,
    relative: () => q4,
    vertical: () => j4
});

var _n, w2 = [ "nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle" ], H4 = [ [ "leftEye", "rightEye" ], [ "leftEar", "rightEar" ], [ "leftShoulder", "rightShoulder" ], [ "leftElbow", "rightElbow" ], [ "leftWrist", "rightWrist" ], [ "leftHip", "rightHip" ], [ "leftKnee", "rightKnee" ], [ "leftAnkle", "rightAnkle" ] ], j4 = [ [ "leftKnee", "leftShoulder" ], [ "rightKnee", "rightShoulder" ], [ "leftAnkle", "leftKnee" ], [ "rightAnkle", "rightKnee" ] ], q4 = [ [ [ "leftHip", "rightHip" ], [ "leftShoulder", "rightShoulder" ] ], [ [ "leftElbow", "rightElbow" ], [ "leftShoulder", "rightShoulder" ] ] ], k2 = {
    leftLeg: [ "leftHip", "leftKnee", "leftAnkle" ],
    rightLeg: [ "rightHip", "rightKnee", "rightAnkle" ],
    torso: [ "leftShoulder", "rightShoulder", "rightHip", "leftHip", "leftShoulder" ],
    leftArm: [ "leftShoulder", "leftElbow", "leftWrist" ],
    rightArm: [ "rightShoulder", "rightElbow", "rightWrist" ],
    head: []
}, be = _u(), I2 = 0;

async function X4(e) {
    return !_n || ce.initial ? _n = await xt(e.segmentation.modelPath) : e.debug && ee(_n.modelUrl), 
    _n;
}

var K4 = {};

function S2(e, t, n = {
    order: 2,
    multiplier: 25
}) {
    if (!e || !e) return Number.MAX_SAFE_INTEGER;
    let a = 0;
    for (let r = 0; r < e.length; r++) {
        const s = n.order && n.order !== 2 ? Math.abs(e[r] - t[r]) : e[r] - t[r];
        a += n.order && n.order !== 2 ? s ** n.order : s * s;
    }
    return (n.multiplier || 20) * a;
}

fr(K4, {
    distance: () => S2,
    find: () => lZ,
    similarity: () => oZ
});

var Z4 = (e, t, n, a) => {
    if (e === 0) return 1;
    const r = (1 - (t === 2 ? Math.sqrt(e) : e ** (1 / t)) / 100 - n) / (a - n);
    return Math.max(Math.min(r, 1), 0);
};

function oZ(e, t, n = {
    order: 2,
    multiplier: 25,
    min: .2,
    max: .8
}) {
    const a = S2(e, t, n);
    return Z4(a, n.order || 2, n.min || 0, n.max || 1);
}

function lZ(e, t, n = {
    order: 2,
    multiplier: 25,
    threshold: 0,
    min: .2,
    max: .8
}) {
    if (!Array.isArray(e) || !Array.isArray(t) || e.length < 64 || t.length === 0) return {
        index: -1,
        distance: Number.POSITIVE_INFINITY,
        similarity: 0
    };
    let a = Number.MAX_SAFE_INTEGER, r = -1;
    for (let s = 0; s < t.length; s++) {
        const i = t[s].length === e.length ? S2(e, t[s], n) : Number.MAX_SAFE_INTEGER;
        if (i < a && (a = i, r = s), a < (n.threshold || 0)) break;
    }
    return {
        index: r,
        distance: a,
        similarity: Z4(a, n.order || 2, n.min || 0, n.max || 1)
    };
}

fr({}, {
    Models: () => h6,
    validateModel: () => $2
});

var xn, Y4 = .005, Xn = {
    keypoints: [],
    padding: [ [ 0, 0 ], [ 0, 0 ], [ 0, 0 ], [ 0, 0 ] ]
};

function J4(e) {
    for (const t of H4) {
        const n = e.keypoints.findIndex(r => r.part === t[0]), a = e.keypoints.findIndex(r => r.part === t[1]);
        if (e.keypoints[n] && e.keypoints[a] && e.keypoints[n].position[0] < e.keypoints[a].position[0]) {
            const r = e.keypoints[n];
            e.keypoints[n] = e.keypoints[a], e.keypoints[a] = r;
        }
    }
    for (const t of j4) {
        const n = e.keypoints.findIndex(r => r && r.part === t[0]), a = e.keypoints.findIndex(r => r && r.part === t[1]);
        e.keypoints[n] && e.keypoints[a] && e.keypoints[n].position[1] < e.keypoints[a].position[1] && e.keypoints.splice(n, 1);
    }
    for (const [ t, n ] of q4) {
        const a = e.keypoints.findIndex(p => p && p.part === t[0]), r = e.keypoints.findIndex(p => p && p.part === t[1]), s = e.keypoints.findIndex(p => p && p.part === n[0]), i = e.keypoints.findIndex(p => p && p.part === n[1]);
        if (!e.keypoints[s] || !e.keypoints[i]) continue;
        const l = e.keypoints[a] ? [ Math.abs(e.keypoints[s].position[0] - e.keypoints[a].position[0]), Math.abs(e.keypoints[i].position[0] - e.keypoints[a].position[0]) ] : [ 0, 0 ], o = e.keypoints[r] ? [ Math.abs(e.keypoints[i].position[0] - e.keypoints[r].position[0]), Math.abs(e.keypoints[s].position[0] - e.keypoints[r].position[0]) ] : [ 0, 0 ];
        if (l[0] > l[1] || o[0] > o[1]) {
            const p = e.keypoints[a];
            e.keypoints[a] = e.keypoints[r], e.keypoints[r] = p;
        }
    }
}

function uZ(e) {
    for (let t = 0; t < e.length; t++) if (e[t] && Xn.keypoints[t]) {
        const n = [ Math.abs(e[t].positionRaw[0] - Xn.keypoints[t].positionRaw[0]), Math.abs(e[t].positionRaw[1] - Xn.keypoints[t].positionRaw[1]) ];
        n[0] < Y4 && n[1] < Y4 ? e[t] = Xn.keypoints[t] : Xn.keypoints[t] = e[t];
    } else Xn.keypoints[t] = e[t];
    return e;
}

function dZ(e, t) {
    e.keypoints = e.keypoints.filter(a => a == null ? void 0 : a.position);
    for (const a of e.keypoints) a.position = [ a.position[0] * (t[0] + Xn.padding[2][0] + Xn.padding[2][1]) / t[0] - Xn.padding[2][0], a.position[1] * (t[1] + Xn.padding[1][0] + Xn.padding[1][1]) / t[1] - Xn.padding[1][0] ], 
    a.positionRaw = [ a.position[0] / t[0], a.position[1] / t[1] ];
    const n = ph(e.keypoints.map(a => a.position), t);
    return e.box = n.box, e.boxRaw = n.boxRaw, e;
}

var pr, N2 = 0, C2 = Number.MAX_SAFE_INTEGER, Jo = {
    boxes: [],
    bodies: [],
    last: 0
};

async function Q4(e, t) {
    var n;
    if (!(xn != null && xn.executor) || !((n = xn == null ? void 0 : xn.inputs) != null && n[0].shape)) return [];
    t.skipAllowed || (Jo.boxes.length = 0), C2++;
    const a = (t.body.skipTime || 0) > se() - Jo.last, r = C2 < (t.body.skipFrames || 0);
    return t.skipAllowed && a && r ? Jo.bodies : new Promise(async s => {
        const i = {};
        C2 = 0, i.input = function(o, p) {
            var u, c;
            const d = {};
            if (!((u = o == null ? void 0 : o.shape) != null && u[1]) || !((c = o == null ? void 0 : o.shape) != null && c[2])) return o;
            Xn.padding = [ [ 0, 0 ], [ o.shape[2] > o.shape[1] ? Math.trunc((o.shape[2] - o.shape[1]) / 2) : 0, o.shape[2] > o.shape[1] ? Math.trunc((o.shape[2] - o.shape[1]) / 2) : 0 ], [ o.shape[1] > o.shape[2] ? Math.trunc((o.shape[1] - o.shape[2]) / 2) : 0, o.shape[1] > o.shape[2] ? Math.trunc((o.shape[1] - o.shape[2]) / 2) : 0 ], [ 0, 0 ] ], 
            d.pad = Or(o, Xn.padding), d.resize = Ue.resizeBilinear(d.pad, [ p, p ]);
            const h = Qe(d.resize, "int32");
            return Object.keys(d).forEach(f => ae(d[f])), h;
        }(e, N2), i.res = xn == null ? void 0 : xn.execute(i.input), Jo.last = se();
        const l = await i.res.array();
        Jo.bodies = i.res.shape[2] === 17 ? function(o, p, u) {
            const c = o[0][0], d = [];
            let h = 0;
            for (let A = 0; A < c.length; A++) if (h = c[A][2], h > p.body.minConfidence) {
                const x = [ c[A][1], c[A][0] ];
                d.push({
                    score: Math.round(100 * h) / 100,
                    part: w2[A],
                    positionRaw: x,
                    position: [ Math.round((u.shape[2] || 0) * x[0]), Math.round((u.shape[1] || 0) * x[1]) ]
                });
            }
            h = d.reduce((A, x) => x.score > A ? x.score : A, 0);
            const f = [], m = ph(d.map(A => A.position), [ u.shape[2], u.shape[1] ]), g = {};
            for (const [ A, x ] of Object.entries(k2)) {
                const b = [];
                for (let v = 0; v < x.length - 1; v++) {
                    const I = d.find(T => T.part === x[v]), N = d.find(T => T.part === x[v + 1]);
                    I && N && I.score > (p.body.minConfidence || 0) && N.score > (p.body.minConfidence || 0) && b.push([ I.position, N.position ]);
                }
                g[A] = b;
            }
            const y = {
                id: 0,
                score: h,
                box: m.box,
                boxRaw: m.boxRaw,
                keypoints: d,
                annotations: g
            };
            return J4(y), f.push(y), f;
        }(l, t, e) : function(o, p, u) {
            const c = [];
            for (let d = 0; d < o[0].length; d++) {
                const h = o[0][d], f = Math.round(100 * h[55]) / 100;
                if (f > p.body.minConfidence) {
                    const m = [];
                    for (let b = 0; b < 17; b++) {
                        const v = h[3 * b + 2];
                        if (v > p.body.minConfidence) {
                            const I = [ h[3 * b + 1], h[3 * b + 0] ];
                            m.push({
                                part: w2[b],
                                score: Math.round(100 * v) / 100,
                                positionRaw: I,
                                position: [ Math.round((u.shape[2] || 0) * I[0]), Math.round((u.shape[1] || 0) * I[1]) ]
                            });
                        }
                    }
                    const g = [ h[52], h[51], h[54] - h[52], h[53] - h[51] ], y = [ Math.trunc(g[0] * (u.shape[2] || 0)), Math.trunc(g[1] * (u.shape[1] || 0)), Math.trunc(g[2] * (u.shape[2] || 0)), Math.trunc(g[3] * (u.shape[1] || 0)) ], A = {};
                    for (const [ b, v ] of Object.entries(k2)) {
                        const I = [];
                        for (let N = 0; N < v.length - 1; N++) {
                            const T = m.find(w => w.part === v[N]), R = m.find(w => w.part === v[N + 1]);
                            T && R && T.score > (p.body.minConfidence || 0) && R.score > (p.body.minConfidence || 0) && I.push([ T.position, R.position ]);
                        }
                        A[b] = I;
                    }
                    const x = {
                        id: d,
                        score: f,
                        box: y,
                        boxRaw: g,
                        keypoints: [ ...m ],
                        annotations: A
                    };
                    J4(x), c.push(x);
                }
            }
            return c.sort((d, h) => h.score - d.score), c.length > p.body.maxDetected && (c.length = p.body.maxDetected), 
            c;
        }(l, t, e);
        for (const o of Jo.bodies) dZ(o, [ e.shape[2] || 1, e.shape[1] || 1 ]), 
        uZ(o.keypoints);
        Object.keys(i).forEach(o => ae(i[o])), s(Jo.bodies);
    });
}

var Sh = [], e6 = 0, T2 = Number.MAX_SAFE_INTEGER, Nh = 0, Ch = 2.5;

async function t6(e, t) {
    if (!(pr != null && pr.executor)) return [];
    const n = (t.object.skipTime || 0) > se() - e6, a = T2 < (t.object.skipFrames || 0);
    return t.skipAllowed && n && a && Sh.length > 0 ? (T2++, Sh) : (T2 = 0, ce.kernels.includes("mod") && ce.kernels.includes("sparsetodense") ? new Promise(async r => {
        const s = [ e.shape[2] || 0, e.shape[1] || 0 ], i = Ue.resizeBilinear(e, [ Nh, Nh ], !1), l = ze(i, lt.tf255), o = au(l, [ 0, 3, 1, 2 ]);
        let p;
        t.object.enabled && (p = pr.execute(o)), e6 = se();
        const u = await async function(c, d, h) {
            var f, m;
            let g = 0, y = [];
            const A = Nh;
            for (const I of [ 1, 2, 4 ]) {
                const N = 13 * I, T = at(c.find(F => F.shape[1] === N ** 2 && (F.shape[2] || 0) === hh.length)), R = await T.array(), w = at(c.find(F => F.shape[1] === N ** 2 && (F.shape[2] || 0) < hh.length)), E = Q(w, [ -1, 4, (((f = w.shape) == null ? void 0 : f[1]) || 0) / 4 ]), $ = Zl(E, 2), M = await $.array();
                for (let F = 0; F < T.shape[0]; F++) for (let P = 0; P < (((m = T.shape) == null ? void 0 : m[1]) || 0); P++) {
                    const L = R[F][P];
                    if (L > (h.object.minConfidence || 0) && P !== 61) {
                        const O = (.5 + Math.trunc(F % N)) / N, B = (.5 + Math.trunc(F / N)) / N, G = M[F].map(re => re * (N / I / A)), [ W, z ] = [ O - Ch / I * G[0], B - Ch / I * G[1] ], [ X, q ] = [ O + Ch / I * G[2] - W, B + Ch / I * G[3] - z ];
                        let Z = [ W, z, X, q ];
                        Z = Z.map(re => Math.max(0, Math.min(re, 1)));
                        const Y = [ Z[0] * d[0], Z[1] * d[1], Z[2] * d[0], Z[3] * d[1] ], te = {
                            id: g++,
                            score: Math.round(100 * L) / 100,
                            class: P + 1,
                            label: hh[P].label,
                            box: Y.map(re => Math.trunc(re)),
                            boxRaw: Z
                        };
                        y.push(te);
                    }
                }
                ae([ T, w, E, $ ]);
            }
            const x = y.map(I => [ I.boxRaw[1], I.boxRaw[0], I.boxRaw[3], I.boxRaw[2] ]), b = y.map(I => I.score);
            let v = [];
            if (x && x.length > 0) {
                const I = await Ue.nonMaxSuppressionAsync(x, b, h.object.maxDetected || 0, h.object.iouThreshold, h.object.minConfidence);
                v = Array.from(await I.data()), ae(I);
            }
            return y = y.filter((I, N) => v.includes(N)).sort((I, N) => N.score - I.score), 
            y;
        }(p, s, t);
        Sh = u, ae([ i, l, o, ...p ]), r(u);
    }) : Sh);
}

var Th = [ "nose", "leftEye", "rightEye", "leftEar", "rightEar", "leftShoulder", "rightShoulder", "leftElbow", "rightElbow", "leftWrist", "rightWrist", "leftHip", "rightHip", "leftKnee", "rightKnee", "leftAnkle", "rightAnkle" ], pZ = Th.length, Rh = Th.reduce((e, t, n) => (e[t] = n, 
e), {});

[ [ "leftHip", "leftShoulder" ], [ "leftElbow", "leftShoulder" ], [ "leftElbow", "leftWrist" ], [ "leftHip", "leftKnee" ], [ "leftKnee", "leftAnkle" ], [ "rightHip", "rightShoulder" ], [ "rightElbow", "rightShoulder" ], [ "rightElbow", "rightWrist" ], [ "rightHip", "rightKnee" ], [ "rightKnee", "rightAnkle" ], [ "leftShoulder", "rightShoulder" ], [ "leftHip", "rightHip" ] ].map(([ e, t ]) => [ Rh[e], Rh[t] ]);

var cZ = [ [ "nose", "leftEye" ], [ "leftEye", "leftEar" ], [ "nose", "rightEye" ], [ "rightEye", "rightEar" ], [ "nose", "leftShoulder" ], [ "leftShoulder", "leftElbow" ], [ "leftElbow", "leftWrist" ], [ "leftShoulder", "leftHip" ], [ "leftHip", "leftKnee" ], [ "leftKnee", "leftAnkle" ], [ "nose", "rightShoulder" ], [ "rightShoulder", "rightElbow" ], [ "rightElbow", "rightWrist" ], [ "rightShoulder", "rightHip" ], [ "rightHip", "rightKnee" ], [ "rightKnee", "rightAnkle" ] ];

function hZ(e) {
    const t = e.reduce(({
        maxX: n,
        maxY: a,
        minX: r,
        minY: s
    }, {
        position: {
            x: i,
            y: l
        }
    }) => ({
        maxX: Math.max(n, i),
        maxY: Math.max(a, l),
        minX: Math.min(r, i),
        minY: Math.min(s, l)
    }), {
        maxX: Number.NEGATIVE_INFINITY,
        maxY: Number.NEGATIVE_INFINITY,
        minX: Number.POSITIVE_INFINITY,
        minY: Number.POSITIVE_INFINITY
    });
    return [ t.minX, t.minY, t.maxX - t.minX, t.maxY - t.minY ];
}

function fZ(e, [ t, n ], [ a, r ]) {
    const s = t / a, i = n / r;
    return e.map((l, o) => ((p, u) => ({
        id: u,
        score: p.score,
        boxRaw: [ p.box[0] / r, p.box[1] / a, p.box[2] / r, p.box[3] / a ],
        box: [ Math.trunc(p.box[0] * i), Math.trunc(p.box[1] * s), Math.trunc(p.box[2] * i), Math.trunc(p.box[3] * s) ],
        keypoints: p.keypoints.map(({
            score: c,
            part: d,
            position: h
        }) => ({
            score: c,
            part: d,
            position: [ Math.trunc(h.x * i), Math.trunc(h.y * s) ],
            positionRaw: [ h.x / a, h.y / a ]
        })),
        annotations: {}
    }))(l, o));
}

var aa, mZ = class {
    constructor(e, t) {
        ve(this, "priorityQueue"), ve(this, "numberOfElements"), ve(this, "getElementValue"), 
        this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;
    }
    enqueue(e) {
        this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);
    }
    dequeue() {
        const e = this.priorityQueue[0];
        return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, 
        e;
    }
    empty() {
        return this.numberOfElements === -1;
    }
    size() {
        return this.numberOfElements + 1;
    }
    all() {
        return this.priorityQueue.slice(0, this.numberOfElements + 1);
    }
    max() {
        return this.priorityQueue[0];
    }
    swim(e) {
        for (;e > 0 && this.less(Math.floor(e / 2), e); ) this.exchange(e, Math.floor(e / 2)), 
        e = Math.floor(e / 2);
    }
    sink(e) {
        for (;2 * e <= this.numberOfElements; ) {
            let t = 2 * e;
            if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;
            this.exchange(e, t), e = t;
        }
    }
    getValueAt(e) {
        return this.getElementValue(this.priorityQueue[e]);
    }
    less(e, t) {
        return this.getValueAt(e) < this.getValueAt(t);
    }
    exchange(e, t) {
        const n = this.priorityQueue[e];
        this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;
    }
};

function n6(e, t, n, a) {
    return {
        y: a.get(e, t, n),
        x: a.get(e, t, n + pZ)
    };
}

function a6(e, t, n) {
    const {
        heatmapY: a,
        heatmapX: r,
        id: s
    } = e, {
        y: i,
        x: l
    } = n6(a, r, s, n);
    return {
        x: e.heatmapX * t + l,
        y: e.heatmapY * t + i
    };
}

function r6(e, t, n) {
    return e < t ? t : e > n ? n : e;
}

function s6(e, t) {
    return {
        x: e.x + t.x,
        y: e.y + t.y
    };
}

var cr, gZ = [ "MobilenetV1/offset_2/BiasAdd", "MobilenetV1/heatmap_2/BiasAdd", "MobilenetV1/displacement_fwd_2/BiasAdd", "MobilenetV1/displacement_bwd_2/BiasAdd" ], Eh = 1, Ou = 16, yZ = 2500;

function i6(e, t, n, a, r, s, i = 2) {
    const l = (g, y, A) => ({
        y: r6(Math.round(g.y / Ou), 0, y - 1),
        x: r6(Math.round(g.x / Ou), 0, A - 1)
    }), [ o, p ] = a.shape, u = l(t.position, o, p), c = (d = u, {
        y: s.get(d.y, d.x, e),
        x: s.get(d.y, d.x, s.shape[2] / 2 + e)
    });
    var d;
    let h = s6(t.position, c);
    for (let g = 0; g < i; g++) {
        const y = l(h, o, p), A = n6(y.y, y.x, n, r);
        h = s6({
            x: y.x * Ou,
            y: y.y * Ou
        }, {
            x: A.x,
            y: A.y
        });
    }
    const f = l(h, o, p), m = a.get(f.y, f.x, n);
    return {
        position: h,
        part: Th[n],
        score: m
    };
}

function AZ(e, t, n, a, r) {
    const s = cZ.map(([ d, h ]) => [ Rh[d], Rh[h] ]), i = s.map(([ , d ]) => d), l = s.map(([ d ]) => d), o = t.shape[2], p = i.length, u = new Array(o), c = a6(e.part, Ou, n);
    u[e.part.id] = {
        score: e.score,
        part: Th[e.part.id],
        position: c
    };
    for (let d = p - 1; d >= 0; --d) {
        const h = i[d], f = l[d];
        u[h] && !u[f] && (u[f] = i6(d, u[h], f, t, n, r));
    }
    for (let d = 0; d < p; ++d) {
        const h = l[d], f = i[d];
        u[h] && !u[f] && (u[f] = i6(d, u[h], f, t, n, a));
    }
    return u;
}

function xZ(e, t, n, a, r) {
    const [ s, i ] = r.shape;
    let l = !0;
    const o = Math.max(n - Eh, 0), p = Math.min(n + Eh + 1, s);
    for (let u = o; u < p; ++u) {
        const c = Math.max(a - Eh, 0), d = Math.min(a + Eh + 1, i);
        for (let h = c; h < d; ++h) if (r.get(u, h, e) > t) {
            l = !1;
            break;
        }
        if (!l) break;
    }
    return l;
}

function o6(e, {
    x: t,
    y: n
}, a) {
    return e.some(({
        keypoints: r
    }) => {
        var s;
        const i = (s = r[a]) == null ? void 0 : s.position;
        return !!i && function(l, o, p, u) {
            const c = p - l, d = u - o;
            return c * c + d * d;
        }(n, t, i.y, i.x) <= yZ;
    });
}

function bZ(e, t) {
    return t.reduce((n, {
        position: a,
        score: r
    }, s) => (o6(e, a, s) || (n += r), n), 0) / t.length;
}

function vZ(e, t, n, a, r, s) {
    const i = [], l = function(o, p) {
        const [ u, c, d ] = p.shape, h = new mZ(u * c * d, ({
            score: f
        }) => f);
        for (let f = 0; f < u; ++f) for (let m = 0; m < c; ++m) for (let g = 0; g < d; ++g) {
            const y = p.get(f, m, g);
            y < o || xZ(g, y, f, m, p) && h.enqueue({
                score: y,
                part: {
                    heatmapY: f,
                    heatmapX: m,
                    id: g
                }
            });
        }
        return h;
    }(s, t);
    for (;i.length < r && !l.empty(); ) {
        const o = l.dequeue();
        if (o6(i, a6(o.part, Ou, e), o.part.id)) continue;
        let p = AZ(o, t, e, n, a);
        p = p.filter(d => d.score > s);
        const u = bZ(i, p), c = hZ(p);
        u > s && i.push({
            keypoints: p,
            box: c,
            score: Math.round(100 * u) / 100
        });
    }
    return i;
}

async function l6(e, t) {
    if (!(aa != null && aa.executor)) return [];
    const n = qe(() => {
        if (!aa.inputs[0].shape) return [];
        const s = Ue.resizeBilinear(e, [ aa.inputs[0].shape[2], aa.inputs[0].shape[1] ]), i = $e(ze(Qe(s, "float32"), 127.5), 1), l = aa.execute(i, gZ).map(o => at(o, [ 0 ]));
        return l[1] = va(l[1]), l;
    }), a = await Promise.all(n.map(s => s.buffer()));
    for (const s of n) ae(s);
    const r = vZ(a[0], a[1], a[2], a[3], t.body.maxDetected, t.body.minConfidence);
    return aa.inputs[0].shape ? fZ(r, [ e.shape[1], e.shape[2] ], [ aa.inputs[0].shape[2], aa.inputs[0].shape[1] ]) : [];
}

var wZ = [ "fgr", "pha", "r1o", "r2o", "r3o", "r4o" ], Pt = {}, R2 = 0;

function u6(e) {
    ae([ Pt.r1i, Pt.r2i, Pt.r3i, Pt.r4i, Pt.downsample_ratio ]), Pt.r1i = Ye(0), 
    Pt.r2i = Ye(0), Pt.r3i = Ye(0), Pt.r4i = Ye(0), R2 = e.segmentation.ratio || .5, 
    Pt.downsample_ratio = Ye(R2);
}

async function d6(e) {
    return !cr || ce.initial ? cr = await xt(e.segmentation.modelPath) : e.debug && ee(cr.modelUrl), 
    u6(e), cr;
}

var On, p6 = e => qe(() => {
    const t = at(e, [ 0 ]), n = ne(t, lt.tf255);
    return Qe(n, "int32");
});

function E2(e, t) {
    const n = e ? p6(e) : Qa([ t.shape[1] || 0, t.shape[2] || 0, 3 ], 255, "int32"), a = t ? p6(t) : Qa([ e.shape[1] || 0, e.shape[2] || 0, 1 ], 255, "int32"), r = yt([ n, a ], -1);
    return ae([ n, a ]), r;
}

async function kZ(e, t) {
    if (cr || (cr = await d6(t)), !(cr != null && cr.executor)) return null;
    Pt.src = ze(e, 255), R2 !== t.segmentation.ratio && u6(t);
    const [ n, a, r, s, i, l ] = await cr.executeAsync(Pt, wZ);
    let o;
    switch (t.segmentation.mode || "default") {
      case "default":
        o = E2(n, a);
        break;

      case "alpha":
        o = E2(null, a);
        break;

      case "foreground":
        o = E2(n, null);
        break;

      case "state":
        p = r, o = qe(() => {
            const u = {};
            return u.unstack = la(p, -1), u.concat = yt(u.unstack, 1), u.split = Ia(u.concat, 4, 1), 
            u.stack = yt(u.split, 2), u.squeeze = at(u.stack, [ 0 ]), u.expand = pn(u.squeeze, -1), 
            u.add = _e(u.expand, 1), u.mul = ne(u.add, 127.5), u.cast = Qe(u.mul, "int32"), 
            u.tile = Ao(u.cast, [ 1, 1, 3 ]), u.alpha = Qa([ u.tile.shape[0] || 0, u.tile.shape[1] || 0, 1 ], 255, "int32"), 
            yt([ u.tile, u.alpha ], -1);
        });
        break;

      default:
        o = Ye(0);
    }
    var p;
    return ae([ Pt.src, n, a, Pt.r1i, Pt.r2i, Pt.r3i, Pt.r4i ]), [ Pt.r1i, Pt.r2i, Pt.r3i, Pt.r4i ] = [ r, s, i, l ], 
    o;
}

async function c6(e) {
    return !On || ce.initial ? On = await xt(e.segmentation.modelPath) : e.debug && ee(On.modelUrl), 
    On;
}

function $2(e, t, n) {
    var a, r;
    if (!t || !((a = e == null ? void 0 : e.config) != null && a.validateModels)) return null;
    const s = [ "const", "placeholder", "noop", "pad", "squeeze", "add", "sub", "mul", "div" ], i = [ "biasadd", "fusedbatchnormv3", "matmul", "switch", "shape", "merge", "split", "broadcastto" ], l = [], o = [], p = t.modelUrl, u = t.executor;
    if ((r = u == null ? void 0 : u.graph) != null && r.nodes) for (const c of Object.values(u.graph.nodes)) {
        const d = c.op.toLowerCase();
        l.includes(d) || l.push(d);
    } else !u && e.config.debug && ee();
    for (const c of l) s.includes(c) || i.includes(c) || e.env.kernels.includes(c) || e.env.kernels.includes(c.replace("_", "")) || e.env.kernels.includes(c.replace("native", "")) || e.env.kernels.includes(c.replace("v2", "")) || o.push(c);
    return e.config.debug && o.length > 0 && ee(), o.length > 0 ? {
        name: n,
        missing: o,
        ops: l,
        url: p
    } : null;
}

var h6 = class {
    constructor(e) {
        ve(this, "instance"), ve(this, "models", {}), this.models = {}, this.instance = e;
    }
    stats() {
        let e = 0, t = 0, n = 0;
        for (const r of Object.values(yn)) e += r.sizeFromManifest, t += r.sizeLoadedWeights, 
        n += r.sizeDesired;
        const a = n > 0 ? t / n : 0;
        return {
            numLoadedModels: Object.values(yn).length,
            numDefinedModels: Object.keys(this.models).length,
            percentageLoaded: a,
            totalSizeFromManifest: e,
            totalSizeWeights: t,
            totalSizeLoading: n,
            modelStats: Object.values(yn)
        };
    }
    reset() {
        for (const e of Object.keys(this.models)) this.models[e] = null;
    }
    async load(e) {
        var t, n, a, r, s, i, l, o, p, u, c, d, h, f, m, g, y, A, x, b, v, I, N, T, R, w, E;
        ce.initial && this.reset(), e && (this.instance = e);
        const $ = {};
        $.blazeface = this.instance.config.face.enabled && !this.models.blazeface ? NK(this.instance.config) : null, 
        $.antispoof = this.instance.config.face.enabled && ((t = this.instance.config.face.antispoof) != null && t.enabled) && !this.models.antispoof ? async function(M) {
            var F;
            return ce.initial && (En = null), En ? M.debug && ee(En.modelUrl) : En = await xt((F = M.face.antispoof) == null ? void 0 : F.modelPath), 
            En;
        }(this.instance.config) : null, $.liveness = this.instance.config.face.enabled && ((n = this.instance.config.face.liveness) != null && n.enabled) && !this.models.liveness ? async function(M) {
            var F;
            return ce.initial && ($n = null), $n ? M.debug && ee($n.modelUrl) : $n = await xt((F = M.face.liveness) == null ? void 0 : F.modelPath), 
            $n;
        }(this.instance.config) : null, $.faceres = this.instance.config.face.enabled && ((a = this.instance.config.face.description) != null && a.enabled) && !this.models.faceres ? async function(M) {
            var F;
            return ce.initial && (Rn = null), Rn ? M.debug && ee(Rn.modelUrl) : Rn = await xt((F = M.face.description) == null ? void 0 : F.modelPath), 
            Rn;
        }(this.instance.config) : null, $.emotion = this.instance.config.face.enabled && ((r = this.instance.config.face.emotion) != null && r.enabled) && !this.models.emotion ? async function(M) {
            var F, P, L;
            return ce.initial && (Tn = null), Tn ? M.debug && ee(Tn.modelUrl) : (Tn = await xt((F = M.face.emotion) == null ? void 0 : F.modelPath), 
            s2 = ((L = (P = Tn == null ? void 0 : Tn.inputs) == null ? void 0 : P[0].shape) == null ? void 0 : L[3]) === 3, 
            Xk = s2 ? [ "angry", "disgust", "fear", "happy", "neutral", "sad", "surprise" ] : [ "angry", "disgust", "fear", "happy", "sad", "surprise", "neutral" ]), 
            Tn;
        }(this.instance.config) : null, $.iris = this.instance.config.face.enabled && ((s = this.instance.config.face.iris) != null && s.enabled) && !((i = this.instance.config.face.attention) != null && i.enabled) && !this.models.iris ? async function(M) {
            var F, P;
            return ce.initial && (ha = null), ha ? M.debug && ee(ha.modelUrl) : ha = await xt((F = M.face.iris) == null ? void 0 : F.modelPath), 
            (Ho = ha != null && ha.executor && ((P = ha.inputs) != null && P[0].shape) ? ha.inputs[0].shape[2] : 0) === -1 && (Ho = 64), 
            ha;
        }(this.instance.config) : null, $.facemesh = this.instance.config.face.enabled && ((l = this.instance.config.face.mesh) != null && l.enabled) && !this.models.facemesh ? async function(M) {
            var F, P, L, O, B, G;
            return ce.initial && (Kt = null), (F = M.face.attention) != null && F.enabled && (Kt != null && Kt.signature) && Object.keys(((P = Kt == null ? void 0 : Kt.signature) == null ? void 0 : P.outputs) || {}).length < 6 && (Kt = null), 
            Kt ? M.debug && ee(Kt.modelUrl) : Kt = (L = M.face.attention) != null && L.enabled ? await xt(M.face.attention.modelPath) : await xt((O = M.face.mesh) == null ? void 0 : O.modelPath), 
            kp = Kt.executor && ((B = Kt == null ? void 0 : Kt.inputs) != null && B[0].shape) ? (G = Kt == null ? void 0 : Kt.inputs) == null ? void 0 : G[0].shape[2] : 256, 
            Kt;
        }(this.instance.config) : null, $.gear = this.instance.config.face.enabled && ((o = this.instance.config.face.gear) != null && o.enabled) && !this.models.gear ? async function(M) {
            var F;
            return ce.initial && (Ra = null), Ra ? M.debug && ee(Ra.modelUrl) : Ra = await xt((F = M.face.gear) == null ? void 0 : F.modelPath), 
            Ra;
        }(this.instance.config) : null, $.ssrnetage = this.instance.config.face.enabled && ((p = this.instance.config.face.ssrnet) != null && p.enabled) && !this.models.ssrnetage ? async function(M) {
            return ce.initial && (Mn = null), Mn ? M.debug && ee(Mn.modelUrl) : Mn = await xt(M.face.ssrnet.modelPathAge), 
            Mn;
        }(this.instance.config) : null, $.ssrnetgender = this.instance.config.face.enabled && ((u = this.instance.config.face.ssrnet) != null && u.enabled) && !this.models.ssrnetgender ? async function(M) {
            var F;
            return ce.initial && (Fn = null), Fn ? M.debug && ee(Fn.modelUrl) : Fn = await xt((F = M.face.ssrnet) == null ? void 0 : F.modelPathGender), 
            Fn;
        }(this.instance.config) : null, $.mobilefacenet = this.instance.config.face.enabled && ((c = this.instance.config.face.mobilefacenet) != null && c.enabled) && !this.models.mobilefacenet ? async function(M) {
            var F;
            return ce.initial && (fa = null), fa ? M.debug && ee(fa.modelUrl) : fa = await xt((F = M.face.mobilefacenet) == null ? void 0 : F.modelPath), 
            fa;
        }(this.instance.config) : null, $.insightface = this.instance.config.face.enabled && ((d = this.instance.config.face.insightface) != null && d.enabled) && !this.models.insightface ? async function(M) {
            return ce.initial && (ma = null), ma ? M.debug && ee(ma.modelUrl) : ma = await xt(M.face.insightface.modelPath), 
            ma;
        }(this.instance.config) : null, $.blazepose = this.instance.config.body.enabled && !this.models.blazepose && ((h = this.instance.config.body.modelPath) != null && h.includes("blazepose")) ? async function(M) {
            if (ce.initial && (Ca = null), Ca) M.debug && ee(Ca.modelUrl); else {
                const F = (Ca = await xt(M.body.modelPath)) != null && Ca.executor ? Object.values(Ca.modelSignature.inputs) : void 0;
                q1 = Array.isArray(F) ? parseInt(F[0].tensorShape.dim[1].size) : 0;
            }
            return Ca;
        }(this.instance.config) : null, $.blazeposedetect = this.instance.config.body.enabled && !this.models.blazeposedetect && this.instance.config.body.detector && this.instance.config.body.detector.modelPath ? cK(this.instance.config) : null, 
        $.efficientpose = this.instance.config.body.enabled && !this.models.efficientpose && ((f = this.instance.config.body.modelPath) != null && f.includes("efficientpose")) ? async function(M) {
            return ce.initial && (Xt = null), Xt ? M.debug && ee(Xt.modelUrl) : Xt = await xt(M.body.modelPath), 
            Xt;
        }(this.instance.config) : null, $.movenet = this.instance.config.body.enabled && !this.models.movenet && ((m = this.instance.config.body.modelPath) != null && m.includes("movenet")) ? async function(M) {
            var F;
            return ce.initial && (xn = null), xn ? M.debug && ee(xn.modelUrl) : (pk([ "size" ], M), 
            xn = await xt(M.body.modelPath)), (N2 = xn != null && xn.executor && ((F = xn == null ? void 0 : xn.inputs) != null && F[0].shape) ? xn.inputs[0].shape[2] : 0) < 64 && (N2 = 256), 
            H().flagRegistry.WEBGL_USE_SHAPES_UNIFORMS && H().set("WEBGL_USE_SHAPES_UNIFORMS", !1), 
            xn;
        }(this.instance.config) : null, $.posenet = this.instance.config.body.enabled && !this.models.posenet && ((g = this.instance.config.body.modelPath) != null && g.includes("posenet")) ? async function(M) {
            return !aa || ce.initial ? aa = await xt(M.body.modelPath) : M.debug && ee(aa.modelUrl), 
            aa;
        }(this.instance.config) : null, $.handtrack = this.instance.config.hand.enabled && !this.models.handtrack && ((A = (y = this.instance.config.hand.detector) == null ? void 0 : y.modelPath) != null && A.includes("handtrack")) ? async function(M) {
            var F;
            if (ce.initial && (Et[0] = null), Et[0]) M.debug && ee(Et[0].modelUrl); else {
                pk([ "tensorlistreserve", "enter", "tensorlistfromtensor", "merge", "loopcond", "switch", "exit", "tensorliststack", "nextiteration", "tensorlistsetitem", "tensorlistgetitem", "reciprocal", "shape", "split", "where" ], M), 
                Et[0] = await xt((F = M.hand.detector) == null ? void 0 : F.modelPath);
                const P = Et[0].executor ? Object.values(Et[0].modelSignature.inputs) : void 0;
                ss[0][0] = Array.isArray(P) ? parseInt(P[0].tensorShape.dim[1].size) : 0, 
                ss[0][1] = Array.isArray(P) ? parseInt(P[0].tensorShape.dim[2].size) : 0;
            }
            return Et[0];
        }(this.instance.config) : null, $.handskeleton = this.instance.config.hand.enabled && this.instance.config.hand.landmarks && !this.models.handskeleton && ((b = (x = this.instance.config.hand.detector) == null ? void 0 : x.modelPath) != null && b.includes("handtrack")) ? async function(M) {
            var F;
            if (ce.initial && (Et[1] = null), Et[1]) M.debug && ee(Et[1].modelUrl); else {
                Et[1] = await xt((F = M.hand.skeleton) == null ? void 0 : F.modelPath);
                const P = Et[1].executor ? Object.values(Et[1].modelSignature.inputs) : void 0;
                ss[1][0] = Array.isArray(P) ? parseInt(P[0].tensorShape.dim[1].size) : 0, 
                ss[1][1] = Array.isArray(P) ? parseInt(P[0].tensorShape.dim[2].size) : 0;
            }
            return Et[1];
        }(this.instance.config) : null, this.instance.config.hand.enabled && !this.models.handdetect && ((I = (v = this.instance.config.hand.detector) == null ? void 0 : v.modelPath) != null && I.includes("handdetect")) && ($.handdetect = async function(M) {
            var F;
            return ce.initial && (Zo = null), Zo ? M.debug && ee(Zo.modelUrl) : Zo = await xt((F = M.hand.detector) == null ? void 0 : F.modelPath), 
            Zo;
        }(this.instance.config), $.handskeleton = async function(M) {
            var F;
            return ce.initial && (Yo = null), Yo ? M.debug && ee(Yo.modelUrl) : Yo = await xt((F = M.hand.skeleton) == null ? void 0 : F.modelPath), 
            Yo;
        }(this.instance.config)), $.centernet = this.instance.config.object.enabled && !this.models.centernet && ((N = this.instance.config.object.modelPath) != null && N.includes("centernet")) ? async function(M) {
            if (ce.initial && (Ta = null), Ta) M.debug && ee(Ta.modelUrl); else {
                const F = (Ta = await xt(M.object.modelPath)) != null && Ta.executor ? Object.values(Ta.modelSignature.inputs) : void 0;
                Uo = Array.isArray(F) ? parseInt(F[0].tensorShape.dim[2].size) : 0;
            }
            return Ta;
        }(this.instance.config) : null, $.nanodet = this.instance.config.object.enabled && !this.models.nanodet && ((T = this.instance.config.object.modelPath) != null && T.includes("nanodet")) ? async function(M) {
            if (!pr || ce.initial) {
                const F = (pr = await xt(M.object.modelPath)) != null && pr.executor ? Object.values(pr.modelSignature.inputs) : void 0;
                Nh = Array.isArray(F) ? parseInt(F[0].tensorShape.dim[2].size) : 416;
            } else M.debug && ee(pr.modelUrl);
            return pr;
        }(this.instance.config) : null, $.selfie = this.instance.config.segmentation.enabled && !this.models.selfie && ((R = this.instance.config.segmentation.modelPath) != null && R.includes("selfie")) ? c6(this.instance.config) : null, 
        $.meet = this.instance.config.segmentation.enabled && !this.models.meet && ((w = this.instance.config.segmentation.modelPath) != null && w.includes("meet")) ? X4(this.instance.config) : null, 
        $.rvm = this.instance.config.segmentation.enabled && !this.models.rvm && ((E = this.instance.config.segmentation.modelPath) != null && E.includes("rvm")) ? d6(this.instance.config) : null;
        for (const [ M, F ] of Object.entries($)) F != null && F.then && F.then(P => this.models[M] = P);
        await Promise.all(Object.values($));
    }
    list() {
        const e = Object.keys(this.models).map(t => {
            var n;
            return {
                name: t,
                loaded: this.models[t] !== null,
                size: 0,
                url: this.models[t] ? (n = this.models[t]) == null ? void 0 : n.modelUrl : null
            };
        });
        for (const t of e) {
            const n = Object.keys(yn).find(a => a.startsWith(t.name));
            n && (t.size = yn[n].sizeLoadedWeights, t.url = yn[n].url);
        }
        return e;
    }
    loaded() {
        return this.list().filter(e => e.loaded).map(e => e.name);
    }
    validate() {
        const e = [];
        for (const t of Object.keys(this.models)) {
            const n = this.models[t];
            if (!n) continue;
            const a = $2(this.instance, n, t);
            a && e.push(a);
        }
        return e;
    }
}, Sp, $h, Mh, M2, Qo, F2 = `
/9j/4AAQSkZJRgABAQEAYABgAAD/4QBoRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUA
AAABAAAARgEoAAMAAAABAAIAAAExAAIAAAARAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQu
bmV0IDQuMi4xMwAA/9sAQwAGBAUGBQQGBgUGBwcGCAoQCgoJCQoUDg8MEBcUGBgXFBYWGh0lHxob
IxwWFiAsICMmJykqKRkfLTAtKDAlKCko/9sAQwEHBwcKCAoTCgoTKBoWGigoKCgoKCgoKCgoKCgo
KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo/8AAEQgBAAEAAwEhAAIRAQMRAf/E
AB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAE
EQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZH
SElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1
tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEB
AQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXET
IjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFla
Y2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXG
x8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A+qaKACigApGOKAML
Xp8xlF5A7V4X8RtYs7PzfNImnx8sa8Kp9z3q2tEgp6angWs62ZZ5CTGoJ6DArGNz5p+UrID6EUrF
PUlW1EuN0XNW7PQ2L5j3JnoKXN0KijqNP0eYoqXBdgPuuo+ZPeupisWn2Jd4+0r924XgsQOCff3/
AJ1FzRKxDqGii6m3siiQ8F1XGfXI6YNWLfRbiRQMkcZI9fpTDluT2/h6Qy8gDPbtmtG38JeY480Z
5zSLUTZg8M28YwYxjAArXtdPt402qgHbpSaLWhma3o0Uqk7Nx9DWLaaVblgPs6qRyds2M/gRSQp9
zZOni2iWS2hlQ+kjYz9OMGrdjq89vIPPVhj+8M/lQyDq9P1WOYBlMZz1AOD+VdDaTiReOKulK0jO
tHmi0WDTlr0TyxRVhT8tJjIX+9SUxHXUV553BRQAVBcPhSBTSuxPY86+IGti0s5I7dsORy9fM3i6
8e8mfDO5P90ZrWWiJicNPpZZtxV/xrW0jQt4DOv6Vk2dEEdTY6BHuB25rpbPSo0QARjP0qTRI17W
wA/hFaMWmoQMgflQXYsDS142rU9tpqqenfNA7GgtihxkdKuRW6qMY/GkDZY8sY4Ap4hXbyB+VArk
EtuH4wPyrk/EGkOm+a3jw3suRQLc5i38SX9hJ9nnY+XnBUdPyNdFY6pa3KkkAE9l6f8AfJ/pSJT6
GhDmI+Zb4ZRycdv6ium0nUhKFydrelTsNnS2829RnrVgV6NKXNG55lWPLIM81Op+WrZkRMfmNNzT
A7GivPO4KKAEY4XNYWt3vkwPg4OK0giJdjw/xrqhm87Zs8tc7pX5A+leSajf6aHYJ50kn4AZpTep
rBWRm2Vobm4BXfyehPFdnpmnBFUY5rI2SN63tlToK0YI+KZpFF+3QdavwoKTLtoW0Toaswpk5pCb
LCxipAhoIuP2dKevHXoaYDylRyxhlwRQI4nxVoCXWZI1GfpXGtbSWjYPGP73+NIGupt6TqMsLruZ
ih4xnP5V09mQ+JLd8gn0xSYJnVaVdkook69K34zuUGunDS3Rx4qOzHVIp4rrOMY3NJQI7GivPO8K
KAILt9kZrz3xlebYiu8KCCWb0XvW0NFch6ysfO3jLVjfXLIn+pQkKorl7WxNxIPl71g2dUUdpo+l
pBGvHPet23iC8ihFosrxirkHQUFo0IF4FXI1O726CpKLacCrMJoJLYHAPpTwucHpSRJJ5e4AZI9x
UqpxzVpCuOC8cUpQUMRnXttuB4rjNdsYyeVwfXpmpGmcvcQyafMCFJjPY10eg34BUg4DcZP8jUO4
HaRq3lLNF+IHet7R7jz7c56rwa2wz9+xhiVeFy/T1PFegeaNPWigDsc0ZrzzvDNIaAM7VpNqdegr
xL4l6kywyRhseZ19lrdfAZL4jxYg3Fw20d63tJsdrDI5rm3Z3R0R0Mce1eKnQYAplIkWrMJ45oZS
NO3PHbNXIyfpSGWowSOasxLUiZdjFSqtNEMkUemKlAGKsRJjAppFAiORMjmsTVrNZEO4cfSoZSOD
1eJ7WXBUzQZ+7nkfSo7e2Ei+ZaMzxntjBX2NSU1Y6/wxqojiEFzkA8KTXYaUoWRyv3W5rSjpNHPX
+BmpSg8V6J5gUUAdhRXnneFFAGHrTfu5PpXzj8S70/aZtxzztXFbv4DKHxHI+H4GZiz9zxXXW8G3
GBXMjvLRXAx0oPGPSmMVeOnWrMTYpFI0bcg1fh54xmgovRcD3qxETSIZcRvzp+/BpEkqsBUqsM9K
q4Em4Gkxk0yRGXrVW6i8yFhkg+tJjRxGsWrxllkUMh9eK5uMz6bcebbnfG33kPcVkay2OntPKuo0
nhXI67c8qa7Lw3c+adjcEDGK1paSRhVV4s6A0or0jyRRQ1AHX0V553hRQBz+vNtt5z3xXzX8Qbdm
uic5YnOMdK3l8JnTXvlbwpYl+WySOgrp5YfLOOB9O1c62O7qQkc+9RsKChFPWp4DluOlSykaNruH
ArUgHShFNF2NT1qxGO3NBmyxGcE1N2560CFzjrUysO9JAPDDjFOVuKoQuSRTWouBkazbCa3cd8cV
wF7IISQccHBzUSWpV9C3o1x5b5GAjdQD1rs9DjC3kckbEhqKfxIzn8LOupRXqnkPccBSkUAzraK8
87wooA5rxMSI3HqK8B8bQl9Q8sffY5b/AAraXwkUviNrw9pH2W1ViMMRTdRjw4HpWNtDti9TPc4P
FQs2M5qdyyMHLcfjV63HTAoBGtap0wK0YxigpsuRDtVhVYd6GQydVwwIqdRnqKCR23I5pCMUW6gD
YNKuetAEise9KTxQBWuFyhrznxNZkXjFeN3I+tTIZg2OqmzmxNF0PO3vXp/g2+hukVl4zyPanTXv
JmVR+60dpThXpnlPceopWFAbnV0V553hSGgRynjC5FujOey14Ssp1HxNmTnc+a3kvcIpv37HoEYQ
QmMdVHSsnVbYJF5jVk0dsNzlruVIsl2wKxbjWrVHILjg1CRbZJb+ILHPzyhfStODWLQgFJFYd+el
UJM27HUIXxhga1Y5lLVLKLkMnoauxnPPrSEx7ShF+Y/n2qrc6xBbhizDAqkK1zJuvG9nbg8ZA681
ly/Ei052RO3uKAsZlx8QGd8xxvt9Aa1NH8dK7AXMcip64zigdkdrZX8F7EJLdwwNXMkrz1qRMRly
CK4TxmpidWI49felPYSOMmi80NIoOV6qRzXYeA5SskYPfirpfEjGr8LPWVHyD6U4CvQPL3ZItOYc
UDOoNFeed4Uhpks4H4iE/Z5MeleMeGULeLgjds10S+BGdL+Jc9OSBU2Huc5Nc74yvUtrcDBrJnZF
63PJdXvLy/lKWw46bvQVz82jXhkLO5Y+9ZlsYthcRnbIjY9R3q3awTRkEM3WmJI6C0ea3dGRsr1x
XY6TqW9FLHnjrUs0izpLK5DDjofSta3ckH09KRUkZuuTvFGdvPauE1Y3U6Mqbssf/rUxHPTaJPK2
ZmJPbBqzY6DCZh5xJC9s9aBJHU6dpemJjfEmfetJtI0+VPkUr/unFOxdiextHs33W07YHQHk11mk
Xb3KbZ1xIvcd6LEyWho4Nct41sTPYb16ipexCPPZN+wYGCvH1rrPAEJmvkPoc1VL4kZVvgZ6yFwK
cBXoHkkqinFaVyzo80GuE7WJRQSziPiGdthK5HQV4x4J/wBI8WPIewNdEvgRNL42emO/yj1UHNef
eNpRczbC+I17DvWT2OqJxc0sMK4TCisy41q0hfEkqj8aixdwTXNOlwvmqD9anS9tXH7uVG+hosO4
/wC0oOhrR0+6G4YNIEzsNEuCxAPNdjZruA4xxUmjINSjURksOlcbqFykbnjFA1sYGoassaknCqO5
rl7rxhGm7yBnBxuJq0rkSlYpw+NLlsfd5P8AerVsvHEqSBHwPVgcgVpyMyVXU3rXxcHYETAk+hru
/DWti6ZSTyOKzZqndHaxvvUGq2rQ+dYyqR24qWI8dvbr7LqDxyDAzXpvw6FvIxePGSM06Xxoyr/A
zviKFHNegeX1J41zUhXioGbuaSuM6wpCaBHG/EcA6HN/exxXjXw2jL67cv8A3Qa6H8CFR+NnoWpO
I4XI44rxLxrqjQzSEsQM1gdSPM9U1uR1YbmWIdXHf2rmpIb67YS28UrRlsLI3c/jW0VZGUpO5pW1
jfLNOjahawzwReYI5cjzMkDavHJ5/SrVv9uhtPtVxCPLBwzxnlT9KGghLU3tKvvPjHzbl7EGuisJ
GRxWLOg7nRXJEbDjmvSNK+aFSfSoZr0KutRkphc4NcRrdkVjL9aVio7Hk3iqS8ubhrWzUlsZY9kG
cZNc5D4aee5MclzJIFTzHAO0MfatqSOWu7bFS1srDUZEis0vIZoUxPvfcC+4/dx2xjr712XiTwXb
WmlQ6hol3cRhoFd4rlg3zY5wR0GelavQwjq7GD4etdVvSnk2wAB+9v8A8mvcfA2kXiRo0/UdcDis
ZnTTulqeoWqbUAJqWUb42X1FZlnjfjSwlGrr5S/eNdD4RkvLAAQ4yRyaUZcruVKl7TQ9I0G+mnzH
ckFwM8VuIK7ac3KF2eXiKapz5UWYxipNtMyNejNch0jSar3cjR27uoyQCRVRWom9DxTx54gu5fMi
lbKdMVjfCZPNlv5v9rFbVHpYqjGzbOn8SzFI9o715L4u0r7arYzk+lYdTqSujy7U/C0u4vHk+WwO
xuh9q3J9dgvbdVukMV1EwbDDgn04rZMwlHoZ+orZ6hfQ3RWVnQYCgZAq+8U0ln5NtBsV2yxYcfgK
JtW0CnB31LlroVwJ1nQLGDjeP7w+lb0dsFxjrWB0tHS6NuWPJ6A16ToUm63T3Gallr4S7cxiTjrX
PaxaF7dlVeSMUhxZ5jd+H7qCa4eF3DSE5x3zXN3Wk6jbyeaiFWUY6ZyPStYS5SalPmVipFbX0E4c
W0alvmPHJrag0rVvEE6LdljGpG2NRtQD+tW5XMI0uU9M8NeFo9PiQhecDIIrtrOMIoG3H4VlJm9t
C6CB06VPGM1IHLeItGS6uw+ORT7e3jsbQvj7gzUNam0JaWE+HN7NqOqX80n3FO1RXo8YzXdS+BHk
4z+KyzGPapcU2YIv7qQtiuaxvcaWqG4O6FwfSrS1JbPnrxoxkv7qIfejcitj4V2f2exumI+8+aKn
xHTT+G5d8Txlm4rjLxMsQwzWT3OiK0Mm6sEkVsAcjFc1d+FEmlGwEDPQVopaEuOpr6f4ZWNAu3tW
vHpAj5ZQcUFIWaDjGMVUMQ3cVDBmvbhY7QAV2nh+T/R1yeKhlrY31+b61FcQK6nIoJMi401WblRi
qr6PCw5UYq9y+YgOgWzNkRrx3xWjp+nx2v3FQcelAbmko9anQ4GBUNisPHWr1qMrQhS2K11HvmYV
hamcxSRZ5xRIqluS/DKAQQXZxyXrvo2FdlL4EeZjH+/ZbjNSZpswLNBrE1Gt7VE4ODVIlnh/j61F
j4lmeTGyUbq6LwdEqWbeX0YbhSqfEddP4Bddj4JIrhL5d8h7VjI6oLQqKNzelWre3yc4/ClFjaL6
wqBxxUUxwCKu5BmXRA6c+9ZjP83FSBoQuPs4BrsNBlUW659KmRrDY6G1lyQtW3Hy0lqQ1qVJnAbm
oy3b9KYJCqRj3o4zRctIlhjLHmpSuOBRbQOpLGpPFaES7UqkZzKN1KsEc87/AHUUmvPLTVGv72aQ
k7WJwKmRrQ3ud74Ltilgz4++2a6iNDXdS0gjyMU71my7GpqTbxSbMki3SViajTTHqkSeR/GeyZmg
nQHkEE1S+F+oPPavBL96I4/Cia1udVF+4dVrkW+Fq8+v4tjMDWUkdVJ6WM0cNV+F+MVmjUcZgqnP
1qpNNnkcVRLiZtxIS1UzzIF7mghlxUZpVQdq6nTVdAoAOKzkbQWhvwM6gMM1twOJYx3NOJE11Kt1
H1/pVVlwBkk+9NocXoOQ45FPj+fkUJFF2NSB700v/hTEty5ZpkjvVyUgcCq6GM9zC14/8Se6GcZQ
1574Xs5WkI2HBPHFQ1dm1KSSZ7Rotn9l0+KPHIHNacae1dy0Vjxaj5ptlhVp+2s2CJ9ppCKzuWNx
zSFc1SYrHNeNdIGpaYw25ZeRXmvheyk0jVpEdcLJ0q3ZxNKTa0O3vQHg/DNcHrsJDmsmjspnNzNt
fFIJ24GazOhC+azDmgZIOOKBsp3J2qSaZodubq58yQ4QAnmhGT3NO18pb7BORmu205LfYpyKVkWp
Oxr5gKYWoIZWgfGfloFq1qTPLubnGO1RPtxg4P0oBAkY/hBz6VNDDkZ6AU0W2WSdqkdKr9ZOaGSj
VtcLHmnOcgmmYvcz7mBLy3MbdD1q9ouiRK6bUAVeelOC1InPlidSsWMDFOCEdq3uefykqrinYqGy
rFvApMVka2DAowKAsMkRXQqwyDXn/iWyitNQ3qPl6itIvRoF8RXinW4tQ6HI6GuW8SIVBPalc6qe
5x9x97r3qruwTjrWZ0ksZ9TUmcDNAmZ9/wAoao63rR0+w22MLPtAzt6mghmfofiB76LdJBJBIp5D
d/oa7bSdWLIPnpDi9TM8TeKdas51XTbIyxd3J/pXS+E/EFxqNoFu7do5OmD60maHWrnZyDRkn/69
MlEyOR0xntVoNx+FUgYjPxg4FLCuWDZyKQr2RoRnP0qO+nEFpJITgAUzLqZnhu6+0rknOTXpOmwJ
Fbrt5yMmnHYyr6Oxb2ijaKLnPYMClwKQWK3n0hn+lachHOJ9pNNN0apQFzsY10a4v4hXQh0xpieQ
MA1XLZNjhK80cT8OdV+3Wl3A7ZZJCw+hrR1qLcjZ/CsbnfHRnFXseHJArOYYbrUs1uPhYbuatqFP
ByfSkMq3UIINYkto+87Tx6GkSxfsDbflGD7CtTw/pk4nzITtPIFMFudsukh4Rxz71paTpKwP5jcn
0qTRy0NORMDgVCqewoJTJgAoxjntTiTu7fWmFxAcnn1q3EPl+X8KZMi4gKqB1Peob/Tv7Us5bfeU
yOoq4R5nYxqT5I8xieH9J1DTbvyJELRg8ODwa9Ms5mSFV9BWiptbnNVrKdmif7Q1KLg96XIZc5Is
pNL5pqeUrmMtZs0jzV08phchaY00zH1p2ZNxjS1g+LdJOt6U9ssmxjyGp2urDjLlaZzng/wUPDqz
TSTmWeTrjpVjVk3Rvjr2rnqQ5dDvo1XUd2cTqSNk9OKxXGCeKxZ1DAxHTr2q5C/y8GokUhsz54qu
uCxzSQjQ0+FZblR2ro4bZYiMVQ0dBb7Qi5x0qzuG5QOh71LYErDufpSeWrHnimIXbjkUjLkH1Hem
gGxryc+tXI19KYmWegq9YLiLJ7mtqS945cS7QsWehqxA9dEjz4krPSxyZqbFFhGxUm6smjRM55Lk
HvSvNxXTY57kLT+9MNwKdhXGm5FIbkU7Bca1wMEVhaiuQcVhXWiZ14R6tHGanGBI2OtYkqEHjgVy
s9ErEeo6UBsHipKEZs5qpPdRxcbhx70NCSuybTNWihc5brW9Fq6vjMnFSdEIdDRi8RRKygZbHFbu
m6nb3RA3gMegNJhOm0jbXGOoxTuCc1Rz3FyoGKawz9KaAVcZqeMgCmIkB4FaUTbYwB6V00Fuzixb
0SFMuDU8Mlbs4UPeXHeiOXkUrDuXYnyKk3cVk0ap6HMxxketSMhrcwRC0dMMZFMQ3yzSeVQAeUaz
9Vj8uPd271nVV4m+GdpnHX67pCeKyLtBtNcR6xlk9RVeWTb3qRnO6trgttyIfm71z7ai8j7/AJmN
DNqUVa5Yi1AnjynHuBV+11YJhWWXcP8AZNSzqgmaEerSsf3NtIQP4mGKtRavdRgMIpVI9KjU0a7n
R6T43uYQI7qN2Tpkqciu503VVuQGAYZHQjFVc4alPlZrpKGAznpTwxOc9+lWjIlUACnM4XApiLNk
nmvnsK0NvpXZRVonmYqV52GsmanhXitTmFkSiJTSAvwrxUxXIrJ7miOfjf1pzNWxkRlqYWpgJupu
6gQbuahvIxPA6eo4pNXVioS5WmefakGhndH4INZs5DJXA10PaTurmLO21uKpSZqGMoXGnRzBiyjd
9Kx5rcQS428fSkjanLoaOliHGZFB56VswW+mtPufcBsGOAfmxz+tFkd8HpoaUx09FAtFY8DO71qb
Sms/Nb7RbecG6AEjFLS5c78t+p0djpVs9wsyQiJAdyr1rW+zqjErzSe559Sbk9S3C+MA1bjbgE1S
MSXzMVG0vNUI2tPKrAuCMnrVzNd0PhR49W/O2xrHmp4TxVMzQshpIzzQBehqesnuaI5VGzT2bitz
FEbNTC1ADS1JupgG6l3UAc14s04yR/aYRll+8BXCtLncDXFWjys9TCz5oW7GddH5qqNzWDOgQnC8
VSuo1kHzAGkPYopEY2+RWxV23Vzj5G/Kg3jWaNazhZuqNXS6TaKhB2c0jR1nJWOlhOxRxU4YkCgx
Y0OQatQyDbyaaFYe8uF4NY3iC9ltbVGj43NTIL3h7WzMihjzXVQXYYDdW9Cf2WcOJpfaRZ3g9KsQ
mupnCLIabGeaAL0LcVY3cVmzRHIxtUhetzEjZqjLUAIWpN1ArhupwagAfDKQ3Q1594v0c2bm6tx+
5Y8j+6ayrR5onThp8s7dzkZjuqAAmuBnqC7c0iwgtzSA0rWzjfGRW3ZadDu4AoNYo2rfS4v7orSh
05UA2r0pDbsTm29KRottBNyJ0wpJ9KhD7f6U0ikNWffIFBz60zVUW52ow4UcUN6EPcx44WsbgOmd
ua7TT5Bd24KHnFKnLlZFSN4koluLdueRWvp14swweG9DXoxldHlTjYtzGoo25qzEvwtUxas2jRPQ
5CNqkLVsYoYzUzdQA3dSFqBBmnqaBhuqhriCXTpVIzxUz+Fl03aSPI9QTypW2/dz0qKNw3SvOPZR
Mqin8VLKRcs3O4Cuk0w/MDjt1NBtHY6O2IIHY1pxgFaETIRwMkjtVSUEk4570MlFW5bap6dKzWm8
1tqH8aY+hp2FvGoGayNevVt7/ap4xzUvYjqTLtvLPcvJxSaVcyWsxTnFZlnT2t15xHmCtOBYwQy4
B9q7cPO+jPPxFO2qLEj5HWo42+aus4HpoX4W4FTF+KlotbHII9SFuK0MUNZqiLUDE3UbqBBupwag
Bc1DefPbyD/ZND2KjujyPWlKzuPesRZjHJXms9lMuw3StjnmphKDSLTJ7OfE3JrpbO4GQc9qlnRA
3LO82k5NbFvdADkjBoCSHyXIIIzgVQvdRigT7wzjgUzO1jHknlvG7qnp61etYFQDIpCZoqVijzXn
3iC8EmsOuaCGb/heR/s0ijkVv6fbxy3QMg5xmsnuX0Ldzut3+UYTPWk+2GJSe+M1pFtamcldalmx
1eO4XaThhWnC+TXqR2PHqL3maUJ4qRjxSEjj42qXdxVmaGs1MJoATfSbqBAG5p6mgAzTJTmNvpQU
tzzHXY83D/U1zF5FhjgV5r3Pa6FMsV5HWnLe7RhqBRdmTwagN2d2K2rPU1C5LAnPrUs6Iysbdrq6
f3gK0BrUKj/WClY05iM6xLOcQAj3NT29uznfKSzHuadzNu7NSBFjHNSm5VO9IRnajqoWMhTzXFtA
bvUfMduSeg702Qz0rS7FbTToQFwzjJqaGTFyfK5PQViyzUuFmuIdgGABya5u/vTaN5cnUHFUmLoZ
zyskwlgJweSK6zQdUEwVJeGr0aUrxPLxEfe0OrhPAqVjxWhznGRtUwatDK4jNxURbmkAm6jNABup
6tQAFqhupNtu59qUnZFwV5JHnWsHdIx96w5lz15rzT2uhRmt85xWbcxMnUGmZlB0bdxmrNvFIcfM
350mWjbs7YkDJY/jW5ZWW4jikWkdNp9mqYJFaJdEHHakUULu/VB1rLn1Ld/FgetMGYd/qWSQmSa0
/AemS32pfa7piLeLkg9z6UmQtz0W7uQ2cZx0A9BVzR7cAea6j2rPqX0L99KRat5A6Dk1wOoKZ52a
YfMORTYRLujiGWEq6/NWza2yKQVHNdOHerRy4laJo6TTnbbtb8KuM3Fdh5z3OJjbmpt3FaMxAtUZ
agBN1GaQBzTwaAAms3VbjERUGsa07RsdeFpuUuY4jUjljWTKK4j02RE4IpJYFk6imQkVl0xWarsO
mAEcUi0bNnZBR0rWtoguMCkUi21wI161mXuocEKaYXMS4u+pY/hVCSWSY4HT0pEmlouiSahdpEBl
mOceleiwWcNjClvHgJH97Hc1EmVFFi3Czy7mwIl/WtJbjP7uLgd/apQ2VNVvtsBhiPzdK5S4nAuR
nqOCaTGi9pcytPlU+XpmumtWII44rah8ZjiNIXRuWeNvvViQ/LXpJWPJbu7nCRvVkNxVsxBmqJmo
EPiXca0YLMuOlJsuKuPlsSi5IrNuG8s4HWs5VEkbwoOTKsk+FJY4rC1K53k1xTk5O7PSpwVNWRzt
4cms+WpKICtSLTETQj5q0YeBSGiys23pUguGxQMq3E59ayrm4x3yaAKiRtO2WPHcmhruKFxFajzZ
ScA44qRHoXhuMaLpxaUg6hcDLMf4F9KlhuDeXGASIl+8azZslYma68y48m1+7nFW5rtbRNhb5z1p
iMKbUg0zuW4A4rPgb7VdKXOMmpA7HRbMS7nUYiUda0lkQOBngVrS+JGdbWLRt2bAx5BqeQ/LXpnj
PQ4GJ+ashuK0MhWaoWcA0AaOmASMK7jRNPWYBmHyiuepO2x10qfcv6vYxCzYqoGK4HVYVTJrmb5l
c6oaM5TUJ8EgGsG4kLNUHT0M64OaqMMikSRsuKbnFMRLG3zVehOaGNE445NNlnVFpDMu6uie9Vo1
8z5mOAOST2pDK91cNN+5tsrH3PrW54a06KxT7fdrlh/q1Pc+tJ6IUdZGvHPLezMcnBOWbsPap5r3
ylFtbdT1xUWNWzU0/Zbwlgfmx8zGsHWtRHmMqE59aAMyNifvHPc1f0gtPdqkY5JosJHeNci2tktY
euPnNY+oXWZEVJNrZ9aun8SIq/CzodHuriIokhDIR1ronbKZr0o6o8ipoz//2Q==`, _2 = `
/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAsICAoIBwsKCQoNDAsNERwSEQ8PESIZGhQcKSQrKigk
JyctMkA3LTA9MCcnOEw5PUNFSElIKzZPVU5GVEBHSEX/2wBDAQwNDREPESESEiFFLicuRUVFRUVF
RUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUX/wAARCASwBLADASIA
AhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAEDAgQFBgf/xABDEAEAAgECBAMECQIDBgUFAQAA
AQIDBBEFEiExE0FRBiJhcRQjMkJSgZGhsWLBJDNyFSVTY3OSNEPR4fAHFjWCokT/xAAYAQEAAwEA
AAAAAAAAAAAAAAAAAQIDBP/EACARAQEBAQADAQEBAQEBAAAAAAABAhEDITFBEjJRIhP/2gAMAwEA
AhEDEQA/APqYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAKNTq8OkxzfNkisQC8eb1XtRNbzXT4q7eU2nu0MntRq/D8StMccvW29ZmdvgjsTyvZjxOLj
+s8WLxn8TFPXs6Oj9oct7c14rkxz22nrB2I49KOdTjelmszfmpMeUxv/AA28OqwZ4icWWtt/SUi4
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmdo3nsPNe0Pt
Fh09Z0+DNWL7+9O/7A3eJcZppsV5raI27esvH6jX5ddM25p79Ilo59VbUZOe2Tm/PeGvfPfT2iKR
PLv1+DO678XmW/a97U6TtOyzTbTF538/T9WjTNecm9a7126tqk3rSYxY5ta1plRZqZNXGjyZcPXl
mZmsx+qjBrsuO16xM7eXRt04JrdTltk5OWJnfaWf0a2lty5MdZnfzSn+WOHiOutFpjHa9e8bQ2fp
+alYy462pk7zXbuxjPesbRS0f6ZZV1ET1tErzXFLHo+A+1ddZf6NrI8PJHa1vN6iJi0bxMTHwfOa
zhzd61v1846utwniM6DUdb3nBaNrVmd9vjC/ZVePYirBqMWppz4rxaPgtEAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAItaK1m09ojcHnvarjM8P0vh49+a/eY8ng9D
h1fGM1rxjtGPfvbzdbjuTJxHX48cTPNltM/KsS9Dw7S49Jp6UpHaGe2vjz1y9J7LYK13vHWe7bj2
ex1tvM80ekuxW3RnW3Vm6P5jRx8H0+OYmMcb+bapo8GKPdpC6bQwtdHU8JpWkdJ/JweL6e23iU67
d4dubSqyVi9Zi0bwIs68XGp36TtEq7ZJmZmevzdbifCKWtbJinkt6eTgZPFw32t+sRurbWVzxs1y
Rv6T8V1NZNPtfq0seTm+Kevr+SZuxXjvaPiV8N4viycto9HseG6+uu08W6Rkj7UPmFck1tE1nlmP
Ld3eA8V8HVVi1pjq6Ma/pnqce/ERMTETHaUrKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAADW19+TQ5p/p2bLS4v04Zmt5VjeQeJ4bjnLqsupv+Ka1+ERLv4reTmcNxcuC
vy3l0qdI2hlr66sT02ot0ZV7qqrInruzrVZLGSZ37JjqgYTG0K5lbaFVhDT1Ub456RPweY4hixWi
eSdpjvD1eWejz3FNHWYtkpvFo9EIseb3tS3SerOms22rfpPqZKzvvHSYUz70TExG6Gdbs2rljeJ/
Mx5L0vEzPaelnOi98c9J2bFNTFpit47+a+PVUvx9T9nOIfT+GV5p3yY/ds67wvsXqpxau+G09Lx+
r3TqrEAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADV4ljnLw3U0jvO
O0fs2lWqyUw6XLkyfYrWZkHldBEV09eveG3Fq1mI3jd4vPrOIaid8G9MP3Y38k6fNrt/rMk9Ou8s
tfXXn49rGWInuy8SO/k5Gl1E3rG/fzbOe94wTy99mbRvTrMOOvNfJWsesywniukrG/jU6fF43WYN
TmtEeJtEQ06aSmK2+bNtEd+qfSO17unF9Hmvy1y13XWyVmN4tExLxVK8PmNq5NrT58zawam+m/yc
0Xj8NpRYSvQZ7xEOdqI3rPozxayNRXe0ct/ON03jmrKB5nV4q1yTO20Obmv4c+cx8HoeI6WZpNoj
q83niYmYscU0r8aJ6T1n49zeJ+Meqm1drb9J+Kd5p136StGVem9l9TbHxLDFp7W7+sS+q1nesT6w
+PcAzVjiGHftzQ+v4f8AJpv6On8jH9ZgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAABp8VrW/C9TW0ztOO3b5Nxp8VmI4bn37TWYB8f1HFtTfUfR9FWJmsdZ9I7MtJxDX5s
d8ta1y0xzteaR2277rcuhycP12SceLxMeWNpjttHwlu8I0mfQ1y+D7k5YmJmY36T36Ka43z/AF1t
cI1ds+qxVj7/AEej19PCw9HJ4NoK4OIU5Y35YmZdzVTGebVZabx5jJS+Tmns81rNLm1Wrzc9rVw4
Yibbem72mXTTS0w0M3BvEta1bWrM95ie5EanY87wXgNOL6XPfxraXLhra/W28bR/dzYzarBqJxRe
bzE7Rt5vWU9n8mPHOGmS0Ypnea1naJb+k9ncNLR7u2y/WcxXO4TOoyUrN6zD0FaW5Y3hu49FiwUi
KxCvLMR0hlW0jn6ukWw3iXjOJzbDlneOj3GaN6zDzfFOH+LE7SRGo83XNSZ2lbG2/WfdlvaT2cy6
rNFInlrv1mfJ37cK4PwTTxOoidRm2+/2/KFuyMp47XB4LivXiunrH2b2iH2qn2K/J8x4fGDNxTSZ
9Nh8OviRvTyfT6xtWI+DeXs9MNZubypASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAOZx6/LoOWPvWiHTcf2hiZ0e8fc2mf1E5+vP/AEeuSd7RC2uKtI6QjHfeINTfwtPf
Jvty9WPfbt/lucP03gxfJf7d/wBoReYpm97zaNeLb4Ims9Nt94auDjem1Wo5PFi1onylS+1o7l8V
bxvtupjDMdNkYtXS1+Stt+m63xImEJ4xjHER2ZxMUjeUTO3VRmydBbjLJqPi08mbeVOXJPq1sl5Q
Vbkz9+rRy35rxHqzmZlVEe/Ez5LRlW5iyfR6zffaIjq1OSNZps2a21rZInafSPJhxGMl9LStLRWM
lorM/A4dkrWbYfLZC2W/7K6eubX6b4RzT+W76K8b7G6X62cu3Sten59nsm3j+OXz3/0ANGIAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0OIYfpOHPijvNNo+fdvtXJO18k/
/OwPFYbz2ls3jx8VqW6xMdWPEdP9D4lkx/dt79flLLHbkxTPwY6nt2512ORTRzE2x4/dpE7cvkme
E4IrW3hRMxO8THRtU1FKWtvtvK2upx22rzRCtXkqzh2jtF7ZbT122b01ndnpuWuP3Z3+Ky20qDVv
fauzVy3mejZzNK8dVjqi87KLRLYtXruqvXzkQp7Qoid88R6rcl+WGlW0/Sa22mfhCZOq2x082ix6
jkm822pO8VrPdr4dNObVeDo8XW3uzMbzK+mvxT7szE27cvnu9j7PcNjSaXx8mOIzZevbrEeic5tN
+SZnpt8J4fHD9HXHO3PPW0x/DeBtJxx29vaAJQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAKNRim9Z5e89Nl4DzXtVh5babURHrSf7f3ec1+qnDorWrvvt5Pccb0n0zhmWk
Rvevv1+cPE2rGTFNZU26PFfxwa5dVkjelI2772nZnX6bbrEUq3o0d678u8wmuDL2ittvVjXdneeK
cGv4jpJ6U56+kS7+j118+GLXpakzHaWlp9NNY3tv+bbiYiNoQy1y30uyZJlrWmZnuym6q1iIJnop
yW2Te8bdWnnypQqzZOadokiIpSZntWN5lrxki19vNRxrUeBwnNNd+fJEY6/OejXLn3Xe/wDp9wyn
E8uo4lqqxblv7lJ26T6vpD5X7G8QycKzeBMbzMRM1/FH/wA/h9QwZ6ajDXLitvWzRgsAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeL45w+dDrZvWv1OWd4+E+j2jX
12jx67TWw5Y6T2nzifU+rZ1y9eHwzDYxxEy18+DJodXfT5o96vafWPVbjyxDn1OOzHudbM0rt2UW
iI69mVtRXZq5tREb9VUoy2iIlRbJ0UX1VZ6btTLrI7V6yk62M2oisT1c7JmtkttVMUyZp6x0beDS
RWOvdKijDimvWd3G9pNRMfRcNfvZOb9Hpb0itJeP47k/3hgjaZnbaP1XxWW3T0movbNS0W645nbf
0nrMPpXs3xamoxdJiLbe/X1n8Uf3fKsOTw4jbaXo+EarJhtGTHMxeJ6xH7Sti9Zaj6x3HM4NxXFx
DS1mtoi8dJrv2l011QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AGjxLhODieOIye7kr9m8d4eM4to9RwjPXFa0ZIvG9bR0fQXmPbDFvTTZPOJmEWS/V8bs9R43NxLL
G8eFbePg1bajU5/s0l1ceKLx1hbjwRE9mOpx0y2uRTSZsm3PMw2aaKtIjo6kYo9EXpET0hVLXxYK
xC6MZvyx1lFs0RHfaPiCnU12pLyHGNDbUajBekWma2npWN3p8+opa20e9LSyZLxExTlpM+vdOdcZ
a9tPS8MyUvFrzWlI6727u1pYxYrbVmb7x+TQx6au3Nqcl7/0rcmW9axGnwZJj1novmxnZXV0fFp4
ZxLBPgTGK8xzXr5fOH0bFlpmxVyY7Rato3iYfNuG2x56Wrqa8s2jz+7Lu8O12bS6jkwzN6THNNI6
tvrN68Y4rxlx1vHa0bskAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAA4XtTTm0OKfTJ/aXdcL2pyRGjwU362yb7fkJz9eTxxyZJjyltRXzUZK7TFtl9Lbwy06YzrHwa+
fJFd/wCVt8m0bQ0eS2qzcm+1K/an+zNZFL5M1pjFXeI72ky48eGnPkvNp27+TPU6nHpMfLXaIjpE
erk5dRMxOfN1mPeisfshW1ne1a1577Y6x5R3U0zze31FOWI6ze0byU098kRlzbxM9qrMlPDpyRMR
Md5Vt/Ihp5898mWZm1pjftE91uCt7fCI7dWeHDEW3t723l6rslqxWZnasR+SYhFbzhnfxJ2jyeq9
lcGXWZcmW0zWKxHLaI7794eJx5fpfEKabT8t8l5isddo3l9S4VjrwrRUwzSJt3tav3pdOL6Y6dXD
j8HFWm+/KsU4NRXPvtWazHquWVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAa+fXYNP9u8b+kdZBsDkZOO135cWOZn4y5Wu4xqctbe9y19Kp4njt6vi+PDm8DFMWybbzPlV
5PiGtz67UxbNbeKTtWIjaIXYpnwuaftT5tXJT3vmi1pMsrU5qIrG1V1a+5DCa7b9GFbRr5J6Wnbt
Cu+Wmk0m8956z8ZWZNorbfzcbX5rZslazPux3hUt41NTntktObJ13+zX1bek01r4/HzVm0bxPXy/
+bNfDgjVa2uOY92kdfg6ufJOKvLXtttVVSqbcta2vM7zXtHpLQy5ZtMd+vWd+7Zy3mdJHXra3f0c
vUarw7zFY5rT2hH1Lavnrgx81p3U49Pk4nE5L35MO/StfNRXR5tXnrS8W67WvfyiPSPi7uLHFK1p
jrtSsbR5Lc4RzsXBaYreP4l45esRD2HD9fnw6evvWvO3Tfr0aGk0U55ra0TFInv6uzgrXFXlx0i0
77RPlC83Yj+JW7oddqr6vHzTTw9/f6dod+L1t9m0T8pcbFSmPHER3892W0zPuz+jSbVvidkcqmfP
Sel7bekrI4n4dZnPWIrHeYnZee2Wpy8dEaml4npNZblw5qzb8M9JbYgAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAABEzFYmZnaI7yCXL1XGa0jJXT0571nbee27DiXEprp8nhbxG20W8
5cbD0ikfnKO+urTPvjoZdXqctdsmTaPSvRpWmsdZ6yztfaGplvv3lWW1tyRlz1x0vkn7Vo5atTNe
Y0+1o79V2KsZsvX7Ne5mwxnyTNvsx2iGneM/rCdRSuOsTasTt5kRFtpjqmOH4t4nk7estiMNa97R
Hwhna0iuKTEdmGWa4672nZtRele1N59Zlq6vLOSsYorEc07qcW65euzRvtXvPZy52naZ7ujr6fXV
rWdukREK8+njHgmZmPc67bq6ivVWhxxgxZLztNrT1mZ/SP4VZs0zaOvfp84WUtNsXLvtv3699+rU
z7+Jtt5qURqMnPpctaR1rMSw4ZoK57eNk6xHaJRh97Ltt7lo5Z+L1HAPZvVauZ2nFTSzMTzeJEz8
to6xPfvsZntPZ9rXxabmxzefdrv0j1dXh/BcmstW1qxTHHasR3+b0GPhGl+kWmd64dNEVjf73T7X
y8vy+Ddx6O3iRakxTH5RXrMw1/lX+3Itw2MFIraN48qRHdZi0cUjmmPen9noox1iO0fNzdXEYrTt
stcmd9aX0bJ+HePmiKTitO8TMLZ1cVjrMfqpz6ys4pjfrPRWZ9rXXptUit6zO+23VyaRHEc05L1/
w9J9ys/en1ljqdVbwYw452tlnl3jyjzbmmiMeKtYjpEbLeTXPUU8ee/+qjJpsV5rbkrFqzE1tEbT
DpYNbW21Mnu29fKWna0KbqTdjXXjld0cvQ63ltGHNPSfs2n+HUbS9c2s2UASqAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAOVxPWe99HpP8ArmP4b+r1EabT3yT3iOkesvMVtN7za07zad5l
XV5GmM9vVfEstvDx0jtaVVMlq+UJ18b5cMRvPeSuK87bUt+i2Z3PtG7zXpjkzXt6R+TXyTMzvM7t
ydHqZ+zhv1+Cv/ZuqvPTHMfOYaTMil1a1K2vHSLTELq2v+KWzThGo84rH5rq8JzedqR+ZeI7WnOS
34pYTafWXR/2Pln/AMyrKOCWnvmiPyR6O1y9585lhWJvl557Q6eo4T4dYiMvW3b3UanhldHpJtGX
e09unmjsT7eb1l4trI2t0hsZfrdNO0bzy+nzU20/+NmkzO9esz+TZxWis9dttvPv+Tn21jjaW8zn
26bTG3mp1M/Wzv3t0jyWXiKZJmsTERaZhXXDbNl8WaztWenxZLstPp5pau8frDtVrNMM5cfTfpMf
3aunxxbes9d/R09Dp8ebJi09ptFr3jtt2WyrW9wy1Jx132mK+Xq9PotT0iIU19ntLtExa3T47T+q
6nBaYvsZstZ+cT/LeMnUi0TXffo1s2m8Ws2/OIMWk5Jib5L328rS2t94Sh5TV4ppklpW6PT6rh+P
NbebTHyas8E081mZy5P2W6OFhjxNTE/hr/LoRO0Kvo9dPqctKzMxEx1la5t3tdnjnMs4noievcrO
yZjeFF1OSnNV0OG62cn1GWffj7Mz5w05joovzY7xes7TE7w0xrjPeex6Ua+j1UarBFu1o6Wj0lsN
3JfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrU5o0+nvlt92P3BxuM6nxNRGCs+7Tv8
2hToxm1r3m9utrTvMsonqyt7XTmcja0u3O6FMfi5t/u0/lzdJM81p9O3zdvHTwsUR5+bfPqOfX1h
dqV+3O7bs1+T31oqmI3TEM4rvCdkDGIIhlFd2daboS0NXG2bD6bufxXU1vlmu/u4us/N0+L1tTSx
kr9qk7w89j1FNZMV3jxLzvaJ8mer+LSOZqK2xZotbvljfr/89U453rXt9lse081xZtNjx7TGKu0t
DHlrevSevaN5Y6+tJ8c7VRNMt63n3ub+6/R54rERMztDYy4a5omclYmfxKcenrjtHLvtPrCnVmdb
eFe3JXmjy6eS/DrMuLVYsta9Mdt++6qLxO+0dEc8UmInr18iUfReHcXrqccb9Z27Q61Lb13eJ9nc
1Z35rTvE9avY4bTkpG8xEfB05vYxqybc07R281naGMREdoT5JQqy9mply7Q3bV3iXG1eXw7TWSka
c258t7+tpT5/BjT7MfHqndz12Z+M4lMMKyziUJJiN1WSu9fku23RaOgKNJqbaTU1t9yelo+D0cTE
xEx1iXmM1Nt3W4PqvFweDaffx9vjDbGvxz+TP66QDRiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAOJxzU73rp6z296zsZMkYsdr2naKxvLyObNOfNfJbvad1dXkaeOdpvsc2yuZVzfbfqybutwu
s5s8R92J3dvJb3tnO4HSMegtmt3nfZvYp8SZl0z45NfSK7onH1bNcfRFqnUKJr0Y7dVtq7prjEsK
0XVpEM6028mW20IHK41aPo3J6zs4ODhdcvPnvExFevNXpMOrxi/PlrTee7PLX6Pwa09uaNlKtHg9
dM3z5d7ReOu02nu0JzZMfblrv5R5uvrcdImZ26T1mYhxs1Os7RH93PZ7axuafNfLitvbaYU3yZYt
PXs9NwHhui1HBa5LVicsb81onrEuVqNNSuS8Y67dZ6xPZa59Il9uX41vEitImZme3q2Kxbxora0T
Md/ROSa4Ztkj7c9OafL5LuGYubmyX3iu/TfbdSfVnpvZLT/XZK233+Mbbva1xRXyiPk8pwbH4N6T
adq5a71n0tD1WDL4tPe6Xr0tDpz8YVnJHWEXYxbqlBedoef4tW0XraO09HdyztSZcbUz43C+ee9b
SVMaeOfqq7+jGckQ1Yz7+7v2RN/WXPXZPjci2+2yyJaVMuy+uSJlA2d+pNoVRbeDcSxyTE+TDDlt
pdRXLTynrHrDOyiyZeVFnY9TjvXJjres71tG8MnJ4Nqt4tp7T1jrV1nRL1x2cvABKAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAHJ49qfD09cNZ97JPX5PPw2uI6j6Vrsl/ux7tfk1mWr7dOM8iLdm
vfebREefRsWldw7SxqNbWbR7lPesrn3Vteo7dYjDpMGCvfbeXQ0uLlxRLRxROfUc34p6fCHYrXlr
EejqrjY8uzCYW7MZjdVKqK9VlaxCYrsnYExBMRMJRPZA8/xPHtmpP9W2xx76vhWOInvt/C7ike7N
vwzE9kcapGfhlevTaFbFo8RqJ5vy8/RoW09ek0msxHfp3dzNoLzp4zUmZpMbT8HJyYJi20X2n0lh
ZY1li/RaidBF4w2mK3jrHaFGp1lN+tptPp5IjBkid5mIp16TKu0abBPv33vPlM7z+iPdFNcWXU5I
tkrNce/b1W5db1nTaf3ax9q0fxDW1ebNk2phty1mOu09VOm8W19orEz23j1TwfSeERFuEYMddptW
d43dvBn21eKJ75KbW+cf/JcTgMxXTb3nbljz+TpcPmc2uyZO1KRtVtGVdi0bx07qJnllsRO6rNTe
N4XVamsy8mnvPwc3R2jPwe8TPbdlxXNOPSZfhWWpwO85OFzv57qrODkzeHntSe8Sn6Rv0a3EZ218
8nXekfr1a0ZLVnqx19dWb6demXybOO7lYMvNMdW9S/VVLo0us7tPHdtUtEwJiZU3jq2Jhham8CVG
PNODNTJXvWd3qcWSubFXJWd4tG8PK3pPd1OB6veLaa89Y61/u2xfxh5c/rsgNHOAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAANLimq+i6O0xPv392rdeZ4rq/pOqnlnelOkIt5F8Z7Wj27I2I6sb25YY
V1ImY3dbQ08LRc23vZp2j5OJG+XJWle9p2h6HHtbJXFT7OOIpX+7TxT31j5rycdTh+Dpz+XaG/sw
w18PHWseULN2trBE9UcrJKBhFU7JAQi0dEomegNDUYovM7x3jb5tO1ZvpbaTLtzRExWfWPJ08kbT
Ex5NXWYYyV5omYtHWJieyeDzuizfRs19Jn6TM7Ru1uMcJxZqTkw+5f4ebqa7SV1MR4tdrx2vEfy1
axqsNOTLjnLXytVXi3Xj8+nmsxTLM16d5npPyUzpekTtSK+U7vS6vQ/SYmK1vWPS1HOn2dvvvvE/
tDO5XlcO+LbfHSd/W3o6/BdDOXPTnj3Kz38rS6Wm4FNrRyRzTH3p6RH/AKvR8L4dXSzE3jmtHn5I
mbfqLV+m4dbLSsZInHjr3iI6zLpYaxS01rHuxHRHiT9mv6s67Vj1aqL6326MrWiYa+/Q54BxPaGe
XRZpj8MquB4+Xg8zPnB7SX30to379GxpK1xcHiKz5IS8xr8PLPixH2bftLTy05o6dHYyVjLhy0t1
izjZa3pMVv3iO/qz1G2L+NbSajbNyW7xLsY8kTDz+fJXFqKZN4iZnafi6WHL0iYlStI7OO+7axW2
crFl7dW9jvE9ULN+J3ZbdFGOy+AYWpEqN7afNXLj+1Wd23KrJVMvCzseh0+auow1yU7WhY4fCdV4
OadPefcvPuz6S7jol649Tl4AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV581NPhtkvO0R+4NPi2
r8DB4dJ9+/7Q83Po2NTqLanNbLfvPaPSFDHV66sZ5ET0hRknyW2lTtMyouz0c8usx2n7s7vScKwx
zc1vu/y85p+maJh6Th+SOWeveXR4/wDLm8v+nX5mUWa9bbrInolmu5jdTNkxYFk2Isr3TuCzeGMz
+THdEyDDJO9Ja823rt2XWnya946pGvktDXta0ztWu/ybvLE9dkcoOf4GbJPWK1j49VmLh9JtE33v
Mevb9G7WsW8l1ccREISophiJ2jpDYpijbaOjOuOJ8ujOdqxsgVcsUjaETYvbaFFrgu5lVsm0yUtu
ryg43H5m+GIj1XcJzePoL4pnrWGtxmfchr8JvfHS1622if3QljzTTLes+qrNjrkiYtCzPMxnm095
YZJ6boS5teB49Tqscza97VtvWvlv8V/FOF34RrIxTM2xXjelp/eHoeA6XnzReY3ivX/0dfivDcfE
9HbDbaLx1pb0lOs+jO7K8Lis3cN+0NKcd9PmthzV5clJ2mF9J9GHHVL108dm1SznYr/Ft0tuhLb8
mNohFbMhLWy0mJ3rPXvDvcO1karBG8/WV6Wj+7kWrvDDBlvpdRGSnbzj1hpjX4z8mOx6UYYstc2O
uSk71tG7Ns5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeXneJ62dVl5KT9VTt8Z9W9xbWclPo+O
fft9qfSHEU1pv48ftYST23ZTDC/p0YtlVuvVjMbM5+LCZjYGWGdrTPxiHY4ffaf3cjTxz1v6xMS6
Olty2iXVj/Dk8n+ndrkhnGRo1v8AFdW3RCrZ5uiYsqrboncSu508yjmZRYQt50TfowYTbYGVrKrT
uTZjvukQnYhMIGVY2ZxPVWyrHVCWzXpVXkt3TE7Va+W4K7X3jv1auTNy3jdba0RZpamfroQN7Hk3
6wr1GTaN2OOJiu6Mu98NvgDi8Wy74d/yZ8PiPAiO2zU4nb6qIn1bugjfFE/ASp1ke9u15mbbRDZ1
Mb823kx0Ontn1OOkedoJCvT8I03gaKsz9q/WW+isRWsVjtHRKyrhe0XCfpWL6Vgr9fjjrEfeh5fF
feH0V5Dj3DPoOo+k4a/U5J6xH3ZZ7z3228evytOk7NvFbo0cdols47bSybt7HbddHVqUs2aW3Qnq
xVeu8LILR3SlZw3V/R8nhXn6u0/pLuPMXjeHT4Zruf6jLPvR9mZ8/g1xrvpz+TH7HUAaMAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAABRq9VXSYJyW79qx6yvmdo3l5viGs+maqYrO+OnSvx+KLeLZz2te1rZL2v
ed7WneZYWnZl5K72YV1xEyxmeqJljzIEWlVkszvbZp5soN3h2SJz3pP3odCnuWmPRxuERfJrZmtZ
mtY96fR28kbX3dXj/wAuTyf6bmK+9YX1s0cNtm3Sd4LFY2K23W1s16StiUJW7bp22RW3RluBuruz
mWEgrmCGWyNkoExKE1QlPmsqRDKeyBjaejWy2W3ttDUyz1QKslvehVqKTNosyyTvELabXptIJpaP
B39Ia2mz+JGpr51jdZefDx2hzuHZObNq58poJaGtjxJ2+LoaKP8ADRPo5+T3skx5OhpOmC0fBNQ0
5yTbn+bt8A0u9raiY6RHLVwY62mI6zMvaaHBGn0mPHt1iN5+aYVsACBXqMFNTgviyxvW0bSsAeE1
mkvw7V2w5Ote9besJx2er4rw2nEdNNekZa9aW9JeQjnxZLYskTW9Z2mJY7zz26fHrrdpbZsY7NGt
mxjvso1b9NmUwpx33XRO4K7VUTE1nmrvEx1bVo2VWiJE/XY4frY1WPlt0y17x6/FuPM0m+HJGTHO
1qu9pNVXVYt46Xj7VfRtnXXL5MfzexsALsgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHM4jxOMFJphmJv529Dq
ZLfjDjPEIx450+K3v2+1MeUOHSOWFc3nJkmZnf4yujpVlqunOeFpV2nctLCZUXRM7MJtsWlRkv3Q
ky5NmpWt9RnrixVm17TtEQnJabXisRMzPSIew9n+CRoccajURvqLx5/chfOest642OGcIpoOG2w7
ROW9d72+LQvXevyejcPUU5M+SvpLeOataraw2a0dLbLqTtK1G3Es4lVWWUSoldFtmcXUbpidgXzK
GEW3TuCUSncnsDFMMLSms9EC6J6FpVzbZE5ALy0809ZbFr9GtfrEoFMzuuwz0Ueey3HbaBLDXe7i
tMOfwWnP9I+NZbuttvhs1uBRtXPb4SDm3iIvf57N7Dbl0VrS5+XrltEd+Z1Jx7cNms9N4TURRw3T
+PrcO3WszEvZOD7P6aYiMlvu16S7y1QAIAABxOPcLnUY/pWCv1tI96I+9DtgmXl68Biy7/NtUu3+
O8HnFa2s0tfd75KR5fFyMWTdhrPHVnX9R0cd21S3Rzsdm1iuqs256wrmGcT0RYSx5d047X02SMmO
esd49YRE9WcdSXhZ2O1p89NRji9J+cei1xMc3wXi+KZj1j1dTTaqmor06WjvWW+ddcu8XK8BZmAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAMMmWmKu952UZ9XFZmuP3revlDTtzWnmvO8q3XGmfHb9ZanV3yxtWeWn7y4es
vPNtDqZJ6Ts5mppvdl/XXRMyfGvSNlu/RVvtOzLfoipLT1VTKbSpvfogRkvtDVyZOhkyvQcA4Dzz
XV6yvTvTHMfvK+c9U3rkW+zvA/D21urr789cdZ8vi9KDb45rejl8Rry6iJ/FV1HP4vXbBTJEfYt1
+UpiHM295bXsqrO9l8QkZ0lZEqqLeyBZHZLGvZkhIndADKJ3TMoqWQMZ6pjsxll2jsCLSrmU2lFY
36gieyu0LJk3jbsga0wdqzK20QpyztQGprL/AFMrOE05NLkt6qdVWZxNrSe5o9vWBLiUjnzXn0vL
q555dHt8HOwV928/1z/LpzXxbYccRvzTB+jucOwxh0dI22mY3ltIrHLWIjyjZKyoAAAAACJiJjaY
3iXleM8InR5J1GniZw2n3oj7s/8Ao9Wi9a3rNbRE1mNpifNFnVs65XhcWTdt47bnFuF24dm8TFEz
p7T0/pn0a+HJux1OOrOux08d1ndqY7tillVkzExLOk7yd4YxGwluViJhE45raL0na0dtlWO0+bZr
1TKi+2zptZGTamT3b/tLacvJjiY3XaTWdYxZZ6/dtPm1zrv1z78fPcbwC7EAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhkyV
xUm152iAZWtFazNp2iGhm1Vss8uP3aevnKrNntqLdelI7VRHRnrX/HRjx/tZREVjZXeybW6KbWZt
pCZ6S08tN7Nmbb7zCrJtyoS5145bSx5mWafelr3tsKmS/o08uXyhlly7RPV2+AcBnPNdZrK+53pS
fP4ytnPVda4y4BwHxOXV6uvu96Unz+MvVxG0bQRG0bR2G0nHLb2gCUDX12LxtFmpHeazt82wT1gH
mMN4tWs+rcr2aEV8DU5sM/cvO3yb+O0csLUTSdrLphRE8tlkZI7Atr2ZMazDJVKTYSCawi7Ksq7z
1QERvLK3ZGPrKbyCrbdnMcsbeaa18/RhvvM7oGEwTG0JmYYTIML22a2e28xELM19oURPNO4lOem+
n3ZY5+prVnMc2GYU4/L4A0a15cNf6rz/AC6fC6+NxCPOuOu/5tHJTbHj+F5/l1+BYumXJMd9o3/d
MRXYASgAAAAAAABhlxUz4rY8lYtS0bTEvH8R4ffhmo6bzhtPu29Pg9mq1Gnx6rDbFmrzVsizq2df
zXkMWTeIbNL7tbXaHLwzUctvexWn3bmPL8WFnHVL326VZ91MfFVjvvVlz79kLrcf2m7j7bNHH3bl
J2SirLQoy4t1++7G0dBC/RanxI8PJPv18/WG241+alovSdrV6w6mDNGfFF4/OPSW2b1zeTPL1aAs
zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAVZ9RXBTe3WZ7R6iZOpzZq4ac1p+UermZMl89+a/byj0Ra9815ted59PQ32hlrXXRjH
DpCLX6ML5NlNsm/ZRqstfdXzbsZt06sLZNvNB1Za8RDWyZdo7q8udq5Mu/mIMt4md2lmy7JzZuWJ
dHgfBL8RvGo1MTXTxPSPx/8AstJ1XWpIs4BwSdbeNVqq/URPu0n73/s9hEREbRG0QUpWlYrWIisR
tER5JbSccur2gCUAAAAPM8Sry8Uyz67fwuxbzVPGsE49XGbvF42V4M0TEL33ERnktsxpk3sumK2j
admFdPFZ33VS2Mdui2J3UU6LYlFSsN2O5NkCyJ6K7T1TEsbAsxdpReerKkTFGMxvYEz0rsqtbbpC
b2VT1QEzuwtbaGUxspuJU3neWdKoiu8rq12gCI92YatLcublnzbEz1aOptyZqTuDHLfxN6R0+t5X
qdJhjBp6UiPLeXl9NSMnEKxHa1+bb8nrlvxUAAAAAAAAAAABTqtNj1eC2LLXeto/R43VabJw/VTh
ydY+7b1h7ho8V4dXiGlmvbJXrS3xRZ1fGv5rzeHN02bEW3cys3xZJx5ImtqztMS3MeTeGFjqlb2O
8btql3NpbZtYsnSBLeiWfdTjtutid+ghherHS5p0+f3vsX6T8Fkw181d4lMvEWdnHaGnw/UeNh5L
T7+PpPxbjdyWcvAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAo1Oprgr63ntAmTqdRqK4K9etp7Q5d7Wy2m953lNrWyWm953mVd77R0
Za1104xxlN9lV8qnJl2a9s3xUXX2ybsJyRDWtl3YWydEC+2VRkzeW6q+T4tbJm+KRdfK1cmWZnlr
vNp7RC/R6HU8SycmCk7ed57Q9ZwvgOn4fEXtHi5/O9o7fJaZ6z1uRyOEezVstq6jiEbV71xevzer
rWtKxWsRFY6REeSRrJxz22gCUAAAAAANbX6aNVpL0npMRvWfSXlKamsRMVvXm+EvZXjmpaPWHzfL
oNRjzXicfWJ8phfPxFejx72x7xMzK+sXiNoiXlq+Pi6fWV/VfTNqfLJl/WTg9Pji8R70LqvMV1Gq
j/zcv6yz+lanzzZP1lWpelTET6S81Gp1P/Gyf90s412rjtnyfqql6asREdWM9+jz9eJ6yP8Az7uh
odZqMt458tpB1JvEViI3/RhzRt13/R1MNaziiZiJn5K9ZNceKZiIiQcu/WekT+iYrWI3lzdTrs+8
8uW0fJzcur1Np/zsn6g79phVaIeetqNR/wAXJ/3SwnUaj/i5P+6UD0ldonum161h5mNRqP8Ai5P1
lNtRqJjacuT9Qd22WN5aGeZyZd/KHJy59RHbLf8AVq31Gp/4uT9ZEvS8Lr/vSs2npzRtL1z53wK+
oza/HW2XJNd99pmX0Rb8VAAAAAAAAAAAAAAcHj/C5yV+l4I9+v24jzj1cLFk8nu5jeNpeW41wmdL
knU6ev1Vp96sfdn/ANFdTrXG+eq1q5F2LLtbZoY8m8d11bbSydErsYsm+zZrO/zcnBm226uhiyRK
EtrvCrJDOJTeu8A1MWX6Lqq5N/dnpb5O5ExMbx2cPNTeJb/DM/iYPDtPvY+nzhri/jDy5/W6AuwA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAa2p1UYo5adbz+xbxMlvqJ1OqjDHLXree0ejmzNrWm953tPmTPWbWneZ7yoy5YhjrXXTjH8s75N
mtkyxt0VZM2/m175N1V03yTKubMLXVXybeYLLX2VXy7eam+b0bOg4VquJW+rry4/O9uyZOq3UjVm
9r25axMzPaIdvhns1kzbZddM0p5Y47z8/R2+HcF03Doi1a8+Xzvbv+TotJnjDXkt+K8ODHp8cY8N
IpSO0RCwF2YAAAAAAAAACvUZYw6fJkntWN3k8dfHz2vLucdz8mkjFE9bz1+UOZosX1UzPm0nqI/W
MYo9FlcPNklfFGeH/NshLGun+Cz6PtHZtVZWlRLS+jxPkRpIn7rdoupHTdA5s6SI+7H6Mfo+32Y2
+To3neSIiZ7A0IjPXpXLePlMotGW3272t85datKzHZjbTVnsDj+FG/2Y/RlGP4R+jo20u7H6N1Ql
o+H8I/REY957R+jpfReiK6eOYHLtj2tttH6KrY/6Y/R2c+kjeJiFVtLG24hxpw7/AHY/RRkw9O37
O99Hrt1YX0tfOBLjcGp4XF8c+u8fs9c4dcVcGemSI61nd3IneN1orQAAAAAAAAAAAAABFqxes1tE
TE9JiUgPKcX4RbRXnNgiZwWnrH4XPi28PdXpW9JraImsxtMS8pxXhF9DecuGJtgmf+1TWW2N/la1
L7N7T5e3Vy6W3hsYcvLbqzbO9jvvCzvDR0+XeO7crO6FmGSvRThy/RtVXJ92elvk2rRvDUzU7pl4
izsd2J3jeBpcNz+Lg5LT7+Pp+Xk3W7js5eAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADs0NTrN96Yp6edkW8Wzm6+LNTq4pvTHO9vOfRoWtt
1mes95YWvs1s2fZldddOczLPLn2ju0MmebT3YZc2/mpm3qqllN1drsbZIhr3yzvtHf4AsvlYYseb
V5Yx4KTe0+UQ6nDvZ3UazbJqd8OKeu33peq0eh0+hxcmnxxWPOfOfm0mP+steT/ji8N9mKY9suum
L37+HHaPm9DSlaVitKxWsdohI0Y22gAgAAAAAAAAAABXnyRhw3yT92Nwef4xm8bVzET0rPJH5d12
CvLhho3rN9RWs9Z23n5y6O21YhrVYbdGOCfrrLPJRpv863zVS6FS09SvZj3lVZZRdPSqmnSWdrIE
ebOkK4ldTsgW1WKqd1oMZhEVZyRAImOjGI6rJ7IiATNd46qL02bHkiaxaoNGY2n4ImPgtyV2n0Vo
Gvlx7x2beiyTk08RPevSVUxux00+Fn2n7N+n5rRFb4AAAAAAAAAAAAAAACLVres1tETWekxKQHlu
L8InR2nPp43wz3j8P/s5dLveWrFqzW0bxPeJeV4xwmdFec+CJnDM9Y/CrY1xv8qvTZ+WYdbDk5oh
5zHk283U0eo3jaZZ2N5XYjrCnLSJhOK+8d1kxvCqzSwZvousrb7k9LfJ3nB1OLeJdLhufx9LEWn3
6e7LXN9Ofy5/W4AuxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAETaKxMzO0Qi9646Ta07RDmZ9VbPbaOlI7Qi3i+c3TPUaqcu9adKfy0722ZXvFa9
XO1OrjrESxt66ZJmcjPUanlidmhkzTZVfLN5VWvsC2b7R3U3yqrZZtO1esz2h2+F+zWTUcuXXTNM
feKR3n5+iZLVbqRzNJo9TxHLyaekz62ntD1fDOA6fQbZL7Zc/wCKY6R8odLBgxabFGPDSKUjyiFj
SZkYa3aALKAAAAAAAAAAAAAADQ4pl2pTFH3p3n5Q33E12Tn1eSfKscsLZ+orS00eJqbW+Lfnu1tF
XaJnZsz3WpCfsyp00fWSvmPdVYOmSUDd8kR3InoQosy7JmUX7MdwZ17ro7KKT1XRPRAsrO0rYndr
79V1ZBaQiJ6JgCSIJASwrO07MpV2nqBlrv1a1o2bf2qtfLXaQUTO0sb05o3jv3ZXhjS20xEphW5h
yeJjjf7UdJWNKLziyRePsz0lux1SgAQAAAAAAAAAAAAAADG9K5KTS8Rato2mJZAPIcU4ZbQZuekT
OC3afT4NXFkmlntc2GmoxWx5K71tG0vHa/RX0GpmlutJ61t6wrY2xr8dXS5uesN+tt4ef0eaa223
2dnHk3juyreM81OaFGiy/RtZET9jJ7s/2bdutd2jqKeic3iNTsd8a2h1H0jTVtP2o6W+bZbOO+gA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABje9cdJt
adohGTLXFTmvO0fy52bJfU23t0pHaqLeL5xdK9Rnvqb+cUjtCi94xxvK3JetKuHrdZvaa1ljb10y
cnIs1Wt3naJc++TmVWvMz1YWybfMGdsm3eWek0mo4jm8PT0mfW3lDf4V7P5tdMZdRviwfvZ6/TaX
DpMMYsFIpWPTzXmf+steT8jn8L4Dp+HxF77Zc/4pjpHydYGjC3oAAAAAAAAAAAAAAAAADG9opS1p
7RG7zszN6WtPe0zLua+3Joss/wBOzhzG2OsL5+IrY09dsSyYRijbHEMvOChb7KjF0yS2LQ169Mso
S24noyrPVXWejNVKbTuw3T3REdQWU6LYlVvsyiUDPfqupPRr79VuOQX1lZEqoZxIMksd0gT2VT0l
bPZVbuCaW8i8bwr32WxbcGnkjaZa9p2ndv5qbw5+aNugLItF6TEtvTX5sMb969HMpfazc0d9stqe
vVZDdAQAAAAAAAAAAAAAAAADV1+iprtPOO/2u9bektoB4TJTJpNRbHkja1Z6uto8viVht+0HDvpG
H6Tjj6zHHvbecONw7Ltfkmeqmo6Ma69DXbbZTkr1mGWO3RneOaGbZRoM30fVzSelMnT83aef1FZ7
x3h1tBqfpGnjmn369LNc3sc3kzy9bQCzIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAa+q1dNNXr7157VhGp1Xh70x+9f9ocy283m1p5rz3mVbrjXHjt91lz
5c9+fJ1nyjyhdM8lZlOOIiqrUXikd+kMreunnI5XEdX4dZiZcG+XmtNl/F83PeeWWHDOGanieSKY
q+5H2rz2hMzWd1Iqx1yajJXHhrNrW6REeb1nCPZumn2z62Ivl7xTyr/6uhwzhGn4Zj2xxzZJ+1kn
vLoNJnjHW7TbbsAszAAAAAAAAAAAAAAAAAAAAaPFrbaSK/itEOXt0rDf4xb/ACa/GZacRvaF58Q2
IjasQnzPIhCU92tMbZGzHmotG10C6nZkwpPRmipIllEbMIZIE7solgmJBnCyk9VMM6z1BtVllEqK
z0WRILYlluriWcSDJVbusV27gwInaSWM9ECyZ3hqamnSWxFmOSOaqRx725bNnSZNs9J+OynVY+WZ
YYr7TE+nVaIr0Ais81Yn1hKAAAAAAAAAAAAAAAAAABExvG09peU4nov9n66L0j6q/WPg9Y1OJaON
ZpL0+9HWs/EWzeVz9PbmrEtnyc3h9reHy26TWdnSr2YX6657ijLXpLX0+onSamL/AHJ6W+Tbv2aW
ekTv16JzeI1Ox6KJiYiY7Slz+E6jxdN4dp3vj6fl5Og2clnKACAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2jeQRMxEbzO0Q08uqtkma4ulfO3r8lefUePMxWf
cjy9WvlzVxV6T1Z61/x0Y8f7Wc7Ur1lqVy+LqOWJ2hp6rXddon5rOF1tfmz5OkT0qzb8dWbxjp1c
biuuilJ5Z6r+IcQrixzEy8zl1E6rNt1tMztFY81sztU1eRucN4ffi2p5esRM72n0h7rS6XFo8FcO
CkVpX082nwXh3+z9FWLxHi36328vg6TZyW9ABAAAAAAAAAAAAAAAAAAAAAADj8Unm1tK/hqppHvw
y1k8/EMk+m0GOPeafiFpCZYwolnXspvHvLa9mF46gmnZmwozRUiUCBKYYsoBLOFbKAX0llEqqyzi
QXRLOJVRLOOwLIljZMEgrlhKyYYTAK5nZPN0RZjugUanHzVlz6xtLq361c+9eXItPpXX0dubTU+E
bL2lw2++O1fSW6m/VYAISAAAAAAAAAAAAAAAAAp1GbwcfTreelYEydcuMcRrM/L9nnlsV6wqpi2r
tv133mfWVkRyRtEdGFva7MzkYZNoamWN4bV4mYa9qztKIujhVppxGI8r1mJegeZpknBqKZY+7L0t
LRekWrO8TG8Ns/HJ5ZypAWZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAADS12fp4VJ6z9qVuq1HgUiI+3bpDl589cOKZmevqprXPTbx477rDJlrhr1nq4+s182tMRP
RqaziXiZJrWekNG17ZbxWJ336M5LXRbI3dLTJrs07RMY6fan1dHLrowY+X7MVjt6N3R6Kul0EbWm
s7bz8Z+LnabQX43r7Y53php/mXj+Dnv0f1JO1x/8ZxbUzj02O15mfLtD13AvZqnDds+pmMmo26el
XX0Wh0/D8EYtNjilY7+s/NstpOOTW7QBKgAAAAAAAAAAAAAAAAAAAAAADG88tLW9I3BwJtz6nNf1
vK/DHVqYJ3pzT5y3MPZeojOWMQylEKpTVjZnDCwkqzYQyRRICATCITAJZQxhMAshnEq4ZQC2srKq
qrIBZCWNZZgwswmFloVyCu0dFcx1WyrtCBhv5NTPHXds2U5o3hIz4ffbPt+KHUcTSW5c9Jme0u2v
VYAKpAAAAAAAAAAAAAAAAYZctcVOa35R6tLrltN795/YvknNqrfhpPLH92V5isd9mWq6fHjk6rn0
ZxG8KK5Jm/wbVZiYZtqrmkqL023bkxvCiY3lJHNyRG81mHS4Rn5sNsNp64+3yaWaNrzOzHBl+i6q
mT7s9J+S+ay8mex6EIneN47SNXKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAImYiJme0JafEs3h6fkidrZOn5eaLeJk7eOdm1Hi2vmtPTry/CHmOJcUvmvOPF1n09Pm
6HF9ZGm01qxO3R5vSY7XwzmzTy47zzTEd7en5Mfvt2/PURWdo3tvPrPlKymbktFqTtMTvHzbOLDG
f63JXbFX7FdnoODcDprZpq9TjiMMTvSn4vj8l5fxnrk91saPSa7i2hpOfbTVt5x1m0fLydzR6PDo
dPGHBXasd585n1lsRERG0dIF5OOe6tAEqgAAAAAAAAAAAAAAAAAAAAAAADX11+TRZrf0y2Gjxe22
gtH4piP3TPpXKwxtjhuYo9xq442iIblI2pC1RET2ILd9kxCqRjZmwlCSEohIJAQAAJZISDKGUd2M
MoBnVbVVCyAWVWeSuqyOwIlXZZKue4MJV2WWYT2QKbKL9YlfdRdIo35b7/Hd3KTzUrPrDh27uxpb
c2mpPwX/ABX9XAKpAAAAAAAAAAAAAACekTIp1eTwtJmv+GkyJn1oafeazbfpMzLR4jq/o8b823zX
6XNF8ERCvTcNpxLV5LauvPhx9Irv3lhztdtv8TtaWLicXrt03jzjzb2k1nid56ty3s/w+a7Uwzjn
1raejlarhmbhl/FpbxMO/fzj5p/ixSeXOvTtRfeI280ZI26tfDm3pWe63LaZx7qtGvniJ6tPLvOK
fOa9WzbJvTbza02jl3n5SSljscK1MajSxWZ96nSW88xw/VfQ9XMT9nfa3yemid43jtLeXsce88qQ
EqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADia3UTm1l4j7OP3Y/u
7Vp2rM+kPJW1PhYcmS0+9MzKm/jbwz31weMzbV8UppazPL9q0/BF4rk1GLDSNqxPWPhCnHmnNrtT
qPKteWPm6U6OdHaZvO+SaRNvhv12Ub/q3FhtrNVj0uKOt56z6R5y9zix1w4qY6RtWsREOJ7L6OKa
S2rvX6zNM7T6Vh3mmZyOfya7eACzIAAAAAAAAAAAAAAAAAAAAAAAAAAczjVvqMVfW/8AZ03I41bf
Lp6/OVs/UVrY47NyOzUxd4bUJpEbb3Z7IiOrKIVSjZhMLJYyhKIgmGUQSDESIEbJEgQmCITEAmGU
IiGUAyhZVhDOoM4Wx2VQtqBKuyyWEgqlhKyyuyBVaGtkbNmvk7A15l1eH2300R6TMORPSXT4ZO+O
8fFefEX63gEAAAAAAAAAAAAAAAq1WPxdLlp+Kkx+y1Fvsz8gjhaDauGK8sx07y3OE3m1tT6RaP4c
vU6yMNKUx73zT0ilY3l2eF6a+m0kRl/zbzz3+Ez5M8z26fJruW6wzYq5sV8d43raNpZjRzPPaTmx
5b6bJ9rHO3zb2WJ8GWPEscY9bgzxH2t62n19GWW0eHOzHU5XbjXZ1x8WTnz2iZ7S2M1IjH2+LX0V
KTqs8zO9ot0j8nUthi1J3UaOFMTfLFo6xMbS9BwHWTqdHOO8+/hnln5eTjYMFo1WTH5VnePzXcIm
2k4zlpPSmXy/hfF5eMfJns69OA2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAADG/2LfJ874rW845mubliY7bPoto5qzHrDz0+yePNF41OotaJ7RWNtpV1OtfHqZ715fhu
j8adNpcVfeyzE2/vLuanhOu1nEctIxTTFa/+ZPbZ3eHcF0vDbTfFE2yzG03t32+DokynXl9+leDB
TTYKYccbUpWIhYCzEAAAAAAAAAAAAAAAAAAAAAAAAAAAAcXjE/4zDH9M/wAu04XF5/3jj/0f3Wz9
RUYmzDWxS2I7FSyjuzY1ZKpRKEygEwiWUIkGIk2QJNhKQhMIhkCYZQxhlAMoZwwZwgWQshVCyATL
CWc9ldpBhZXLOVdpQK7NfJPRdaWvknoDVvPvOnwuel4+TlXn3nS4VPvXj4QtEV0wAAAAAAAAAAAA
AAAAAVV02CmTxK4qRf8AFFeq0AAAanEsfPpZmO9Ji0NDLfkwdOsulrumiyzHlVzJrz4Ovoy26vB8
cTBa9NffLtMY77Rv8Yegx5ImkKdJoY1HC81Y+3OSbVn0mGGkmbY45u6tnrrTOu2xGO0RxCd+nNVj
qKxTV1vH2pjaGtnyzXXYdo96ZmGXEMk15b7/AGZiVerWPTYckZcNbx5wzc7hGbnxXxzPWk7x8pdF
0S9jh1OXgAlUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAcPjEf4/FP9H93ccXjMf4vDP9Mx+62fqKrx+S+GvibEFSsqyYwlVK
ZYsmIMoRKYJQIPIEiQ2ATCUQygCGUIhMAyhnDCGUIFkLIV1ZxIMpVWWSrsCuyqyyyq09ECq8tfJK
66jJ2Bp5J6upwn7dv9Lk5J951uE/av8AJaIrqAAAAAAAAAAAAAAAAAAAAAAq1Mc2myxPnWf4cmtu
XT9fR0tffk0WSe28bfq5Wbamm3326MtunwfK6PCv/AxPraZ/dz9PO97/AOqf5dHhdZrw7Dv3mOb9
XOxRFM+avpe38mvkPHf/AFWlrKba7Tzt99ZxKkfR7euyNXMTrtPHfa0z+zPiM/UR8Zj+Wbdu8HpN
M2bfzrV13M4dO2pyR61dNvj44/J/oAWZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADj8bj63BPzdhyeNx0wz8ZWz9RWri7Nmv
VrYu0NmqaRZHZlDGGSiwxZSgCEkCBCQSCQBMJRCYgEsoYx3Z17AlMIhlCBnDOGEM4AlhZZKq4KrK
7LLKrIFN2vdfZReAaObu6/CO9vk5OePR1uEd7fJeIrqAIAAAAAAAAAAAAAAAAAAAAGtxCk5NFliI
3mI32+XVyNTyZOHTee946PQKPoeDffw4777eW/yVs60xv+ZxOnr4Okx1t05KRv8Ao41Z5q3yed5m
XY1szXRZ5jvFJ/hxItP0aOSN9q7yrtr4f2tHFM5+KT16Yq/vK/iGSbXw4vO14UcPx5MGfNbPG18m
1oj4THRsTw7VanPXVYpi3gzMcnrvCnG11JOupwuN8+a3pEQ6jT4divjxWnJExa09pbjbM5HHu90A
JUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAHM41H1GOf6nTc/jEf4Ws+lls/UX45uGekNujTwdm5RNIthKIZKLDFlsiQIShIC
EgCUJ7AmGTGO7IDzZQhMSDJMMYZQgZwzhhDOATuqssmVdgVWVWWyqtCBTeVF19lF+wNLNG7q8I+9
8nLyupwnt+S8RXUAQAAAAAAAAAAAAAAAAAAAAAAItWL1mto3iY2lyrcLyUxzix2ia2nvPeK+jrCL
OrTVnxpanhuPPemSs8l6RtE7dJj0ldpNP9GwRSZ3neZmV4cR/Vs4AJQAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANHi1d9H
M+kt5ra+vPoskfDdOfqK4mn7Q3aNHBPZu0W0RdDOGFWcKLCJZeTGQQlCQSgASBsCYZQxhlAJTAmA
TsmAgGcM4YQyjsgRLC3VnaVcgwsrt3Z2V2QK7tbJ1bN5a9waeWO7p8Knt8nNyebpcK8vkvlFdQBA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK9RXmwZI+ErEWjesx6wQeZwejeo0cccuW8
elpblJaaRGxVnCuss4ZrMvJEgCAASISCQIBlCYYpieoM0wx8k7gzIRueYM4Z79FcSy3QEsLJmWFp
BjaVVpZWlXMoGNmvkXXlr3kGtknu6XCf7OXkl1OEdl8orqgIAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAHmskcmtzV/rls0U62OXiWX4zErcc9GmkRfWVkSqqziWayxCPIANwBIhIJSxS
CRG6dwZwlhEs4BluMdzfqgZxLLdXuy3AmVdpZTKuZBjaVVpWWV2QlhZRdfZRcGpl7urwfrzfJy8r
rcH61vPyWitdMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHA4nHLxKZ9awnH2ZcY
jbW459aq8fZpfiI2IZwrqzhmsz3Ebm4JN0AMhCQSIASndiAziWUSriWcAyRujc80DM3RCfIETLCW
UsZEsJYSslXZAwlTddPZTkBp5e7r8Gj6rJPxhx8k9Xa4PG2C8/FaK10QAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAcfjcbZMFvnDWx9m5x2PqcNvS+zSxT7sNPxH62YZQwqzhRZO6UCB
KUAJTux3SDIRuAncQAmJZRLBMSgZ7iIAZRKd2DICUSlAljLCYWMLIFVukNfI2bNbIDTyT7zu8Ijb
Sz/qcG/2nf4T/wCE/wD2WnxWt4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHL9oL
+Hw2cm28VvEuPptfgyVj6yIn0no7/FtJfW8NzYMe3PaPd39d3iMug1WktNc2C9dvPbeP1aZ9xF+v
T471tHu2iflK2HkqWmvaZj5Surqc9Ps5bx+alTHqYHm68S1Vf/NmfnC2vGNTXvyT84Ql6A3cSvHM
sfaxVn5Ssrxyv3sM/lKB1xza8bwT3pePyWV4tpZ+/MfOEjfGrXiGlt2zV/PotrqcN/s5aT/+wLRj
FontMSlAlKEgndO6IAZQljDIEgeQljLCzOVdkCu/SGrkbF56NPNeKxMzMRHxENe0+89DwuNtHHzl
5PJr8NcnLW3Pbf7r1nCZm2gpae8zMrz4i/W6AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAETETG0xukB4HVaeMHEtRi26RedvkyjBSfX9W77QYvC4xz7dMlYlrU7M929dWJLFc6aPK0q
7YLxPS0S22FlP6q38Zac0yR92s/KVc3tHfFf8tpbcsLRvB/dR/8ALLVnU0r9uL1+dZI1mnmdvGpv
6TOy6ym+Oto2tWJ+cJ/tW+KLK5KW+zes/KU7tG+h01p64qx8Y6NXNo6Y+uPJlp8rLf0rfG7MXtHa
0x8pZxqs9e2a8f8A7Oj7HaTHn0+f6RWM23LETfr6vRW4PoL99NT8ui7F4+vEdXXtnt+fVbXjGsr/
AOZE/OsPS29nuH27YrV+VpeV9pdPXhOtw49NG9Mld55+vXcTPd42I47qo7xSfyWV9oM8d8VJ/VxM
d8l46xWF9cV7en6o/qLfxp2I9ob+eCv/AHMo9op89P8A/wBORGmyT5R+qfo2X8P7n9Q/jTsx7RR5
6ef+4/8AuHftg/8A6cWcOSO9J/WEbWr3pY7Efzp2Lcfv5YK/9zWy8d1E/ZpSv5Oba1/+Hb9lc+LP
bFt87I7E/wAabWbiurvEx4nL/pjZzc2bJkn372t85ZXx55/BX85lucC0vPxnTxlnnjm32mOiZqUu
LJ2p4TwnVavNWaYbRTfre0bQ99pcH0bT0xb78vmtiIiNojaErMwAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAHnfarF7umzRHaZrLjYrdIen9ocPi8JyTt1xzF4eUw23rCm3R4r6bMy
wt6kdTaWLdjswmNoZontsCm0K5XWjopnuDC0dGpqG5bs08/daKV672MjbSaif6oh6Z5f2LtvptRX
0tEvUN3Jfo8f7cYve0eX4zV7B5z20xc/C8eSPuZIRficfXlcPaG7ino08HWIbePpLF2NuiyOyrHK
3fZFSwuovHVfaVF4QK5YWTM9UT0EKry6Ps1Tn4zjn8NZn9nOtLseydObiWW34cf918fWfk+PYANn
KAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAq1WKM+ly4p+/WYeBxTNd6zG0xO0
vobw3FcP0bi2em20Tbmj5Srr418V9sa2Z7qKyzi07MXUylhaU7yjqhLCeiq3ddaFNxFYW7NLNG8t
zya+WO6Va9J7FW66mvwidnrXiPY3Ny8RyUn71Jj9Ht3RPjk19HK9pMHj8D1ER3rHN+jqqtTjjNps
uOe16zAifXzfTz7kNyndpYazS9qT0mszDdoxrsi6m8LazMq6zDOsq1ZEyrt1WWlXaUCqyq0rbKbi
Fdp6PReyFd8uqv8ACsfy83aXrPZHHto89/xX2/SP/dpj6y8vx6EBq5gAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAB5n2q03LfDqqx39y39npmlxbS/TOG5se29tuavzgWzeV4mtui2
O3RRSY2hdVhqO2MvI36iu9lUsrSrvDHn6spnmSiq5jooyV6tq1VV69RC32byTh43h8otMx+r6I+Z
aK/g8TwX7bXh9Mid4iW+fjl8n1ICWb57xLBOm4zqse20Tbmj8+qKdnS9q8PhcTw5tumSm0/OHMxz
0Za+uzx3sX1t0Zxurr1ZxvspWiZYWZbsbT0QK7KLrZVZJFaqt5vbezNOTg9J/FaZeJns93wCvLwb
T/GJn92uGHldIBowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADuAPA67F9H4l
qMW20VvO3yRWW97T4fC4rXJHSMtI/WGhVlue3b473K2KzMML4+62tujG9pnozXaOSOVFMnVbmq1t
trJRW5E7wwvUxTvCyY6CHOt7moxz6Wh9PxTzYaT61h8x1MbZK/OH0zTf+Fxf6I/htj45vL9WgLMn
mvbPFvocGWO9L7fq85p5maw9d7VYvE4JkmPu2if3eW0+PasdFNOnxfF1Y2hlykRsmY+LJ0MZjZXa
eq2eyi8oQTO0KLdZWzPRjWu6VaqtHR73g0bcI0sf0Q8Nkq93wqNuFaWP+XDTDDytwBowAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAef9q8HNpcGaI60vtPyl56k9Iew49j8ThGe
PwxFv0l4zH2U26fDfTYiyJljvsjf4sm6vJ1hrXjq2MkqLdZEVbgbMx0auGdmzNt6iHN1Ub5af6of
TdPG2nxx6Vj+HzaaTm1+nx/iyVj930ysbViPRrj45vL9SAuyc7j1efguqj+jd4/T33rD3HEcPj8O
1GP8WOY/Z4TTT7sKadHhbcsZnaCJ3TPZk6VdrKbTutmP0U2nqgrGOsr8deiuI2X09EqKM1dt3uuG
f/jdN/06/wAPE546S9rwud+Gaaf+XH8NMMPK2wGjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAABrcRp4nDtRWPPHP8PCYusPoWSvNjtX1iYfPuWaXtX8MzCuvjfw32siu8ptXoxi
0wy5t4YulReqmazu2skbquURWFInddM7VYRGyL291KFnCcfj8e0le/Lbmn8n0N4b2Ur4nHLWmPsY
5e5a5+OXyXugBZmiY3iY9Xz7NjnTa3Ph/BeYj5PoTxftFg8Hjk2iOmWkW/Psrr418V5WrWd2faFc
V2jdnEMXWxntupmN7NiYU27iWML6dVMVnddjgVqMsdHr+CW5uE6f4Rt+7yuSsTDv+zWXn0WTHP3L
/tK+GHl+O0A1c4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8Dn93W56/wDM
t/L3z59qp24jn+OS38lnpr4r7ZxHQ2TEstt3PXUrt27K57rr1VT0BjKnJPRbMqMs7QlV2fYvHvrd
VknyrEfu9m8f7FZI8fVU85iJewbT45NfQBKo817W4eulzxHaZrL0rje09ItwqbfhtBVs3leai8RD
KLw1sduesL606dWFdsZT1jdhNeq6K9DlhCVUU6s4jZnt1YzAhnM71dH2bycmszY/K1d/0c6OzY4R
fwuK4p8rTstn6z8k7HrwGzkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHz3
Vxvr80/8y38voTwGpj/F5/8AqT/JfjTx/WVeyY6FPspc9dZPVXaOq2WEwIUTVRmjo2rNfLHRI3vZ
DJycXtX8dZh7t879nsnhcbwz23tt+r6I2nxyb+gCVBzuPY/E4PqI9K7ui19fTxNBnp60n+Aj5/pJ
3jZu1aOnnltMNussdfXbm+l3ZM9URHREdZVXTuT1Nk7boQiOkJw28PU47/htEp5eivJPLMTCZ9Vv
x7mJ3iJ9UqNHk8XR4b+tIXuhxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
weqjbWZ4/wCZP8vePCaz/wDIaiP+Zb+UX408f0r9lOxWOifJhXWjfyYWllPRXYQxnrCrJHRd3YZI
6A1NJecHEsN/S0T+76bE7xE+r5dk93LW3pL6ZpMni6PDf8VIn9m2fjm8s9rgFmQxvHNS0esbMiew
PnHLyai9fS0w2aNfUTtrs3+uf5bGPqy068fF227KtSsdFlKqNGMV6myyY6sbdIQI8tlOWOi6Jhhk
j3RD0vA8nicMx9etZmHRcT2Zyb6XNT8N9/2dt0T449T2AJVAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAHhdfG3E9TH9cvdPEcXjk4zqI/q3L8aeP6xr2TsxpLOekMK6mFo6qpXSrm
OqBixvHSVmzC4OfqK7S9/wAByeLwbTW9K7fo8Fqo6Paeyl+fglI/Da0NcMPK7QC7AAB8313TiOf/
AKk/y2MHWrX4jG3E9R/1Lfyv0/aFNOrHxuU7LI7MMayGTVlHWUXhNe6Z6wIUsb9d1m20q7dkDpez
N9tRqKT5xEvRvKez9+Xis1/FSYerb5+OTyf6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAB43j9eXjN/jWJ/Z7J5L2mry8Upb8VIF8f6aGOey2eynHvOy7bowrrYSxZSwQJ2YXZ
92N4BoanrEvVexmTm4blr+HJ/aHltRHSXofYm/1Wrp5RaJaYY+X49WA0c4AD51xONuKan/qW/lbp
+0MOLRtxbU/9SU4J7KadWPjep2WQrr2WRPRk1TvsndXMpiRCb9FNu0rbTuqvKBscCjfi9PhWZeue
V9n434rafTHL1TfPxy+T/QAszAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHmv
avHtfTZfnV6VxPajHzcNrf8ABeJFs/XnMcr4no18c+6vr2YadkY2YM57sEDLyY37Mo7MMnYGlqO0
vQ+xNfqNVb1tEfs87qZ2rL0/sVX/AHdnt65P7Q0wx8vx6UBo5wAHz/jUbcX1PT78qtO2vaCnJxjP
8Zif2amnnspp04+OjWejKJ6MKdmcMmyJn4m5ZHzEVPMwtJv0VZLbQDqezcb8RzT6Y/7vUPM+ytZt
n1OTyiIh6Ztn45N/6AFlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABocbxeLw
nUR5xXm/Rvq8+OMuDJjntaswEeBxT0bNZ6NatZpNqz3rO0rqsdO3PxlaWEMpY+aqWXkryT0ZT2V3
7A0dVPuy9f7G124NM/iyT/Z4zWT7sw957MYfB4Fp4/FE2/WWmGHldcBowAAeM9qKcvFeb8VIly9P
0nq7ntbTbVYL+tJj93CwT76unR4/jo0nozhhTsy3Y1sWljM9Ce7HyQIm3RRlttVbaWrnt0Sh6n2U
x8vD8mSfv3/h3XN4Bi8Lg2nj8Uc36y6TeOPXugCUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAPD8RxeBxXUU26Tbmj8+quro+02Lw+I4ssdslNvzhzazvDPbq8d7GW7Dfqz2VzG
0s2qd+iu/Zn5Ksk9BVztX1mI8930zh2LwOHabH+HHWP2fNYp4+vwYvxXiP3fUqxtWIjyjZtj45/L
faQFmQADzftfj3w6fJ6WmHmsP23rvaqnNwqLfhvEvIYZ+sV038bo0noy36MK9oZQxrdMyrlnMbMZ
QKrS1M07zEestq/RRjr4utwY/wAV4j91p9V18fQdJj8LR4ccfdpEfsuREbREJbuMAAAAAAAAAAAA
BAJAAAAEAJEAJQAJQAJEAJQAJQAJEACUJAQlAJEAJQAJQJAAAEAJEAJBAAAJAABAJEJAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwvanDzaPFmjvjv8A
tLztJ3h7HjGHx+FainnFeaPnHV4vFbeIU038VbHeGF+kso7Mb9mTdhKnLK3dRm7SIrHhGPxeP6Sv
9cT/AHfSnz72Zx+J7Q45/BWZ/Z9BbZ+OXyfQBZQABzeP4/E4NqI9Ii36S8Ng/wAx9C4jTxOH6ivr
jn+Hz3B/mQi/GvjdCnWNlsdI2V07LIlg6USrt2ZzZXMoFV+zPhGLxeOaavpbm/RVltEN72Yx+Jxm
b7dKUmf7L5+s9/HtRA2cqRACRACRACRACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQCQQCRACRACRCQBCQBCQB
ACRACRACRACRACL1i9LVntMbPATTwdRkxT3pea/u+gPE8Xx+DxrPHlaYt+qNfGvjvtXXsi0dOrKk
dEXjZg6VMtbP2bMtXUdpEV0/Y2nNxbNf8OP+727xvsXH+N1U/wBEfy9k3nxyb+gCVQAGOWvNivX1
rMPnGGOXNNfOJ2fSZ6w+dZKeHxDPX8N7R+6L8a+L63KdoZ7q6zvEMpnowdKJ6ywmWUyqvIKM0vQ+
x+D6rU55+9aKx+TzWa36vbezmDwODYenW+95/Nphj5L6dQBo5wAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAEiAAAEoA
AAAAAAAAAAAAAEAkEAkRuAkQbgkQAkQAkQAkQAl5T2nx8nEMOT8dNv0l6pwfarHvpcGWPu32/WCr
YvK4mOem6b9mGKd4Z3idmFdka0y1c892zfpMtLPaNpEV6D2Kj/Eauf6YeweQ9ieuTVz8K/3evbT4
5NfQBKoAA8FxCvJxrUx/XMvevD8Zry8fz/Haf2RfjTx/6RSOnRMyypHu9kXjowrqVSrvPRnZVl6V
kK0775MsUjvadn0nT4ow6bFijtSsVfPuFYvpPGtNTy54mfy6vorXDm8l9pEC7JIgBIgBIgBIgBIg
BIgBIhIAgBIhIAgBIgBIIBIAAhIAhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAA
AAAAAAAAABAJQkAEAAAAAAAAAAjc3BIjdG4Mkbo5kcwMjdhzHMDPc3V8xzAs3N1fMjmBZubq+Y5g
Wbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmOYFm5ur5jmBZubq+Y5gWbm6vmTzAz3N2HMnmBlu5ftFTx
OEZJ/DMW/d0t2rxKni8N1FPWkiZ9eS08e7Cy8dGGn6UhZaJljXZGnmc3UT3dPP2cnUT78xCIV6j2
H/8A9c/6f7vXPI+w8bU1U+vL/d63du5NfUiDcVSIAS8b7RV5eOb/AIqRL2TyXtNX/e2KfXH/AHlF
+NPH/pr4+2xcxx0hFpY11K7R16KM32ZWz3UaidqSgrc9kcPicWyZJjfw6T+727y3sXh2xarN+K0V
h6lvPjj3e0ASqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJQAAAAAkQAkQAkAAAAAAAAAAAAAAA
EgAAAAAAAAAAAAAAAAAAAAAgAAABKDcAN0bgkY8xzAyRux5kcwM9zdXNkTcFm6OZXzMeYFvMibKu
ZHMC2bo51U2RuC2bom6rc3BZzom6sBZzI52ADPnOdggFnMc6skFnMc6rc3BbznOp3RzAv50c6nml
HMC/nOf4qOY5wX85zqOc5wbHOc7X5znBsc6edr85zg2ec52vzpi4NjmY5bROG+/bllVzsNTk5dLl
n0pP8BHmMHWNmzt0aum8obm08vVjfrtnxztR0mXHzTvaZdjVRMTLkZo6yiFen9iZ2pqY/wBP93rN
3kPY+/LfPX1rE/u9XzN3HfqzdO6vmTuIZ7m7Hc3Bnu8t7TR/vHBP9E/y9Pu837SV31umn+if5Rfi
/j/01MMb1hjkrtKzBG0bMsmOZY11tOYamr6Und0LUc7XT7u3rJPqL8er9lcPhcFpbzyWm39v7O00
+FYvA4Zpsc94xxu227jv1IAgAAAAAAAAABKAAAASgASgBIgBIgBIgBIhIAAAAAAAAAAAAAAAAAAC
UACUJAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAg3AEbomQZbo3YzLGbAz3RNlc3YzcFs2YzdVN2
M2Bdzom6nmNwW86JurTAMuY3REJ2BB1ZRVMVBhsbSsiqeUFXLucq3lTygp5TlXcpygp5TlXcpygp
5TlXcqOUFXKjlXcrGYBXysdlswiYBVMdUTCyY6sZBWxlnMMZgGLGZZSwkDdHMiWO4MuY5mEyjcFn
N1OdVzHMC3nTzqeY5gX85zqOZPMC+Lqdbk20eb/RKOZr8QybaK/XvtH7iZ9aGlp2luzT3fg19NHS
OjbmPcYX67XH1XSZ9XIzRvMuzrK7zLkZYmYnciunb9lZ5dTk+OP+71cXeP8AZnJ/ip2nf3J/l6iL
/Fu5L9bMWZczXi6YuIbEWTzKIuyiwLt3nuO25uI4a/hx7/rLuczg8TicvFLbfdpEK6+NPH/phhjo
stLGkctUWnoxrrU3j1cnWTzZq1jzl1clo5Zcu8c+txR63iP3Tn6pv4+g4o5cVI9IiGe7CJ2iE7t3
GyN2O6dwSINwSISAlAAlACRAAlAAlACRACRCQAAAAAAAAAASgASISAAAAAAAAAAAAACQAAAAAAAA
AAAAAASAAAAAAAAAAAAAAAAIAAAQCAJljuljsCJlhMs9mOwMJYys5TkBVsjZdyHICrZPKt5E8oK4
qmKrOVOwMIqyirPY2Bjyp2ZbAI2NmSARsbMgEbI2ZAMdjZICNkbMkSCNmOzJEgx2YyzljMAwlhKy
WEwCuWErJhhMArlhLOWEgxljMpljIImWMyTKJA3N0IBO5vux3NwZbnMx3NwZczT4jf3MdPW27a3a
fJOq1XNP2KdIRfi+J2trSYfcjeF+Wm1OicVeWIiN9kai8xjY12ORqultnI1Ecsujq79XP1FovWYI
rTgeq+j8QrWZ+3Mx+r2UXeC0WG2Ti2kiN5mL807eUREvbzbaejefHJv62Iv8WUXa0WTFhVtRdlF2
rz9WUXBtc7jR9dqc2T1ttHyhvZMvJitb0jdq6XHNcNenWVN3028U99WRj6Kb02be3Tq18/SN2Lpc
3UdN9nOmZrqKX/DaJ/d0svvTLRzV3jomK6+Pd1vvWJj0ZczT0mXxNJht60hfFnQ4qu3N1cWTEgs3
Tur5k7gz3N2O5uDM3Y7m4MtxBuCQASIASIASAAAAAAACRCQAAAAAAAAEoSAAAAAAAAAAAlAAlCQA
AAAAAAAAAAASAAAAAAAAAAAAIASgAAAEJAQJQCNkbMgGOyOVnsAw5TlZ7GwMOVPKy2NgY7GzIBGx
skA2AAAAAAAAAAQkBAEghEskAxYzDPZGwK5hjMLJhjMAqmGEwumrCagomFcw2JqqtUFEsLLrV82F
o7gqljKyYYTGwMZRKUSCAQAboJnaN5Bjkneu0d5W4ccViIiOzHFWbTzNumP1Zarr8eeRMbxDW1Mx
NO67NbkhzNVnmInqzaOZrL93JyZeV0M1++7S02jvxDWxhxx033tPpC8Z6rrezWjmZyazJG2/u03h
2vFibTHoqvamiwVwY+nLGzV0+SZ1Mx8G0/45tOhzJ5lXMc3UVXRdlF1HP+iYsDPLPPy49/tz1+Te
pSIr0ho6ak5Ms5J8o2q6NImOrHV7XX488ypzTtHXo0s9t6zG7c1G1qz6ubeZiZ3UatXJG3yauSO7
cvMTEx5tPLb3prPRMVr0HB8vicNxf0+7+kt+LOJwTJyY/Bnz3tH93X36N58cWvq6LSyiyndMSlC7
mZcymLJiwLosmJVRLKLAtiU7q4lMSCzc3YxJuDMRuAlKAEgAAAlAkAAAAAABKAEgAAAAAJAAAAAA
AAAAAAAEgAAAAAAAAAAAAAkAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAhIAAACAAAASgAAAAAAEAAAA
hGzJAImGMwzQDDZjNVuyNgUTVhNGxysZqDVmiu1G5NN2M4waM0+DCaN2cbGcQNGaMZq3JxMJxA1J
qx2bU4kU09slorWNwa20z02RXHbJbl26QvtFovbHWkxEdJt5y2MOHlr2U1W3jx+1hiw8vSO63lmI
XRTaEWmtY6snRHO1VpmJ+DjavpSZl2s8b7y4HFcnh0n0gha5ebJN55KRM2mdoiPN6fh+kpwXh0Wy
RHj5Otp/s5Ps1p62y31+em9aTMYt/OfVfxTiPjZ52naI7fBrI5t66xz5+a1rW7yx0eSL6iZjtEOX
qNbSletom3lENjh2fbHzbbWt3iVozruc+5ztWubf4M4ybpQ2Oboyrva0Vjza8WdDR4OkXt3n9ldX
kaePP9VtYqctYhdvt5oivTeCZ2YOxXk6ubqMfV0b9mrljfqlFcq88k7z2U5axeItDa1OPessuC8P
ya7XRWYnwqdbT/ZMilvIu4dpslNdixXja8Y5tt85djZdbDWnGOesRtXFtuw6T27No5Kx2OrKYQlC
ExKJgBnEpiyvdlEgsizKLKollFgWxLKJVRLKJBbEp3VxLKJBnuMWQJEbpBIAAAJAAAABIAAAAAAA
lAJAAAAAAAAAAAAAASAAAAAAAAAAAAAJAAAABAJABAlAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAA
AAABAJQAAAAgAABAAI2EoBGyJhkgGPKxmqxAKpownHC+YRMdN5BrTj67R3bOn01o7p01Iv71u89o
b9a7LfBTfS1vWI2jf12VfQPSW8KX2mas+NC2iv6xMNfJpMnLtEbuuxtMRCtzF55NR5rPps1N/ctP
y6uHreE6nXZ4pak48X3rT06fB7fNeI33cbX6mI32R/MWu7XF116aDSRhxbRERs8f499bkyZeeKae
kzE2mdon81/tfxDLGOunwbzlzbx08oaHBvZHJlx48mrvaa94pu04y617576rNGLRRM0397JEd/lu
9Dw/S3x4qxffo6mm4NjwUiKY4iI9Ib1dHFY6QIaNabbrYrLfrpJtaK1rMzPZb/s+05IpP59OyLeJ
k7eNfRaOc1ue32I7fGXYpi5Y77M8OGMeOKxHSFsU3Y29deZMzirl6dlVvhLatCjJHeYQv1rXnps1
8k9/VsW6qLVmZIi1rzitlvFKRvaZ2h6TSaenC9FFY+3brM+sqeG8Prp4+kZ+lvuxPkr1mqm95nfp
DXM459676a2q1dsV7XietvNno78+CJn1cjX6mOeIm0bR33dfRU5NJjidt9t5afjG/V6JZ7I2QMNh
nyo2BhsMuVG3wAhMSbbQRAMolnE+iuGUSCyJZRKuGUSCyJZK4llEgyZMYTuCUsYSCQASISAAAlCQ
AAAAAAEoASCASAAAAAAAAAAAAlACRACQAAAAAAAAAEgCEoASCAAAAAAAAAAAAAAAAAAAAAAABAAA
AAAAAAAISAIAAAAAAQAAACASgAAAQJAQAAhIDHZhln3do7z0WS18mWsajHjmes7pg3dNi5aRMNqO
yvDHTpPRaigHZhN4hHRlaVN59JY3zRENLUavaO+yq0iNVlitJ6vNcR1MVi0zO0era1/Ea0rPvbz5
PM5MWp45qvo2GZrhmfrsnpHpHzTCseEcM/2vrr8Q1Eb4qzy44nziPN63HpYiIiI7LNHoqabBTFii
IpSNohuVxrKtWMEejPwY9G1FFmHB4mWJn7MdfnIM9JpIx15to5pbUaas/a6rqViI7MxPxqX0UT1r
O3wVzpbR2hviP5i03Y5s6a879FNtHljydhExCv8AMTPJXBnRZbz0iG5ptFjwe/l96zctMVamTJtE
yTMibu1VrdTzRMR0j0ed4lr64MVpm0RERvMz5NvX62uOJ69XhOKX1HH9bHDtFvNYnfJeOy0Z2ojX
6jjnEq6fRUmccTvN/J9H0eKcOnx45neaxEbubwHgOHg+milI3vP2resu3Wu0JQmITsmISDHZHKz2
JgFc1RMLJhGwK9iIZ7MZgEdgmAEwyiWCdwWRLKJVxKYsC2JTuriWUSDNlEsIlMAySx3SCRCQSIAS
AAACRACQAAAAAAASIASAAAAAAAAAAAAAAACRACRACQASIAAAAAAAAAAAAAAAAAAAAAAAAQCUAAAA
AAAAAAIAAAAAAAAQAAAAAACBICBICAAEJAQJQCJcLjuS2ny6fPG/LWdpd1o8T0X07SXx/e7wCdJx
Wa0jmneHQpxPDMdZmJfNtZm49weZrh0/j4o7VtSZ2+Uw0/8A7o49k92vBLc/ntFohFW9PqGXimOI
6Tu1L8T3eCx6r2t1O3JwvHjifO99v7t/Bwf2l1PXU6rS6eJ8qUm8x+so5TsekzcSjbvs4mt4rzW5
K2mbT0itesy2cHsvbvqtbmyz5xERWP2jd1tJwrTaONsOKtZ8585+cnDrzmn4Rq+IZObUROHD32n7
Vv8A0ej0uhxaXFGPFSK1j0bkY4jyZRVZVXFGUVWbGwKsk8mObekNrSW3pWf1a2aYjHbm7bNnQ1id
PW0TvuDdhJEbQABMsLW2R0ZTMQrvfbz2YWzVhpanUxEd0dWkW5c8R5uXxDX1w4pnfr5Q19XxKuOJ
2neXltVqtVxbV/RdJ715+1bypANfiOu1HENV9C0MTfNeesx2rD1PAeBYuE6aKx72W3W9/WVnBuB4
eF4dqRzZbdb5J72l160WVK02ZxCYhOwI23TsnY2BGxsnYBjsiYZsZBjMMZZSgGEolMsQDdG6NwZ7
piVe6YkFsSziVMWZRILolMSriWUSCyJTuwhMSDMRCQSI3SAlACRCQAAEoAEoASAAAAAAAAACUACR
ACQAAAAAAAAAAAAASAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAABAAAAAAAAAAAAACBKAAAAAAAQ
JQAAAhICEbJAYTWJ7wx8KvpC0BV4ceieWGewDHlNmWwCNjZICNhIDmcZredBecdpiY69FXCOLW+i
UiZidukulmxxlx2paN4mNng+K4+I8Hy2yaTfl37TXetoCPfRxfp1qi3F48ofKMvtvxak8s6LDv61
rZji9rPaLUf5PC+bfttS0q8q3p9W/wBrRMdpUZuKdN99nzvFqPbTVz7nD8OKs+do2/mW3h4D7Xaq
ZnPrtNpqz35aRaYOHY9Zk4pNt9rR+rl6zi+OnS+WN57Rv1lXp/YrNaYtruL6zNPnGO3hxP6O5w/2
f0HDuun09Yv55Le9afznqcOvO4tBreMTHu30unnva0bWt8on+70nDuE4OHYYx4Kbesz3tPrMuhGO
IjpDOKrK9YVpsyiGUQnYGOyUgI2SlAIEmwMWMs9kTAMJYzDOYRMArmGErZhhMArlHmzmGMwDE3Ts
bAbs4swj5pgFkSziVcM4BZEsolXDKAZwyhjCYBkACQhIAAAAAAAJAAAAAAAAAAAAAAAAAAAShIAA
AAAAAAJAAAAAAAAAAAAAABAJEAAAAAAAAAAAAAAAIEoBKAAAAAAAAAAAAAAABAlAAAAAAAIAAAAA
BAkBAkBAkBAlACEgMZjdjbFW8bWrEx8YWANb6Fp+bfwab+vLDKMFK9qxH5L0bAr8OPRPKz2AY7J2
SbAjYZAI2E7AIEgIEgIEgMdkSy2NgY7MdlmyNoBXsxmFuyNgVTVjNV3KjlBRNTlXTVHKCrlIqt5T
lBhEMohlFerLlBjEMohMVTEARDKCITsAk2AEgAAAkAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAD/
2Q==`;

async function IZ(e) {
    let t;
    return t = typeof createImageBitmap == "function" ? await async function(n) {
        const a = (i, l = "application/octet-stream") => fetch(`data:${l};base64,${i}`).then(o => o.blob());
        let r, s;
        switch (n.config.warmup) {
          case "face":
            r = await a(F2);
            break;

          case "body":
          case "full":
            r = await a(_2);
            break;

          default:
            r = null;
        }
        if (r) {
            const i = await createImageBitmap(r);
            s = await n.detect(i, n.config), i.close();
        }
        return s;
    }(e) : typeof Image < "u" || ce.Canvas !== void 0 ? await async function(n) {
        return new Promise(a => {
            let r, s;
            switch (n.config.warmup) {
              case "face":
                r = "data:image/jpeg;base64," + F2;
                break;

              case "full":
              case "body":
                r = "data:image/jpeg;base64," + _2;
                break;

              default:
                r = "";
            }
            if (typeof Image < "u") s = new Image(); else {
                if (!ce.Image) return void a(void 0);
                s = new ce.Image();
            }
            s.onload = async () => {
                const i = Zr(s.naturalWidth, s.naturalHeight);
                if (i) {
                    const l = i.getContext("2d");
                    l && l.drawImage(s, 0, 0);
                    const o = await n.image(i, !0), p = o.tensor ? await n.detect(o.tensor, n.config) : void 0;
                    a(p);
                } else ee(), a(void 0);
            }, r ? s.src = r : a(void 0);
        });
    }(e) : await async function(n) {
        const a = i => Buffer.from(i, "base64");
        let r, s;
        if (r = n.config.warmup === "face" ? a(F2) : a(_2), "node" in Dh && dn() === "tensorflow") {
            const i = e7.decodeJpeg(r), l = pn(i, 0);
            n.tf.dispose(i), s = await n.detect(l, n.config), n.tf.dispose(l);
        } else n.config.debug && ee();
        return s;
    }(e), t;
}

async function SZ(e, t) {
    await U1(e, !1);
    const n = se();
    return e.state = "warmup", t && (e.config = gn(e.config, t)), e.config.warmup && e.config.warmup.length !== 0 && e.config.warmup !== "none" ? new Promise(async a => {
        await e.models.load(), await async function(i) {
            var l, o, p, u;
            if (!H().flagRegistry.ENGINE_COMPILE_ONLY) return;
            const c = dn(), d = Rr();
            if (c !== "webgl" && c !== "humangl" || !(d != null && d.checkCompileCompletion)) return;
            H().set("ENGINE_COMPILE_ONLY", !0);
            const h = Mt().state.numTensors, f = [];
            for (const [ g, y ] of Object.entries(i.models.models)) {
                if (!y) continue;
                const A = y != null && y.modelSignature && ((o = (l = y == null ? void 0 : y.inputs) == null ? void 0 : l[0]) != null && o.shape) ? [ ...y.inputs[0].shape ] : [ 1, 64, 64, 3 ], x = y != null && y.modelSignature && ((u = (p = y == null ? void 0 : y.inputs) == null ? void 0 : p[0]) != null && u.dtype) ? y.inputs[0].dtype : "float32";
                for (let v = 0; v < A.length; v++) A[v] === -1 && (A[v] = v === 0 ? 1 : 64);
                const b = ka(A, x);
                try {
                    const v = y.execute(b);
                    f.push(g), Array.isArray(v) ? v.forEach(I => ae(I)) : ae(v);
                } catch {
                    i.config.debug && ee();
                }
                ae(b);
            }
            const m = await d.checkCompileCompletionAsync();
            d.getUniformLocations(), i.config.debug && ee(m.length), H().set("ENGINE_COMPILE_ONLY", !1), 
            Mt().state.numTensors - h > 0 && ee();
        }(e);
        const r = await IZ(e), s = se();
        e.config.debug && ee(e.config.warmup, Math.round(s - n)), e.emit("warmup"), 
        a(r);
    }) : _u();
}

var NZ = class {
    constructor(e) {
        ve(this, "version"), ve(this, "config"), ve(this, "result"), ve(this, "state"), 
        ve(this, "process"), ve(this, "tf"), ve(this, "env", ce), ve(this, "draw", ck), 
        ve(this, "match", K4), ve(this, "models"), ve(this, "events"), ve(this, "faceTriangulation"), 
        ve(this, "faceUVMap"), ve(this, "performance"), mr(this, Sp, void 0), mr(this, $h, void 0), 
        mr(this, Mh, void 0), ve(this, "analyze", (...r) => {
            if (!sa(this, $h)) return;
            const s = this.tf.engine().state.numTensors, i = sa(this, Sp);
            ds(this, Sp, s);
            const l = s - i;
            l !== 0 && ee(...r, l);
        }), mr(this, M2, r => {
            if (!sa(this, Mh)) return null;
            if (!r) return "input is not defined";
            if (this.env.node && !(r instanceof vt)) return "input must be a tensor";
            try {
                this.tf.getBackend();
            } catch {
                return "backend not loaded";
            }
            return null;
        }), ve(this, "webcam", new ZX()), ve(this, "emit", r => {
            var s;
            (s = this.events) != null && s.dispatchEvent && this.events.dispatchEvent(new Event(r));
        }), mr(this, Qo, {});
        const t = W1.tfjs.replace(/-(.*)/, "");
        var n;
        mp.wasmPath = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@${t}/dist/`, 
        mp.modelBasePath = ce.browser ? "../models/" : "file://models/", this.version = uk, 
        Object.defineProperty(this, "version", {
            value: uk
        }), this.config = JSON.parse(JSON.stringify(mp)), Object.seal(this.config), 
        this.config.cacheModels = typeof indexedDB < "u", e && (this.config = gn(this.config, e)), 
        n = this.config, Nn.cacheModels = n.cacheModels, Nn.verbose = n.debug, Nn.modelBasePath = n.modelBasePath, 
        this.tf = Dh, this.state = "idle", ds(this, Sp, 0), ds(this, $h, !1), ds(this, Mh, !1), 
        this.performance = {}, this.events = typeof EventTarget < "u" ? new EventTarget() : void 0, 
        this.models = new h6(this), wk(), this.result = _u(), this.process = {
            tensor: null,
            canvas: null
        }, this.faceTriangulation = $K, this.faceUVMap = MK, $2(this, null, ""), 
        this.emit("create"), (this.config.debug || this.env.browser) && ee(this.version), 
        this.config.debug && ee(this.tf.version["tfjs-core"]);
        const a = JSON.parse(JSON.stringify(this.env));
        delete a.kernels, delete a.initial, delete a.perfadd, this.config.debug && ee();
    }
    reset() {
        const e = this.config.backend;
        this.config = JSON.parse(JSON.stringify(mp)), this.config.backend = e, a7(), 
        ce.initial = !0;
    }
    validate(e) {
        const t = t7(mp, e || this.config);
        return t.length === 0 && (this.config = gn(this.config, e)), t;
    }
    now() {
        return se();
    }
    image(e, t = !1) {
        return V1(e, this.config, t);
    }
    async segmentation(e, t) {
        var n, a, r;
        if (t && (this.config = gn(this.config, t)), !this.config.segmentation.enabled) return null;
        const s = await V1(e, this.config);
        if (!s.tensor) return null;
        let i = null;
        return (n = this.config.segmentation.modelPath) != null && n.includes("rvm") && (i = await kZ(s.tensor, this.config)), 
        (a = this.config.segmentation.modelPath) != null && a.includes("meet") && (i = await async function(l, o) {
            var p;
            if (_n || (_n = await X4(o)), !(_n != null && _n.executor) || !((p = _n == null ? void 0 : _n.inputs) != null && p[0].shape)) return null;
            const u = {};
            let c;
            switch (u.resize = Ue.resizeBilinear(l, [ _n.inputs[0].shape ? _n.inputs[0].shape[1] : 0, _n.inputs[0].shape ? _n.inputs[0].shape[2] : 0 ], !1), 
            u.norm = ze(u.resize, lt.tf255), u.res = _n.execute(u.norm), u.squeeze = at(u.res, [ 0 ]), 
            [ u.bgRaw, u.fgRaw ] = la(u.squeeze, 2), u.fg = qf(u.fgRaw), u.mul = ne(u.fg, lt.tf255), 
            u.expand = pn(u.mul, 2), u.output = Ue.resizeBilinear(u.expand, [ l.shape[1] || 0, l.shape[2] || 0 ]), 
            o.segmentation.mode || "default") {
              case "default":
                u.input = at(l), u.concat = yt([ u.input, u.output ], -1), c = Qe(u.concat, "int32");
                break;

              case "alpha":
                c = Qe(u.output, "int32");
                break;

              default:
                c = Ye(0);
            }
            return Object.keys(u).forEach(d => ae(u[d])), c;
        }(s.tensor, this.config)), (r = this.config.segmentation.modelPath) != null && r.includes("selfie") && (i = await async function(l, o) {
            var p;
            if (On || (On = await c6(o)), !(On != null && On.executor) || !((p = On == null ? void 0 : On.inputs) != null && p[0].shape)) return null;
            const u = {};
            let c;
            switch (u.resize = Ue.resizeBilinear(l, [ On.inputs[0].shape ? On.inputs[0].shape[1] : 0, On.inputs[0].shape ? On.inputs[0].shape[2] : 0 ], !1), 
            u.norm = ze(u.resize, lt.tf255), u.res = On.execute(u.norm), u.squeeze = at(u.res, [ 0 ]), 
            u.alpha = Ue.resizeBilinear(u.squeeze, [ l.shape[1] || 0, l.shape[2] || 0 ]), 
            u.mul = ne(u.alpha, lt.tf255), o.segmentation.mode || "default") {
              case "default":
                u.input = at(l), u.concat = yt([ u.input, u.mul ], -1), c = Qe(u.concat, "int32");
                break;

              case "alpha":
                c = Qe(u.mul, "int32");
                break;

              default:
                c = Ye(0);
            }
            return Object.keys(u).forEach(d => ae(u[d])), c;
        }(s.tensor, this.config)), ae(s.tensor), i;
    }
    compare(e, t) {
        return async function(n, a, r) {
            const s = {};
            if (!a || !r || a.shape.length !== 4 || a.shape.length !== r.shape.length || a.shape[0] !== 1 || r.shape[0] !== 1 || a.shape[3] !== 3 || r.shape[3] !== 3) return n.debug || ee(a.shape, r.shape), 
            0;
            s.input1 = wn(a), s.input2 = a.shape[1] !== r.shape[1] || a.shape[2] !== r.shape[2] ? Ue.resizeBilinear(r, [ a.shape[1], a.shape[2] ]) : wn(r), 
            s.diff = $e(s.input1, s.input2), s.squared = ne(s.diff, s.diff), s.sum = dt(s.squared);
            const i = (await s.sum.data())[0] / (a.shape[1] || 1) / (a.shape[2] || 1) / 255 / 3;
            return ae([ s.input1, s.input2, s.diff, s.squared, s.sum ]), i;
        }(this.config, e, t);
    }
    async init() {
        await U1(this, !0), await this.tf.ready(), a7();
    }
    async load(e) {
        this.state = "load";
        const t = se(), n = Object.values(this.models.models).filter(r => r).length;
        e && (this.config = gn(this.config, e)), this.env.initial && (await U1(this, !1) || ee(), 
        await rf(), this.env.browser && (this.config.debug && ee(this.config), this.config.debug && ee(this.tf.ENV.flags))), 
        await this.models.load(this), this.env.initial && this.config.debug && ee(this.tf.engine().state.numBytes, this.tf.engine().state.numTensors), 
        this.env.initial = !1, Object.values(this.models.models).filter(r => r).length !== n && (this.models.validate(), 
        this.emit("load"));
        const a = Math.trunc(se() - t);
        a > (this.performance.loadModels || 0) && (this.performance.loadModels = this.env.perfadd ? (this.performance.loadModels || 0) + a : a);
    }
    next(e = this.result) {
        return function(t, n) {
            var a, r, s, i, l, o, p, u, c, d, h, f, m, g, y, A, x, b, v, I, N, T, R, w, E, $;
            const M = se();
            if (!t) return _u();
            const F = Date.now() - t.timestamp, P = F < 1e3 ? 8 - Math.log(F + 1) : 1;
            if (t.canvas && (be.canvas = t.canvas), t.error && (be.error = t.error), 
            be.body && t.body.length === be.body.length) for (let O = 0; O < t.body.length; O++) {
                const B = t.body[O].box.map((q, Z) => ((P - 1) * be.body[O].box[Z] + q) / P), G = t.body[O].boxRaw.map((q, Z) => ((P - 1) * be.body[O].boxRaw[Z] + q) / P), W = t.body[O].keypoints.map((q, Z) => {
                    var Y, te, re, pe, ge, Re, ye, Me, Ee;
                    return {
                        score: q.score,
                        part: q.part,
                        position: [ be.body[O].keypoints[Z] ? ((P - 1) * (be.body[O].keypoints[Z].position[0] || 0) + (q.position[0] || 0)) / P : q.position[0], be.body[O].keypoints[Z] ? ((P - 1) * (be.body[O].keypoints[Z].position[1] || 0) + (q.position[1] || 0)) / P : q.position[1], be.body[O].keypoints[Z] ? ((P - 1) * (be.body[O].keypoints[Z].position[2] || 0) + (q.position[2] || 0)) / P : q.position[2] ],
                        positionRaw: [ be.body[O].keypoints[Z] ? ((P - 1) * (be.body[O].keypoints[Z].positionRaw[0] || 0) + (q.positionRaw[0] || 0)) / P : q.positionRaw[0], be.body[O].keypoints[Z] ? ((P - 1) * (be.body[O].keypoints[Z].positionRaw[1] || 0) + (q.positionRaw[1] || 0)) / P : q.positionRaw[1], be.body[O].keypoints[Z] ? ((P - 1) * (be.body[O].keypoints[Z].positionRaw[2] || 0) + (q.positionRaw[2] || 0)) / P : q.positionRaw[2] ],
                        distance: [ be.body[O].keypoints[Z] ? ((P - 1) * (((Y = be.body[O].keypoints[Z].distance) == null ? void 0 : Y[0]) || 0) + (((te = q.distance) == null ? void 0 : te[0]) || 0)) / P : (re = q.distance) == null ? void 0 : re[0], be.body[O].keypoints[Z] ? ((P - 1) * (((pe = be.body[O].keypoints[Z].distance) == null ? void 0 : pe[1]) || 0) + (((ge = q.distance) == null ? void 0 : ge[1]) || 0)) / P : (Re = q.distance) == null ? void 0 : Re[1], be.body[O].keypoints[Z] ? ((P - 1) * (((ye = be.body[O].keypoints[Z].distance) == null ? void 0 : ye[2]) || 0) + (((Me = q.distance) == null ? void 0 : Me[2]) || 0)) / P : (Ee = q.distance) == null ? void 0 : Ee[2] ]
                    };
                }), z = {};
                let X = {
                    connected: {}
                };
                (a = n.body.modelPath) != null && a.includes("efficientpose") ? X = _k : (r = n.body.modelPath) != null && r.includes("blazepose") ? X = kk : (s = n.body.modelPath) != null && s.includes("movenet") && (X = G4);
                for (const [ q, Z ] of Object.entries(X.connected)) {
                    const Y = [];
                    for (let te = 0; te < Z.length - 1; te++) {
                        const re = W.find(ge => ge.part === Z[te]), pe = W.find(ge => ge.part === Z[te + 1]);
                        re && pe && Y.push([ re.position, pe.position ]);
                    }
                    z[q] = Y;
                }
                be.body[O] = {
                    ...t.body[O],
                    box: B,
                    boxRaw: G,
                    keypoints: W,
                    annotations: z
                };
            } else be.body = JSON.parse(JSON.stringify(t.body));
            if (be.hand && t.hand.length === be.hand.length) for (let O = 0; O < t.hand.length; O++) {
                const B = t.hand[O].box.map((X, q) => ((P - 1) * be.hand[O].box[q] + X) / P), G = t.hand[O].boxRaw.map((X, q) => ((P - 1) * be.hand[O].boxRaw[q] + X) / P);
                be.hand[O].keypoints.length !== t.hand[O].keypoints.length && (be.hand[O].keypoints = t.hand[O].keypoints);
                const W = t.hand[O].keypoints && t.hand[O].keypoints.length > 0 ? t.hand[O].keypoints.map((X, q) => X.map((Z, Y) => ((P - 1) * (be.hand[O].keypoints[q][Y] || 1) + (Z || 0)) / P)) : [];
                let z = {};
                if (Object.keys(be.hand[O].annotations).length !== Object.keys(t.hand[O].annotations).length) be.hand[O].annotations = t.hand[O].annotations, 
                z = be.hand[O].annotations; else if (t.hand[O].annotations) for (const X of Object.keys(t.hand[O].annotations)) z[X] = (o = (l = (i = t.hand[O]) == null ? void 0 : i.annotations) == null ? void 0 : l[X]) != null && o[0] ? t.hand[O].annotations[X].map((q, Z) => q.map((Y, te) => ((P - 1) * be.hand[O].annotations[X][Z][te] + Y) / P)) : null;
                be.hand[O] = {
                    ...t.hand[O],
                    box: B,
                    boxRaw: G,
                    keypoints: W,
                    annotations: z
                };
            } else be.hand = JSON.parse(JSON.stringify(t.hand));
            if (be.face && t.face.length === be.face.length) for (let O = 0; O < t.face.length; O++) {
                const B = t.face[O].box.map((z, X) => ((P - 1) * be.face[O].box[X] + z) / P), G = t.face[O].boxRaw.map((z, X) => ((P - 1) * be.face[O].boxRaw[X] + z) / P);
                let W = t.face[O].annotations;
                if (Object.keys(be.face[O].annotations).length !== Object.keys(t.face[O].annotations).length) be.face[O].annotations = t.face[O].annotations, 
                W = be.face[O].annotations; else if (t.face[O].annotations) for (const z of Object.keys(t.face[O].annotations)) W[z] = (c = (u = (p = t.face[O]) == null ? void 0 : p.annotations) == null ? void 0 : u[z]) != null && c[0] ? t.face[O].annotations[z].map((X, q) => X.map((Z, Y) => ((P - 1) * be.face[O].annotations[z][q][Y] + Z) / P)) : null;
                if (t.face[O].rotation) {
                    const z = {
                        matrix: [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
                        angle: {
                            roll: 0,
                            yaw: 0,
                            pitch: 0
                        },
                        gaze: {
                            bearing: 0,
                            strength: 0
                        }
                    };
                    z.matrix = (d = t.face[O].rotation) == null ? void 0 : d.matrix, 
                    z.angle = {
                        roll: ((P - 1) * (((f = (h = be.face[O].rotation) == null ? void 0 : h.angle) == null ? void 0 : f.roll) || 0) + (((g = (m = t.face[O].rotation) == null ? void 0 : m.angle) == null ? void 0 : g.roll) || 0)) / P,
                        yaw: ((P - 1) * (((A = (y = be.face[O].rotation) == null ? void 0 : y.angle) == null ? void 0 : A.yaw) || 0) + (((b = (x = t.face[O].rotation) == null ? void 0 : x.angle) == null ? void 0 : b.yaw) || 0)) / P,
                        pitch: ((P - 1) * (((I = (v = be.face[O].rotation) == null ? void 0 : v.angle) == null ? void 0 : I.pitch) || 0) + (((T = (N = t.face[O].rotation) == null ? void 0 : N.angle) == null ? void 0 : T.pitch) || 0)) / P
                    }, z.gaze = {
                        bearing: ((P - 1) * (((R = be.face[O].rotation) == null ? void 0 : R.gaze.bearing) || 0) + (((w = t.face[O].rotation) == null ? void 0 : w.gaze.bearing) || 0)) / P,
                        strength: ((P - 1) * (((E = be.face[O].rotation) == null ? void 0 : E.gaze.strength) || 0) + ((($ = t.face[O].rotation) == null ? void 0 : $.gaze.strength) || 0)) / P
                    }, be.face[O] = {
                        ...t.face[O],
                        rotation: z,
                        box: B,
                        boxRaw: G,
                        annotations: W
                    };
                } else be.face[O] = {
                    ...t.face[O],
                    box: B,
                    boxRaw: G,
                    annotations: W
                };
            } else be.face = JSON.parse(JSON.stringify(t.face));
            if (be.object && t.object.length === be.object.length) for (let O = 0; O < t.object.length; O++) {
                const B = t.object[O].box.map((W, z) => ((P - 1) * be.object[O].box[z] + W) / P), G = t.object[O].boxRaw.map((W, z) => ((P - 1) * be.object[O].boxRaw[z] + W) / P);
                be.object[O] = {
                    ...t.object[O],
                    box: B,
                    boxRaw: G
                };
            } else be.object = JSON.parse(JSON.stringify(t.object));
            if (t.persons) {
                const O = t.persons;
                if (be.persons && O.length === be.persons.length) for (let B = 0; B < O.length; B++) be.persons[B].box = O[B].box.map((G, W) => ((P - 1) * be.persons[B].box[W] + G) / P); else be.persons = JSON.parse(JSON.stringify(O));
            }
            t.gesture && (be.gesture = t.gesture), be.width = t.width, be.height = t.height;
            const L = se();
            return I2 = ce.perfadd ? I2 + Math.round(L - M) : Math.round(L - M), 
            t.performance && (be.performance = {
                ...t.performance,
                interpolate: I2
            }), be;
        }(e, this.config);
    }
    async warmup(e) {
        const t = se(), n = await SZ(this, e), a = se();
        return this.performance.warmup = Math.trunc(a - t), n;
    }
    async profile(e, t) {
        const n = await this.tf.profile(() => this.detect(e, t)), a = {};
        let r = 0;
        for (const i of n.kernels) {
            const l = Number(i.kernelTimeMs) || 0;
            a[i.name] ? a[i.name] += l : a[i.name] = l, r += l;
        }
        const s = [];
        Object.entries(a).forEach(i => s.push({
            kernel: i[0],
            time: i[1],
            perc: 0
        }));
        for (const i of s) i.perc = Math.round(1e3 * i.time / r) / 1e3, i.time = Math.round(1e3 * i.time) / 1e3;
        return s.sort((i, l) => l.time - i.time), s.length = 20, s;
    }
    async detect(e, t) {
        return this.state = "detect", new Promise(async n => {
            var a, r, s, i, l, o, p, u, c, d, h, f, m, g, y, A, x, b, v, I, N;
            let T;
            this.state = "config", this.config = gn(this.config, t), this.state = "check";
            const R = sa(this, M2).call(this, e);
            R && (ee(), this.emit("error"), n(_u(R)));
            const w = se();
            await this.load(), T = se(), this.state = "image";
            const E = await V1(e, this.config);
            if (this.process = E, this.performance.inputProcess = this.env.perfadd ? (this.performance.inputProcess || 0) + Math.trunc(se() - T) : Math.trunc(se() - T), 
            this.analyze("Get Image:"), !E.tensor) return this.config.debug && ee(), 
            this.emit("error"), void n(_u("could not convert input to tensor"));
            this.emit("image"), T = se(), this.config.skipAllowed = await async function(W, z) {
                let X = !1;
                if (W.cacheSensitivity === 0 || !z.shape || z.shape.length !== 4 || z.shape[1] > 3840 || z.shape[2] > 2160) return X;
                if (na.inputTensor) if (na.inputTensor.shape[1] !== z.shape[1] || na.inputTensor.shape[2] !== z.shape[2]) ae(na.inputTensor), 
                na.inputTensor = wn(z); else {
                    const q = {};
                    q.diff = $e(z, na.inputTensor), q.squared = ne(q.diff, q.diff), 
                    q.sum = dt(q.squared);
                    const Z = (await q.sum.data())[0] / (z.shape[1] || 1) / (z.shape[2] || 1) / 255 / 3;
                    ae([ na.inputTensor, q.diff, q.squared, q.sum ]), na.inputTensor = wn(z), 
                    X = Z <= (W.cacheSensitivity || 0);
                } else na.inputTensor = wn(z);
                return X;
            }(this.config, E.tensor), this.config.filter.autoBrightness = !!this.config.filter.autoBrightness && this.config.skipAllowed, 
            this.performance.totalFrames || (this.performance.totalFrames = 0), 
            this.performance.cachedFrames || (this.performance.cachedFrames = 0), 
            this.performance.totalFrames++, this.config.skipAllowed && this.performance.cachedFrames++, 
            this.performance.cacheCheck = this.env.perfadd ? (this.performance.cacheCheck || 0) + Math.trunc(se() - T) : Math.trunc(se() - T), 
            this.analyze("Check Changed:");
            let $ = [], M = [], F = [], P = [];
            this.state = "detect:face", this.config.async ? ($ = this.config.face.enabled ? I4(this, E.tensor) : [], 
            this.performance.face && delete this.performance.face) : (T = se(), 
            $ = this.config.face.enabled ? await I4(this, E.tensor) : [], this.performance.face = this.env.perfadd ? (this.performance.face || 0) + Math.trunc(se() - T) : Math.trunc(se() - T)), 
            !this.config.async || this.config.body.maxDetected !== -1 && this.config.hand.maxDetected !== -1 || ($ = await $), 
            this.analyze("Start Body:"), this.state = "detect:body";
            const L = this.config.body.maxDetected === -1 ? gn(this.config, {
                body: {
                    maxDetected: this.config.face.enabled ? 1 * $.length : 1
                }
            }) : this.config;
            this.config.async ? ((a = this.config.body.modelPath) != null && a.includes("posenet") ? M = this.config.body.enabled ? l6(E.tensor, L) : [] : (r = this.config.body.modelPath) != null && r.includes("blazepose") ? M = this.config.body.enabled ? $k(E.tensor, L) : [] : (s = this.config.body.modelPath) != null && s.includes("efficientpose") ? M = this.config.body.enabled ? zk(E.tensor, L) : [] : (i = this.config.body.modelPath) != null && i.includes("movenet") && (M = this.config.body.enabled ? Q4(E.tensor, L) : []), 
            this.performance.body && delete this.performance.body) : (T = se(), 
            (l = this.config.body.modelPath) != null && l.includes("posenet") ? M = this.config.body.enabled ? await l6(E.tensor, L) : [] : (o = this.config.body.modelPath) != null && o.includes("blazepose") ? M = this.config.body.enabled ? await $k(E.tensor, L) : [] : (p = this.config.body.modelPath) != null && p.includes("efficientpose") ? M = this.config.body.enabled ? await zk(E.tensor, L) : [] : (u = this.config.body.modelPath) != null && u.includes("movenet") && (M = this.config.body.enabled ? await Q4(E.tensor, L) : []), 
            this.performance.body = this.env.perfadd ? (this.performance.body || 0) + Math.trunc(se() - T) : Math.trunc(se() - T)), 
            this.analyze("End Body:"), this.analyze("Start Hand:"), this.state = "detect:hand";
            const O = this.config.hand.maxDetected === -1 ? gn(this.config, {
                hand: {
                    maxDetected: this.config.face.enabled ? 2 * $.length : 1
                }
            }) : this.config;
            this.config.async ? ((d = (c = this.config.hand.detector) == null ? void 0 : c.modelPath) != null && d.includes("handdetect") ? F = this.config.hand.enabled ? L4(E.tensor, O) : [] : (f = (h = this.config.hand.detector) == null ? void 0 : h.modelPath) != null && f.includes("handtrack") && (F = this.config.hand.enabled ? U4(E.tensor, O) : []), 
            this.performance.hand && delete this.performance.hand) : (T = se(), 
            (g = (m = this.config.hand.detector) == null ? void 0 : m.modelPath) != null && g.includes("handdetect") ? F = this.config.hand.enabled ? await L4(E.tensor, O) : [] : (A = (y = this.config.hand.detector) == null ? void 0 : y.modelPath) != null && A.includes("handtrack") && (F = this.config.hand.enabled ? await U4(E.tensor, O) : []), 
            this.performance.hand = this.env.perfadd ? (this.performance.hand || 0) + Math.trunc(se() - T) : Math.trunc(se() - T)), 
            this.analyze("End Hand:"), this.analyze("Start Object:"), this.state = "detect:object", 
            this.config.async ? ((x = this.config.object.modelPath) != null && x.includes("nanodet") ? P = this.config.object.enabled ? t6(E.tensor, this.config) : [] : (b = this.config.object.modelPath) != null && b.includes("centernet") && (P = this.config.object.enabled ? Fk(E.tensor, this.config) : []), 
            this.performance.object && delete this.performance.object) : (T = se(), 
            (v = this.config.object.modelPath) != null && v.includes("nanodet") ? P = this.config.object.enabled ? await t6(E.tensor, this.config) : [] : (I = this.config.object.modelPath) != null && I.includes("centernet") && (P = this.config.object.enabled ? await Fk(E.tensor, this.config) : []), 
            this.performance.object = this.env.perfadd ? (this.performance.object || 0) + Math.trunc(se() - T) : Math.trunc(se() - T)), 
            this.analyze("End Object:"), this.state = "detect:await", this.config.async && ([ $, M, F, P ] = await Promise.all([ $, M, F, P ])), 
            this.state = "detect:gesture";
            let B = [];
            this.config.gesture.enabled && (T = se(), B = [ ...qK($), ...jK(M), ...KK(F), ...XK($) ], 
            this.config.async ? this.performance.gesture && delete this.performance.gesture : this.performance.gesture = this.env.perfadd ? (this.performance.gesture || 0) + Math.trunc(se() - T) : Math.trunc(se() - T)), 
            this.performance.total = this.env.perfadd ? (this.performance.total || 0) + Math.trunc(se() - w) : Math.trunc(se() - w);
            const G = ((N = this.process.tensor) == null ? void 0 : N.shape) || [ 0, 0, 0, 0 ];
            this.result = {
                face: $,
                body: M,
                hand: F,
                gesture: B,
                object: P,
                performance: this.performance,
                canvas: this.process.canvas,
                timestamp: Date.now(),
                error: null,
                width: G[2],
                height: G[1],
                get persons() {
                    return function(W, z, X, q, Z) {
                        var Y, te, re, pe, ge, Re;
                        let ye = 0;
                        const Me = [];
                        for (const Ee of W) {
                            const me = {
                                id: ye++,
                                face: Ee,
                                body: null,
                                hands: {
                                    left: null,
                                    right: null
                                },
                                gestures: [],
                                box: [ 0, 0, 0, 0 ]
                            };
                            for (const ue of z) Ee.box[0] > ue.box[0] && Ee.box[0] < ue.box[0] + ue.box[2] && Ee.box[1] + Ee.box[3] > ue.box[1] && Ee.box[1] + Ee.box[3] < ue.box[1] + ue.box[3] && (me.body = ue);
                            if (me.body) for (const ue of X) ue.box[0] + ue.box[2] > me.body.box[0] && ue.box[0] + ue.box[2] < me.body.box[0] + me.body.box[2] && ue.box[1] + ue.box[3] > me.body.box[1] && ue.box[1] + ue.box[3] < me.body.box[1] + me.body.box[3] && me.hands && (me.hands.left = ue), 
                            ue.box[0] < me.body.box[0] + me.body.box[2] && ue.box[0] > me.body.box[0] && ue.box[1] + ue.box[3] > me.body.box[1] && ue.box[1] + ue.box[3] < me.body.box[1] + me.body.box[3] && me.hands && (me.hands.right = ue);
                            for (const ue of q) (ue.face !== void 0 && ue.face === Ee.id || ue.iris !== void 0 && ue.iris === Ee.id || ue.body !== void 0 && ue.body === ((Y = me.body) == null ? void 0 : Y.id) || ue.hand !== void 0 && ue.hand === ((te = me.hands.left) == null ? void 0 : te.id) || ue.hand !== void 0 && ue.hand === ((re = me.hands.right) == null ? void 0 : re.id)) && me.gestures.push(ue);
                            const Oe = [], we = [], Be = ue => {
                                ue && ue.length === 4 && (Oe.push(ue[0], ue[0] + ue[2]), 
                                we.push(ue[1], ue[1] + ue[3]));
                            };
                            Be(me.face.box), Be((pe = me.body) == null ? void 0 : pe.box), 
                            Be((ge = me.hands.left) == null ? void 0 : ge.box), 
                            Be((Re = me.hands.right) == null ? void 0 : Re.box);
                            const nt = Math.min(...Oe), Ve = Math.min(...we);
                            me.box = [ nt, Ve, Math.max(...Oe) - nt, Math.max(...we) - Ve ], 
                            Z != null && Z[1] && (Z != null && Z[2]) && (me.boxRaw = [ me.box[0] / Z[2], me.box[1] / Z[1], me.box[2] / Z[2], me.box[3] / Z[1] ]), 
                            Me.push(me);
                        }
                        return Me;
                    }($, M, F, B, G);
                }
            }, ae(E.tensor), this.emit("detect"), this.state = "idle", n(this.result);
        });
    }
    async sleep(e) {
        return new Promise(t => {
            setTimeout(t, e);
        });
    }
    async video(e, t = !0, n = 0) {
        t ? (sa(this, Qo)[e.id] || (this.config.debug && ee(e.id), sa(this, Qo)[e.id] = !0), 
        !e.paused && sa(this, Qo)[e.id] && e.readyState >= 2 && await this.detect(e), 
        n > 0 && await this.sleep(n), sa(this, Qo)[e.id] && requestAnimationFrame(() => this.video(e, t, n))) : (this.config.debug && ee(e.id), 
        sa(this, Qo)[e.id] = !1);
    }
};

Sp = new WeakMap(), $h = new WeakMap(), Mh = new WeakMap(), M2 = new WeakMap(), 
Qo = new WeakMap();

export {
    NZ as H
};